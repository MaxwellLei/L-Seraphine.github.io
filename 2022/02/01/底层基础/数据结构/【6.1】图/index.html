<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【6.1】图 | Maxwell_Leiの小窝</title><meta name="author" content="Maxwell Lei"><meta name="copyright" content="Maxwell Lei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言图比较复杂，涉及的算法相对较多。 图的定义图，就是例如下图的东西，图可以分为  有向图：即带有明确的方向指向的图，可以使用 $&lt;a,c&gt;$ 表示从 A 到 C 顶点的路径 无向图：不带有明确的方向指向的图，可以使用 $(a,c)$ 表示从 A 到 C 顶点的路径     图注：有向图     图注：无向图  对于图来说，要求边的两端必须存在“顶点”，否则它不是图。同样的，对于图来说">
<meta property="og:type" content="article">
<meta property="og:title" content="【6.1】图">
<meta property="og:url" content="https://www.helloseraphine.top/2022/02/01/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%906.1%E3%80%91%E5%9B%BE/index.html">
<meta property="og:site_name" content="Maxwell_Leiの小窝">
<meta property="og:description" content="前言图比较复杂，涉及的算法相对较多。 图的定义图，就是例如下图的东西，图可以分为  有向图：即带有明确的方向指向的图，可以使用 $&lt;a,c&gt;$ 表示从 A 到 C 顶点的路径 无向图：不带有明确的方向指向的图，可以使用 $(a,c)$ 表示从 A 到 C 顶点的路径     图注：有向图     图注：无向图  对于图来说，要求边的两端必须存在“顶点”，否则它不是图。同样的，对于图来说">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae4e680130.webp">
<meta property="article:published_time" content="2022-02-01T15:30:01.000Z">
<meta property="article:modified_time" content="2025-04-17T03:44:24.337Z">
<meta property="article:author" content="Maxwell Lei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae4e680130.webp"><link rel="shortcut icon" href="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_Image/64abfad3db52f.ico"><link rel="canonical" href="https://www.helloseraphine.top/2022/02/01/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%906.1%E3%80%91%E5%9B%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e46e337e762e79ae7f939118e01248b7";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":30,"position":"top","messagePrev":"距离本文的最后一次更新是","messageNext":"天之前, 部分内容可能已经过时了."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":512},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":2048,"languages":{"author":"作者: Maxwell Lei","link":"链接: ","source":"来源: Maxwell_Leiの小窝","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【6.1】图',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-17 11:44:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Maxwell_Leiの小窝" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://thirdqq.qlogo.cn/g?b=qq&amp;nk=738232585&amp;s=100" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/MessageBoard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/updateLog/"><i class="fa-fw fas fa-wrench"></i><span> 更新日志</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae4e680130.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Maxwell_Leiの小窝"><span class="site-name">Maxwell_Leiの小窝</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/MessageBoard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/updateLog/"><i class="fa-fw fas fa-wrench"></i><span> 更新日志</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【6.1】图</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-01T15:30:01.000Z" title="发表于 2022-02-01 23:30:01">2022-02-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-17T03:44:24.337Z" title="更新于 2025-04-17 11:44:24">2025-04-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/">底层基础</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【6.1】图"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>图比较复杂，涉及的算法相对较多。</p>
<h1 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h1><p>图，就是例如下图的东西，图可以分为</p>
<ul>
<li>有向图：即带有明确的方向指向的图，可以使用 $&lt;a,c&gt;$ 表示从 A 到 C 顶点的路径</li>
<li>无向图：不带有明确的方向指向的图，可以使用 $(a,c)$ 表示从 A 到 C 顶点的路径</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae4ecb2e67.png" alt="image-20220829004344707" style="zoom:80%;" />

<blockquote>
<p>图注：有向图</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae4ee3a3e9.png" alt="image-20220829024720161" style="zoom:80%;" />

<blockquote>
<p>图注：无向图</p>
</blockquote>
<p>对于图来说，要求边的两端必须存在“顶点”，否则它不是图。同样的，对于图来说，也不存在空图的概念。</p>
<p>从图的结构来说，又可以分为：<strong>简单图</strong>和<strong>多重图</strong>。</p>
<ul>
<li>简单图<ol>
<li>不存在重复边</li>
<li>不存在顶点到自身的边</li>
</ol>
</li>
<li>多重图<ol>
<li>允许重复边</li>
<li>允许存在顶点到自身的边</li>
</ol>
</li>
</ul>
<h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><ul>
<li><p>图的阶：图里面的顶点（或者叫结点）个数</p>
</li>
<li><p><strong>顶点的度</strong></p>
<ul>
<li>无向图：顶点的边数</li>
<li>有向图：入度 + 出度<ul>
<li>出度：从顶点指向外面顶点的边</li>
<li>入度：指向顶点的边</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>路径：两个顶点之间的顶点序列</strong>，例如下图：A 到 B 的路径为：A,C,B</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae4f34770b.png" alt="image-20220829025426751" style="zoom:80%;" />
</li>
<li><p>回路：第一个顶点和最后一个顶点相同的路径</p>
</li>
<li><p><strong>简单路径</strong>：在路径序列中，顶点不重复出现的路径</p>
</li>
<li><p>简单回路：除了第一个顶点和最后一个顶点外，其余顶点不出现重复的回路</p>
</li>
<li><p><strong>路径长度：路径上边的数目</strong></p>
</li>
<li><p><strong>点到点的距离</strong>：从顶到到另一个顶点的<strong>最短路径</strong>作为距离，如果不存在最短路径，则认为两点不存在路径，记作 $\infty$ </p>
</li>
<li><p>连通：在无向图中，顶点和顶点间存在路径</p>
</li>
<li><p>强连通：在<strong>有向图</strong>中，顶点和顶点间存在相互路径</p>
</li>
<li><p>完全图</p>
<ul>
<li>无向完全图：无向图中任意两个顶点之间都存在边</li>
<li>有向完全图：有向图中任意两个顶点之间存在反复相反的两条弧</li>
</ul>
</li>
</ul>
<h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>图的存储结构可以分为：</p>
<ul>
<li><strong>邻接矩阵</strong></li>
<li><strong>邻接表</strong></li>
<li><strong>十字链表</strong></li>
<li><strong>邻接多重表</strong></li>
</ul>
<p>如上的存储结构（方法），是对无向图和有向图的不同解决方案。</p>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵的思路很简单，将顶点序列建立二维数组，用 0 或者 1 来表示顶点间的连通性，图示如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae4fb65031.png" alt="image-20220829030718451" style="zoom:80%;" />

<blockquote>
<p>图片来源：王道《数据结构》</p>
</blockquote>
<p>如上的存储方式可以采用二维数组的方式来存储，代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> Vertex[Maxsize];	<span class="comment">//存放顶点的数组</span></span><br><span class="line">	ElemType Edge[Maxsize][Maxsize];	<span class="comment">//存放顶点关系的数组</span></span><br><span class="line">	<span class="type">int</span> vexnum, arcnum;	<span class="comment">//图的总共顶点数和弧的数目</span></span><br><span class="line">&#125;Chart;</span><br></pre></td></tr></table></figure>

<p>如上可知：<strong>对于邻接矩阵来说，最大的问题是如果存储的边的密度很低的话，会造成大量的空间浪费</strong>。</p>
<h3 id="邻接矩阵的性质"><a href="#邻接矩阵的性质" class="headerlink" title="邻接矩阵的性质"></a>邻接矩阵的性质</h3><p>如果将邻接矩阵与自身相乘（矩阵相乘），则对应的结果表示了顶点和顶点间是否存在路径为 1 的路径，如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae4ff3f2e5.png" alt="image-20220829031641842" style="zoom:80%;" />

<blockquote>
<p>图片来源：王道《数据结构》</p>
</blockquote>
<p>同理，如果你<strong>将其与自身相乘 n 次，则对应的结果意味着顶点和顶点间是否存在长度为 n 的路径</strong>。</p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接表采用顺序存储和链式存储相互结合的方法，如下图所示，你会发现它和树部分的“孩子表示法”很类似。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae502d1957.png" alt="image-20220829031940891" style="zoom: 67%;" />

<blockquote>
<p>图片来源：王道《数据结构》</p>
</blockquote>
<p>图示逻辑上理解起来类似于树的“堂兄弟表示法”，代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//边，弧</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> adjvex;		<span class="comment">//弧指向的结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">next</span>;</span>	<span class="comment">//指向下条弧的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType data;	<span class="comment">//顶点信息</span></span><br><span class="line">	ArcNode* first;	<span class="comment">//第一条边</span></span><br><span class="line">&#125;VNode,AdjList[Maxsize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	AdjList vertices;	<span class="comment">//数组存储顶点</span></span><br><span class="line">	<span class="type">int</span> vexnum, arcnum;	<span class="comment">//图的总共顶点数和弧的数目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>邻接表法的缺点是：寻找顶点的入度或者入边很不方便</strong>。</p>
<h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>注：十字链表是用来存储<strong>有向图</strong>而设计的。具体示例如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae5073d1aa.png" alt="image-20220829033432151" style="zoom: 67%;" />

<blockquote>
<p>图片来源：王道《数据结构》</p>
</blockquote>
<h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p><strong>对于邻接矩阵存储无向图来说，会存在大量的数据冗余和空间浪费，而邻接多重表就是为了解决这两个问题而产生的解决方案</strong>，示例如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae50b71187.png" alt="image-20220829033710277" style="zoom: 67%;" />

<p>注：邻接多重表是用来存储<strong>无向图</strong>而设计的。</p>
<h1 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h1><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Adjacent(G,X,Y)</code></td>
<td>判断图 G 是否存在边 &lt;x,y&gt; 或者 (x,y)</td>
</tr>
<tr>
<td><code>NeighBors(G,X)</code></td>
<td>列出图 G 中与结点 X 邻接的边</td>
</tr>
<tr>
<td><code>InsertVertex(G,X)</code></td>
<td>在图 G 中插入顶点 X</td>
</tr>
<tr>
<td><code>DeleteVertex(G,X)</code></td>
<td>在图 G 中删除顶点 X</td>
</tr>
<tr>
<td><code>AddEdge(G,X,Y)</code></td>
<td>若无向边 (x,y) 或者有向边 &lt;x,y&gt; 不存在，则向图 G 中添加该边</td>
</tr>
<tr>
<td><code>FirstNeighbor(G,X)</code></td>
<td>求图 G 中顶点 X 的第一个邻接点，若存在则返回顶点号，不存在返回 -1</td>
</tr>
<tr>
<td><code>NextNeighbor(G,X,Y)</code></td>
<td>找图 G 中顶点 Y 的除了邻接点 X 的其他邻接点，若存在则返回顶点号，不存在返回 -1</td>
</tr>
<tr>
<td><code>Get_edge_value(G,X,Y)</code></td>
<td>获取图 G 中边 (X,Y) 或者 &lt;X,Y&gt;对应的权值</td>
</tr>
<tr>
<td><code>Set_edge_value(G,X,Y)</code></td>
<td>设置图 G 中边 (X,Y) 或者 &lt;X,Y&gt;对应的权值</td>
</tr>
<tr>
<td><code>Adjacent(G,X,Y)</code></td>
<td>判断图 G 是否存在边 (X,Y) 或者 &lt;X,Y&gt;</td>
</tr>
</tbody></table>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h2><p>图的广度优先遍历和树的广度优先遍历（层次遍历）很类似，例如下面的图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae50f475d6.png" alt="image-20220830012444047" style="zoom:80%;" />

<p>我们选择一个顶点开始进行图的广度优先遍历，例如 A 顶点，<strong>第一步将 A 压入辅助队列中，A 出队的时候获取其下一个顶点 B C D 压入队列，依次类推，直到队列为空</strong>。但是图和树不同的是，图有可能出现回环，而树不可能，树的结构保证了每个结点都只会被遍历一次，而图如果出现回环那么同一个顶点会被遍历多次，这个时候就需要再定义一个辅助数组，用来记录哪个结点是否被遍历过。</p>
<p>对于不同图的存储方式和不同的图的类型，其广度优先代码略有不同，代码如下所示。</p>
<p>前排说明：请创建一个头文件，名称为<code>图的存储结构.h</code>，代码如下，此头文件需要被使用图的地方进行引用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> Vertex[Maxsize];	<span class="comment">//存放顶点的数组</span></span><br><span class="line">	ElemType Edge[Maxsize][Maxsize];	<span class="comment">//存放顶点关系的数组</span></span><br><span class="line">	<span class="type">int</span> vexnum, arcnum;	<span class="comment">//图的总共顶点数和弧的数目</span></span><br><span class="line">&#125;GMatrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接表法*/</span></span><br><span class="line"><span class="comment">//边，弧</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> adjvex;		<span class="comment">//弧指向的结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">next</span>;</span>	<span class="comment">//指向下条弧的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> data;	<span class="comment">//顶点信息</span></span><br><span class="line">	ArcNode* first;	<span class="comment">//第一条边</span></span><br><span class="line">&#125;VNode,AdjList[Maxsize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	AdjList vertices;	<span class="comment">//数组存储顶点</span></span><br><span class="line">	<span class="type">int</span> vexnum, arcnum;	<span class="comment">//图的总共顶点数和弧的数目</span></span><br><span class="line">&#125;GraphAdjList;</span><br></pre></td></tr></table></figure>

<h3 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>考虑到需要使用辅助队列完成图的广度优先遍历，需要再创建一个名称为<code>图队列.h</code>的头文件，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;图的存储结构.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemTypeQ int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列元素结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemTypeQ data; <span class="comment">//二叉树结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span> <span class="comment">//下一个结点的指针</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头结点结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">front</span>;</span> <span class="comment">//队列队头指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">rear</span>;</span>  <span class="comment">//队列队尾指针</span></span><br><span class="line">    <span class="type">int</span> size;   <span class="comment">//队列的大小</span></span><br><span class="line">&#125;QHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列-带头结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(QHead* q)</span> &#123;</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;    <span class="comment">//队头指针初始化</span></span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>; <span class="comment">//队尾指针初始化</span></span><br><span class="line">    q-&gt;size = <span class="number">0</span>;    <span class="comment">//初始化队列大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列初始化成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(QHead* q, ElemTypeQ data)</span> &#123;</span><br><span class="line">    QNode* qn = (QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));  <span class="comment">//新元素结点申请内存空间</span></span><br><span class="line">    qn-&gt;data = data;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;size &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qn-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//尾指针为空</span></span><br><span class="line">        q-&gt;front = qn;  <span class="comment">//头指针指向第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        qn-&gt;next = q-&gt;rear-&gt;next;   <span class="comment">//新元素的下一个元素指针指向队尾指针的下一个</span></span><br><span class="line">        q-&gt;rear-&gt;next = qn; <span class="comment">//原来的队尾元素指向新队尾元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;rear = qn;   <span class="comment">//尾指针指向第一个元素</span></span><br><span class="line">    q-&gt;size++;  <span class="comment">//队列的长度+1</span></span><br><span class="line">    <span class="comment">//printf(&quot;元素 %d 入队成功,当前队列长度为:%d\n&quot;, data, q-&gt;size);</span></span><br><span class="line">    <span class="comment">//GetHead(q);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队操作</span></span><br><span class="line">ElemTypeQ <span class="title function_">DeQueue</span><span class="params">(QHead* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>)  <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    QNode* tempNode = q-&gt;front;</span><br><span class="line">    ElemTypeQ tempdata = tempNode-&gt;data; <span class="comment">//获取队头元素</span></span><br><span class="line">    q-&gt;front = tempNode-&gt;next;  <span class="comment">//队头指向新的队头元素</span></span><br><span class="line">    <span class="built_in">free</span>(tempNode); <span class="comment">//释放出队元素的内存空间</span></span><br><span class="line">    q-&gt;size--;  <span class="comment">//队列元素-1</span></span><br><span class="line">    <span class="keyword">return</span> tempdata;    <span class="comment">//返回出队元素数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取队头元素</span></span><br><span class="line">ElemTypeQ <span class="title function_">GetHead</span><span class="params">(QHead* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空队列\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;  <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>, q-&gt;front-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Destory</span><span class="params">(QHead* q)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DeQueue(q);</span><br><span class="line">    &#125;</span><br><span class="line">    InitQueue(q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列已销毁\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下是图的广度优先遍历代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接矩阵-图*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;图的存储结构.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;图队列.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGraph</span><span class="params">(GMatrix* g)</span> &#123;</span><br><span class="line">	g-&gt;arcnum = <span class="number">0</span>;	<span class="comment">//边数目初始化零</span></span><br><span class="line">	g-&gt;vexnum = <span class="number">0</span>;	<span class="comment">//点数目初始化零</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; Maxsize; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		g-&gt;Vertex[k] = <span class="number">0</span>;	<span class="comment">//初始化顶点数组</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Maxsize; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			g-&gt;Edge[i][j] = <span class="number">0</span>;	<span class="comment">//边的关系初始化为零</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;图已初始化\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在图中插入顶点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertVertex</span><span class="params">(GMatrix* g, <span class="type">char</span> v)</span> &#123;</span><br><span class="line">	<span class="comment">//判断图是否已满</span></span><br><span class="line">	<span class="keyword">if</span> (g-&gt;Vertex[Maxsize<span class="number">-1</span>]!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;图已满，无法添加顶点:%c&quot;</span>, v);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果找到数组值为0 表示可以插入顶点</span></span><br><span class="line">		<span class="keyword">if</span> (g-&gt;Vertex[i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			g-&gt;Vertex[i] = v;	<span class="comment">//插入新顶点</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;顶点:%c 插入图位置:%d 成功&quot;</span>, v, i + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;出错&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建图</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CreatGraph</span><span class="params">(GMatrix* g)</span> &#123;</span><br><span class="line">	<span class="comment">/*建立图的顶点和边数*/</span></span><br><span class="line">	<span class="type">int</span> tempVex =<span class="number">0</span>, tempEdge=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入顶点数和边数,例如：2,3(英文的逗号)\n&quot;</span>);</span><br><span class="line">	<span class="comment">//获取输入的顶点和边数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;tempVex, &amp;tempEdge);</span><br><span class="line">	<span class="keyword">if</span> (tempVex&gt;Maxsize || tempEdge &gt; <span class="number">10000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顶点或者边数超出预定范围\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对图的边数和顶点赋值</span></span><br><span class="line">	g-&gt;vexnum = tempVex;</span><br><span class="line">	g-&gt;arcnum = tempEdge;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*建立图的顶点信息*/</span></span><br><span class="line">	tempVex = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入顶点信息\n&quot;</span>);</span><br><span class="line">	<span class="type">char</span> tempdata;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;tempdata);</span><br><span class="line">	<span class="keyword">while</span> (tempdata != <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (tempVex&gt;=Maxsize || tempVex&gt;g-&gt;vexnum<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;输入顶点信息超出预定大小\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		g-&gt;Vertex[tempVex] = tempdata;</span><br><span class="line">		tempVex++;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;tempdata);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*建立图的边的关系*/</span></span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;	<span class="comment">//临时指针</span></span><br><span class="line">	tempVex = <span class="number">0</span>;	<span class="comment">//临时指针</span></span><br><span class="line">	tempEdge = <span class="number">0</span>;	<span class="comment">//存储输入的数据</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入边的信息\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tempEdge);</span><br><span class="line">	<span class="keyword">while</span> (tempEdge != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (index &gt; Maxsize<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;输入顶点信息超出预定数组&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		g-&gt;Edge[index][tempVex] = tempEdge;</span><br><span class="line">		tempVex++;</span><br><span class="line">		<span class="keyword">if</span> (tempVex&gt;g-&gt;vexnum<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			index++;</span><br><span class="line">			tempVex = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tempEdge);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;图建立完成\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第一个邻接点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FirstNeighbor</span><span class="params">(GMatrix* g, <span class="type">int</span> vex)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (g-&gt;Edge[vex][i]==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;查找到第一个邻接点为:%c\n&quot;</span>, g-&gt;Vertex[i]);</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;未查找到邻接点\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回除了该点的下一个邻接点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextNeighbor</span><span class="params">(GMatrix* g, <span class="type">int</span> vex,<span class="type">int</span> nextVex)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = nextVex+<span class="number">1</span>; i &lt; g-&gt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (g-&gt;Edge[vex][i] == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;查找到第一个邻接点为:%c\n&quot;</span>, g-&gt;Vertex[i]);</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;未查找到邻接点\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历(BFS)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(GMatrix* g,<span class="type">int</span> vex)</span> &#123;</span><br><span class="line">	ElemType isSerach[Maxsize];	<span class="comment">//辅助数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		isSerach[i] = <span class="number">0</span>;	<span class="comment">//初始化数组</span></span><br><span class="line">	&#125;</span><br><span class="line">	QHead q;	<span class="comment">//辅助队列</span></span><br><span class="line">	InitQueue(&amp;q);	<span class="comment">//初始化赋值队列</span></span><br><span class="line">	<span class="type">int</span> tempdata,deqdata;	<span class="comment">//临时变量</span></span><br><span class="line">	EnQueue(&amp;q, vex - <span class="number">1</span>);	<span class="comment">//遍历开始点入队</span></span><br><span class="line">	isSerach[vex <span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//如果队列不为空，则继续遍历</span></span><br><span class="line">	<span class="keyword">while</span> (q.size!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		deqdata = DeQueue(&amp;q);	<span class="comment">//出队顶点</span></span><br><span class="line">		tempdata = deqdata;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出队顶点为:%c\n&quot;</span>, g-&gt;Vertex[tempdata]);</span><br><span class="line">		tempdata = FirstNeighbor(g, tempdata);</span><br><span class="line">		<span class="keyword">if</span> (isSerach[tempdata]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			EnQueue(&amp;q, tempdata);	<span class="comment">//压入第一个顶点</span></span><br><span class="line">			isSerach[tempdata] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (tempdata!=<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tempdata = NextNeighbor(g, deqdata, tempdata);</span><br><span class="line">			<span class="keyword">if</span> (tempdata != <span class="number">-1</span> &amp;&amp; isSerach[tempdata] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				EnQueue(&amp;q, tempdata);	<span class="comment">//压入第一个顶点</span></span><br><span class="line">				isSerach[tempdata] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;图广度优先遍历完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//程序入口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	GMatrix g;	<span class="comment">//声明图</span></span><br><span class="line">	InitGraph(&amp;g);	<span class="comment">//初始化图</span></span><br><span class="line">	CreatGraph(&amp;g);	<span class="comment">//创建图</span></span><br><span class="line">	BFS(&amp;g, <span class="number">4</span>);	<span class="comment">//广度优先遍历图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试的图（无向图）示例如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae51869ab6.png" alt="image-20220830013902867" style="zoom:80%;" />

<p>我们从顶点 A 开始广度优先遍历，运行结果如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae51c1992a.png" alt="image-20220830013948174" style="zoom:80%;" />

<p>其中红框部分表示其的存储矩阵输入，蓝色框表示遍历输出的结果，即 A B E F C D。</p>
<p>当然，你也可以使用有向图来进行测试，例如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae5209551c.png" alt="image-20220830014209554" style="zoom:80%;" />

<p>当你使用上述有向图进行广度优先遍历的时候，如果是从顶点 A 开始广度优先遍历，则可以得到完整的遍历序列，如果你从 B 开始则会得到不包含 A 的遍历序列，<strong>事实上，如果你使用包含多个图的森林来测试上述广度优先算法，也会出现如果没有被指向的顶点被漏掉的情况</strong>。</p>
<p>这个时候就需要改进我们的广度优先算法，还记得我们为了避免广度优先遍历多次同一个顶点的时候我们创建了一个辅助数组用来记录每个顶点是否被遍历过吗？这个时候我们就可以继续利用它，遍历这个数组，如果还存在没有被遍历的顶点，则从这个顶点开始，再次进行一次广度优先遍历即可。</p>
<h3 id="邻接表-1"><a href="#邻接表-1" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接表图*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;图的存储结构.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;图队列.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGraph</span><span class="params">(GraphAdjList* g)</span> &#123;</span><br><span class="line">	g-&gt;arcnum = <span class="number">0</span>;	<span class="comment">//边数初始化为零</span></span><br><span class="line">	g-&gt;vexnum = <span class="number">0</span>;	<span class="comment">//顶点数初始化为零</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		g-&gt;vertices[i].data = <span class="number">0</span>;	<span class="comment">//顶点数组初始化为零</span></span><br><span class="line">		g-&gt;vertices[i].first = <span class="literal">NULL</span>;	<span class="comment">//顶点数组初始化为零</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;图初始化完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建邻接表图</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CreatGraph</span><span class="params">(GraphAdjList* g)</span> &#123;</span><br><span class="line">	<span class="type">int</span> tempVex = <span class="number">0</span>, tempArc = <span class="number">0</span>;	<span class="comment">//声明并初始化两个临时变量</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入顶点数和边数,例如：2,3(英文的逗号)\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;tempVex, &amp;tempArc);	<span class="comment">//获取输入的顶点数和边数</span></span><br><span class="line">	g-&gt;vexnum = tempVex;	<span class="comment">//顶点数写入图</span></span><br><span class="line">	g-&gt;arcnum = tempArc;	<span class="comment">//边数写入图</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入顶点信息\n&quot;</span>);</span><br><span class="line">	<span class="type">char</span> tempdata;</span><br><span class="line">	tempVex = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;tempdata);	<span class="comment">//读取要存储的顶点信息</span></span><br><span class="line">	<span class="keyword">while</span> (tempdata != <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果超出自己给出的顶点数或者默认的最大顶点数</span></span><br><span class="line">		<span class="keyword">if</span> (tempVex &gt;g-&gt;vexnum<span class="number">-1</span>|| tempVex &gt;Maxsize)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;超出预定顶点数目\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		g-&gt;vertices[tempVex].data = tempdata;	<span class="comment">//读取的顶点信息写入顶点数组</span></span><br><span class="line">		tempVex++;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;tempdata);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//头插法插入链表部分</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入边表信息，以 -1 表示结束输入\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tempVex);	<span class="comment">//读取边表信息</span></span><br><span class="line">		<span class="comment">//头插法建立边信息表</span></span><br><span class="line">		<span class="keyword">while</span> (tempVex != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ArcNode* arcnode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));	<span class="comment">//创建第一个边</span></span><br><span class="line">			arcnode-&gt;adjvex = tempVex;	<span class="comment">//边信息值赋值给创建的边</span></span><br><span class="line">			arcnode-&gt;next = g-&gt;vertices[i].first;	<span class="comment">//创建的边的下一条指针指向源顶点指向的边</span></span><br><span class="line">			g-&gt;vertices[i].first = arcnode;	<span class="comment">//顶点指向第一条边</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tempVex);	<span class="comment">//读取边表信息</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;图建立成功\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历（BFS）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(GraphAdjList* g,<span class="type">int</span> vex)</span> &#123;</span><br><span class="line">	<span class="type">int</span> isSerach[Maxsize];	<span class="comment">//声明辅助数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		isSerach[i] = <span class="number">0</span>;	<span class="comment">//初始化辅助数组</span></span><br><span class="line">	&#125;</span><br><span class="line">	QHead q;	<span class="comment">//声明队列</span></span><br><span class="line">	InitQueue(&amp;q);	<span class="comment">//初始化辅助队列</span></span><br><span class="line"></span><br><span class="line">	EnQueue(&amp;q, vex - <span class="number">1</span>);	<span class="comment">//第一个顶点入队</span></span><br><span class="line">	isSerach[vex - <span class="number">1</span>] = <span class="number">1</span>;	<span class="comment">//表示第一个顶点已经遍历过了</span></span><br><span class="line"></span><br><span class="line">	ElemTypeQ data = <span class="number">0</span>;</span><br><span class="line">	ArcNode* tempnode;</span><br><span class="line">	<span class="keyword">while</span> (q.size!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		data = DeQueue(&amp;q);	<span class="comment">//出队操作</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顶点 %c 已出队\n&quot;</span>, g-&gt;vertices[data]);</span><br><span class="line">		tempnode = g-&gt;vertices[data].first;</span><br><span class="line">		<span class="keyword">while</span> (tempnode!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果这个顶点没有被遍历过</span></span><br><span class="line">			<span class="keyword">if</span> (isSerach[tempnode-&gt;adjvex]!=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				EnQueue(&amp;q, tempnode-&gt;adjvex);	<span class="comment">//入队下一个顶点</span></span><br><span class="line">				isSerach[tempnode-&gt;adjvex] = <span class="number">1</span>;	<span class="comment">//表面该顶点已经被遍历了</span></span><br><span class="line">			&#125;</span><br><span class="line">			tempnode = tempnode-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;广度优先遍历图完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序入口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	GraphAdjList g;</span><br><span class="line">	InitGraph(&amp;g);</span><br><span class="line">	CreatGraph(&amp;g);</span><br><span class="line">	BFS(&amp;g, <span class="number">1</span>);	<span class="comment">//从图中顶点 A 位置开始广度优先遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果以下图顶点 A 位置开始广度优先遍历，运行结果如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae5209551c.png" alt="image-20220830014209554" style="zoom:80%;" />

 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae529871e4.png" alt="image-20220830033428161" style="zoom:80%;" />

<p>同样的，邻接表创建的无向图也可以使用上述代码进行广度优先遍历，当然，代码依旧存在对于如果没有入度的顶点无法遍历到的情况，解决办法和邻接矩阵部分一样，额外定义遍历辅助数组，查看辅助数组中是否存在未遍历的顶点，如果有，就以该顶点为广度优先遍历的起点开始遍历。</p>
<h3 id="广度优先生成树"><a href="#广度优先生成树" class="headerlink" title="广度优先生成树"></a>广度优先生成树</h3><p>因为广度优先遍历会产生一定的遍历次序，所以可以通过广度优先遍历生成一颗对应的广度优先生成树，图示如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae52f3384a.png" alt="image-20220830034207729" style="zoom:80%;" />

<h2 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h2><p>深度优先遍历类似于树的“深度优先遍历”，例如下图，<strong>如果在 A 开始深度优先遍历，则会先获取 A 点的数据，然后遍历 A 的第一个链接的顶点 E ，获取第一个链接的顶点 E 的数据，然后再遍历 E 的第一个链接的顶点，如果不为空，则继续向下遍历获取数据，直到其子顶点为<code>NULL</code>，则会遍历其父顶点的另一个子顶点</strong>。</p>
<p>你会发现<strong>它的逻辑其实就是递归遍历</strong>，由于图的性质，在实现的时候依旧需要使用辅助数组来标识哪个顶点被遍历过。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae5332c5aa.png" alt="image-20220830192941014" style="zoom:80%;" />

<h3 id="邻接矩阵-2"><a href="#邻接矩阵-2" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>现在来邻接矩阵实现深度优先遍历，首先需要声明一个全局变量<code>int isSerach[Maxsize];</code>用来做辅助数组，记得在使用深度优先遍历前将辅助数组初始化为 0 ，表示顶点没有被访问过。</p>
<p>如下代码只需要放在上面邻接矩阵的广度优先遍历方法的下面即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GMatrix g, <span class="type">int</span> vex)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;遍历顶点:%c\n&quot;</span>, g.Vertex[vex]);</span><br><span class="line">	isSerach[vex] = <span class="number">1</span>;	<span class="comment">//标识已经遍历过顶点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (g.Edge[vex][i]==<span class="number">1</span> &amp;&amp; isSerach[i] !=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			DFS(g, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序入口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	GMatrix g;	<span class="comment">//声明图</span></span><br><span class="line">	InitGraph(&amp;g);	<span class="comment">//初始化图</span></span><br><span class="line">	CreatGraph(&amp;g);	<span class="comment">//创建图</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		isSerach[i] = <span class="number">0</span>;	<span class="comment">//初始化辅助数组</span></span><br><span class="line">	&#125;</span><br><span class="line">	DFS(g, <span class="number">0</span>);	<span class="comment">//深度优先遍历邻接矩阵图 从顶点 A 开始</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试图如下，从下图的顶点 A 开始深度优先遍历。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae5332c5aa.png" alt="image-20220830192941014" style="zoom:80%;" />

<p>运行结果：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae53f8251e.png" alt="image-20220830195702611" style="zoom:80%;" />

<p>同样的，如果图中存在顶点不存在入度，或者是森林图的情况，则需要另外声明一个函数来遍历辅助数组，查看哪个顶点还未被遍历过，对未被遍历过的顶点进行再次的深度优先遍历。</p>
<h3 id="邻接表-2"><a href="#邻接表-2" class="headerlink" title="邻接表"></a>邻接表</h3><p>如下深度优先遍历方法代码只需要在前面广度优先遍历的邻接表的<code>.c</code>文件中添加到最后即可。但是仍需创建一个全局变量<code>int isSerach[Maxsize];</code>，用来做辅助数组，记得在执行深度优先遍历前将辅助数组初始化为<code>0</code>，即</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">&#123;</span><br><span class="line">	isSerach[i] = <span class="number">0</span>;	<span class="comment">//初始化辅助数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphAdjList g,<span class="type">int</span> vex)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;当前顶点为：%c\n&quot;</span>, g.vertices[vex].data);</span><br><span class="line">	isSerach[vex] = <span class="number">1</span>;</span><br><span class="line">	ArcNode* arcnode = g.vertices[vex].first;	<span class="comment">//临时顶点</span></span><br><span class="line">	<span class="keyword">while</span> (arcnode!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (isSerach[arcnode-&gt;adjvex]!=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			DFS(g, arcnode-&gt;adjvex);</span><br><span class="line">			arcnode = arcnode-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序入口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	GraphAdjList g;	<span class="comment">//声明图</span></span><br><span class="line">	InitGraph(&amp;g);	<span class="comment">//初始化图</span></span><br><span class="line">	CreatGraph(&amp;g);	<span class="comment">//创建图</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		isSerach[i] = <span class="number">0</span>;	<span class="comment">//初始化辅助数组</span></span><br><span class="line">	&#125;</span><br><span class="line">	DFS(g, <span class="number">0</span>);	<span class="comment">//对图从顶点 A 进行深度优先遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试图如下，从下图的顶点 A 开始深度优先遍历。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae5332c5aa.png" alt="image-20220830192941014" style="zoom:80%;" />

<p>运行结果:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae5484b6de.png" alt="image-20220830194024910" style="zoom:80%;" />

<p>同样的，如果图中存在顶点不存在入度，或者是森林图的情况，则需要另外声明一个函数来遍历辅助数组，查看哪个顶点还未被遍历过，对未被遍历过的顶点进行再次的深度优先遍历。</p>
<h3 id="深度优先生成树"><a href="#深度优先生成树" class="headerlink" title="深度优先生成树"></a>深度优先生成树</h3><p>同广度优先生成树，随着深度优先的遍历顺序，可以对应的生成一棵深度优先生成树。</p>
<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>生成树的理解如下图，左边的图可以产生如右边的两种生成树（当然不止这两种），其生成树的特点是连通的，且边数目等于顶点数目 -1.</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae54d19108.png" alt="image-20220830200438476" style="zoom:80%;" />

<p><strong>最小生成树是在如上的基础上，边存在权值，如果生成树的边权值之和最小的树，被称为最小生成树</strong>。</p>
<p>获取最小生成树的算法有两种：</p>
<ul>
<li><p><strong>Prim（普利姆）算法</strong></p>
<p><strong>从图中某个顶点开始构建生成树，每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。</strong></p>
</li>
<li><p><strong>Kruskal（克鲁斯卡尔）算法</strong></p>
<p><strong>每次选择一条权值最小的边，使得这两条边的两头联通，直到所有的结点都连通。</strong></p>
</li>
</ul>
<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>最短路径问题，直接用应用带入，例如我们的导航是如何直到我们和目的地之间的最优最短路径呢？</p>
<p>关于最短路径问题可以分为如下情况：</p>
<ul>
<li><strong>单源最短路径</strong><ul>
<li><strong>BFS 算法（无权图）</strong></li>
<li><strong>Dijkstra 算法（带权图，无权图）</strong></li>
</ul>
</li>
<li><strong>各顶点间的最短路径</strong><ul>
<li><strong>Floyd 算法（带权图，无权图）</strong></li>
</ul>
</li>
</ul>
<h2 id="BFS-算法"><a href="#BFS-算法" class="headerlink" title="BFS 算法"></a>BFS 算法</h2><p>BFS 也就是广度优先遍历算法，可以求得无权图（或者说权都为 1）的图的单源最短路径。</p>
<p>实现思路和广度优先遍历无差别，只是在广度优先遍历在读取结点数据的时候需要做两个操作，<strong>创建两个数组，分别表示遍历开始顶点到当前顶的距离和表示自己上一个最近的顶点是谁</strong>。在每次广度优先遍历顶点的时候，将两个数组进行相关赋值操作，遍历完成后，两个数组就包含了当前广度优先遍历顶点到其他顶点的最短路径信息。</p>
<p>此处用邻接矩阵来做代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广度优先-最短路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS_Min_Distance</span><span class="params">(GMatrix* g,<span class="type">int</span> vex)</span> &#123;</span><br><span class="line">	ElemType path[Maxsize];	<span class="comment">//记录上一个顶点</span></span><br><span class="line">	ElemType d[Maxsize];	<span class="comment">//记录顶点间的距离</span></span><br><span class="line">	ElemType isSerach[Maxsize];	<span class="comment">//辅助数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		isSerach[i] = <span class="number">0</span>;	<span class="comment">//初始化数组</span></span><br><span class="line">		path[i] = <span class="number">-1</span>;</span><br><span class="line">		d[i] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	QHead q;	<span class="comment">//辅助队列</span></span><br><span class="line">	InitQueue(&amp;q);	<span class="comment">//初始化赋值队列</span></span><br><span class="line">	<span class="type">int</span> tempdata, deqdata;	<span class="comment">//临时变量</span></span><br><span class="line">	EnQueue(&amp;q, vex - <span class="number">1</span>);	<span class="comment">//遍历开始点入队</span></span><br><span class="line">	isSerach[vex - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	d[vex - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//如果队列不为空，则继续遍历</span></span><br><span class="line">	<span class="keyword">while</span> (q.size != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		deqdata = DeQueue(&amp;q);	<span class="comment">//出队顶点</span></span><br><span class="line">		tempdata = deqdata;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出队顶点为:%c\n&quot;</span>, g-&gt;Vertex[tempdata]);</span><br><span class="line">		tempdata = FirstNeighbor(g, tempdata);</span><br><span class="line">		<span class="keyword">if</span> (isSerach[tempdata] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			EnQueue(&amp;q, tempdata);	<span class="comment">//压入第一个顶点</span></span><br><span class="line">			isSerach[tempdata] = <span class="number">1</span>;</span><br><span class="line">			d[tempdata] = d[deqdata] + <span class="number">1</span>;</span><br><span class="line">			path[tempdata] = deqdata;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (tempdata != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tempdata = NextNeighbor(g, deqdata, tempdata);</span><br><span class="line">			<span class="keyword">if</span> (tempdata != <span class="number">-1</span> &amp;&amp; isSerach[tempdata] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				EnQueue(&amp;q, tempdata);	<span class="comment">//压入第一个顶点</span></span><br><span class="line">				isSerach[tempdata] = <span class="number">1</span>;</span><br><span class="line">				d[tempdata] = d[deqdata] + <span class="number">1</span>;</span><br><span class="line">				path[tempdata] = deqdata; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;图广度优先遍历完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>Dijkstra（迪杰斯特拉）算法是一种可以求带权图的最短路径的算法，例如下面的图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae553c655a.png" alt="image-20220830221648062" style="zoom:80%;" />

<p>该算法需要创建 3 个数组，其作用如下：</p>
<ul>
<li><strong><code>final[]</code>：记录顶点是否被连通了。</strong></li>
<li><strong><code>dist[]</code>：记录顶点关于已连通路径的权值。</strong></li>
<li><strong><code>path[]</code>：记录顶点和算法开始遍历顶点（单源）的路径，实际上是记录和最近上一个顶点。</strong></li>
</ul>
<p>例如，我们从顶点 A 开始算法遍历，首先需要进行数组初始化，初始化结果如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae557cfc87.png" alt="image-20220830222508474" style="zoom:80%;" />

<p>上述 A 顶点的<code>final[]</code>的<code>True</code>表示顶点 A 是目前连通路径中，因为只有一个<code>True</code>，所以它是目前连通路径的唯一顶点，也是初始顶点，而<code>dist[]</code>中的权值表示从顶点 A 到 A 可以直接连通的顶点的权值（带权路径长度），由图可知，顶点 A 和其他顶点都存在通路，所以 BCDE 的<code>dist[]</code>的值是顶点 A 到它们的路径权值，而<code>path</code>数组表示从顶点 A 到其中的任何一个顶点的路径（当前顶点的上一个路径）。</p>
<p>完成上面的初始化工作后，现在开始遍历<code>dist[]</code>数组，找到其中<code>dist[]</code>数值最小的（即权值最小）的，让它成为最短（即结果）路径的一个顶点，即顶点 E 。然后再做类似于初始化的工作，得到的数组结果如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae55c0bc8a.png" alt="image-20220830223723290" style="zoom:80%;" />

<p>数组<code>final[]</code>将顶点 E 的数值修改为<code>True</code>表示顶点 E 已经是最短路径中的一个顶点了，这个时候以顶点 E 为开始，计算从 E 到和它连通的顶点的权值和顶点 A 到它的权值和是否比 A 到其他顶点的权值低，如 C 顶点到 E 的权值为 1 ，A 到 C的原先权值为 3 ，如果从 A 到 E 再到 C 的权值则为 $3+1&#x3D;4$ 比 A 到 C 的权值高，则不覆盖 C 的<code>dist[]</code>值，而与 E 连通的另一个顶点 D 同样的，如果 A 到 E 再到 D 的权值为 $3+6&#x3D;9$，而其值比 A 到 D 的权值高，所以也不覆盖，然后从中选取权值最低的 C 作为新的顶点，依次类推。</p>
<h2 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h2><p>关于 Floyd 算法其思路可以参考 <a href="httpss://www.bilibili.com/video/BV14R4y1x7GB?p=1&t=588">求最短路径Floyd算法！</a> </p>
<p>这个算法就算录视频说明也要说上一阵，不想打字了，自行参考吧  :）</p>
<p>算法的示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Floyd 算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Floyd</span><span class="params">(GMatrix g)</span> &#123;</span><br><span class="line">	<span class="type">int</span> path[Maxsize][Maxsize];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Maxsize; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			path[i][j] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; g.vexnum; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.vexnum; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (g.Edge[i][j]&gt; g.Edge[i][k]+ g.Edge[k][j])</span><br><span class="line">				&#123;</span><br><span class="line">					g.Edge[i][j] = g.Edge[i][k] + g.Edge[k][j];</span><br><span class="line">					path[i][j] = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：算法是在邻接矩阵存储格式下实现的</p>
</blockquote>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>拓扑排序适用于 DAG 图（Directed Acyclic Graph），即有向无环图。人话来说就是图中不能出现回环。</p>
<p>拓扑排序可以解决下图的顺序问题：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae56749272.png" alt="image-20220831003334997" style="zoom:67%;" />

<blockquote>
<p>图片来源：王道《数据结构》</p>
</blockquote>
<p>拓扑排序可以解决上述 AOV 网（Activity On Vertex Network）的执行顺序问题。其解决方案：</p>
<blockquote>
<p>AOV 人话来说就是用顶点来表示一个个的事件&#x2F;活动</p>
</blockquote>
<ol>
<li><strong>从 AOV 网中选择一个没有前驱（入度为 0 ）的顶点并输出</strong></li>
<li><strong>从网中删除该顶点和所有以它为起点的有向边</strong></li>
<li><strong>重复上述操作，直到当前 AOV 网为空 或者 当前网中不存在无前驱的顶点为止</strong></li>
</ol>
<p>拓扑排序代码示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Topological</span><span class="params">(GMatrix g)</span> &#123;</span><br><span class="line">	QHead q;	<span class="comment">//声明辅助队列</span></span><br><span class="line">	InitQueue(&amp;q);	<span class="comment">//初始化队列</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.vexnum; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i==g.vexnum<span class="number">-1</span> &amp;&amp; g.Edge[i][j]==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				EnQueue(&amp;q, j);	<span class="comment">//将无入度的顶点入队</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; g.vexnum<span class="number">-1</span>; k++)</span><br><span class="line">				&#123;</span><br><span class="line">					g.Edge[j][k] = <span class="number">0</span>;	<span class="comment">//将关于无入度的顶点删除边</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顶点数据为:&quot;</span>);</span><br><span class="line">	<span class="comment">//队列不为空，则弹出队列内容</span></span><br><span class="line">	<span class="keyword">while</span> (q.size!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, g.Vertex[DeQueue(&amp;q)]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将代码放在广度优先求最短路径算法下面即可，代码以图的邻接矩阵存储结构实现的。</p>
<p>使用的图示例如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae56bd6c17.png" alt="image-20220831011251475" style="zoom:80%;" />

<p>运行结果：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae56fc7710.png" alt="image-20220831011032498" style="zoom: 77%;" />

<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>图学完啦，学完图就没有其他的数据结构了，剩下就是如何来利用这些数据结构来应用了，比如查找和排序。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae573b7ea8.png" alt="image-20220831013625512" style="zoom:90%;" />
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.helloseraphine.top">Maxwell Lei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.helloseraphine.top/2022/02/01/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%906.1%E3%80%91%E5%9B%BE/">https://www.helloseraphine.top/2022/02/01/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%906.1%E3%80%91%E5%9B%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.helloseraphine.top" target="_blank">Maxwell_Leiの小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae4e680130.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/28/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E6%80%9D%E8%80%83/" title="关于C语言的一些零碎思考"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64abbc352b8f4.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">关于C语言的一些零碎思考</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%908.1%E3%80%91%E6%8E%92%E5%BA%8F/" title="【8.1】排序"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aae62decdbc.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【8.1】排序</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://thirdqq.qlogo.cn/g?b=qq&amp;nk=738232585&amp;s=100" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Maxwell Lei</div><div class="author-info__description">如果有一天我可以在海里翱翔，就像一只小魔鬼鱼</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/MaxwellLei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/MaxwellLei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:738232585@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://afdian.com/a/fastgpt" target="_blank" title="每天给生活来一拳"><i class="fas fa-coffee"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">活着就是能与别人彼此相知，心意相通，人生在世的意义不就是希望有那种与自己有默契的人存在吗，欣赏认可别人，喜欢爱恋别人，厌烦憎恶别人，因为和别人在一起而感到快乐，可以和别人牵着手并肩前行，这个过程就是活着。如果世界里只有自己，我们就无法感受到存在是什么，我们与别人的关系就是我们自己活着的证明。我的灵魂之所以存在，是因为有你们的关注，我的身体之所以存在，则是因为有你们的碰触，所以啊，只要人活在世上，就一定是有意义的。怎么活是自己选的，就像你和我就都选择了像现在这样活着。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.</span> <span class="toc-text">图的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">图的基本概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">3.1.</span> <span class="toc-text">邻接矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">3.1.1.</span> <span class="toc-text">邻接矩阵的性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">十字链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="toc-number">3.4.</span> <span class="toc-text">邻接多重表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">图的基本操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88BFS%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">广度优先遍历（BFS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-1"><span class="toc-number">5.1.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8-1"><span class="toc-number">5.1.2.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">5.1.3.</span> <span class="toc-text">广度优先生成树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88DFS%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">深度优先遍历（DFS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-2"><span class="toc-number">5.2.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8-2"><span class="toc-number">5.2.2.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">5.2.3.</span> <span class="toc-text">深度优先生成树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">7.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS-%E7%AE%97%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text">BFS 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dijkstra-%E7%AE%97%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">Dijkstra 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Floyd-%E7%AE%97%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">Floyd 算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#End"><span class="toc-number">9.</span> <span class="toc-text">End</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/30/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%9F%BA%E7%A1%80%E6%8C%87%E5%8D%97/%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE%E7%A5%9E%E5%99%A8%E6%8E%A8%E8%8D%90%EF%BC%9A%E8%BD%BB%E6%9D%BE%E7%94%BB%E5%87%BA%E4%B8%93%E4%B8%9A%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%9B%BE/" title="科研绘图神器推荐：轻松画出专业神经网络结构图"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2025/05/06/image-20250506194616870-7baa546bb956c8e08f5646878a337ccf.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="科研绘图神器推荐：轻松画出专业神经网络结构图"/></a><div class="content"><a class="title" href="/2025/04/30/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%9F%BA%E7%A1%80%E6%8C%87%E5%8D%97/%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE%E7%A5%9E%E5%99%A8%E6%8E%A8%E8%8D%90%EF%BC%9A%E8%BD%BB%E6%9D%BE%E7%94%BB%E5%87%BA%E4%B8%93%E4%B8%9A%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%9B%BE/" title="科研绘图神器推荐：轻松画出专业神经网络结构图">科研绘图神器推荐：轻松画出专业神经网络结构图</a><time datetime="2025-04-30T12:28:11.000Z" title="发表于 2025-04-30 20:28:11">2025-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/22/%E6%95%B0%E5%AD%A6%E5%9C%B0%E7%90%83%E7%A7%91%E5%AD%A6/%E5%9C%B0%E7%90%83%E5%8C%96%E5%AD%A6/%E5%9C%B0%E7%90%83%E5%8C%96%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B0%81%E9%97%AD%E6%95%88%E5%BA%94/" title="地球化学数据的封闭效应"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2025/04/22/%E4%B8%8B%E8%BD%BD%20-2--a07824441018abfd3eadb8ac26e77787.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="地球化学数据的封闭效应"/></a><div class="content"><a class="title" href="/2025/04/22/%E6%95%B0%E5%AD%A6%E5%9C%B0%E7%90%83%E7%A7%91%E5%AD%A6/%E5%9C%B0%E7%90%83%E5%8C%96%E5%AD%A6/%E5%9C%B0%E7%90%83%E5%8C%96%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B0%81%E9%97%AD%E6%95%88%E5%BA%94/" title="地球化学数据的封闭效应">地球化学数据的封闭效应</a><time datetime="2025-04-22T09:05:21.000Z" title="发表于 2025-04-22 17:05:21">2025-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/22/%E6%95%B0%E5%AD%A6%E5%9C%B0%E7%90%83%E7%A7%91%E5%AD%A6/%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B/%E6%8F%90%E5%8D%87%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%85%B3%E9%94%AE%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97/" title="提升成矿预测模型的关键：深度学习数据增强技术指南"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2025/04/22/image-20250422170300572-273cba575796a988364fcae203a91775.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="提升成矿预测模型的关键：深度学习数据增强技术指南"/></a><div class="content"><a class="title" href="/2025/04/22/%E6%95%B0%E5%AD%A6%E5%9C%B0%E7%90%83%E7%A7%91%E5%AD%A6/%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B/%E6%8F%90%E5%8D%87%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%85%B3%E9%94%AE%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97/" title="提升成矿预测模型的关键：深度学习数据增强技术指南">提升成矿预测模型的关键：深度学习数据增强技术指南</a><time datetime="2025-04-22T07:29:14.000Z" title="发表于 2025-04-22 15:29:14">2025-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/28/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Pytorch%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E6%A6%82%E8%A6%81/" title="深度学习入门概要"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/11/28/6565b0cf0325a.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深度学习入门概要"/></a><div class="content"><a class="title" href="/2023/11/28/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Pytorch%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E6%A6%82%E8%A6%81/" title="深度学习入门概要">深度学习入门概要</a><time datetime="2023-11-28T01:59:36.000Z" title="发表于 2023-11-28 09:59:36">2023-11-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E7%A2%8E%E7%89%87%E5%8C%96%E7%9F%A5%E8%AF%86/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%96%B9%E6%B3%95/" title="蒙特卡洛方法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/11/27/6563fba9bff1e.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="蒙特卡洛方法"/></a><div class="content"><a class="title" href="/2023/11/27/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E7%A2%8E%E7%89%87%E5%8C%96%E7%9F%A5%E8%AF%86/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%96%B9%E6%B3%95/" title="蒙特卡洛方法">蒙特卡洛方法</a><time datetime="2023-11-27T01:27:34.000Z" title="发表于 2023-11-27 09:27:34">2023-11-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Maxwell Lei</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://ahqxdttiopbn.ap-northeast-1.clawcloudrun.com/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://ahqxdttiopbn.ap-northeast-1.clawcloudrun.com/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>