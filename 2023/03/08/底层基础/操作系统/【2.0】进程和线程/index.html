<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【2.0】进程和线程 | Seraphineの小窝</title><meta name="author" content="Seraphine"><meta name="copyright" content="Seraphine"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言NULL，基础部分，很长很多很麻烦 进程与线程进程的概念程序：是静态的，程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。进程（Process）：是动态的，是程序的一次执行过程。 进程的组成系统使用 PCB（进程控制块）来描述进程的基本情况和运行状态，进而控制和管理进程。   相应的，程序段，数据段和 PCB 三个部分构成了进程实体。进程是动态的，进程实体是静态的。 进程是">
<meta property="og:type" content="article">
<meta property="og:title" content="【2.0】进程和线程">
<meta property="og:url" content="https://www.helloseraphine.top/2023/03/08/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%902.0%E3%80%91%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Seraphineの小窝">
<meta property="og:description" content="前言NULL，基础部分，很长很多很麻烦 进程与线程进程的概念程序：是静态的，程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。进程（Process）：是动态的，是程序的一次执行过程。 进程的组成系统使用 PCB（进程控制块）来描述进程的基本情况和运行状态，进而控制和管理进程。   相应的，程序段，数据段和 PCB 三个部分构成了进程实体。进程是动态的，进程实体是静态的。 进程是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad352d0a82.webp">
<meta property="article:published_time" content="2023-03-08T15:30:01.000Z">
<meta property="article:modified_time" content="2023-07-14T13:00:31.171Z">
<meta property="article:author" content="Seraphine">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad352d0a82.webp"><link rel="shortcut icon" href="https://img.helloseraphine.top:8089/blog/2023/07/10/64abfad3db52f.ico"><link rel="canonical" href="https://www.helloseraphine.top/2023/03/08/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%902.0%E3%80%91%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e46e337e762e79ae7f939118e01248b7";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"距离本文的最后一次更新是","messageNext":"天之前, 部分内容可能已经过时了."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":512},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":2048,"languages":{"author":"作者: Seraphine","link":"链接: ","source":"来源: Seraphineの小窝","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【2.0】进程和线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-14 21:00:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Seraphineの小窝" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://thirdqq.qlogo.cn/g?b=qq&amp;nk=738232585&amp;s=100" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/MessageBoard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/updateLog/"><i class="fa-fw fas fa-wrench"></i><span> 更新日志</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img.helloseraphine.top:8089/blog/2023/07/09/64aad352d0a82.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Seraphineの小窝"><span class="site-name">Seraphineの小窝</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/MessageBoard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/updateLog/"><i class="fa-fw fas fa-wrench"></i><span> 更新日志</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【2.0】进程和线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-08T15:30:01.000Z" title="发表于 2023-03-08 23:30:01">2023-03-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-14T13:00:31.171Z" title="更新于 2023-07-14 21:00:31">2023-07-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/">底层基础</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【2.0】进程和线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>NULL，基础部分，很长很多很麻烦</p>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><p><strong>程序</strong>：是<strong>静态</strong>的，程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。<br><strong>进程</strong>（Process）：是<strong>动态</strong>的，是程序的一次执行过程。</p>
<h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><p>系统使用 <strong>PCB（进程控制块）</strong>来描述进程的基本情况和运行状态，进而控制和管理进程。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad372ab6f7.png" alt="image-20230303191359280" style="zoom:80%;" />

<p>相应的，<strong>程序段，数据段和 PCB 三个部分构成了进程实体</strong>。进程是动态的，进程实体是静态的。</p>
<p>进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配和调度</strong>的一个独立单位。</p>
<blockquote>
<p><strong>PCB 是进程存在的唯一标志</strong></p>
</blockquote>
<h2 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h2><ol>
<li>动态性：进程是动态产生，变化和消亡的</li>
<li>并发性：内存中有多个进程实体，各进程可以并发执行</li>
<li>独立性：独立运行，获得资源，进行调度的基本单位</li>
<li>异步性</li>
<li>结构性</li>
</ol>
<h2 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h2><ol>
<li>进程正在被创建时，其状态为“ <strong>创建态</strong> ”，这个阶段会分配资源，初始化 PCB</li>
<li>当进程创建完成后，便进入“<strong>就绪态</strong>”，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行</li>
<li>如果一个进程此时在CPU上运行，那么这个进程处于“<strong>运行态</strong>”。</li>
<li>在进程运行的过程中，可能会请求等待某个事件的发生。在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“<strong>阻塞态</strong>”</li>
<li>一个进程可以执行exit系统调用，请求操作系统终止该进程。此时该进程会进入“<strong>终止态</strong>”，操作系统会让该进程下CPU，并回收内存空间等资源，<strong>最后还要回收该进程的PCB</strong>。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad37850e34.png" alt="image-20230303194359726" style="zoom:80%;" />

<p>$\color{red}{运行态} \to 阻塞态$ 是一种进程自身做出的<strong>主动行为</strong>。$\color{red}{阻塞态} \to 运行态$ 不能由进程自身控制，是一种<strong>被动行为</strong>。</p>
<blockquote>
<p>注意：不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态</p>
<p>另外，在单核 CPU 情况下，同一时刻只会有一个进程处于运行态</p>
</blockquote>
<p>补充：进程的挂起态和七状态模型</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad37d465f8.png" alt="image-20230304181741819" style="zoom:80%;" />

<h2 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h2><h3 id="链式方式"><a href="#链式方式" class="headerlink" title="链式方式"></a>链式方式</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3820313d.png" alt="image-20230303194924225" style="zoom:80%;" />

<h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3870eec4.png" alt="image-20230303201906700" style="zoom:80%;" />

<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制的主要功能是<strong>对系统中的所有进程实施有效的管理</strong>，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p>
<blockquote>
<p>进程状态的转换，需要通过原语转换，不可中断</p>
</blockquote>
<p><strong>原语</strong>的执行具有<strong>原子性</strong>，即执行过程只能一气呵成，<strong>期间不允许被中断</strong>。可以用<strong>“关中断指令”和“开中断指令”</strong>这两个<strong>特权指令</strong>实现原子性。</p>
<p>因为 CPU 在执行指令后需要检查是否有外部中断信号，这个时候关闭中断指令，即使收到中断信号，也不会中断，这样就实现了原子性，等到执行完成后，进行开中断。</p>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad38bf12c8.png" alt="image-20230303202908058" style="zoom:80%;" />

<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad38ff01f9.png" alt="image-20230303203152548" style="zoom:80%;" />

<h3 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3943d115.png" alt="image-20230303203341450" style="zoom:80%;" />

<h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad39827e49.png" alt="image-20230303203433572" style="zoom:80%;" />



<h2 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h2><p>进程间通信（Inter-Process Communication，IPC）是<strong>指两个进程 之间产生数据交互</strong>。</p>
<blockquote>
<p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p>
</blockquote>
<p>进程的通信可以分为三种：<strong>共享存储，消息传递和管道通信</strong></p>
<h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>即开辟一段共享的内存空间，这样不同的进程可以在这个共享的内存空间中，读取或者写入数据来完成通信。</p>
<p><strong>为避免出错，各个进程对共享空间的访问应该是互斥的</strong>。</p>
<p>共享存储又可以分为：</p>
<ul>
<li><strong>基于存储区的共享</strong>：操作系统在内存中划出一块共享存储区，数据的形式、存放位置都<strong>由通信进程控制，而不是操作系统</strong>。这种共享方式速度很快，是一种高级通信方式。**</li>
<li><strong>基于数据结构的共享</strong>：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。</li>
</ul>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p><strong>进程间的数据交换以格式化的消息（Message）为单位</strong>。进程通过操作系统提供的“发送消息／接收消息”两个原语进行数据交换。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="httpss://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20230303210524715.png" alt="image-20230303210524715" style="zoom:50%;" />

<p>消息传递又可以分为</p>
<ul>
<li><p><strong>直接通信方式</strong>：消息发送进程要指明接收进程的ID。</p>
</li>
<li><p><strong>间接通信方式</strong>：以“信箱”作为中间实体进行消息传递。</p>
<blockquote>
<p>可以多个进程往同一个信箱 send 消息，也可以多个进程，从同一个信箱中receive消息 </p>
</blockquote>
</li>
<li><p><strong>管道通信</strong>：“管道”是一个特殊的共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区</p>
<ol>
<li>管道<strong>只能采用半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</li>
<li>各进程要<strong>互斥地访问管道</strong>（由操作系统实现）</li>
<li><strong>当管道写满时，写进程将阻塞</strong>，直到读进程将管道中的数据取走，即可唤醒写进程。</li>
<li><strong>管道中的数据一旦被读出，就彻底消失</strong>。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：①<strong>一个管道允许多个写进程，一个读进程</strong>；②<strong>允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据</strong>（Linux的方案）。</li>
</ol>
</li>
</ul>
<h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，<strong>引入了“线程”，来增加并发度</strong>。</p>
<p><strong>线程是一个基本的CPU执行单元，也是程序执行流的最小单位</strong>。</p>
<p>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）。<br>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad39f8127f.png" alt="image-20230303220256817" style="zoom:80%;" />

<h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3a371c2b.png" alt="image-20230303220437107" style="zoom:80%;" />

<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>早期的操作系统（如：早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3a7bc2ab.png" alt="image-20230303221645391" style="zoom: 43%;" />

<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高<br><strong>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</strong>。</p>
<h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><p>大多数现代操作系统都实现了内核级线程，如Windows、Linux</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3ac20364.png" alt="image-20230303222328962" style="zoom:43%;" />

<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。<br>缺点：<strong>一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</strong>。</p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><ul>
<li><strong>一对一模型</strong>：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</li>
<li><strong>多对一模型</strong>：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3b062ce1.png" alt="image-20230303222528761" style="zoom: 43%;" /></li>
<li><strong>多对多模型</strong>：n用户及线程映射到m个内核级线程（n＞＝m）。每个用户进程对应m个内核级线程。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3b498aae.png" alt="image-20230303222627366" style="zoom:43%;" /></li>
</ul>
<blockquote>
<p>操作系统只“看得见”内核级线程，因此<strong>只有内核级线程才是处理机分配的单位</strong>。</p>
</blockquote>
<h2 id="线程的状态与转换"><a href="#线程的状态与转换" class="headerlink" title="线程的状态与转换"></a>线程的状态与转换</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3b933f34.png" alt="image-20230303222839798" style="zoom:50%;" />

<p>管理线程是通过 TCB（线程控制块）。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3be29246.png" alt="image-20230303223133291" style="zoom:67%;" />

<p>多个线程 TCB 组成一张线程表，进行分类管理。</p>
<h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><h2 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h2><p>在多到程序系统中，由于资源优先，来使用调度来分配资源来实现并发执行。</p>
<h2 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h2><ol>
<li><p><strong>高级调度</strong>（作业调度）：按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。<strong>作业调入时会建立PCB，调出时才撤销PCB</strong>。</p>
<blockquote>
<p>即将外存中的程序&#x2F;作业，调入内存进行执行</p>
</blockquote>
</li>
<li><p><strong>低级调度</strong>（进程调度／处理机调度）：按照某种策略从就绪队列中<strong>选取一个进程</strong>，将处理机分配给它</p>
</li>
<li><p><strong>中级调度</strong>（内存调度）：按照某种策略决定将哪个处于挂起状态的进程重新调入内存。</p>
<blockquote>
<p>即将内存中挂起态的程序&#x2F;作业，调入外存中以腾出内存空间</p>
</blockquote>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3c46e8bf.png" alt="image-20230304181844478" style="zoom:80%;" />

<h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><p>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p>
<p><strong>需要进行进程调度</strong>的情况：</p>
<ol>
<li>当前运行的进程<strong>主动放弃处理机</strong></li>
<li>当前运行的进程<strong>被动放弃处理机</strong></li>
</ol>
<p><strong>不能进行进程调度</strong>的情况：</p>
<ol>
<li>在<strong>处理中断的过程</strong>中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li>
<li><strong>进程在操作系统内核程序临界区中</strong>。</li>
<li>在<strong>原子操作过程中（原语）</strong>。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li>
</ol>
<blockquote>
<p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</p>
<p>临界区：访问临界资源的那段代码。</p>
<p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p>
</blockquote>
<h2 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h2><p><strong>非剥夺调度方式</strong>，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p>
<p><strong>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</strong>。</p>
<p><strong>剥夺调度方式</strong>，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p>
<p>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统。</p>
<h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>调度程序进行调度的时机：</p>
<ol>
<li><strong>创建新进程</strong></li>
<li><strong>进程退出</strong></li>
<li>运行<strong>进程阻塞</strong></li>
<li><strong>I&#x2F;O中断</strong>发生</li>
</ol>
<blockquote>
<ul>
<li>非抢占式调度策略，只有运行进程阻塞或退出才触发调度程序工作</li>
<li>抢占式调度策略，每个时钟中断或k个时钟中断会触发调度程序工作</li>
</ul>
</blockquote>
<h2 id="闲逛进程"><a href="#闲逛进程" class="headerlink" title="闲逛进程"></a>闲逛进程</h2><p>调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程（idle）</p>
<p>闲逛进程的特性：</p>
<ul>
<li><strong>优先级最低</strong></li>
<li>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</li>
<li>能耗低</li>
</ul>
<h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><p><strong>CPU利用率：指CPU“忙碌”的时间占总时间的比例</strong>。</p>
<p>$\large 利用率 &#x3D; \frac{忙碌的时间}{总时间}$ </p>
<p><strong>系统吞吐量：单位时间内完成作业的数量</strong>。</p>
<p>$\large 系统吞吐量 &#x3D; \frac{中共完成了多少道作业}{总共花了多少时间}$ </p>
<p><strong>周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔</strong>。</p>
<p>$周转时间&#x3D;作业完成时间 - 作业提交时间$ </p>
<p>$\large 平均周转时间 &#x3D; \frac{各作业周转时间之和}{作业数}$ </p>
<p>$\large 带权周转时间 &#x3D; \frac{作业周转时间}{作业实际运行时间} &#x3D; \frac{作业完成时间 - 作业提交时间}{作业实际运行时间}$ </p>
<blockquote>
<p>带权周转时间必然是 $\geqslant 1$ </p>
<p>带权周转时间与周转时间是越小越好</p>
</blockquote>
<p>$\large 平均带权周转时间 &#x3D; \frac{各作业带权周转时间之和}{作业数}$ </p>
<p><strong>等待时间</strong>，指进程／作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p>
<p>对于<strong>进程</strong>来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I／O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p>
<p>对于<strong>作业</strong>来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p>
<p>响应时间，指从用户提交请求到首次产生响应所用的时间。</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h3><table>
<thead>
<tr>
<th>类目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）</td>
</tr>
<tr>
<td>算法规则</td>
<td>按照作业&#x2F;进程到达的先后顺序进行服务</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>用于<strong>作业调度</strong>时，考虑的是哪个作业先到达<strong>后备队列</strong>（外存）；<br />用于<strong>进程调度</strong>时，考虑的是哪个进程先到达<strong>就绪队列</strong>（内存）；</td>
</tr>
<tr>
<td>是否可以抢占</td>
<td><strong>非抢占式算法</strong>（即阻塞或者结束进程）</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：公平、算法实现简单<br/>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，<strong>FCFS算法对长作业有利，对短作业不利</strong></td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td><strong>不会</strong></td>
</tr>
</tbody></table>
<h3 id="短作业优先（SJF）"><a href="#短作业优先（SJF）" class="headerlink" title="短作业优先（SJF）"></a>短作业优先（SJF）</h3><p>短作业／进程优先调度算法：每次调度时选择<strong>当前已到达且运行时间最短</strong>的作业／进程。</p>
<table>
<thead>
<tr>
<th>类目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</td>
</tr>
<tr>
<td>算法规则</td>
<td>最短的作业／进程优先得到服务（所谓“最短”，是指要求服务时间最短）</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先（<strong>SPF</strong>，Shortest Process First）算法”</td>
</tr>
<tr>
<td>是否可以抢占</td>
<td>SJF 和 SPF是<strong>非抢占式算法</strong>。但是<strong>也有抢占式的版本——最短剩余时间优先算法</strong>(SRTN,Shortes<br/>st Remaining Time Next)</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：“最短的”平均等待时间、平均周转时间<br/>缺点：不公平。<strong>对短作业有利，对长作业不利。可能产生饥饿现象</strong>。另外，作业／进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td><strong>会</strong>。如果源源不断地有短作业／进程到来，可能使长作业／进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”</td>
</tr>
</tbody></table>
<p><strong>最短剩余时间优先算法</strong>（SPF）：每当有进程<strong>加入就绪队列改变时就需要调度</strong>，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度</p>
<blockquote>
<ol>
<li>如果题目中未特别说明，所提到的“短作业／进程优先算法<strong>”默认是非抢占式的</strong></li>
<li>很多书上都会说“SJF调度算法的平均等待时间、平均周转时间最少”（严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少<br>应该加上一个条件“在所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转时间最少”）</li>
<li>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间</li>
</ol>
</blockquote>
<h3 id="高响应比优先（HRRN）"><a href="#高响应比优先（HRRN）" class="headerlink" title="高响应比优先（HRRN）"></a>高响应比优先（HRRN）</h3><p>高响应比优先算法：非抢占式的调度算法，只有当前运行的进程主动放弃CPU时（正常&#x2F;异常完成，或主动阻塞），才需要进行调度，调度时<strong>计算所有就绪进程的响应比，选响应比最高的进程上处理机</strong>。</p>
<table>
<thead>
<tr>
<th>类目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>要综合考虑作业&#x2F;进程的等待时间和要求服务的时间</td>
</tr>
<tr>
<td>算法规则</td>
<td>在每次调度时先计算各个作业／进程的响应比，选择响应比最高的作业／进程为其服务<br /> $\large 响应比 &#x3D; \frac{等待时间 + 要求服务时间}{要求服务时间}$</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>即可用于作业调度，也可用于进程调度</td>
</tr>
<tr>
<td>是否可以抢占</td>
<td><strong>非抢占式的算法</strong>。因此只有当前运行的作业／进程主动放弃处理机时，才需要调度，才需要计算响应比</td>
</tr>
<tr>
<td>优缺点</td>
<td>综合考虑了等待时间和运行时间（要求服务时间）<br/><strong>等待时间相同时，要求服务时间短的优先（SJF的优点）</strong><br /><strong>要求服务时间相同时，等待时间长的优先（FCFS的优点）</strong><br />对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td><strong>不会</strong></td>
</tr>
</tbody></table>
<h3 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h3><table>
<thead>
<tr>
<th>类目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</td>
</tr>
<tr>
<td>算法规则</td>
<td>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td><strong>用于进程调度</strong>（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</td>
</tr>
<tr>
<td>是否可以抢占</td>
<td>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法<strong>属于抢占式的算法</strong>。由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：公平；响应快，适用于分时操作系统；<br/>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td><strong>不会</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此<strong>时间片不能太大</strong>。</p>
<p>另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见<strong>时间片也不能太小</strong>。</p>
</blockquote>
<h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><table>
<thead>
<tr>
<th>类目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</td>
</tr>
<tr>
<td>算法规则</td>
<td>每个作业／进程有各自的优先级，调度时选择优先级最高的作业／进程</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I／0调度中</td>
</tr>
<tr>
<td>是否可以抢占</td>
<td>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而<strong>抢占式还需在就绪队列变化时，检查是否会发生抢占</strong>。</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业／进程的偏好程度。<br/>缺点：若源源不断地有高优先级进程到来，则<strong>可能导致饥饿</strong></td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td><strong>会</strong></td>
</tr>
</tbody></table>
<p>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级和动态优先级</strong>两种。</p>
<ul>
<li>静态优先级：创建进程时确定，之后一直不变。</li>
<li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li>
</ul>
<p>【如何合理地设置各类进程的优先级？】</p>
<ul>
<li>系统进程优先级 <strong>高于</strong> 用户进程</li>
<li>前台进程优先级 <strong>高于</strong> 后台进程</li>
<li>操作系统更<strong>偏好I／O型进程</strong>（或称I／0繁忙型进程）</li>
</ul>
<p>【如果采用的是动态优先级，什么时候应该调整？】</p>
<ul>
<li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li>
<li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li>
<li>如果发现一个进程频繁地进行1&#x2F;0操作，则可适当提升其优先级</li>
</ul>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p>FCFS算法的优点是公平，SJF 算法的优点是能尽快处理完短作业，平均等待／周转时间等参数很优秀，时间片轮转调度算法可以让各个进程得到及时的响应，优先级调度算法可以灵活地调整各种进程被服务的机会，能否对其他算法做个折中权衡？得到一个综合表现优秀平衡的算法呢？这就是<strong>多级反馈队列调度算法</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3d0355f0.png" alt="image-20230306210318660" style="zoom:67%;" />

<p><strong>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</strong>。</p>
<p><strong>新进程</strong>到达时先进入<strong>第1级队列</strong>，按<strong>FCFS原则</strong>排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。<strong>如果此时已经在最下级的队列，则重新放回最下级队列队尾</strong>。</p>
<p>只有第 $k$ 级队列为空时，才会为 $k＋1$ 级队头的进程分配时间片。</p>
<p><strong>被抢占处理机的进程重新放回原队列队尾</strong>。</p>
<table>
<thead>
<tr>
<th>类目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>对其他调度算法的折中权衡</td>
</tr>
<tr>
<td>算法规则</td>
<td>1．设置多级就绪队列，各级队列优先级从高到低，时间片从小到大<br />2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾<br/>3．只有第 $k$ 级队列为空时，才会为 $k＋1$ 级队头的进程分配时间片</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>用于进程调度</td>
</tr>
<tr>
<td>是否可以抢占</td>
<td><strong>抢占式的算法</strong>。在k级队列的进程运行过程中，若更上级的队列（1～k—1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</td>
</tr>
<tr>
<td>优缺点</td>
<td>对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I／O密集型进程<br />【拓展：可以将因I／O而阻塞的进程重新放回原队列，这样I／O型进程就可以保持较高优先级】</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td><strong>会</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>时间片轮转调度算法，优先级调度算法，多级反馈队列调度算法适合用于交互式系统。</p>
</blockquote>
<h3 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a>多级队列调度算法</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3d599db9.png" alt="image-20230306210932286" style="zoom:67%;" />

<p><strong>队列之间</strong>可采取<strong>固定优先级，或时间片划分</strong>：</p>
<ul>
<li><p>固定优先级：高优先级空时低优先级进程才能被调度</p>
</li>
<li><p>时间片划分：如三个队列分配时间50％、40％、10％</p>
</li>
</ul>
<p><strong>各队列</strong>可采用不同的调度策略，如：</p>
<ul>
<li>系统进程队列采用优先级调度</li>
<li>交互式队列采用RR </li>
<li>批处理队列采用FCFS</li>
</ul>
<h1 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h1><h2 id="同步与互斥基本概念"><a href="#同步与互斥基本概念" class="headerlink" title="同步与互斥基本概念"></a>同步与互斥基本概念</h2><p>同步亦<strong>称直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要<strong>在某些位置上协调它们的工作次序而产生的制约关系</strong>。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<p>我们把<strong>一个时间段内只允许一个进程使用的资源称为临界资源</strong>。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p>
<p>对临界资源的访问，必须互斥地进行。<strong>互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待</strong>。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p>
<p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    entry section;	<span class="comment">//进入区,检查是否可以访问临界区</span></span><br><span class="line">    critical section;	<span class="comment">//临界区，访问临界资源的diamond</span></span><br><span class="line">    <span class="built_in">exit</span> section;	<span class="comment">//退出区，解除“正在访问临界资源的标志”（解除上锁）</span></span><br><span class="line">    remainder section;	<span class="comment">//剩余区,其他处理</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p>
<ol>
<li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>
<li><strong>忙则等待</strong>。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li>
<li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li>
<li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<h2 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h2><h3 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h3><p>算法思想：<strong>两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程</strong>。也就是说每个进程进入临界区的权限只能被另一个进程赋予。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3dc97838.png" alt="image-20230306220721552" style="zoom:67%;" />

<p>该算法可以实现“<strong>同一时刻最多只允许一个进程访问临界区</strong>”</p>
<p>单标志法存在的主要问题是：<strong>违背“空闲让进”原则</strong>。</p>
<h3 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h3><p>算法思想：设置一个布尔型数组flagl］，<strong>数组中各个元素用来标记各进程想进入临界区的意愿</strong>，比如 <code>flag[0]＝ture</code> 意味着 0 号进程 $P_0$ 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 <code>flag[i]</code> 设为 <code>true</code>，之后开始访问临界区。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3e14bd61.png" alt="image-20230306221149962" style="zoom:67%;" />

<p>双标志先检查法的主要问题是：<strong>违反“忙则等待”原则</strong>，在并发运行的时候，可能会出现多个进程同时访问的情况。</p>
<p>原因在于，<strong>进入区的“检查”和“上锁”两个处理不是一气呵成的</strong>。“检查”后，“上锁”前可能发生进程切换。</p>
<h3 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h3><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3e61ecb7.png" alt="image-20230306221637462" style="zoom:67%;" />

<p>因此，<strong>双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象</strong>。</p>
<h3 id="Paterson-算法"><a href="#Paterson-算法" class="headerlink" title="Paterson 算法"></a>Paterson 算法</h3><p>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3ec9774e.png" alt="image-20230306223519981" style="zoom: 67%;" />

<p>Peterson 算法用软件方法<strong>解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则</strong>，但是<strong>依然未遵循让权等待的原则</strong>。</p>
<h2 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h2><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><p><strong>利用“开／关中断指令”实现</strong>（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3f186d17.png" alt="image-20230306224414667" style="zoom:60%;" />

<p>优点：简单、高效<br>缺点：<strong>不适用于多处理机</strong>；<strong>只适用于操作系统内核进程，不适用于用户进程</strong>（因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p>
<h3 id="TestAndSet-TS指令-TSL指令"><a href="#TestAndSet-TS指令-TSL指令" class="headerlink" title="TestAndSet (TS指令&#x2F;TSL指令)"></a>TestAndSet (TS指令&#x2F;TSL指令)</h3><p>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令</p>
<p><strong>TSL 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成</strong>。以下是用C语言描述的逻辑</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3f8056e0.png" alt="image-20230306224655818" style="zoom:67%;" />

<p>若刚开始<code>lock</code>是<code>false</code>，则 TSL 返回的<code>old</code>值为<code>false</code>， <code>while</code>循环条件不满足，直接跳过循环，进入临界区。若刚开始<code>lock</code>是<code>true</code>，则执行TLS后<code>old</code>返回的值为<code>true</code>， <code>while</code>循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p>
<p>相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境。</p>
<p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p>
<h3 id="Swap指令-XCHG指令"><a href="#Swap指令-XCHG指令" class="headerlink" title="Swap指令 (XCHG指令)"></a>Swap指令 (XCHG指令)</h3><p>有的地方也叫Exchange指令，或简称XCHG指令。</p>
<p>Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3fd2217b.png" alt="image-20230306225543780" style="zoom:80%;" />

<p>逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在<code>old</code>变量上），再将上锁标记<code>lock</code>设置为<code>true</code>，最后检查<code>old</code>，如果<code>old</code>为<code>false</code>则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p>
<p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>解决临界区最简单的工具就是互斥锁（mutex lock）。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数<code>acquire()</code>获得锁，而函数<code>release()</code>释放锁。</p>
<p>每个互斥锁有一个布尔变量<code>available</code>，表示锁是否可用。如果锁是可用的，调用<code>acqiure()</code>会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p>
<p><code>acquire()</code>或&#96;&#96;release()&#96;的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。</p>
<p><strong>互斥锁</strong>的主要缺点是<strong>忙等待</strong>，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用<code>acquire()</code>。当多个进程共享同一CPU时，就浪费了CPU周期。因此，<strong>互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行</strong>。</p>
<p>需要连续循环忙等的互斥锁，都可称为自旋锁（spin lock），如TSL指令、swap指令、单标志法。</p>
<p>特性：</p>
<ul>
<li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li>
<li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li>
<li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li>
<li>不太适用于单处理机系统，忙等的过程中不可能解锁</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad402f1d72.png" alt="image-20230306233055402" style="zoom:67%;" />

<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><ol>
<li>在双标志先检查法中，<strong>进入区的“检查”、“上锁”操作无法一气呵成</strong>，从而导致了两个进程有可能同时进入临界区的问题；</li>
<li>所有的解决方案都无法实现“让权等待”。</li>
</ol>
<p>1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法——信号量机制。</p>
<p>用户进程可以通过使用操作系统提供的<strong>一对原语来对信号量进行操作</strong>，从而很方便的实现了进程互斥、进程同步。</p>
<p>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以<strong>用一个信号量来表示系统中某种资源的数量</strong>，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p>
<p>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断／开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p>
<p>一对原语：<code>wait(S)</code>原语和<code>signal(S)</code>原语，可以把原语理解为我们自己写的函数，函数名分别为<code>wait</code>和 <code>signal</code>，括号里的信号量S其实就是函数调用时传入的一个参数。</p>
<p><code>wait</code>、<code>signal</code>原语常<strong>简称为P、V操作</strong>（来自荷兰语 proberen和verhogen）。因此，做题的时候常把 <code>wait(S)、signal(S)</code>两个操作分别写为P（S）、V（S）。</p>
<h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p>用一个<strong>整数</strong>型的变量作为信号量，用来<strong>表示系统中某种资源的数量</strong>。</p>
<blockquote>
<p>与普通整数变量的区别：对信号量的操作只有三种，即 <strong>初始化、P操作、V操作</strong></p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad4092a3da.png" alt="image-20230307181547864" style="zoom:67%;" />

<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad40d4fd3a.png" alt="image-20230307182220128" style="zoom:80%;" />

<p><code>S.value</code>的初值表示系统中某种资源的数目。</p>
<p>对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此需要执行<code>S.value--</code>，表示资源数减1，当<code>S.value＜0</code>时表示该类资源已分配完毕，因此进程应调用<code>block </code>原语进行自我阻塞（当前运行的进程从运行态→阻塞态），主动放弃处理机，并插入该类资源的等待队列<code>S.L</code>中。可见，<strong>该机制遵循了“让权等待”原则，不会出现“忙等”现象</strong>。</p>
<p>对信号量S的一次V操作意味着进程释放一个单位的该类资源，因此需要执行<code>S.value＋＋</code>，表示资源数加1，若加1后仍是<code>S.value＜＝0</code>，表示依然有进程在等待该类资源，因此应调用<code>wakeup</code>原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态→就绪态）。</p>
<h3 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a>实现进程互斥</h3><ol>
<li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li>
<li>设置互斥信号量<code>mutex</code>, 初值为1</li>
<li>在进入区<code>P(mutex)</code>——申请资源</li>
<li>在退出区<code>V(mutex)</code>——释放资源</li>
</ol>
<blockquote>
<p>注意：<strong>对不同的临界资源需要设置不同的互斥信号量</strong>。P、V操作必须成对出现。缺少<code>P(mutex)</code>就不能保证临界资源的互斥访问。缺少<code>V(mutex)</code>会导致资源永不被释放，等待进程永不被唤醒。</p>
</blockquote>
<h3 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h3><p>进程同步：要让各并发进程按要求有序地推进。</p>
<p>用信号量实现进程同步：</p>
<ol>
<li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</li>
<li><strong>设置同步信号量S，初始为0</strong>.</li>
<li>在“前操作”之后执行<code>V(S)</code>.</li>
<li>在“后操作”之前执行<code>P(S)</code>.</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad412b89a9.png" alt="image-20230307185525671" style="zoom:80%;" />

<h3 id="实现进程的前驱关系"><a href="#实现进程的前驱关系" class="headerlink" title="实现进程的前驱关系"></a>实现进程的前驱关系</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad41759e5c.png" alt="image-20230307185852766" style="zoom:40%;" />

<p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）因此，</p>
<ol>
<li>要<strong>为每一对前驱关系各设置一个同步信号量</strong>。</li>
<li>在“前操作”之后对相应的同步信号量执行V操作。</li>
<li>在“后操作”之前对相应的同步信号量执行P操作。</li>
</ol>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>信号量机制存在的问题：编写程序困难、易出错，为了更加易用，出现了管程。</p>
<p>管程是一种特殊的软件模块，有这些部分组成：</p>
<ol>
<li>局部于管程的<strong>共享数据结构</strong>说明；</li>
<li>对该数据结构进行操作的<strong>一组过程</strong>；</li>
<li>对局部于管程的共享数据设置初始值的语句；</li>
<li>管程有一个名字。</li>
</ol>
<p>管程的基本特征：</p>
<ol>
<li>局部于管程的数据只能被局部于管程的过程所访问；</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li>
<li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong>。</li>
</ol>
<p>【用管程解决生产者消费者问题】</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad41c563f8.png" alt="image-20230307204053789" style="zoom:80%;" />

<h1 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h1><h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）</p>
<ul>
<li>生产者、消费者共享一个初始为空、大小为 $n$ 的缓冲区。</li>
<li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li>
<li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li>
<li>缓冲区是临界资源，各进程必须互斥地访问。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad42189ff7.png" alt="image-20230307192202837" style="zoom:80%;" />

<h2 id="多生产者多消费者问题"><a href="#多生产者多消费者问题" class="headerlink" title="多生产者多消费者问题"></a>多生产者多消费者问题</h2><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p>
<p>互斥关系：</p>
<ol>
<li>对缓冲区（盘子）的访问要互斥地进行</li>
</ol>
<p>同步关系（一前一后）：</p>
<ol>
<li>父亲将苹果放入盘子后，女儿才能取苹果。</li>
<li>母亲将橘子放入盘子后，儿子才能取橘子。</li>
<li><strong>只有盘子为空时，父亲或母亲才能放入水果</strong>。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad426c9b56.png" alt="image-20230307193942825" style="zoom:80%;" />

<h2 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h2><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）</p>
<p>同步关系（从事件的角度来分析）：</p>
<ol>
<li>桌上有组合一→第一个抽烟者取走东西</li>
<li>桌上有组合二→第二个抽烟者取走东西</li>
<li>桌上有组合三→第三个抽烟者取走东西</li>
<li>发出完成信号→供应者将下一个组合放到桌上</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad42c01e87.png" alt="image-20230307195157566" style="zoom:80%;" />

<h2 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h2><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。</p>
<p>因此要求：</p>
<ol>
<li>允许多个读者可以同时对文件执行读操作； </li>
<li>只允许一个写者往文件中写信息；</li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作； </li>
<li>写者执行写操作前，应让已有的读者和写者全部退出。</li>
</ol>
<p>互斥关系：写进程一写进程、写进程一读进程。读进程与读进程不存在互斥问题。</p>
<h2 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h2><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><p>在并发环境下<strong>，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象</strong>，就是“死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进。</p>
<p><strong>死锁</strong>：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p>
<p><strong>饥饿</strong>：<strong>由于长期得不到想要的资源，某进程无法问前推进的现象</strong>。比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p>
<p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那至少有两个或两个以上的进程同时发生死锁。另外，发生死锁的进程一定处于阻塞态。</li>
<li>可能只有一个进程发生饥饿。发生饥饿的进程既可能是阻塞态（如长期得不到需要的I／O设备），也可能是就绪态（长期得不到处理机）</li>
<li>可能只有一个进程发生死循环。死循环的进程可以上处理机运行（可以是运行态），只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。<strong>死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者的问题</strong>。</li>
</ul>
<h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>
<ul>
<li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li>
<li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li><strong>请求和保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<blockquote>
<p>注意！发生死锁时一定有循环等待，但是<strong>发生循环等待时未必死锁</strong>（循环等待是死锁的必要不充分条件）</p>
<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p>
</blockquote>
<h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h3><ol>
<li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li>
<li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li>
<li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad431e9678.png" alt="image-20230307210257718" style="zoom:80%;" />

<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。</p>
<p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：SPOOLing技术。操作系统可以采用SPOOLing 技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备…</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad43737664.png" alt="image-20230307210459458" style="zoom: 50%;" />

<p>该策略的缺点：<strong>并不是所有的资源都可以改造成可共享使用的资源</strong>。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</p>
<h3 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h3><p>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p>
<p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p>
<p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</p>
<p>该策略的缺点：</p>
<ol>
<li>实现起来比较复杂。</li>
<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li>
<li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li>
</ol>
<h3 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h3><p>请求和保持条件：<strong>进程已经保持了至少一个资源</strong>，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p>
<p>可以<strong>采用静态分配方法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p>
<p>该策略实现起来简单，但也有明显的缺点：</p>
<ol>
<li>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，<strong>资源利用率极低</strong>。另外，该策略也有可能导致某些进程饥饿。</li>
</ol>
<h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><p>循环等待条件：存在一种<strong>进程资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。</p>
<p>可采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定<strong>每个进程必须按编号递增的顺序请求资源</strong>，同类资源（即编号相同的资源）一次申请完。</p>
<p>原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。</p>
<p>该策略的缺点：</p>
<ol>
<li>不方便增加新的设备，因为可能需要重新分配所有的编号：</li>
<li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；</li>
<li>必须按规定次序申请资源，用户编程麻烦。</li>
</ol>
<h2 id="避免死锁（银行家算法）"><a href="#避免死锁（银行家算法）" class="headerlink" title="避免死锁（银行家算法）"></a>避免死锁（银行家算法）</h2><p>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，<strong>安全序列可能有多个</strong>。</p>
<p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</p>
<p><strong>如果系统处于安全状态，就一定不会发生死锁</strong>。如果系统进入不安全状态，就<strong>可能发生死锁</strong>（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</p>
<p>因此可以<strong>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求</strong>。这也是“<strong>银行家算法</strong>”的核心思想。</p>
<p>银行家算法是荷兰学者Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于避免死锁。</p>
<p>核心思想：<strong>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待</strong>。</p>
<h2 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h2><p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：</p>
<ol>
<li><strong>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁</strong>。</li>
<li><strong>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来</strong>。</li>
</ol>
<h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><p>为了能对系统是否已发生了死锁进行检测，必须：</p>
<ol>
<li>用某种数据结构来保存资源的请求和分配信息；</li>
<li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad43f70eef.png" alt="image-20230308223754219" style="zoom:80%;" />

<p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。</p>
<p>相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…</p>
<p>如果按上述过程分析，<strong>最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁</strong>（相当于能找到一个安全序列）</p>
<p><strong>如果最终不能消除所有边，那么此时就是发生了死锁</strong>。最终还连着边的那些进程就是处于死锁状态的进程。</p>
<p><strong>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</strong>。</p>
<h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><p>一旦检测出死锁的发生，就应该立即解除死锁。</p>
<blockquote>
<p><strong>并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</strong></p>
</blockquote>
<p>解除死锁的主要方法有：</p>
<ol>
<li><strong>资源剥夺法</strong>。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li><strong>撤销进程法</strong>（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>
</ol>
<p>【如何绝对“对谁下手”？】</p>
<ol>
<li>进程优先级</li>
<li>已执行多长时间</li>
<li>还要多久能完成</li>
<li>进程已经使用了多少资源</li>
<li>进程是交互式的还是批处理式的</li>
</ol>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.helloseraphine.top">Seraphine</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.helloseraphine.top/2023/03/08/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%902.0%E3%80%91%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">https://www.helloseraphine.top/2023/03/08/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%902.0%E3%80%91%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.helloseraphine.top" target="_blank">Seraphineの小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad352d0a82.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/02/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%901.0%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="【1.0】操作系统概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad0c81d966.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【1.0】操作系统概述</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/10/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%903.0%E3%80%91%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="【3.0】内存管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5a2b7fca.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【3.0】内存管理</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://thirdqq.qlogo.cn/g?b=qq&amp;nk=738232585&amp;s=100" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Seraphine</div><div class="author-info__description">如果有一天我可以在海里翱翔，就像一只小魔鬼鱼</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/L-Seraphine" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:738232585@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://app.helloseraphine.top:8187/explore" target="_blank" title="每天给生活来一拳"><i class="fas fa-coffee"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">活着就是能与别人彼此相知，心意相通，人生在世的意义不就是希望有那种与自己有默契的人存在吗，欣赏认可别人，喜欢爱恋别人，厌烦憎恶别人，因为和别人在一起而感到快乐，可以和别人牵着手并肩前行，这个过程就是活着。如果世界里只有自己，我们就无法感受到存在是什么，我们与别人的关系就是我们自己活着的证明。我的灵魂之所以存在，是因为有你们的关注，我的身体之所以存在，则是因为有你们的碰触，所以啊，只要人活在世上，就一定是有意义的。怎么活是自己选的，就像你和我就都选择了像现在这样活着。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">进程的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.2.</span> <span class="toc-text">进程的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.3.</span> <span class="toc-text">进程的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.4.</span> <span class="toc-text">进程的状态与转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">2.5.</span> <span class="toc-text">进程的组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.1.</span> <span class="toc-text">链式方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.2.</span> <span class="toc-text">索引方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.6.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.6.1.</span> <span class="toc-text">进程的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-number">2.6.2.</span> <span class="toc-text">进程的终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E5%94%A4%E9%86%92"><span class="toc-number">2.6.3.</span> <span class="toc-text">进程的阻塞和唤醒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">2.6.4.</span> <span class="toc-text">进程的切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">2.7.</span> <span class="toc-text">进程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-number">2.7.1.</span> <span class="toc-text">共享存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">2.7.2.</span> <span class="toc-text">消息传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.8.</span> <span class="toc-text">线程的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">2.8.1.</span> <span class="toc-text">线程的属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.9.</span> <span class="toc-text">线程的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.9.1.</span> <span class="toc-text">用户级线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.9.2.</span> <span class="toc-text">内核级线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.9.3.</span> <span class="toc-text">多线程模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.10.</span> <span class="toc-text">线程的状态与转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">3.</span> <span class="toc-text">处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">调度的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-number">3.2.</span> <span class="toc-text">调度的层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">3.3.</span> <span class="toc-text">进程调度的时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">进程调度的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">3.5.</span> <span class="toc-text">调度器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%B2%E9%80%9B%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.6.</span> <span class="toc-text">闲逛进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-number">3.7.</span> <span class="toc-text">调度算法的评价指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.8.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%88FCFS%EF%BC%89"><span class="toc-number">3.8.1.</span> <span class="toc-text">先来先服务（FCFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%EF%BC%88SJF%EF%BC%89"><span class="toc-number">3.8.2.</span> <span class="toc-text">短作业优先（SJF）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%EF%BC%88HRRN%EF%BC%89"><span class="toc-number">3.8.3.</span> <span class="toc-text">高响应比优先（HRRN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.8.4.</span> <span class="toc-text">时间片轮转调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.8.5.</span> <span class="toc-text">优先级调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.8.6.</span> <span class="toc-text">多级反馈队列调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.8.7.</span> <span class="toc-text">多级队列调度算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">4.</span> <span class="toc-text">同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">同步与互斥基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">进程互斥的软件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">单标志法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5"><span class="toc-number">4.2.2.</span> <span class="toc-text">双标志先检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5"><span class="toc-number">4.2.3.</span> <span class="toc-text">双标志后检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Paterson-%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.4.</span> <span class="toc-text">Paterson 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">进程互斥的硬件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">中断屏蔽方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TestAndSet-TS%E6%8C%87%E4%BB%A4-TSL%E6%8C%87%E4%BB%A4"><span class="toc-number">4.3.2.</span> <span class="toc-text">TestAndSet (TS指令&#x2F;TSL指令)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swap%E6%8C%87%E4%BB%A4-XCHG%E6%8C%87%E4%BB%A4"><span class="toc-number">4.3.3.</span> <span class="toc-text">Swap指令 (XCHG指令)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">4.4.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">4.5.</span> <span class="toc-text">信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">4.5.1.</span> <span class="toc-text">整型信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">4.5.2.</span> <span class="toc-text">记录型信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">4.5.3.</span> <span class="toc-text">实现进程互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">4.5.4.</span> <span class="toc-text">实现进程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-number">4.5.5.</span> <span class="toc-text">实现进程的前驱关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">4.6.</span> <span class="toc-text">管程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">经典同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">生产者消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">问题描述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.</span> <span class="toc-text">多生产者多消费者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">吸烟者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.</span> <span class="toc-text">读者写者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">5.5.</span> <span class="toc-text">哲学家进餐问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">死锁的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.1.2.</span> <span class="toc-text">死锁产生的必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">6.1.3.</span> <span class="toc-text">死锁的处理策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">6.2.</span> <span class="toc-text">预防死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.2.1.</span> <span class="toc-text">破坏互斥条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.2.2.</span> <span class="toc-text">破坏不剥夺条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E8%AF%B7%E6%B1%82%E5%92%8C%E4%BF%9D%E6%8C%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.2.3.</span> <span class="toc-text">破坏请求和保持条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.2.4.</span> <span class="toc-text">破坏循环等待条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%88%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">避免死锁（银行家算法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="toc-number">6.4.</span> <span class="toc-text">死锁的检测和解除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">6.4.1.</span> <span class="toc-text">死锁的检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="toc-number">6.4.2.</span> <span class="toc-text">死锁的解除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#End"><span class="toc-number">7.</span> <span class="toc-text">End</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/27/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%907-0%E3%80%91%E5%88%A9%E7%94%A8-AdaBoost-%E5%85%83%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E5%88%86%E7%B1%BB%E6%80%A7%E8%83%BD/" title="【7.0】利用 AdaBoost 元算法提高分类性能"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/27/64c289afc0375.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【7.0】利用 AdaBoost 元算法提高分类性能"/></a><div class="content"><a class="title" href="/2023/07/27/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%907-0%E3%80%91%E5%88%A9%E7%94%A8-AdaBoost-%E5%85%83%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E5%88%86%E7%B1%BB%E6%80%A7%E8%83%BD/" title="【7.0】利用 AdaBoost 元算法提高分类性能">【7.0】利用 AdaBoost 元算法提高分类性能</a><time datetime="2023-07-27T15:14:47.000Z" title="发表于 2023-07-27 23:14:47">2023-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/26/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%906-0%E3%80%91%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" title="【6.0】支持向量机"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/26/64c0ee747ef54.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【6.0】支持向量机"/></a><div class="content"><a class="title" href="/2023/07/26/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%906-0%E3%80%91%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" title="【6.0】支持向量机">【6.0】支持向量机</a><time datetime="2023-07-26T09:56:27.000Z" title="发表于 2023-07-26 17:56:27">2023-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/23/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%905-0%E3%80%91Logistic%E5%9B%9E%E5%BD%92/" title="【5.0】Logistic回归"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/23/64bc0b2ba3af1.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【5.0】Logistic回归"/></a><div class="content"><a class="title" href="/2023/07/23/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%905-0%E3%80%91Logistic%E5%9B%9E%E5%BD%92/" title="【5.0】Logistic回归">【5.0】Logistic回归</a><time datetime="2023-07-22T16:56:59.000Z" title="发表于 2023-07-23 00:56:59">2023-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/15/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%904-0%E3%80%91%E5%9F%BA%E4%BA%8E%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/" title="【4.0】基于概率论的分类方法：朴素贝叶斯"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/15/64b2b7ea54813.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【4.0】基于概率论的分类方法：朴素贝叶斯"/></a><div class="content"><a class="title" href="/2023/07/15/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%904-0%E3%80%91%E5%9F%BA%E4%BA%8E%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/" title="【4.0】基于概率论的分类方法：朴素贝叶斯">【4.0】基于概率论的分类方法：朴素贝叶斯</a><time datetime="2023-07-15T15:10:22.000Z" title="发表于 2023-07-15 23:10:22">2023-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/12/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%903-0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91/" title="【3.0】决策树"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.helloseraphine.top:8089/blog/2023/07/14/64b14a3d10830.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【3.0】决策树"/></a><div class="content"><a class="title" href="/2023/07/12/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%903-0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91/" title="【3.0】决策树">【3.0】决策树</a><time datetime="2023-07-12T13:12:43.000Z" title="发表于 2023-07-12 21:12:43">2023-07-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By Seraphine</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://app.helloseraphine.top:8460/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://app.helloseraphine.top:8460/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>