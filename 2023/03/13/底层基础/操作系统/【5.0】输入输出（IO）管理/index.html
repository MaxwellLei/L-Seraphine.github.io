<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【5.0】输入输出（IO）管理 | Maxwell_Leiの小窝</title><meta name="author" content="Maxwell Lei"><meta name="copyright" content="Maxwell Lei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言NULL，懒得写了 I&#x2F;O管理概述I&#x2F;O设备的概念和分类“I／O”就是“输入／输出”（Input／Output）。I／O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。 UNIX 系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。  按使用特性分类  按传输速率分类  按信息交换单位分类">
<meta property="og:type" content="article">
<meta property="og:title" content="【5.0】输入输出（IO）管理">
<meta property="og:url" content="https://www.helloseraphine.top/2023/03/13/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%905.0%E3%80%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88IO%EF%BC%89%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="Maxwell_Leiの小窝">
<meta property="og:description" content="前言NULL，懒得写了 I&#x2F;O管理概述I&#x2F;O设备的概念和分类“I／O”就是“输入／输出”（Input／Output）。I／O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。 UNIX 系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。  按使用特性分类  按传输速率分类  按信息交换单位分类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad8c55168b.webp">
<meta property="article:published_time" content="2023-03-13T15:30:01.000Z">
<meta property="article:modified_time" content="2025-04-17T03:44:24.165Z">
<meta property="article:author" content="Maxwell Lei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad8c55168b.webp"><link rel="shortcut icon" href="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_Image/64abfad3db52f.ico"><link rel="canonical" href="https://www.helloseraphine.top/2023/03/13/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%905.0%E3%80%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88IO%EF%BC%89%E7%AE%A1%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e46e337e762e79ae7f939118e01248b7";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":30,"position":"top","messagePrev":"距离本文的最后一次更新是","messageNext":"天之前, 部分内容可能已经过时了."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":512},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":2048,"languages":{"author":"作者: Maxwell Lei","link":"链接: ","source":"来源: Maxwell_Leiの小窝","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【5.0】输入输出（IO）管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-17 11:44:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Maxwell_Leiの小窝" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://thirdqq.qlogo.cn/g?b=qq&amp;nk=738232585&amp;s=100" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/MessageBoard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/updateLog/"><i class="fa-fw fas fa-wrench"></i><span> 更新日志</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad8c55168b.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Maxwell_Leiの小窝"><span class="site-name">Maxwell_Leiの小窝</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/MessageBoard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/updateLog/"><i class="fa-fw fas fa-wrench"></i><span> 更新日志</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【5.0】输入输出（IO）管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-13T15:30:01.000Z" title="发表于 2023-03-13 23:30:01">2023-03-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-17T03:44:24.165Z" title="更新于 2025-04-17 11:44:24">2025-04-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/">底层基础</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【5.0】输入输出（IO）管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>NULL，懒得写了</p>
<h1 id="I-O管理概述"><a href="#I-O管理概述" class="headerlink" title="I&#x2F;O管理概述"></a>I&#x2F;O管理概述</h1><h2 id="I-O设备的概念和分类"><a href="#I-O设备的概念和分类" class="headerlink" title="I&#x2F;O设备的概念和分类"></a>I&#x2F;O设备的概念和分类</h2><p>“I／O”就是“输入／输出”（Input／Output）。I／O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p>
<p><strong>UNIX 系统将外部设备抽象为一种特殊的文件</strong>，用户可以使用与文件操作相同的方式对外部设备进行操作。 </p>
<h3 id="按使用特性分类"><a href="#按使用特性分类" class="headerlink" title="按使用特性分类"></a>按使用特性分类</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad8d2a701c.png" alt="image-20230311203028289" style="zoom:50%;" />

<h3 id="按传输速率分类"><a href="#按传输速率分类" class="headerlink" title="按传输速率分类"></a>按传输速率分类</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad8d6d2cbb.png" alt="image-20230311203117825" style="zoom:50%;" />

<h3 id="按信息交换单位分类"><a href="#按信息交换单位分类" class="headerlink" title="按信息交换单位分类"></a>按信息交换单位分类</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad8db8dc89.png" alt="image-20230311203148294" style="zoom:50%;" />

<h2 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I&#x2F;O控制器"></a>I&#x2F;O控制器</h2><p>I&#x2F;O设备的<strong>机械部件</strong>主要用来执行具体 I&#x2F;O操作。如我们看得见摸得着的鼠标／键盘的按钮；显示器的LED屏；移动硬盘的磁臂、磁盘盘面。I／O设备的电子部件通常是一块插入主板扩充槽的印刷电路板。</p>
<p>I／O设备的<strong>电子部件</strong>通常是一块插入主板扩充槽的印刷电路板。</p>
<p>CPU无法直接控制I／O设备的机械部件，因此I／O设备还要有一个电子部件作为CPU和I／O设备机械部件之间的“中介”，用于实现CPU对设备的控制。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad8df78c58.png" alt="image-20230311203558826" style="zoom:67%;" />

<h3 id="I-O控制器的组成"><a href="#I-O控制器的组成" class="headerlink" title="I&#x2F;O控制器的组成"></a>I&#x2F;O控制器的组成</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad8e3e62f7.png" alt="image-20230311203938774" style="zoom:67%;" />

<p>注意：</p>
<ol>
<li>一个I／O控制器可能会对应多个设备；</li>
<li>数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制／状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为<strong>内存映像 I&#x2F;O</strong>；另一些计算机则采用 I&#x2F;O 专用地址，即<strong>寄存器独立编址</strong>。</li>
</ol>
<h3 id="内存映像和寄存器独立编址"><a href="#内存映像和寄存器独立编址" class="headerlink" title="内存映像和寄存器独立编址"></a>内存映像和寄存器独立编址</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad8e86cf4e.png" alt="image-20230311204435610" style="zoom:50%;" />

<h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad8ec52606.png" alt="image-20230311204528062" style="zoom: 50%;" />

<h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><p>【完成一次读／写操作的流程（Key word：<strong>轮询</strong>）】</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad8f09d94c.png" alt="image-20230311204835150" style="zoom:80%;" />

<p>【CPU干预的频率】</p>
<p>很频繁，I／O操作开始之前、完成之后需要CPU介入，并且在等待I／O完成的过程中CPU需要不断地轮询检查。</p>
<p>【数据传送的单位】</p>
<p>每次<strong>读／写一个字</strong></p>
<p>【数据的流向】</p>
<p>读操作（数据输入）：I／O设备→CPU→内存</p>
<p>写操作（数据输出）：内存→CPU→I／O</p>
<p><strong>设备每个字的读／写都需要CPU的帮助</strong>。</p>
<p>【主要缺点和主要优点】</p>
<p>优点：实现简单。在读／写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”）</p>
<p>缺点：<strong>CPU和I／O设备只能串行工作</strong>，<strong>CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低</strong>。</p>
<h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><p>引入中断机制。由于I／O设备速度很慢，因此在CPU发出读／写命令后，可将等待I／O的进程阻塞，先切换到别的进程执行。当I／O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从I／O控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，CPU恢复等待I／O的进程（或其他进程）的运行环境，然后继续执行。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="httpss://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20230312152125249.png" alt="image-20230312152125249" style="zoom:50%;" />

<ol>
<li>CPU会在每个指令周期的末尾检查中断；</li>
<li>中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的频率太高，也会降低系统性能。</li>
</ol>
<p>【完成一次读／写操作的流程（Key word：<strong>中断</strong>）】</p>
<p>【CPU 干预的频率】</p>
<p>每次 $I&#x2F;O$ 操作开始之前、完成之后需要CPU介入。</p>
<p><strong>等待1&#x2F;O完成的过程中CPU可以切换到别的进程执行</strong>。</p>
<p>【数据传送的单位】</p>
<p>每次读／写一个<strong>字</strong>。</p>
<p>【数据的流向】</p>
<p>读操作（数据输入） ： 1&#x2F;O设备→CPU—内存</p>
<p>写操作（数据输出） ：内存→CPU—1&#x2F;O设备</p>
<p>【优缺点】</p>
<p>优点：与“程序直接控制方式”相比，在“中断驱动方式”中，I／O控制器会通过中断信号主动报告I／O已完成，CPU不再需要不停地轮询。CPU和I／O设备可并行工作，<strong>CPU利用率得到明显提升</strong>。</p>
<p>缺点：每个字在I／O设备与内存之间的传输，都需要经过CPU。而<strong>频繁的 中断处理会消耗较多的CPU时间</strong>。</p>
<h3 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h3><p>与“中断驱动方式”相比，<strong>DMA方式（Direct Memory Access，直接存储器存取</strong>。主要用于块设备的I／O控制）有这样几个改进：</p>
<ol>
<li><strong>数据的传送单位是“块”</strong>。不再是一个字、一个字的传送；</li>
<li>数据的流向是<strong>从设备直接放入内存，或者从内存直接到设备</strong>。不再需要CPU作为“快递小哥”。</li>
<li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad8f97725d.png" alt="image-20230312155618365" style="zoom:67%;" />

<h4 id="DMA-控制器"><a href="#DMA-控制器" class="headerlink" title="DMA 控制器"></a>DMA 控制器</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad8ff8d5be.png" alt="image-20230312155845639" style="zoom:67%;" />

<p>DR（Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。</p>
<p>MAR（Memory Address Register，内存地址寄存器）：在输入时，MAR表示数据应放到内存中的什么 位置；输出时MAR表示要输出的数据放在内存中的什么位置。</p>
<p>Data Counter，数据计数器）：表示剩余要读／写的字节数。</p>
<p>CR（Command Register，命令／状态寄存器）：用于存放CPU发来的I／O命令，或设备的状态信息。</p>
<p>【完成一次读／写操作的流程】</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad903c9f26.png" alt="image-20230312155914789" style="zoom:50%;" />

<p>【CPU干预的频率】</p>
<p>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</p>
<p>【数据传送的单位】</p>
<p>每次读／写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</p>
<p>【数据的流向】</p>
<p>读操作（数据输入） ： 1&#x2F;0设备→内存</p>
<p>写操作（数据输出） ：内存→1&#x2F;0设备</p>
<blockquote>
<p>不再需要经过CPU</p>
</blockquote>
<p>【主要缺点和主要优点】</p>
<p>优点：数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I／O设备的并行性得到提升。</p>
<p>缺点：<strong>CPU每发出一条I／O指令，只能读／写一个或多个连续的数据块</strong>。</p>
<h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><p>通道：<strong>一种硬件</strong>，可以理解为是“弱鸡版的CPU”。通道可以识别并执行一系列通道指令。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad908a632c.png" alt="image-20230312160450988" style="zoom:67%;" />

<blockquote>
<p>与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存</p>
</blockquote>
<p>【完成一次读／写操作的流程】</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad90db7d2d.png" alt="image-20230312160541408" style="zoom:50%;" />

<p>【CPU干预的频率】</p>
<p>极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读／写后才需要发出中断信号，请求CPU干预。</p>
<p>【数据传送的单位】</p>
<p>每次读／写一组数据块</p>
<p>【数据的流向】</p>
<p>读操作（数据输入）：I／O设备→内存</p>
<p>写操作（数据输出）：内存→I／O设备</p>
<blockquote>
<p>在通道的控制下进行</p>
</blockquote>
<p>【优缺点】</p>
<p>缺点：实现复杂，需要专门的通道硬件支持</p>
<p>优点：<strong>CPU、通道、I／O设备可并行工作，资源利用率很高</strong>。</p>
<h2 id="I-O软件层次结构"><a href="#I-O软件层次结构" class="headerlink" title="I&#x2F;O软件层次结构"></a>I&#x2F;O软件层次结构</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad9149ea40.png" alt="image-20230312163115919" style="zoom:67%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad918b0a77.png" alt="image-20230312161137319" style="zoom:50%;" />

<p>每一层会利用其下层提供的服务，实现某些功能，并屏蔽实现的具体细节，向高层提供服务（“封装思想”）</p>
<h3 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h3><p>用户层软件<strong>实现了与用户交互的接口</strong>，用户可直接使用该层提供的、与1／O操作相关的库函数对设备进行操作。</p>
<p>用户层软件将用户请求翻译成格式化的I／O请求，并<strong>通过“系统调用”请求操作系统内核的服务</strong>。</p>
<h3 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h3><p>设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p>
<ol>
<li>向上层提供统一的调用接闷（如 read／write 系统调用）</li>
<li>设备的保护</li>
<li>差错处理</li>
<li>设备的分配与回收</li>
<li>数据缓冲区管理：可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</li>
<li>建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序：用户或用户层软件发出I／O操作相关系统调用的系统调用时，需要指明此次要操作的I／O设备的逻辑设备名；<br><strong>设备独立性软件需要通过“逻辑设备表（LUT，Logical UnitTable）”来确定逻辑设备对应的物理设备</strong>，并找到该设备对应的设备驱动程序<br>操作系统系统可以采用两种方式管理逻辑设备表（LUT）：<ul>
<li><strong>整个系统只设置一张LUT</strong>，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。</li>
<li><strong>为每个用户设置一张LUT</strong>，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</li>
</ul>
</li>
</ol>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p><strong>主要负责对硬件设备的具体控制，将上层发出的一系列命令（如read&#x2F;write）转化成特定设备“能听得懂”的一系列操作</strong>。包括设置设备寄存器；检查设备状态等</p>
<p>不同的1&#x2F;0设备有不同的硬件特性，具体细节只有设备的厂家才知道。因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序。</p>
<blockquote>
<p>驱动程序一般会以一个独立进程的方式存在。</p>
</blockquote>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>当I／O任务完成时，I／O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad91e392a7.png" alt="image-20230312163011664" style="zoom:67%;" />

<blockquote>
<p>中断处理程序也会和硬件直接打交道</p>
</blockquote>
<h2 id="输入输出程序接口"><a href="#输入输出程序接口" class="headerlink" title="输入输出程序接口"></a>输入输出程序接口</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad92255c5b.png" alt="image-20230312190128888" style="zoom:67%;" />

<p>阻塞I／O：应用程序发出I／O系统调用，进程需转为阻塞态等待。</p>
<p>非阻塞I／O：应用程序发出I／O系统调用，系统调用可迅速返回，进程无需阻塞等待。</p>
<h2 id="设备驱动程序接口"><a href="#设备驱动程序接口" class="headerlink" title="设备驱动程序接口"></a>设备驱动程序接口</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad92681c9d.png" alt="image-20230312191740156" style="zoom: 50%;" />

<p>不同的操作系统，对设备驱动程序接口的标准各不相同。</p>
<p>设备厂商必须根据操作系统的接口要求，开发相应的设备驱动程序，设备才能被使用</p>
<h1 id="设备独立性软件-1"><a href="#设备独立性软件-1" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h1><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad92a51a81.png" alt="image-20230312231205868" style="zoom:50%;" />

<h2 id="I-O核心子系统"><a href="#I-O核心子系统" class="headerlink" title="I&#x2F;O核心子系统"></a>I&#x2F;O核心子系统</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad92e59b36.png" alt="image-20230312231448558" style="zoom:50%;" />

<h3 id="I-O调度"><a href="#I-O调度" class="headerlink" title="I&#x2F;O调度"></a>I&#x2F;O调度</h3><p>I／O调度：用某种算法确定一个好的顺序来处理各个I／O请求。</p>
<p>如：磁盘调度（先来先服务算法、最短寻道优先算法、SCAN算法、C—SCAN算法、LOOK算法、C—LOOK算法）。当多个磁盘I／O请求到来时，用某种调度算法确定满足I／O请求的顺序。</p>
<p>同理，打印机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定I／0调度顺序。</p>
<h3 id="设备保护"><a href="#设备保护" class="headerlink" title="设备保护"></a>设备保护</h3><p>操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限（如：只读、读和写等）。</p>
<p>在UNIX系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。</p>
<h2 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h2><h3 id="什么是脱机技术"><a href="#什么是脱机技术" class="headerlink" title="什么是脱机技术"></a>什么是脱机技术</h3><p>手工操作阶段：主机直接从I／O设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备。</p>
<p>批处理阶段引入了脱机输入／输出技术（用磁带完成）：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad932b8133.png" alt="image-20230312231755541" style="zoom:50%;" />

<blockquote>
<p>Tips：为什么称为“脱机”——脱离主机的控制进行的输入／输出操作。</p>
</blockquote>
<p>引入脱机技术后，<strong>缓解了CPU与慢速I／O设备的速度矛盾</strong>。</p>
<p>另一方面，即使CPU在忙碌，也可以提前将数据输入到磁带；即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。</p>
<h3 id="输入井和输出井"><a href="#输入井和输出井" class="headerlink" title="输入井和输出井"></a>输入井和输出井</h3><p><strong>“假脱机技术”，又称“SPOOLing技术”是用软件的方式模拟脱机技术</strong>。SPOOLing系统的组成如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad9368f71b.png" alt="image-20230312232527999" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad93a80dc1.png" alt="image-20230312233043717" style="zoom:50%;" />

<p>要实现SPOOLing技术，<strong>必须要有多道程序技术的支持</strong>。系统会建立“输入进程”和“输出进程”。</p>
<h3 id="共享打印机原理"><a href="#共享打印机原理" class="headerlink" title="共享打印机原理"></a>共享打印机原理</h3><p>独占式设备——<strong>只允许各个进程串行使用的设备</strong>。一段时间内只能满足一个进程的请求。</p>
<p>共享设备——<strong>允许多个进程“同时”使用的设备</strong>（宏观上同时使用，微观上可能是交替使用）。可以同时满足多个进程的使用请求。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad93e71a4d.png" alt="image-20230312233527900" style="zoom:50%;" />

<p>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：</p>
<ol>
<li>在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中；</li>
<li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。</li>
</ol>
<p>当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务。</p>
<p>虽然系统中只有一个台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p>
<p><strong>SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备、可将独占式设备改造成共享设备</strong>。</p>
<h2 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h2><h3 id="设备分配时应考虑的因素"><a href="#设备分配时应考虑的因素" class="headerlink" title="设备分配时应考虑的因素"></a>设备分配时应考虑的因素</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad9429fd52.png" alt="image-20230313181413982" style="zoom:50%;" />

<h4 id="固有属性"><a href="#固有属性" class="headerlink" title="固有属性"></a>固有属性</h4><ul>
<li>独占设备：一个时段只能分配给一个进程（如打印机）</li>
<li>共享设备：可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用。</li>
<li>虚拟设备——采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLing技术实现的共享打印机）</li>
</ul>
<h4 id="设备分配算法"><a href="#设备分配算法" class="headerlink" title="设备分配算法"></a>设备分配算法</h4><p>先来先服务，优先级高者优先，短任务优先等等</p>
<h4 id="设备分配中的安全"><a href="#设备分配中的安全" class="headerlink" title="设备分配中的安全"></a>设备分配中的安全</h4><p><strong>安全分配方式</strong>：为进程分配一个设备后就将进程阻塞，本次I／O完成后才将进程唤醒。（eg：考虑进程请求打印机打印输出的例子）</p>
<p>一个时段内每个进程只能使用一个设备</p>
<ul>
<li>优点：破坏了“请求和保持”条件，不会死锁</li>
<li>缺点：对于一个进程来说，CPU和I／O设备只能串行工作</li>
</ul>
<p><strong>不安全分配方式</strong>：进程发出1&#x2F;0请求后，系统为其分配1&#x2F;0设备，进程可继续执行，之后还可以发出新的1&#x2F;0请求。只有某个1&#x2F;0请求得不到满足时才将进程阻塞。</p>
<p>一个进程可以同时使用多个设备</p>
<ul>
<li><p>优点：进程的计算任务和I／O任务可以并行处理，使进程迅速推进</p>
</li>
<li><p>缺点：有可能发生死锁（死锁避免、死锁的检测和解除）</p>
</li>
</ul>
<h3 id="静态分配和动态分配"><a href="#静态分配和动态分配" class="headerlink" title="静态分配和动态分配"></a>静态分配和动态分配</h3><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源</p>
<blockquote>
<p>破坏了“请求和保持”条件，不会发生死锁</p>
</blockquote>
<p>动态分配：进程运行过程中动态申请设备资源</p>
<h3 id="设备分配管理中的数据结构"><a href="#设备分配管理中的数据结构" class="headerlink" title="设备分配管理中的数据结构"></a>设备分配管理中的数据结构</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad9498afe9.png" alt="image-20230313182407855" style="zoom:50%;" />

<p><strong>设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad94da1477.png" alt="image-20230313182527494" style="zoom:67%;" />

<p><strong>控制器控制表（COCT）：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad9526fa61.png" alt="image-20230313182625421" style="zoom:67%;" />

<p><strong>通道控制表（CHCT）：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad9573b7a2.png" alt="image-20230313182707200" style="zoom:67%;" />

<p><strong>系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad95bb23b4.png" alt="image-20230313182734853" style="zoom:67%;" />

<h3 id="设备分配的步骤"><a href="#设备分配的步骤" class="headerlink" title="设备分配的步骤"></a>设备分配的步骤</h3><ol>
<li>根据进程请求的物理设备名查找SDT（注：物理设备名是进程请求分配设备时提供的参数）</li>
<li>根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将<br>设备分配给进程。 </li>
<li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li>
<li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li>
</ol>
<blockquote>
<p>注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I／O设备进行数据传送</p>
</blockquote>
<p>缺点：</p>
<ol>
<li>用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</li>
<li>若换了一个物理设备，则程序无法运行</li>
<li>若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li>
</ol>
<p>改进方法：<strong>建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</strong>。</p>
<h4 id="设备分配步骤的改进"><a href="#设备分配步骤的改进" class="headerlink" title="设备分配步骤的改进"></a>设备分配步骤的改进</h4><ol>
<li>根据进程请求的逻辑设备名查找SDT（注：用户编程时提供的逻辑设备名其实就是“设备类型”）</li>
<li>查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。</li>
<li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li>
<li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad96101198.png" alt="image-20230313184050029" style="zoom:50%;" />

<p>逻辑设备表（LUT）<strong>建立了逻辑设备名与物理设备名之间的映射关系</strong>。</p>
<p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。</p>
<p>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。</p>
<p>逻辑设备表的设置问题：</p>
<ul>
<li>整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户</li>
<li>操作系统每个用户一张LUT：<strong>不同用户的逻辑设备名可重复</strong>，适用于多用户操作系统</li>
</ul>
<h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><p><strong>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区</strong>。</p>
<p><strong>使用硬件作为缓冲区的成本较高，容量也较小</strong>，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</p>
<p>一般情况下，<strong>更多的是利用内存作为缓冲区</strong>，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区</p>
<h3 id="缓冲区的作用"><a href="#缓冲区的作用" class="headerlink" title="缓冲区的作用"></a>缓冲区的作用</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad96557a0b.png" alt="image-20230313184320866" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad969764c9.png" alt="image-20230313184404811" style="zoom:50%;" />

<h3 id="缓冲区的管理"><a href="#缓冲区的管理" class="headerlink" title="缓冲区的管理"></a>缓冲区的管理</h3><h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><p>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>单缓冲</strong>的策略，<strong>操作系统会在主存中为其分配一个缓冲区</strong>（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</p>
<blockquote>
<p>注意：<strong>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出</strong>；当缓冲区为空时，可以往缓冲区冲入数据，但<strong>必须把缓冲区充满以后，才能从缓冲区把数据传出</strong>。</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad96d3ee31.png" alt="image-20230313184801355" style="zoom:33%;" />

<p><strong>在“单缓冲”题型中，可以假设初始状态为工作区满，缓冲区空。</strong></p>
<p>结论：<strong>采用单缓冲策略，处理一块数据平均耗时Max（C，T）＋M</strong></p>
<h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><p>假设某用户进程请求某种块设备读入若干块的数据。<strong>若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区</strong>（若题目中没有特别说明，一个缓冲区的大小就是一个块）</p>
<p>双缓冲题目中，<strong>假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空</strong>。</p>
<p>结论：<strong>采用双缓冲策略，处理一个数据块的平均耗时为Max（T，C＋M）</strong>。</p>
<h4 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h4><p><strong>将多个大小相等的缓冲区链接成一个循环队列</strong>。</p>
<p>注：以下图示中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad976362c7.png" alt="image-20230313190129221" style="zoom:50%;" />

<h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><p>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</p>
<p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：用于收容输入数据的工作缓冲区（hin）、用于提取输入数据的工作缓冲区（sin）、用于收容输出数据的工作缓冲区（hout）、用于提取输出数据的工作缓冲区（sout）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad97a270b1.png" alt="image-20230313190409291" style="zoom:50%;" />

<h1 id="磁盘和固态硬盘"><a href="#磁盘和固态硬盘" class="headerlink" title="磁盘和固态硬盘"></a>磁盘和固态硬盘</h1><h2 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h2><h3 id="磁盘，磁道，扇区"><a href="#磁盘，磁道，扇区" class="headerlink" title="磁盘，磁道，扇区"></a>磁盘，磁道，扇区</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aad983c7315.png" alt="image-20230311200956483" style="zoom:50%;" />

<p>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aad98802ce5.png" alt="image-20230311201623127" style="zoom:50%;" />

<p>磁盘的盘面被划分成一个个磁道。这样的一个“圈”就是一个磁道。</p>
<p>一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”。各个扇区存放的数据量相同（如1KB）。</p>
<p><strong>最内侧磁道上的扇区面积最小，因此数据密度最大</strong>。</p>
<h3 id="如何在磁盘中读-写数据"><a href="#如何在磁盘中读-写数据" class="headerlink" title="如何在磁盘中读&#x2F;写数据"></a>如何在磁盘中读&#x2F;写数据</h3><p>需要把“磁头”移动到想要读／写的扇区所在的磁道。</p>
<p>磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读／写操作。</p>
<h3 id="盘面，柱面"><a href="#盘面，柱面" class="headerlink" title="盘面，柱面"></a>盘面，柱面</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aad98c920c9.png" alt="image-20230311202229677" style="zoom:50%;" />

<p>可用<strong>（柱面号，盘面号，扇区号）</strong>来定位任意一个“磁盘块”。在“文件的物理结构”小节中，我们经常提到文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号）的地址形式。</p>
<p>可根据该地址读取一个“块”</p>
<ol>
<li>根据“柱面号”移动磁臂，让磁头指向指定柱面；</li>
<li>激活指定盘面对应的磁头；</li>
<li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读／写。</li>
</ol>
<h3 id="磁盘的分类"><a href="#磁盘的分类" class="headerlink" title="磁盘的分类"></a>磁盘的分类</h3><p>磁头可以移动的称为<strong>活动头磁盘</strong>。磁臂可以来回伸缩来带动磁头定位磁道。</p>
<p>磁头不可移动的称为<strong>固定头磁盘</strong>。这种磁盘中每个磁道有一个磁头。</p>
<p>盘片可以更换的称为<strong>可换盘磁盘</strong>。</p>
<p>盘片不可更换的称为<strong>固定盘磁盘</strong>。</p>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><h3 id="一次读写需要的时间"><a href="#一次读写需要的时间" class="headerlink" title="一次读写需要的时间"></a>一次读写需要的时间</h3><p><strong>寻找时间（寻道时间</strong>）Ts：在读／写数据前，将磁头移动到指定磁道所花的时间。</p>
<ol>
<li>启动磁头臂是需要时间的。假设耗时为s；</li>
<li>移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则：<br>寻道时间Ts＝s＋m＊n</li>
</ol>
<p><strong>延迟时间</strong>TR：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为（单位：转／秒，或转／分），则平均所需的延迟时间TR＝（1／2）＊（1／r）＝1／2r</p>
<blockquote>
<p>1／r 就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此再乘以1／2</p>
</blockquote>
<p><strong>传输时间</strong>T：从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读／写的字节数为b，每个磁道上的字节数为N。则：<br>传输时间Tt＝（1／r）＊（b／N）＝b／（rN）</p>
<blockquote>
<p>每个磁道要可存N字节的数据，因此b字节的数据需要b&#x2F;N 个磁道才能存储。而读&#x2F;写一个磁道所需的时间<br>刚好又是转一圈所需要的时间1&#x2F;r</p>
</blockquote>
<p>总的平均存取时间Ta＝Ts＋1／2r＋b／（rN）</p>
<p><strong>延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间</strong>。</p>
<h3 id="先来先服务算法（FCFS）"><a href="#先来先服务算法（FCFS）" class="headerlink" title="先来先服务算法（FCFS）"></a>先来先服务算法（FCFS）</h3><p>根据进程请求访问磁盘的先后顺序进行调度。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aad999b561d.png" alt="image-20230313191329635" style="zoom:67%;" />

<p>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去。</p>
<p>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。</p>
<h3 id="最短时间寻址时间优先算法（SSTF）"><a href="#最短时间寻址时间优先算法（SSTF）" class="headerlink" title="最短时间寻址时间优先算法（SSTF）"></a>最短时间寻址时间优先算法（SSTF）</h3><p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aad99dec2b8.png" alt="image-20230313192056436" style="zoom: 67%;" />

<p>优点：性能较好，平均寻道时间短</p>
<p>缺点：<strong>可能产生“饥饿”现象</strong>.</p>
<h3 id="扫描算法（SCAN）"><a href="#扫描算法（SCAN）" class="headerlink" title="扫描算法（SCAN）"></a>扫描算法（SCAN）</h3><p>SSTF算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，<strong>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</strong>。这就是扫描算法（SCAN）的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aad9a217a1d.png" alt="image-20230313192407997" style="zoom:67%;" />

<p>优点：性能较好，平均寻道时间较短，<strong>不会产生饥饿现象</strong></p>
<p>缺点：</p>
<ol>
<li>只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。</li>
<li><strong>SCAN算法对于各个位置磁道的响应频率不平均</strong>（如：假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了）</li>
</ol>
<h3 id="LOOK调度算法"><a href="#LOOK调度算法" class="headerlink" title="LOOK调度算法"></a>LOOK调度算法</h3><p>扫描算法（SCAN）中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。LOOK调度算法就是为了解决这个问题，<strong>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</strong>。（边移动边观察，因此叫LOOK）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aad9a730ff8.png" alt="image-20230313192634335" style="zoom:67%;" />

<h3 id="循环扫描算法（C-SCAN）"><a href="#循环扫描算法（C-SCAN）" class="headerlink" title="循环扫描算法（C-SCAN）"></a>循环扫描算法（C-SCAN）</h3><p>SCAN算法对于各个位置磁道的响应频率不平均，而C—SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，<strong>而返回时直接快速移动至起始端而不处理任何请求</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aad9abd3b36.png" alt="image-20230313192802437" style="zoom:67%;" />

<p>优点：比起SCAN来，对于各个位置磁道的响应频率很平均。</p>
<p>缺点：只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。</p>
<h3 id="C-LOOK调度算法"><a href="#C-LOOK调度算法" class="headerlink" title="C-LOOK调度算法"></a>C-LOOK调度算法</h3><p>C—SCAN算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C—LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aad9b69626d.png" alt="image-20230313192948714" style="zoom:67%;" />

<h2 id="减少延迟时间的方法"><a href="#减少延迟时间的方法" class="headerlink" title="减少延迟时间的方法"></a>减少延迟时间的方法</h2><p>结论：磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”。</p>
<h3 id="交替编号"><a href="#交替编号" class="headerlink" title="交替编号"></a>交替编号</h3><p>若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aad9bae1815.png" alt="image-20230313193222017" style="zoom:43%;" />

<h4 id="磁盘地址结构的设计"><a href="#磁盘地址结构的设计" class="headerlink" title="磁盘地址结构的设计"></a>磁盘地址结构的设计</h4><p>【思考：为什么？】<br>磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）</p>
<p>答：<strong>读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间</strong>。</p>
<h3 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h3><p>具体做法：让相邻盘面的扇区编号“错位”</p>
<p>原理：<strong>读取完一个扇区后需要一段时间处理才可以继续读入下一个扇区</strong>。“错位命名法”可降低延迟时间</p>
<h2 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h2><h3 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h3><ol>
<li><strong>进行低级格式化（物理格式化）</strong>，<strong>将磁盘的各个磁道划分为扇区</strong>。一个扇区通常可分为头、数据区域（如512B大小）、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误）</li>
<li>将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的C盘、D盘、E盘）</li>
<li><strong>进行逻辑格式化</strong>，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表）</li>
</ol>
<h3 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h3><p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。</p>
<p><strong>初始化程序可以放在ROM（只读存储器）中。ROM中的数据在出厂时就写入了，并且以后不能再修改</strong>。</p>
<p>【初始化程序程序（自举程序）放在ROM中存在什么问题？】</p>
<p>万一需要更新自举程序，将会很不方便，因为ROM中的数据无法更改。如何解决呢？</p>
<p>ROM中只存放很小的“自举装入程序，<strong>完整的自举程序放在磁盘的启动块（即引导块／启动分区）上，启动块位于磁盘的固定位置</strong>。</p>
<blockquote>
<p>拥有启动分区的磁盘称为启动磁盘或系统磁盘（C：盘）</p>
</blockquote>
<h3 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h3><p><strong>坏了、无法正常使用的扇区就是“坏块”。这属于硬件故障，操作系统是无法修复的</strong>。应该将坏块标记出来，以免错误地使用到它。</p>
<p>对于简单的磁盘，<strong>可以在逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如：在FAT表上标明</strong>。（在这种方式中，坏块对操作系统不透明）</p>
<p>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。</p>
<p><strong>在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化</strong>。</p>
<p><strong>会保留一些“备用扇区”，用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明</strong>。</p>
<h2 id="固态硬盘-SSD"><a href="#固态硬盘-SSD" class="headerlink" title="固态硬盘 SSD"></a>固态硬盘 SSD</h2><h3 id="固态硬盘的结构"><a href="#固态硬盘的结构" class="headerlink" title="固态硬盘的结构"></a>固态硬盘的结构</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64aad9c23dffd.png" alt="image-20230313195557737" style="zoom:50%;" />

<p>闪存翻译层：<strong>负责翻译逻辑块号</strong>，找到对应页（Page）</p>
<p>存储介质：多个闪存芯片（Flash Chip）—每个芯片包含多个块（block）—每个块包含多个页（page）</p>
<h3 id="读写特性"><a href="#读写特性" class="headerlink" title="读写特性"></a>读写特性</h3><p>以页（page）为单位读／写—相当于磁盘的“扇区”</p>
<p>以块（block）为单位“擦除”，擦干净的块，其中的每页都可以写一次，读无限次</p>
<p><strong>支持随机访问</strong>，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址</p>
<p><strong>读快、写慢</strong>。要写的页如果有数据，则不能写入，需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页。</p>
<p>【与机械硬盘相比】</p>
<ol>
<li>SSD读写速度快，随机访问性能高，用电路控制访问位置；机械硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟</li>
<li>SSD 安静无噪音、耐摔抗震、能耗低、造价更贵</li>
<li><strong>SSD的一个“块”被擦除次数过多（重复写同一个块）可能会坏掉</strong>，而机械硬盘的扇区不会因为写的次数太多而坏掉</li>
</ol>
<h3 id="磨损均衡技术"><a href="#磨损均衡技术" class="headerlink" title="磨损均衡技术"></a>磨损均衡技术</h3><p>思想：将“擦除”平均分布在各个块上，以提升使用寿命。</p>
<ul>
<li><strong>动态磨损均衡：写入数据时，优先选择累计擦除次数少的新闪存块</strong>。</li>
<li><strong>静态磨损均衡：SSD监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务</strong>。</li>
</ul>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>结（忙…..</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.helloseraphine.top">Maxwell Lei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.helloseraphine.top/2023/03/13/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%905.0%E3%80%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88IO%EF%BC%89%E7%AE%A1%E7%90%86/">https://www.helloseraphine.top/2023/03/13/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%905.0%E3%80%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88IO%EF%BC%89%E7%AE%A1%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.helloseraphine.top" target="_blank">Maxwell_Leiの小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad8c55168b.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/11/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%904.0%E3%80%91%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title="【4.0】文件管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/09/64aad76d0aba9.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【4.0】文件管理</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/11/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%901.0%E3%80%91Python%E5%85%A5%E9%97%A8/" title="【1.0】Python入门"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2023/07/10/64abbdc4cc2bf.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【1.0】Python入门</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://thirdqq.qlogo.cn/g?b=qq&amp;nk=738232585&amp;s=100" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Maxwell Lei</div><div class="author-info__description">如果有一天我可以在海里翱翔，就像一只小魔鬼鱼</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/MaxwellLei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/MaxwellLei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:738232585@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://afdian.com/a/fastgpt" target="_blank" title="每天给生活来一拳"><i class="fas fa-coffee"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">活着就是能与别人彼此相知，心意相通，人生在世的意义不就是希望有那种与自己有默契的人存在吗，欣赏认可别人，喜欢爱恋别人，厌烦憎恶别人，因为和别人在一起而感到快乐，可以和别人牵着手并肩前行，这个过程就是活着。如果世界里只有自己，我们就无法感受到存在是什么，我们与别人的关系就是我们自己活着的证明。我的灵魂之所以存在，是因为有你们的关注，我的身体之所以存在，则是因为有你们的碰触，所以啊，只要人活在世上，就一定是有意义的。怎么活是自己选的，就像你和我就都选择了像现在这样活着。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#I-O%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">I&#x2F;O管理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E8%AE%BE%E5%A4%87%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">I&#x2F;O设备的概念和分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%BF%E7%94%A8%E7%89%B9%E6%80%A7%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.1.</span> <span class="toc-text">按使用特性分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.2.</span> <span class="toc-text">按传输速率分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2%E5%8D%95%E4%BD%8D%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.3.</span> <span class="toc-text">按信息交换单位分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">I&#x2F;O控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.2.1.</span> <span class="toc-text">I&#x2F;O控制器的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E7%8B%AC%E7%AB%8B%E7%BC%96%E5%9D%80"><span class="toc-number">2.2.2.</span> <span class="toc-text">内存映像和寄存器独立编址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">I&#x2F;O控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">程序直接控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.2.</span> <span class="toc-text">中断驱动方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA-%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.3.</span> <span class="toc-text">DMA 方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">DMA 控制器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.4.</span> <span class="toc-text">通道控制方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.</span> <span class="toc-text">I&#x2F;O软件层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%B1%82%E8%BD%AF%E4%BB%B6"><span class="toc-number">2.4.1.</span> <span class="toc-text">用户层软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6"><span class="toc-number">2.4.2.</span> <span class="toc-text">设备独立性软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.3.</span> <span class="toc-text">设备驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.4.</span> <span class="toc-text">中断处理程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.5.</span> <span class="toc-text">输入输出程序接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.6.</span> <span class="toc-text">设备驱动程序接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6-1"><span class="toc-number">3.</span> <span class="toc-text">设备独立性软件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.1.</span> <span class="toc-text">I&#x2F;O核心子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E8%B0%83%E5%BA%A6"><span class="toc-number">3.1.1.</span> <span class="toc-text">I&#x2F;O调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.1.2.</span> <span class="toc-text">设备保护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">3.2.</span> <span class="toc-text">假脱机技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">3.2.1.</span> <span class="toc-text">什么是脱机技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%BA%95%E5%92%8C%E8%BE%93%E5%87%BA%E4%BA%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">输入井和输出井</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%89%93%E5%8D%B0%E6%9C%BA%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.3.</span> <span class="toc-text">共享打印机原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">3.3.</span> <span class="toc-text">设备的分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%97%B6%E5%BA%94%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">3.3.1.</span> <span class="toc-text">设备分配时应考虑的因素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">固有属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">设备分配算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">设备分配中的安全</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">3.3.2.</span> <span class="toc-text">静态分配和动态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.3.</span> <span class="toc-text">设备分配管理中的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.3.4.</span> <span class="toc-text">设备分配的步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%AD%A5%E9%AA%A4%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">设备分配步骤的改进</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">缓冲区管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.4.1.</span> <span class="toc-text">缓冲区的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">3.4.2.</span> <span class="toc-text">缓冲区的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">单缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">双缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">循环缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">缓冲池</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="toc-number">4.</span> <span class="toc-text">磁盘和固态硬盘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">磁盘的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%EF%BC%8C%E7%A3%81%E9%81%93%EF%BC%8C%E6%89%87%E5%8C%BA"><span class="toc-number">4.1.1.</span> <span class="toc-text">磁盘，磁道，扇区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%AD%E8%AF%BB-%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">4.1.2.</span> <span class="toc-text">如何在磁盘中读&#x2F;写数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%98%E9%9D%A2%EF%BC%8C%E6%9F%B1%E9%9D%A2"><span class="toc-number">4.1.3.</span> <span class="toc-text">盘面，柱面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.1.4.</span> <span class="toc-text">磁盘的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%86%99%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">4.2.1.</span> <span class="toc-text">一次读写需要的时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95%EF%BC%88FCFS%EF%BC%89"><span class="toc-number">4.2.2.</span> <span class="toc-text">先来先服务算法（FCFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4%E5%AF%BB%E5%9D%80%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%88SSTF%EF%BC%89"><span class="toc-number">4.2.3.</span> <span class="toc-text">最短时间寻址时间优先算法（SSTF）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%88SCAN%EF%BC%89"><span class="toc-number">4.2.4.</span> <span class="toc-text">扫描算法（SCAN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LOOK%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.5.</span> <span class="toc-text">LOOK调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%88C-SCAN%EF%BC%89"><span class="toc-number">4.2.6.</span> <span class="toc-text">循环扫描算法（C-SCAN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-LOOK%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.7.</span> <span class="toc-text">C-LOOK调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">减少延迟时间的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%9B%BF%E7%BC%96%E5%8F%B7"><span class="toc-number">4.3.1.</span> <span class="toc-text">交替编号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">磁盘地址结构的设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E4%BD%8D%E5%91%BD%E5%90%8D"><span class="toc-number">4.3.2.</span> <span class="toc-text">错位命名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">磁盘的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.4.1.</span> <span class="toc-text">磁盘初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E5%9D%97"><span class="toc-number">4.4.2.</span> <span class="toc-text">引导块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%8F%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.3.</span> <span class="toc-text">坏块的管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98-SSD"><span class="toc-number">4.5.</span> <span class="toc-text">固态硬盘 SSD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">4.5.1.</span> <span class="toc-text">固态硬盘的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E7%89%B9%E6%80%A7"><span class="toc-number">4.5.2.</span> <span class="toc-text">读写特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%A8%E6%8D%9F%E5%9D%87%E8%A1%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">4.5.3.</span> <span class="toc-text">磨损均衡技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#End"><span class="toc-number">5.</span> <span class="toc-text">End</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/10/11/%E6%95%B0%E5%AD%A6%E5%9C%B0%E7%90%83%E7%A7%91%E5%AD%A6/%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B%E7%B3%BB%E5%88%97(%E5%9B%9B)%20%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B%E7%9A%84%E2%80%9C%E4%B8%BB%E5%8A%9B%E5%86%9B%E2%80%9D%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E4%B8%8E%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="大数据成矿预测系列(四) | 成矿预测的“主力军”：随机森林与支持向量机深度解析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2025/10/11/PixPin_2025-10-11_20-59-22-small50-77deb6bd1f88f9bd5636576083671bfa.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大数据成矿预测系列(四) | 成矿预测的“主力军”：随机森林与支持向量机深度解析"/></a><div class="content"><a class="title" href="/2025/10/11/%E6%95%B0%E5%AD%A6%E5%9C%B0%E7%90%83%E7%A7%91%E5%AD%A6/%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B%E7%B3%BB%E5%88%97(%E5%9B%9B)%20%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B%E7%9A%84%E2%80%9C%E4%B8%BB%E5%8A%9B%E5%86%9B%E2%80%9D%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E4%B8%8E%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="大数据成矿预测系列(四) | 成矿预测的“主力军”：随机森林与支持向量机深度解析">大数据成矿预测系列(四) | 成矿预测的“主力军”：随机森林与支持向量机深度解析</a><time datetime="2025-10-11T11:10:26.000Z" title="发表于 2025-10-11 19:10:26">2025-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/06/%E6%95%B0%E5%AD%A6%E5%9C%B0%E7%90%83%E7%A7%91%E5%AD%A6/%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B%E7%B3%BB%E5%88%97(%E4%B8%89)%20%E4%BB%8E%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B%E5%88%B0%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%B8%BA%E4%BD%95%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%98%AF%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B%E7%9A%84%E6%96%B0%E5%89%8D%E6%B2%BF%EF%BC%9F/" title="大数据成矿预测系列(三) | 从统计模型到机器学习：为何机器学习是成矿预测的新前沿？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2025/10/06/PixPin_2025-10-06_16-03-33-small50-1ee5e787f8b16f780e9b588d09e664ff.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大数据成矿预测系列(三) | 从统计模型到机器学习：为何机器学习是成矿预测的新前沿？"/></a><div class="content"><a class="title" href="/2025/10/06/%E6%95%B0%E5%AD%A6%E5%9C%B0%E7%90%83%E7%A7%91%E5%AD%A6/%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B%E7%B3%BB%E5%88%97(%E4%B8%89)%20%E4%BB%8E%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B%E5%88%B0%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%B8%BA%E4%BD%95%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%98%AF%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B%E7%9A%84%E6%96%B0%E5%89%8D%E6%B2%BF%EF%BC%9F/" title="大数据成矿预测系列(三) | 从统计模型到机器学习：为何机器学习是成矿预测的新前沿？">大数据成矿预测系列(三) | 从统计模型到机器学习：为何机器学习是成矿预测的新前沿？</a><time datetime="2025-10-06T06:39:20.000Z" title="发表于 2025-10-06 14:39:20">2025-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/01/%E6%95%B0%E5%AD%A6%E5%9C%B0%E7%90%83%E7%A7%91%E5%AD%A6/%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B%E7%B3%BB%E5%88%97(%E4%BA%8C)%20%20%E6%91%86%E8%84%B1%E6%9D%9F%E7%BC%9A%EF%BC%8C%E6%8B%A5%E6%8A%B1%E6%9C%AA%E6%9D%A5%EF%BC%9A%E8%AF%81%E6%8D%AE%E6%9D%83%E9%87%8D%E6%B3%95%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%87%AA%E8%BA%AB%E5%B1%80%E9%99%90%EF%BC%9F/" title="大数据成矿预测系列(二) | 证据权重法如何克服自身局限？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2025/10/01/Gemini_Generated_Image_8y9yok8y9yok8y9y%20-1--a610bd85ac1d712b230b4fbfb85c6513.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大数据成矿预测系列(二) | 证据权重法如何克服自身局限？"/></a><div class="content"><a class="title" href="/2025/10/01/%E6%95%B0%E5%AD%A6%E5%9C%B0%E7%90%83%E7%A7%91%E5%AD%A6/%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B%E7%B3%BB%E5%88%97(%E4%BA%8C)%20%20%E6%91%86%E8%84%B1%E6%9D%9F%E7%BC%9A%EF%BC%8C%E6%8B%A5%E6%8A%B1%E6%9C%AA%E6%9D%A5%EF%BC%9A%E8%AF%81%E6%8D%AE%E6%9D%83%E9%87%8D%E6%B3%95%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%87%AA%E8%BA%AB%E5%B1%80%E9%99%90%EF%BC%9F/" title="大数据成矿预测系列(二) | 证据权重法如何克服自身局限？">大数据成矿预测系列(二) | 证据权重法如何克服自身局限？</a><time datetime="2025-10-01T10:01:16.000Z" title="发表于 2025-10-01 18:01:16">2025-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/26/%E6%95%B0%E5%AD%A6%E5%9C%B0%E7%90%83%E7%A7%91%E5%AD%A6/%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B%E7%B3%BB%E5%88%97(%E4%B8%80)%20%20%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B%E2%80%9C%E8%AF%81%E6%8D%AE%E6%9D%83%E9%87%8D%E6%B3%95%E2%80%9D%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" title="大数据成矿预测系列(一) | 经典模型“证据权重法”的前世今生"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2025/09/26/image-20250926223705437-4ccb11334f7d76257080220a82828c17.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大数据成矿预测系列(一) | 经典模型“证据权重法”的前世今生"/></a><div class="content"><a class="title" href="/2025/09/26/%E6%95%B0%E5%AD%A6%E5%9C%B0%E7%90%83%E7%A7%91%E5%AD%A6/%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%90%E7%9F%BF%E9%A2%84%E6%B5%8B%E7%B3%BB%E5%88%97(%E4%B8%80)%20%20%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B%E2%80%9C%E8%AF%81%E6%8D%AE%E6%9D%83%E9%87%8D%E6%B3%95%E2%80%9D%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" title="大数据成矿预测系列(一) | 经典模型“证据权重法”的前世今生">大数据成矿预测系列(一) | 经典模型“证据权重法”的前世今生</a><time datetime="2025-09-26T03:18:01.000Z" title="发表于 2025-09-26 11:18:01">2025-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/18/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E7%A2%8E%E7%89%87%E5%8C%96%E7%9F%A5%E8%AF%86/%E5%B2%AD%E5%9B%9E%E5%BD%92%E5%92%8C%20Lasso%E5%9B%9E%E5%BD%92/" title="岭回归和 Lasso回归"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/blog/2025/09/18/Gemini_Generated_Image_pc3syspc3syspc3s%20-1-%20-1--9906598b7a936291c5f1c5cf814fd38b.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="岭回归和 Lasso回归"/></a><div class="content"><a class="title" href="/2025/09/18/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E7%A2%8E%E7%89%87%E5%8C%96%E7%9F%A5%E8%AF%86/%E5%B2%AD%E5%9B%9E%E5%BD%92%E5%92%8C%20Lasso%E5%9B%9E%E5%BD%92/" title="岭回归和 Lasso回归">岭回归和 Lasso回归</a><time datetime="2025-09-18T08:36:08.000Z" title="发表于 2025-09-18 16:36:08">2025-09-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Maxwell Lei</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://ahqxdttiopbn.ap-northeast-1.clawcloudrun.com/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://ahqxdttiopbn.ap-northeast-1.clawcloudrun.com/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>