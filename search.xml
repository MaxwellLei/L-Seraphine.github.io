<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【7.1】非均衡分类问题</title>
      <link href="/2023/08/28/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%907-1%E3%80%91%E9%9D%9E%E5%9D%87%E8%A1%A1%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/28/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%907-1%E3%80%91%E9%9D%9E%E5%9D%87%E8%A1%A1%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>非均衡问题（Imbalanced Problem）是指在一个数据集中，不同类别之间的样本数量差异较大的情况</strong>。例如，一个二分类问题中，其中一类的样本数比另一类多很多，通常会被认为是一个非均衡问题。这部分是讨论机器学习算法在应用方面的评价问题。</p><p>在前面，我们构建了一个用于检测患疝病的马匹是否存活的系统。在那里，我们构建了分类器，但是并没有对分类后的情形加以讨论。假如某人给我们牵来一匹马，他希望我们能预测这匹马能否生存。我们说马会死，那么他们就可能会对马实施安乐死，而不是通过给马喂药来延缓其不可避免的死亡过程。我们的预测也许是错误的，马本来是可以继续活着的。毕竟，我们的分类器只有80%的精确率（accuracy）。如果我们预测错误，那么我们将会错杀了一个如此昂贵的动物，更不要说人对马还存在情感上的依恋。</p><p>本文内容学习来源感谢：</p><ul><li><strong>《Machine Learning in Action》</strong></li><li><strong>《智能之门》</strong></li><li><strong>哔哩哔哩，维基百科等网络</strong></li></ul><blockquote><p>前排说明</p><ul><li>本文所有代码基于 Python 3.10 版本，理论上你的版本为 3.X 皆可运行。</li><li>在代码的注释中看到符号：❓，则表示注释的代码部分函数解释说明可以在最后的相关函数中查阅。</li></ul></blockquote><h1 id="其他分类性能度量指标"><a href="#其他分类性能度量指标" class="headerlink" title="其他分类性能度量指标"></a>其他分类性能度量指标</h1><h2 id="正确率、召回率"><a href="#正确率、召回率" class="headerlink" title="正确率、召回率"></a>正确率、召回率</h2><p>到现在为止，本文所有机器学习内容的<strong>都是基于错误率来衡量分类器任务的成功程度的</strong>。错误率指的是在所有测试样例中错分的样例比例。<strong>实际上，这样的度量错误掩盖了样例如何被分错的事实</strong>。在机器学习中，有一个普遍适用的称为<strong>混淆矩阵</strong>（confusion matrix）的工具，它可以帮助人们更好地了解分类中的错误。有这样一个关于在房子周围可能发现的动物类型的预测，这个预测的三类问题的混淆矩阵如下所示。</p><img src="https://img.helloseraphine.top:8089/blog/2023/08/28/64ecb37174885.png" alt="image-20230828224701523" style="zoom:50%;" /><p>利用混淆矩阵就可以更好地理解分类中的错误了。<strong>如果矩阵中的非对角元素均为0，就会得到一个完美的分类器</strong>。</p><p>接下来，我们考虑另外一个混淆矩阵，这次的矩阵只针对一个简单的二类问题。在上图中中，给出了该混淆矩阵。在这个二类问题中，如果将一个正例判为正例，那么就可以认为产生了一个<strong>真正例</strong>（True Positive，TP，也称真阳）；如果对一个反例正确地判为反例，则认为产生了一个<strong>真反例</strong>（True Negative，TN，也称真阴）。相应地，另外两种情况则分别称为<strong>伪反例</strong>（False Negative，FN，也称假阴）和<strong>伪正例</strong>（False Positive，FP，也称假阳）。这 4 种情况如下图所示。</p><img src="https://img.helloseraphine.top:8089/blog/2023/08/28/64ecb48a6f072.png" alt="image-20230828225151852" style="zoom:50%;" /><p>在分类中，当某个类别的重要性高于其他类别时，我们就可以利用上述定义来定义出多个比错误率更好的新指标。第一个指标是<strong>正确率</strong>（Precision），它等于 $正确率 &#x3D;\Large \frac{真正例}{真正例+伪正例}$，给出的是预测为正例的样本中的真正正例的比例。第二个指标是<strong>召回率</strong>（Recall） ，它等于 $\Large 召回率 &#x3D; \frac{真正例}{真正例 + 伪反例}$，<strong>给出的是预测为正例的真实正例占所有真实正例的比例</strong>。<strong>在召回率很大的分类器中，真正判错的正例的数目并不多</strong>。</p><p>我们可以很容易构造一个高正确率或高召回率的分类器，但是很难同时保证两者成立。如果将任何样本都判为正例，那么召回率达到百分之百而此时正确率很低。构建一个同时使正确率和召回率最大的分类器是具有挑战性的。</p><h2 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h2><p><strong>另一个用于度量分类中的非均衡性的工具是ROC曲线（ROC curve），ROC代表接收者操作特征（receiver operating characteristic）</strong>，它最早在二战期间由电气工程师构建雷达系统时使用过。下图给出了一条ROC曲线的例子。</p><img src="https://img.helloseraphine.top:8089/blog/2023/08/28/64ecb6ca3b479.png" alt="image-20230828230126645" style="zoom: 67%;" /><p>在上图的 ROC 曲线中，给出了两条线，一条虚线一条实线。图中的横轴是伪正例的比例（$伪正例比例 &#x3D;\Large \frac{伪正例}{真反例+伪正例}$)），而纵轴是真正例的比例（$真正例比例 &#x3D;\Large \frac{真正例}{真正例+伪反例}$）。ROC曲线给出的是当阈值变化时假阳率和真阳率的变化情况。<strong>左下角的点所对应的是将所有样例判为反例的情况，而右上角的点对应的则是将所有样例判为正例的情况</strong>。虚线给出的是随机猜测的结果曲线。</p><p>ROC曲线不但可以用于比较分类器，还可以基于<strong>成本效益</strong>（cost-versus-benefit）分析来做出决策。由于在不同的阈值下，不同的分类器的表现情况可能各不相同，因此以某种方式将它们组合起来或许会更有意义。如果只是简单地观察分类器的错误率，那么我们就难以得到这种更深入的洞察效果了。</p><p><strong>在理想的情况下，最佳的分类器应该尽可能地处于左上角，这就意味着分类器在假阳率很低的同时获得了很高的真阳率</strong>。例如在垃圾邮件的过滤中，这就相当于过滤了所有的垃圾邮件，但没有将任何合法邮件误识为垃圾邮件而放入垃圾邮件的文件夹中。</p><p>对不同的ROC曲线进行比较的一个指标是<strong>曲线下的面积</strong>（Area Unser the Curve，AUC）。A<strong>UC 给出的是分类器的平均性能值</strong>，当然它并不能完全代替对整条曲线的观察。一个完美分类器的AUC为 1.0，而随机猜测的AUC则为 0.5。</p><h1 id="基于代价函数的分类器决策控制"><a href="#基于代价函数的分类器决策控制" class="headerlink" title="基于代价函数的分类器决策控制"></a>基于代价函数的分类器决策控制</h1><p>除了调节分类器的阈值之外，我们还有一些其他可以用于处理非均衡分类的代价的方法，其中的一种称为<strong>代价敏感的学习</strong>（cost-sensitive learning）。考虑下图中的代价矩阵，第一张表给出的是到目前为止分类器的代价矩阵（代价不是0就是1）。我们可以基于该代价矩阵计算其总代价：<code>TP*0+FN*1+FP*1+TN*0</code>。接下来我们考虑下面的第二张表，基于该代价矩阵的分类代价的计算公式为：<code>TP*(-5)+FN*1+FP*50+TN*0</code>。采用第二张表作为代价矩阵时，两种分类错误的代价是不一样的。类似地，这两种正确分类所得到的收益也不一样。如果在构建分类器时，知道了这些代价值，那么就可以选择付出最小代价的分类器。</p><img src="https://img.helloseraphine.top:8089/blog/2023/08/28/64ecbb3d43335.png" alt="image-20230828232028089" style="zoom: 80%;" /><h1 id="处理非均衡问题的数据抽样方法"><a href="#处理非均衡问题的数据抽样方法" class="headerlink" title="处理非均衡问题的数据抽样方法"></a>处理非均衡问题的数据抽样方法</h1><p>另外一种针对非均衡问题调节分类器的方法，就是对分类器的训练数据进行改造。这可以通过<strong>欠抽样</strong>（undersampling）或者<strong>过抽样</strong>（oversampling）来实现。过抽样意味着复制样例，而欠抽样意味着删除样例。不管采用哪种方式，数据都会从原始形式改造为新形式。抽样过程则可以通过随机方式或者某个预定方式来实现。</p><p>通常也会存在某个罕见的类别需要我们来识别，比如在信用卡欺诈当中。如前所述，正例类别属于罕见类别。我们希望对于这种罕见类别能尽可能保留更多的信息，因此，我们应该保留正例类别中的所有样例，而对反例类别进行欠抽样或者样例删除处理。这种方法的一个缺点就在于要确定哪些样例需要进行剔除。但是，在选择剔除的样例中可能携带了剩余样例中并不包含的有价值信息。</p><p>上述问题的一种解决办法，就是选择那些离决策边界较远的样例进行删除。假定我们有一个数据集，其中有50例信用卡欺诈交易和5000例合法交易。如果我们想要对合法交易样例进行欠抽样处理，使得这两类数据比较均衡的话，那么我们就需要去掉4950个样例，而这些样例中可能包含很多有价值的信息。这看上去有些极端，因此有一种替代的策略就是使用反例类别的欠抽样和正例类别的过抽样相混合的方法。</p><p>要对正例类别进行过抽样，我们可以复制已有样例或者加入与已有样例相似的点。一种方法是加入已有数据点的插值点，但是这种做法可能会导致过拟合的问题。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>细枝末节的内容，但是有有些重要。</p><img src="https://img.helloseraphine.top:8089/blog/2023/08/28/64ecbc4b266c9.png" alt="image-20230828232455777" style="zoom: 25%;" />]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> ROC曲线 </tag>
            
            <tag> AUC </tag>
            
            <tag> 非均衡分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【7.0】利用 AdaBoost 元算法提高分类性能</title>
      <link href="/2023/07/27/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%907-0%E3%80%91%E5%88%A9%E7%94%A8-AdaBoost-%E5%85%83%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E5%88%86%E7%B1%BB%E6%80%A7%E8%83%BD/"/>
      <url>/2023/07/27/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%907-0%E3%80%91%E5%88%A9%E7%94%A8-AdaBoost-%E5%85%83%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E5%88%86%E7%B1%BB%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>当做重要决定时，大家可能都会考虑吸取多个专家而不只是一个人的意见</strong>。机器学习处理问题时也是如此，<strong>这就是元算法（meta—algorithm）背后的思路</strong>。<strong>元算法是对其他算法进行组合的一种方式</strong>。接下来我们将集中关注一个称作 AdaBoost（读作[ˈeɪdəˌbust]） 的最流行的元算法。</p><p>本文内容学习来源感谢：</p><ul><li><strong>《Machine Learning in Action》</strong></li><li><strong>《智能之门》</strong></li><li><strong>哔哩哔哩，维基百科等网络</strong></li></ul><blockquote><p>前排说明</p><ul><li>本文所有代码基于 Python 3.10 版本，理论上你的版本为 3.X 皆可运行。</li><li>在代码的注释中看到符号：❓，则表示注释的代码部分函数解释说明可以在0最后的相关函数中查阅。</li></ul></blockquote><h1 id="基于数据集多重抽样的分类器"><a href="#基于数据集多重抽样的分类器" class="headerlink" title="基于数据集多重抽样的分类器"></a>基于数据集多重抽样的分类器</h1><p>前面已经介绍了五种不同的分类算法，它们各有优缺点。我们自然可以将不同的分类器组合起来，<strong>而这种组合结果则被称为集成方法（ensemble method）或者元算法（meta-algorithm）</strong>。使 用集成方法时会有多种形式：可以是不同算法的集成，也可以是同一算法在不同设置下的集成，还可以是数据集不同部分分配给不同分类器之后的集成。</p><p><strong>AdaBoost</strong></p><ul><li>优点：泛化错误率低，易编码，可以应用在大部分分类器上，无参数调整。</li><li>缺点：<strong>对离群点敏感</strong>。</li><li>适用数据类型：数值型和标称型数据。</li></ul><h2 id="bagging"><a href="#bagging" class="headerlink" title="bagging"></a>bagging</h2><p><a href="https://zh.wikipedia.org/wiki/Bagging%E7%AE%97%E6%B3%95">Bagging</a>（读作[ˈbæɡɪŋ]），它是 Bootstrap Aggregating （引导聚集算法，又称<strong>装袋算法</strong>）的缩写，<strong>是在从原始数据集选择 S 次后得到 S 个新数据集的一种技术。新数据集和原数据集的大小相等。每个数据集都是通过在原始数据集中随机选择一个样本来进行替换而得到的</strong>。这里的替换就意味着可以多次地选择同一样本。这一性质就允许新数据集中可以有重复的值，而原始数据集的某些值在新集合中则不再出现。</p><p>在<em>S</em>个数据集建好之后，将某个学习算法分别作用于每个数据集就得到了<em>S</em>个分类器。当我们要对新数据进行分类时，就可以<strong>应用这S个分类器进行分类</strong>。与此同时，<strong>选择分类器投票结果中最多的类别作为最后的分类结果</strong>。</p><p>Bagging在降低模型的方差和提高泛化能力方面表现出色，特别是在复杂模型和高维数据上。<strong>常见的Bagging算法包括随机森林（Random Forests）</strong>，<strong>它是基于决策树的一种集成学习方法</strong>。</p><h2 id="boosting"><a href="#boosting" class="headerlink" title="boosting"></a>boosting</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95">Boosting</a>（<strong>提升方法</strong>）是一种与bagging很类似的技术。不论是在boosting还是bagging当中，所使用的多个分类器的类型都是一致的。但是在前者当中，<strong>不同的分类器是通过串行训练而获得的，每个新分类器都根据已训练出的分类器的性能来进行训练</strong>（通过串行训练多个弱学习器<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>（weak learners），然后将它们组合成一个强学习器（strong learner））。</p><p><strong>Boosting 的核心思想是重点关注被前一轮弱学习器分类错误的样本，对它们进行加权，然后在下一轮中训练新的弱学习器来纠正之前的错误</strong>。由于boosting分类的结果是基于所有分类器的加权求和结果的，因此 boosting 与 bagging 不太一样。bagging中的分类器权重是相等的，而 boosting 中的分类器权重并不相等，每个权重代表的是其对应分类器在上一轮迭代中的成功度。</p><p>boosting 方法拥有多个版本，本章将只关注其中一个最流行的版本 <strong>AdaBoost</strong>。</p><h1 id="训练算法：基于错误提升分类器的性能"><a href="#训练算法：基于错误提升分类器的性能" class="headerlink" title="训练算法：基于错误提升分类器的性能"></a>训练算法：基于错误提升分类器的性能</h1><p>能否使用弱分类器和多个实例来构建一个强分类器？这是一个非常有趣的理论问题。这里的“弱”意味着分类器的性能比随机猜测要略好，但是也不会好太多。这就是说，在二分类情况下弱分类器的错误率会高于 50%，而“强”分类器的错误率将会低很多。AdaBoost 算法即脱胎于上述理论问题。</p><p>AdaBoost 运行过程如下：<strong>训练数据中的每个样本，并赋予其一个权重，这些权重构成了向量<em>D</em>。一开始，这些权重都初始化成相等值。首先在训练数据上训练出一个弱分类器并计算该分类器的错误率，然后在同一数据集上再次训练弱分类器。在分类器的第二次训练当中，将会重新调整每个样本的权重，其中第一次分对的样本的权重将会降低，而第一次分错的样本的权重将会提高。为了从所有弱分类器中得到最终的分类结果，AdaBoost 为每个分类器都分配了一个权重值 alpha ，这些 alpha 值是基于每个弱分类器的错误率进行计算的。</strong>其中，错误率 <em>ε</em> 的定义为：$\huge\varepsilon&#x3D;\frac{未正确分类的样本数目}{所有样本数目}$ 。</p><p>而 alpha 的计算公式为：$\huge \alpha &#x3D; \frac{1}{2} \ln{(\frac{1-\varepsilon}{\varepsilon})}$ 。其算法流程如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/26/64c13154954f3.png" alt="image-20230726224354493" style="zoom:80%;" /><p>计算出 alpha 值之后，可以对权重向量<em>D</em>进行更新，以使得那些正确分类的样本的权重降低而错分样本的权重升高。<em>D</em>的计算方法如下。</p><ul><li><strong>如果某个样本被正确分类</strong>，那么该样本的权重更改为：$\huge D_i^{(t+1)}&#x3D;\frac{D_i^{(t)}e^{- \alpha}}{Sum(D)}$ 。</li><li>而<strong>如果某个样本被错分</strong>，那么该样本的权重更改为：$\huge D_i^{(t+1)}&#x3D;\frac{D_i^{(t)}e^{ \alpha}}{Sum(D)}$ 。</li></ul><p>在计算出<em>D</em>之后，AdaBoost又开始进入下一轮迭代。AdaBoost算法会不断地重复训练和调整权重的过程，直到训练错误率为 0 或者弱分类器的数目达到用户的指定值为止。</p><h1 id="基于单层决策树构建弱分类器"><a href="#基于单层决策树构建弱分类器" class="headerlink" title="基于单层决策树构建弱分类器"></a>基于单层决策树构建弱分类器</h1><p><strong>单层决策树</strong>（decision stump，也称决策树桩）是一种简单的决策树。前面我们已经介绍了决策树的工作原理，接下来将构建一个单层决策树，而它仅基于单个特征来做决策。由于这棵树只有一次分裂过程，因此它实际上就是一个树桩。</p><p>现在我们创建一个名称为 adaboost.py 的新文件来添加如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadSimpData</span>():</span><br><span class="line">    <span class="comment"># 创建数据集</span></span><br><span class="line">    datMat = matrix([[ <span class="number">1.</span> , <span class="number">2.1</span>],</span><br><span class="line">                    [ <span class="number">2.</span> , <span class="number">1.1</span>],</span><br><span class="line">                    [ <span class="number">1.3</span>, <span class="number">1.</span> ],</span><br><span class="line">                    [ <span class="number">1.</span> , <span class="number">1.</span> ],</span><br><span class="line">                    [ <span class="number">2.</span> , <span class="number">1.</span> ]])</span><br><span class="line">    <span class="comment"># 数据集对应目标值</span></span><br><span class="line">    classLabels = [<span class="number">1.0</span>, <span class="number">1.0</span>, -<span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">1.0</span>]</span><br><span class="line">    <span class="comment"># 返回数据集及其对应目标值</span></span><br><span class="line">    <span class="keyword">return</span> datMat,classLabels</span><br></pre></td></tr></table></figure><p>下图给出了上述数据集的示意图。如果想要试着从某个坐标轴上选择一个值（即选择一条与坐标轴平行的直线<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>）来将所有的圆形点和方形点分开，这显然是不可能的。这就是单层决策树难以处理的一个著名的问题。通过使用多棵单层决策树，我们就可以构建出一个能够对该数据集完全正确分类的分类器。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/26/64c13ab447b2f.png" alt="image-20230726232433851" style="zoom: 67%;" /><p>有了数据，接下来就可以通过构建多个函数来建立单层决策树。</p><p>第一个函数将用于测试是否有某个值小于或者大于我们正在测试的阈值。第二个函数则更加复杂一些，它会在一个加权数据集中循环，并找到具有最低错误率的单层决策树。现在在 adaboost.py 文件中添加如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据划分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stumpClassify</span>(<span class="params">dataMatrix, dimen, threshVal, threshIneq</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param dataMatrix: 一个二维的数据矩阵，其中每行表示一个样本，每列表示一个特征。</span></span><br><span class="line"><span class="string">    :param dimen: 一个整数，表示要使用的特征列的索引。</span></span><br><span class="line"><span class="string">    :param threshVal: 特征列上的阈值，将数据划分成两个类别。</span></span><br><span class="line"><span class="string">    :param threshIneq: 一个字符串，表示阈值比较的方式。如果为&#x27;lt&#x27;（less than），则将特征值小于等于threshVal的样本分为一类；</span></span><br><span class="line"><span class="string">    :return: 返回列表，其中标记为-1.0的样本属于一类，标记为1.0的样本属于另一类。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建一个结果列表，和数据集同一数量一列，且默认填充 1</span></span><br><span class="line">    retArray = ones((shape(dataMatrix)[<span class="number">0</span>], <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 根据字符串判断比较方式</span></span><br><span class="line">    <span class="keyword">if</span> threshIneq == <span class="string">&#x27;lt&#x27;</span>:</span><br><span class="line">        <span class="comment"># 将数据集根据阈值（决策树最优解）划分类别，写入分类结果列表</span></span><br><span class="line">        retArray[dataMatrix[:, dimen] &lt;= threshVal] = -<span class="number">1.0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        retArray[dataMatrix[:, dimen] &gt; threshVal] = -<span class="number">1.0</span></span><br><span class="line">    <span class="comment"># 返回分类结果</span></span><br><span class="line">    <span class="keyword">return</span> retArray</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建树桩（弱分类器）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buildStump</span>(<span class="params">dataArr, classLabels, D</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param dataArr: 一个二维的数据列表，其中每行表示一个样本，每列表示一个特征。</span></span><br><span class="line"><span class="string">    :param classLabels: 一个包含样本类别标签的列表，用于分类问题。</span></span><br><span class="line"><span class="string">    :param D: 一个包含样本权重的向量，用于加权错误率计算。</span></span><br><span class="line"><span class="string">    :return: 返回分类字典结果，最小错误权重，最小错误的目标值分类结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 列表转换为矩阵</span></span><br><span class="line">    dataMatrix = mat(dataArr)</span><br><span class="line">    <span class="comment"># 目标值列表转换为矩阵并转置</span></span><br><span class="line">    labelMat = mat(classLabels).T</span><br><span class="line">    <span class="comment"># 获取数据集的样本数目 m 和维度（特征数目） n</span></span><br><span class="line">    m, n = shape(dataMatrix)</span><br><span class="line">    <span class="comment"># 划分步数</span></span><br><span class="line">    numSteps = <span class="number">10.0</span></span><br><span class="line">    <span class="comment"># 分类结果（字典类型）</span></span><br><span class="line">    bestStump = &#123;&#125;</span><br><span class="line">    <span class="comment"># 形状为 m 行 1 列的全 0 矩阵</span></span><br><span class="line">    bestClasEst = mat(zeros((m, <span class="number">1</span>)))</span><br><span class="line">    <span class="comment">#❓(inf) 最小错误为正无穷大</span></span><br><span class="line">    minError = inf</span><br><span class="line">    <span class="comment"># 遍历所有特征</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 拿到第 i 列的最小值</span></span><br><span class="line">        rangeMin = dataMatrix[:, i].<span class="built_in">min</span>()</span><br><span class="line">        <span class="comment"># 拿到第 i 列的最大值</span></span><br><span class="line">        rangeMax = dataMatrix[:, i].<span class="built_in">max</span>()</span><br><span class="line">        <span class="comment"># 将一个特征的取值范围划分为若干个离散区间</span></span><br><span class="line">        stepSize = (rangeMax - rangeMin) / numSteps</span><br><span class="line">        <span class="comment"># 遍历每个分区从最小到最大</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">1</span>, <span class="built_in">int</span>(numSteps) + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 根据阈值分类规则遍历</span></span><br><span class="line">            <span class="keyword">for</span> inequal <span class="keyword">in</span> [<span class="string">&#x27;lt&#x27;</span>, <span class="string">&#x27;gt&#x27;</span>]:</span><br><span class="line">                <span class="comment"># 计算划分阈值，每次增加/减少（取决于 j 的正负）一个分区间隔</span></span><br><span class="line">                threshVal = (rangeMin + <span class="built_in">float</span>(j) * stepSize)</span><br><span class="line">                <span class="comment"># 根据阈值 threshVal 划分数据类别</span></span><br><span class="line">                predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)</span><br><span class="line">                <span class="comment"># 创建一个 m 行 1 列的结果列表</span></span><br><span class="line">                errArr = mat(ones((m, <span class="number">1</span>)))</span><br><span class="line">                <span class="comment">#❓ 判断根据阈值划分的目标值正确率，正确的将其值赋值为 0</span></span><br><span class="line">                errArr[predictedVals == labelMat] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 错误权重 = 权重 x 是否错误</span></span><br><span class="line">                weightedError = D.T * errArr</span><br><span class="line">                <span class="comment"># 输出信息</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;划分信息: 当前划分特征 <span class="subst">&#123;i&#125;</span>, 划分阈值 <span class="subst">&#123;threshVal&#125;</span>, 划分规则: <span class="subst">&#123;inequal&#125;</span>, 错误权重 <span class="subst">&#123;weightedError&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="comment"># 如果错误权重小于当前记录的最小错误</span></span><br><span class="line">                <span class="keyword">if</span> weightedError &lt; minError:</span><br><span class="line">                    <span class="comment"># 替换当前错误权重为最小权重</span></span><br><span class="line">                    minError = weightedError</span><br><span class="line">                    <span class="comment"># 记录根据阈值分类结果</span></span><br><span class="line">                    bestClasEst = predictedVals.copy()</span><br><span class="line">                    <span class="comment"># 记录当前分类特征；dim 是单词 dimension（维度） 的缩写</span></span><br><span class="line">                    bestStump[<span class="string">&#x27;dim&#x27;</span>] = i</span><br><span class="line">                    <span class="comment"># 记录弱分类器的划分阈值；thresh 是单词 threshold（阈值）的缩写</span></span><br><span class="line">                    bestStump[<span class="string">&#x27;thresh&#x27;</span>] = threshVal</span><br><span class="line">                    <span class="comment"># 记录弱分类器划分规则，是小于阈值还是大于阈值；ineq 是单词 inequality（不等式）的缩写</span></span><br><span class="line">                    bestStump[<span class="string">&#x27;ineq&#x27;</span>] = inequal</span><br><span class="line">    <span class="comment"># 返回分类字典结果，最小错误权重，最小错误的目标值分类结果</span></span><br><span class="line">    <span class="keyword">return</span> bestStump, minError, bestClasEst</span><br></pre></td></tr></table></figure><p>现在我们使用如下代码进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认权重 0.2</span></span><br><span class="line">D = mat(ones((<span class="number">5</span>,<span class="number">1</span>))/<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 获得数据集及其对应的目标值</span></span><br><span class="line">datMat,classLabels = loadSimpData()</span><br><span class="line"><span class="comment"># 弱分类器获得分类结果</span></span><br><span class="line"><span class="built_in">print</span>(buildStump(datMat,classLabels,D))</span><br></pre></td></tr></table></figure><p>运行结果如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">0.9</span>, 划分规则: lt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">0.9</span>, 划分规则: gt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.0</span>, 划分规则: lt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.0</span>, 划分规则: gt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.1</span>, 划分规则: lt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.1</span>, 划分规则: gt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.2</span>, 划分规则: lt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.2</span>, 划分规则: gt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.3</span>, 划分规则: lt, 错误权重 [[<span class="number">0.2</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.3</span>, 划分规则: gt, 错误权重 [[<span class="number">0.8</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.4</span>, 划分规则: lt, 错误权重 [[<span class="number">0.2</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.4</span>, 划分规则: gt, 错误权重 [[<span class="number">0.8</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.5</span>, 划分规则: lt, 错误权重 [[<span class="number">0.2</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.5</span>, 划分规则: gt, 错误权重 [[<span class="number">0.8</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.6</span>, 划分规则: lt, 错误权重 [[<span class="number">0.2</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.6</span>, 划分规则: gt, 错误权重 [[<span class="number">0.8</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.7000000000000002</span>, 划分规则: lt, 错误权重 [[<span class="number">0.2</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.7000000000000002</span>, 划分规则: gt, 错误权重 [[<span class="number">0.8</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.8</span>, 划分规则: lt, 错误权重 [[<span class="number">0.2</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.8</span>, 划分规则: gt, 错误权重 [[<span class="number">0.8</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.9</span>, 划分规则: lt, 错误权重 [[<span class="number">0.2</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">1.9</span>, 划分规则: gt, 错误权重 [[<span class="number">0.8</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">2.0</span>, 划分规则: lt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">0</span>, 划分阈值 <span class="number">2.0</span>, 划分规则: gt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">0.89</span>, 划分规则: lt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">0.89</span>, 划分规则: gt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.0</span>, 划分规则: lt, 错误权重 [[<span class="number">0.2</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.0</span>, 划分规则: gt, 错误权重 [[<span class="number">0.8</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.11</span>, 划分规则: lt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.11</span>, 划分规则: gt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.22</span>, 划分规则: lt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.22</span>, 划分规则: gt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.33</span>, 划分规则: lt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.33</span>, 划分规则: gt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.44</span>, 划分规则: lt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.44</span>, 划分规则: gt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.55</span>, 划分规则: lt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.55</span>, 划分规则: gt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.6600000000000001</span>, 划分规则: lt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.6600000000000001</span>, 划分规则: gt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.77</span>, 划分规则: lt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.77</span>, 划分规则: gt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.8800000000000001</span>, 划分规则: lt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.8800000000000001</span>, 划分规则: gt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.9900000000000002</span>, 划分规则: lt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">1.9900000000000002</span>, 划分规则: gt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">2.1</span>, 划分规则: lt, 错误权重 [[<span class="number">0.6</span>]]</span><br><span class="line">划分信息: 当前划分特征 <span class="number">1</span>, 划分阈值 <span class="number">2.1</span>, 划分规则: gt, 错误权重 [[<span class="number">0.4</span>]]</span><br><span class="line">(&#123;<span class="string">&#x27;dim&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;thresh&#x27;</span>: <span class="number">1.3</span>, <span class="string">&#x27;ineq&#x27;</span>: <span class="string">&#x27;lt&#x27;</span>&#125;, matrix([[<span class="number">0.2</span>]]), array([[-<span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>],</span><br><span class="line">       [-<span class="number">1.</span>],</span><br><span class="line">       [-<span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>]]))</span><br></pre></td></tr></table></figure><p>上述单层决策树的生成函数是决策树的一个简化版本。它就是所谓的弱学习器，即弱分类算法。到现在为止，我们已经构建了单层决策树，并生成了程序，做好了过渡到完整 AdaBoost 算法的准备。</p><h1 id="完整-AdaBoost-算法的实现"><a href="#完整-AdaBoost-算法的实现" class="headerlink" title="完整 AdaBoost 算法的实现"></a>完整 AdaBoost 算法的实现</h1><p>现在我们拥有了实现一个完整AdaBoost算法所需要的所有信息。AdaBoost 算法实现的伪代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对每次迭代：</span><br><span class="line">    利用buildStump()函数找到最佳的单层决策树   </span><br><span class="line">    将最佳单层决策树加入到单层决策树数组 </span><br><span class="line">    计算alpha   </span><br><span class="line">    计算新的权重向量D </span><br><span class="line">    更新累计类别估计值  </span><br><span class="line">    如果错误率等于0.0，则退出循环   </span><br></pre></td></tr></table></figure><p>现在，在 adaboost.py 文件中添加如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AdaBoost 算法实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">adaBoostTrainDS</span>(<span class="params">dataArr,classLabels,numIt=<span class="number">40</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param dataArr: 数据集</span></span><br><span class="line"><span class="string">    :param classLabels: 数据集对应的目标值</span></span><br><span class="line"><span class="string">    :param numIt: 用于指定迭代次数（默认为40次）</span></span><br><span class="line"><span class="string">    :return: 返回弱分类器列表和累计分类结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 存储弱分类器的列表，AdaBoost算法会在每次迭代中生成一个弱分类器，并将其添加到这个列表中</span></span><br><span class="line">    weakClassArr = []</span><br><span class="line">    <span class="comment"># 获取数据集一共多少样本（行）</span></span><br><span class="line">    m = shape(dataArr)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 初始化样本权重</span></span><br><span class="line">    D = mat(ones((m,<span class="number">1</span>))/m)</span><br><span class="line">    <span class="comment"># 初始化一个累计的分类结果向量，用于存储多个弱分类器的加权累计结果</span></span><br><span class="line">    aggClassEst = mat(zeros((m,<span class="number">1</span>)))</span><br><span class="line">    <span class="comment"># 开始迭代</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numIt):</span><br><span class="line">        <span class="comment"># 迭代一共弱分类器结果</span></span><br><span class="line">        bestStump,error,classEst = buildStump(dataArr,classLabels,D)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;权重：<span class="subst">&#123;D.T&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment">#❓ 计算当前弱分类器的权重 alpha</span></span><br><span class="line">        alpha = <span class="built_in">float</span>(<span class="number">0.5</span>*log((<span class="number">1.0</span>-error)/<span class="built_in">max</span>(error,<span class="number">1e-16</span>)))</span><br><span class="line">        <span class="comment"># 计算的权重保存在弱分类器结果字典中</span></span><br><span class="line">        bestStump[<span class="string">&#x27;alpha&#x27;</span>] = alpha</span><br><span class="line">        <span class="comment"># 存储弱分类器</span></span><br><span class="line">        weakClassArr.append(bestStump)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;弱分类器分类结果: <span class="subst">&#123;classEst.T&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment">#❓ 计算当前弱分类器的加权指数，用于更新样本的权重</span></span><br><span class="line">        expon = multiply(-<span class="number">1</span>*alpha*mat(classLabels).T,classEst)</span><br><span class="line">        D = multiply(D,exp(expon))</span><br><span class="line">        D = D/D.<span class="built_in">sum</span>()</span><br><span class="line">        <span class="comment"># 使用当前弱分类器的加权分类结果更新累计分类结果</span></span><br><span class="line">        aggClassEst += alpha*classEst</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;累计分类结果: <span class="subst">&#123;aggClassEst.T&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 计算累计分类结果和实际类别标签之间的错误</span></span><br><span class="line">        aggErrors = multiply(sign(aggClassEst) != mat(classLabels).T,ones((m,<span class="number">1</span>)))</span><br><span class="line">        <span class="comment"># 计算错误率</span></span><br><span class="line">        errorRate = aggErrors.<span class="built_in">sum</span>()/m</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;错误率: <span class="subst">&#123;errorRate&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 如果错误率为0，说明已经完美分类数据，可以提前终止迭代</span></span><br><span class="line">        <span class="keyword">if</span> errorRate == <span class="number">0.0</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 返回弱分类器列表和累计分类结果</span></span><br><span class="line">    <span class="keyword">return</span> weakClassArr,aggClassEst</span><br></pre></td></tr></table></figure><p>函数名称尾部的DS代表的就是<strong>单层决策树</strong>（decision stump），它是AdaBoost中最流行的弱分类器，当然并非唯一可用的弱分类器。上述函数确实是建立于单层决策树之上的，但是我们也可以很容易对此进行修改以引入其他基分类器。</p><h1 id="测试算法：基于AdaBoost的分类"><a href="#测试算法：基于AdaBoost的分类" class="headerlink" title="测试算法：基于AdaBoost的分类"></a>测试算法：基于AdaBoost的分类</h1><p>一旦拥有了多个弱分类器以及其对应的alpha值，进行测试就变得相当容易了。在上面的<code>adaBoostTrainDS()</code>中，我们实际已经写完了大部分的代码。现在，需要做的就只是将弱分类器的训练过程从程序中抽出来，然后应用到某个具体的实例上去。每个弱分类器的结果以其对应的alpha值作为权重。所有这些弱分类器的结果加权求和就得到了最后的结果。</p><p>现在将如下代码添加到 adaboost.py 文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">adaClassify</span>(<span class="params">datToClass,classifierArr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param datToClass: 将待分类的数据集</span></span><br><span class="line"><span class="string">    :param classifierArr: AdaBoost 算法的集成分类器</span></span><br><span class="line"><span class="string">    :return: 返回整合所有弱分类器后的最终分类结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 转换待分类数据集为矩阵</span></span><br><span class="line">    dataMatrix = mat(datToClass)</span><br><span class="line">    <span class="comment"># 获取数据集的样本数（行数）</span></span><br><span class="line">    m = shape(dataMatrix)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 初始化一个累计的分类结果向量，用于存储多个弱分类器的加权累计结果</span></span><br><span class="line">    aggClassEst = mat(zeros((m,<span class="number">1</span>)))</span><br><span class="line">    <span class="comment"># 对 AdaBoost 中的每个弱分类器进行迭代</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(classifierArr)):</span><br><span class="line">        classEst = stumpClassify(dataMatrix,classifierArr[i][<span class="string">&#x27;dim&#x27;</span>],classifierArr[i][<span class="string">&#x27;thresh&#x27;</span>],classifierArr[i][<span class="string">&#x27;ineq&#x27;</span>])</span><br><span class="line">        aggClassEst += classifierArr[i][<span class="string">&#x27;alpha&#x27;</span>]*classEst</span><br><span class="line">        <span class="built_in">print</span>(aggClassEst)</span><br><span class="line">    <span class="comment"># 返回整合所有弱分类器后的最终分类结果。使用 sign 函数将累计分类结果转换为类别标签</span></span><br><span class="line">    <span class="keyword">return</span> sign(aggClassEst)</span><br></pre></td></tr></table></figure><p>我尝试运行这段代码，它在 <code>3.X</code> 版本报错，如你所见，<strong>《Machine Learning in Action》</strong> 是在 <code>2.x</code>版本上实现的，我尝试修改了一些代码，例如<code>alpha = float(0.5*log((1.0-error)/maximum(float(error),minFloat)))</code>。但是它只能解决一小部分报错，它会带来其他报错，我有点困，不想动脑子，就暂时不修改它了，如果你感兴趣，自行尝试吧。</p><h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><h2 id="inf"><a href="#inf" class="headerlink" title="inf"></a><code>inf</code></h2><p>在NumPy中，**<code>inf</code>表示正无穷大（positive infinity）。它是一个特殊的浮点数常量，用于表示大于所有有限浮点数的值**。</p><p><code>-inf</code>则表示负无穷大（negative infinity），表示小于所有有限浮点数的值。</p><p><strong>这两个特殊值可以用于执行各种数学运算</strong>，例如除以零、计算极限等情况。当进行数值运算时，如果结果超过浮点数表示的范围，就会得到<code>inf</code>或<code>-inf</code>。</p><h2 id="errArr-predictedVals-labelMat-0"><a href="#errArr-predictedVals-labelMat-0" class="headerlink" title="errArr[predictedVals == labelMat] = 0"></a><code>errArr[predictedVals == labelMat] = 0</code></h2><p><code>errArr[predictedVals == labelMat] = 0</code> 这个代码就有点抽象了，不过我们来一点点看，首先需要了解 <code>predictedVals</code> 和 <code>labelMat</code> 都是行数相同的矩阵（1 列），使用<code>predictedVals == labelMat</code> 会得到 <code>true</code> 或者 <code>false</code> 的结果，注意此结果是一个矩阵，然后根据结果矩阵的 <code>true</code> 来给对应的位置赋值 0。</p><blockquote><p>如果你认为不理解，可以查看 NumPy 的文档 <a href="https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing">Boolean array indexing（布尔数组索引)</a> </p></blockquote><h2 id="max"><a href="#max" class="headerlink" title="max()"></a><code>max()</code></h2><p>在代码中的体现是 <code>alpha = float(0.5*log((1.0-error)/max(error,1e-16)))</code>。具体来说，<code>max(error, 1e-16)</code> 的作用是比较 <code>error</code> 和 <code>1e-16</code> 这两个数的大小，然后返回其中较大的那个数。如果 <code>error</code> 大于等于 <code>1e-16</code>，则返回 <code>error</code>，否则返回 <code>1e-16</code>。</p><p><code>1e-16</code> 表示科学计数法中的小数，即 1 乘以 10 的负 16 次方，也就是 0.0000000000000001，它通常用于避免出现非常小的数值。<strong>这种写法在很多情况下用于处理误差或防止除零错误。通过将误差或某个数值与一个较小的阈值（如 <code>1e-16</code>）进行比较，可以确保得到一个非零的结果，避免出现异常或无效计算</strong>。</p><h2 id="multiply"><a href="#multiply" class="headerlink" title="multiply()"></a><code>multiply()</code></h2><p><code>multiply()</code> 是 NumPy 库中的一个函数，<strong>用于对两个数组中对应位置的元素进行逐元素相乘</strong>。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">arr2 = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">result = np.multiply(arr1, arr2)</span><br><span class="line"><span class="built_in">print</span>(result)  </span><br><span class="line"><span class="comment"># 输出: [4 10 18]</span></span><br></pre></td></tr></table></figure><h2 id="sign"><a href="#sign" class="headerlink" title="sign()"></a><code>sign()</code></h2><p><code>sign()</code> 是 NumPy 库中的一个函数，用于对数组中的元素进行符号函数运算，<strong>返回每个元素的正负号</strong>。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.array([-<span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">result = np.sign(arr)</span><br><span class="line"><span class="built_in">print</span>(result)  </span><br><span class="line"><span class="comment"># 输出: [-1  0  1 -1  1]</span></span><br></pre></td></tr></table></figure><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>大概理解起来容易，但是实现起来又十分的繁杂且混乱😥</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/27/64c28974dc38e.png" alt="image-20230727231240680" style="zoom:80%;" /><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">弱学习器是指准确率略高于随机猜测的学习器，例如决策树深度较浅的模型。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">这里说的平行于坐标轴的直线是因为决策树根据信息熵找到划分的最佳特征值，也就是示例数据集中的两个特征之一，即 x 轴特征或者 y 特征。</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 弱分类器 </tag>
            
            <tag> AdaBoost </tag>
            
            <tag> 元算法 </tag>
            
            <tag> 决策树桩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【6.0】支持向量机</title>
      <link href="/2023/07/26/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%906-0%E3%80%91%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
      <url>/2023/07/26/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%906-0%E3%80%91%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>支持向量机（Support Vector Machines），简直就是 21 世纪酷刑😥</p><p>本文内容学习来源感谢：</p><ul><li>《Machine Learning in Action》</li><li>《智能之门》</li><li>哔哩哔哩，维基百科等网络</li></ul><blockquote><p>前排说明：本文所有代码基于 Python 3.10 版本，理论上你的版本为 3.X 皆可运行。</p></blockquote><h1 id="基于最大间隔分隔数据"><a href="#基于最大间隔分隔数据" class="headerlink" title="基于最大间隔分隔数据"></a>基于最大间隔分隔数据</h1><p>支持向量机</p><ul><li>优点：泛化错误率低，计算开销不大，结果易于解释</li><li>缺点：对参数调节和核函数的选择敏感，原始分类器不加修改仅适用于二类问题</li><li>适用数据类型：数值型和标称型数据</li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/23/64bcf4d9c1661.png" alt="image-20230723173717814" style="zoom: 80%;" /><p>在开始说明 SVM 之前，需要先解释几个概念，考虑上图四个数据点分布图像，一个问题是：<strong>能否画出一条直线将不同类别的点区分开来？</strong>先考虑下图中的数据，它们之间已经分隔的足够开，因此可以很容易的在图中画出一条直线将两组数据分开。在这种情况下，这组数据被称为<strong>线性可分（Linearly separable）数据</strong> 。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/23/64bcf6ea2380e.png" alt="image-20230723174617110" style="zoom:80%;" /><p>上述将数据集分割开来的直线称为<strong>分隔超平面（separating hyperplane）</strong>。在上面给出的例子中，<strong>由于数据点都在二维平面山，所以此时的分隔超平面就是一条直线</strong>。但是，如果给的数据集是三维的，那么此时用来分隔数据的就是一个平面。更高维度的依次类推。如果数据集是 1024 维度，那么就需要 1023 维度的某对象来对数据进行分隔。这个 1023 维的某对象称为<strong>超平面（hyerplane）</strong>，也就是分类的决策边界。分布在超平面一侧的所有数据都属于某个类别，而分布在另一侧的所有数据都属于另一个类别。</p><p>我们希望采用这种方式来构建分类器，即如果数据点距离决策边界很远，那么最后其预测结果也就越可信。<strong>我们希望找到离分隔超平面最近的点，确保它们离分隔面的距离尽可能的远，这里点到分隔面的距离被称为间隔（margin）</strong>。我们希望间隔尽可能的大，这是因为如果我们犯错或者在有限数据上训练分类器的话，我们希望分类器尽可能的健壮<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p><p><strong>支持向量（support vector）</strong>就是距离分隔超平面最近的那些点。接下来要试着最大化支持向量到分隔面的距离，需要找到此问题的优化解决方法。</p><h1 id="寻找最大间隔"><a href="#寻找最大间隔" class="headerlink" title="寻找最大间隔"></a>寻找最大间隔</h1><p>如何求解数据集的最佳分割线？如下图所示。分隔超平面的形式可以写成 $\large w^Tx +b$ 。要计算点到分隔超平面的距离，就必须给出点到分隔面的法线或者垂线的长度，该值为 $\Large \frac{|w^Tx + b|}{||w||}$ 。这里的常数 $b$ 类似于 Logistic 回归中的截距 $w_0$ 。这里的向量 $w$ 和常数 $b$ 一起描述了说给数据的分割线或者超平面。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/26/64c0d6cb13773.png" alt="image-20230726161804768" style="zoom: 67%;" /><h2 id="分类器求解的优化问题"><a href="#分类器求解的优化问题" class="headerlink" title="分类器求解的优化问题"></a>分类器求解的优化问题</h2><p>前面提到了分类器，但是还没有介绍它的工作原理。理解其工作原理将有助于理解基于优化问题的分类器求解过程。输入数据给分类器会输出一个类别标签，这相当于一个类似于 Sigmoid 的函数在作用。下面将使用类似于<strong>赫维赛德阶跃函数</strong>（单位阶跃函数）的函数对 $\large w^Tx+b$ 作用得到 $f(x^Tx+b)$ ，其中当 $u&lt;0$ 时 $f(u)$ 输出 $-1$ ，反之则输出 $+1$ 。这和前面的 Logistic 回归有所不同，那里的类别标签是 0 或 1。</p><p>这里的类别标签为什么采用 $-1$ 和 $+1$ ，而不是 0 或者 1呢？这是由于 $-1$ 和 $+1$ 仅仅相差一个符号，方便数学上处理。我们可以通过一个统一公式来表示间隔或者数据点到分割超平面的距离，同时不必要担心数据到底是属于 $-1$ 还是 $+1$ 。</p><p>当计算数据点到分隔面的距离并确定分隔面的放置位置时，间隔通过 $\large label \times (w^Tx + b)$ 来计算，这时就能体现出 $-1$ 和 $+1$ 类的好处了。如果数据点处于正方向（即＋1类）并且离分隔超平面很远的位置时，$\large w^Tx + b$ 会是一个很大的正数，同时 $\large label \times (w^Tx + b)$ 也会是一个很大的正数。而如果数据点处于负方向（$-1$类）并且离分隔超平面很远的位置时，此时由于类别标签为 $-1$，则 $\large label \times (w^Tx + b)$ 仍然是一个很大的正数。</p><p>现在的目标就是找出分类器定义中的 $w$ 和 $b$。为此，我们必须找到具有最小间隔的数据点，而这些数据点也就是前面提到的支持向量。一旦找到具有最小间隔的数据点，我们就需要对该间隔最大化。这就可以写作：</p><p>$\Large argmax_{w,b} \begin{Bmatrix} min_{n}(label \times (x^T +b)) \times \frac{1}{||w||} \end{Bmatrix}$  </p><p>直接求解上述问题相当困难，所以我们将它转换成为另一种更容易求解的形式。首先考察一下上式中大括号内的部分。由于对乘积进行优化是一件很讨厌的事情，因此我们要做的是固定其中一个因子而最大化其他因子。如果令所有支持向量的 $label \times (x^T +b)$ 都为 1，那么就可以通过求 $||w||^{-1}$ 的最大值来得到最终解。但是，并非所有数据点的 $label \times (x^T +b)$ 都等于 1，只有那些离分隔超平面最近的点得到的值才为 1。而离超平面越远的数据点，其 $label \times (x^T +b)$ 的值也就越大。</p><p>在上述优化问题中，给定了一些约束条件然后求最优值，因此该问题是一个带约束条件的优化问题。这里的约束条件就是 $label \times (x^T +b) \geq 1.0 $。对于这类优化问题，有一个非常著名的求解方法，即<strong>拉格朗日乘子法（拉格朗日数乘法）</strong>。</p><blockquote><p>剩下具体内容推理及其繁杂，可以参考 <a href="https://www.bilibili.com/video/BV1hT4y1r73X/">1小时候教会你svm支持向量机，学不会来打我！！</a> 当然你如果希望更加清晰的了解，参考这位数学博士的讲解 <a href="https://www.bilibili.com/video/BV1iU4y117k2/">【合集·支持向量机】 十分钟 机器学习系列 第八篇章：支持向量机</a> </p></blockquote><h1 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h1><img src="https://img.helloseraphine.top:8089/blog/2023/07/26/64c0eb4ed998d.png" alt="img" style="zoom:80%;" /><blockquote><p>图片来自于知乎：SMON</p></blockquote><p>如上图所示，数据点处于一个圆中，人类的大脑能够意识到这一点。然而，对于分类器而言，它只能识别分类器的结果是大于0 还是 小于 0 。如果只是在 x 和 y 轴构成的坐标系中插入直线进行分类的话，我们并不会得到理想的结果。<strong>我们或许可以对圆中的数据进行某种形式的转换，从而得到某些新的变量来表示数据</strong>。在这种表示情况下，我们就更容易得到大于 0 或者小于 0 的测试结果。在这个例子中，我们将数据从一个特征空间转换到另一个特征空间。在新空间下，我们可以很容易利用已有的工具对数据进行处理。数学家们喜欢将这个过程称之为从一个特征空间到另一个特征空间的映射。<strong>在通常情况下，这种映射会将低维特征空间映射到高维空间</strong>。</p><p>这种从某个特征空间到另一个特征空间的映射是通过核函数来实现的。你可以把核函数想象成一个包装器（wrapper）或者是接口（interface），<strong>它能把数据从某个很难处理的形式转换成为另一个较容易处理的形式</strong>。如果上述特征空间映射的说法听起来很让人迷糊的话，那么可以将它想象成为另外一种距离计算的方法。前面我们提到过距离计算的方法。距离计算的方法有很多种，不久我们也将看到，核函数一样具有多种类型。<strong>经过空间转换之后，我们可以在高维空间中解决线性问题，这也就等价于在低维空间中解决非线性问题</strong>。</p><p>SVM优化中一个特别好的地方就是，所有的运算都可以写成内积（inner product，也称点积）的形式。向量的内积指的是两个向量相乘，之后得到单个标量或者数值。我们可以把内积运算替换成核函数，而不必做简化处理。<strong>将内积替换成核函数的方式被称为核技巧（kernel trick）或者核“变电”（kernel substation）</strong>。</p><p>核函数并不仅仅应用于支持向量机，很多其他的机器学习算法也都用到核函数。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>支持向量机非常好用，但是原理又有一定的复杂性，本来打算弄个例子，目前来看，难度太大，遂决定在后面出使用 <code>scikit-learn</code> 的时候再弄例子。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/26/64c0ed923c854.png" alt="image-20230726175526950" style="zoom: 33%;" /><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">健壮&quot;通常指的是系统、软件或算法具有强大、稳定和鲁棒的性能，能够在各种不同的情况下正常运行，即使面对异常或错误输入也能保持良好的表现。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 支持向量机 </tag>
            
            <tag> 核函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【5.0】Logistic回归</title>
      <link href="/2023/07/23/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%905-0%E3%80%91Logistic%E5%9B%9E%E5%BD%92/"/>
      <url>/2023/07/23/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%905-0%E3%80%91Logistic%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇将会是令人激动的一部分，因为我们将首次接触到最优化算法。在我们生活中也会遇到很多最优化问题，例如如何在最短时间内从 A 点到达 B 点？如何投入最少的工作获取最大化的收益等等。</p><p>如果你并不理解什么是回归，这并不重要，后面的文章将会详细说明回归。现在假设有一些数据点，我们用一条直线对这些点进行拟合（<strong>该线称为最佳拟合直线</strong>），这个拟合的过程就称作回归。</p><p><strong>利用 Logistic 回归进行分类的主要思想是：根据现有数据对分类边界线建立回归公式，以此进行分类</strong>。</p><blockquote><p>前排提醒：本实例使用 Python 版本 3.X 理论上都可以运行，我本人使用的是 3.10 版本</p></blockquote><h1 id="基于-Logistic-回归和-Sigmoid-函数的分类"><a href="#基于-Logistic-回归和-Sigmoid-函数的分类" class="headerlink" title="基于 Logistic 回归和 Sigmoid 函数的分类"></a>基于 Logistic 回归和 Sigmoid 函数的分类</h1><p> Logistic 回归</p><ul><li><p>优点：计算代价不高，易于理解和实现</p></li><li><p>缺点：容易欠拟合，分类精度不高</p></li><li><p>适用数据类型：数值型和标称型数据</p></li></ul><p>我们希望的函数应该是：<strong>能接受所有的输入然后预测输出类别</strong>。例如，在二分类情况下，希望函数输出 0 或 1 。或许你之前接触过这种性质的函数，该函数称为**<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BD%8D%E9%98%B6%E8%B7%83%E5%87%BD%E6%95%B0">单位阶跃函数，又称为赫维赛德阶跃函数（Heaviside step function）</a>**。然而，单位阶跃函数的问题在于：该函数在跳跃点上从 0 瞬间跳跃到 1，这个瞬间跳跃的过程有时很难处理。幸好，另一个函数也有类似的性质，且数学上更容易处理，这就是 <strong>Sigmoid 函数</strong>。Sigmoid 函数具体的计算公式：$\huge \sigma(z) &#x3D; \frac{1}{1+e^{-z}}$ 。</p><blockquote><p>关于单位阶跃函数，可以参考<a href="https://www.bilibili.com/video/BV1ha411a78r/">电路21:什么是单位就阶跃函数?什么是电路的单位阶跃响应?</a>。</p></blockquote><p>如下图给出了 Sigmoid 函数在不同坐标尺度下的曲线图。当 $x &#x3D; 0$ 的时候，Sigmoid 函数值为 0.5，随着 $x$ 的增大，对应的 Sigmoid 值将会逼近 1；同理，随着 $x$ 的值减少，其值也会逼近于 0。如果横坐标刻度够大，Sigmoid 函数看起来就很像是一个阶跃函数。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/20/64b9193072401.png" alt="image-20230720192315491" style="zoom:80%;" /><blockquote><p>图片由 R 语言生成，如果你感兴趣的话，相关代码如下所示：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>cowplot<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">z1 <span class="operator">&lt;-</span> seq<span class="punctuation">(</span><span class="operator">-</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> by <span class="operator">=</span> <span class="number">0.1</span><span class="punctuation">)</span></span><br><span class="line">z2 <span class="operator">&lt;-</span> seq<span class="punctuation">(</span><span class="operator">-</span><span class="number">20</span><span class="punctuation">,</span> <span class="number">20</span><span class="punctuation">,</span> by <span class="operator">=</span> <span class="number">0.1</span><span class="punctuation">)</span></span><br><span class="line">output1 <span class="operator">&lt;-</span> 1 <span class="operator">/</span> <span class="punctuation">(</span><span class="number">1</span> <span class="operator">+</span> <span class="built_in">exp</span><span class="punctuation">(</span><span class="operator">-</span>z1<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">output2 <span class="operator">&lt;-</span> 1 <span class="operator">/</span> <span class="punctuation">(</span><span class="number">1</span> <span class="operator">+</span> <span class="built_in">exp</span><span class="punctuation">(</span><span class="operator">-</span>z2<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">data1 <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>z <span class="operator">=</span> z1<span class="punctuation">,</span> output <span class="operator">=</span> output1<span class="punctuation">,</span> func <span class="operator">=</span> <span class="string">&quot;Function 1&quot;</span><span class="punctuation">)</span></span><br><span class="line">data2 <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>z <span class="operator">=</span> z2<span class="punctuation">,</span> output <span class="operator">=</span> output2<span class="punctuation">,</span> func <span class="operator">=</span> <span class="string">&quot;Function 2&quot;</span><span class="punctuation">)</span></span><br><span class="line">data <span class="operator">&lt;-</span> rbind<span class="punctuation">(</span>data1<span class="punctuation">,</span> data2<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">plot1 <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>data1<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">geom_line<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> z<span class="punctuation">,</span> y <span class="operator">=</span> output<span class="punctuation">)</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">xlab<span class="punctuation">(</span><span class="string">&quot;z&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">ylab<span class="punctuation">(</span><span class="string">&quot;Output&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">ggtitle<span class="punctuation">(</span><span class="string">&quot;局部&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">theme_minimal<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">plot2 <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>data2<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">geom_line<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> z<span class="punctuation">,</span> y <span class="operator">=</span> output<span class="punctuation">)</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">xlab<span class="punctuation">(</span><span class="string">&quot;z&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">ylab<span class="punctuation">(</span><span class="string">&quot;Output&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">ggtitle<span class="punctuation">(</span><span class="string">&quot;整体&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">theme_minimal<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置两个图的不同横坐标范围</span></span><br><span class="line">plot1 <span class="operator">&lt;-</span> plot1 <span class="operator">+</span> coord_cartesian<span class="punctuation">(</span>xlim <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">plot2 <span class="operator">&lt;-</span> plot2 <span class="operator">+</span> coord_cartesian<span class="punctuation">(</span>xlim <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">20</span><span class="punctuation">,</span> <span class="number">20</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制两个图的布局</span></span><br><span class="line">plot_grid<span class="punctuation">(</span>plot1<span class="punctuation">,</span> plot2<span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></blockquote><p>因此，<strong>为了实现 Logistic 回归分类器，我们可以在每个特征上都乘以一个回归系数（weight），然后把所有的结果值都相加，将这个总和带入 Sigmoid 函数中，进而得到一个范围在 $0 \sim 1$ 的值。任何大于 0.5 的值被分为类 1，小于 0.5 的分为类 2</strong>。因此，Logistic回归可以看作是一种概率估计的方法。</p><p>确定了分类器的函数形式之后，现在的问题变成了：<strong>最佳回归系数（weight）是多少？如何确定它的大小？</strong></p><h1 id="基于最优化方法的最佳回归系数确定"><a href="#基于最优化方法的最佳回归系数确定" class="headerlink" title="基于最优化方法的最佳回归系数确定"></a>基于最优化方法的最佳回归系数确定</h1><p>Sigmoid 函数的输入记为 $z$，公式得出：$\Large  z &#x3D; w_0x_0 + w_1x_1 + w_2x_2 + … +w_nx_n$ 。</p><p>如果采用向量的写法<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，可以写成：$\Large z&#x3D;w^Tx$ 。其中向量 $x$ 是分类器的输入数据，向量 $w$ 就是我们要找的最佳系数，从而使分类器尽可能的精确。</p><p>下面介绍梯度上升这一最优化方法。</p><h2 id="梯度上升法"><a href="#梯度上升法" class="headerlink" title="梯度上升法"></a>梯度上升法</h2><p>我们介绍的第一个最优化算法叫梯度上升法。<strong>梯度上升法基于的思想是：要找到某函数的最大值，最好的方法是沿着该函数的梯度方向探寻</strong>。如果梯度记为 $\triangledown$ ，则函数 $f(x,y)$ 的梯度由下面的公式表示：</p><p>$\huge \triangledown f(x,y) &#x3D; \begin{pmatrix} \frac{\partial f(x,y)}{\partial x} \ \frac{\partial f(x,y)}{\partial y} \end{pmatrix}$ </p><p>这是机器学习中最容易混淆的地方，但在数学上并不难，需要做的是牢记这些符号的意义。这个梯度意味着要沿着 x 的方向移动 $\Large \frac{\partial f(x,y)}{\partial x}$ ，沿 y 的方向移动 $\Large \frac{\partial f(x,y)}{\partial y}$ 。其中，函数 $f(x,y)$ 必须要在待计算的点上有定义并且可微。</p><blockquote><p>这里提到的梯度上升，及其公式，如果你足够熟悉的话，会发现它是高等数学中的偏导，另外如果你感兴趣可以查看在《智能之门》一书中开篇有提到人工智能算法的基础，<strong>梯度下降，反向传播，损失函数</strong>，三者联合可以多次迭代求解最大值&#x2F;最小值，当然有些笼统，因为可能会出现局部最大值或者局部最小值的问题。</p></blockquote><img src="https://img.helloseraphine.top:8089/blog/2023/07/21/64b96698f37ad.png" alt="image-20230721005339070" style="zoom: 67%;" /><p>如上图，梯度上升算法沿着梯度方向移动过程（迭代过程）。可以看到梯度增长的方向总是指向函数值增长最快的方向。这里所说的是移动方向，而没提到移动量的大小。该量值称为步长，记作 $\alpha$ 。用向量来表示的话，梯度上升算法的迭代公式：$\huge w&#x3D; w + \alpha \triangledown_w f(w)$ 。</p><blockquote><p>梯度下降算法公式：$\huge w&#x3D; w - \alpha \triangledown_w f(w)$</p></blockquote><p>该公式将会一直被迭代进行，直到到达某个停止条件为止，比如迭代次数达到某个指定值或者算法达到某个可以允许的误差范围。</p><p>在了解了上面的内容后，现在来看看我们接下来要使用 Logistic 回归分类器的例子，数据可视化如下图所示，<a href="">具体数据 点我下载</a>。其中下图的数据为 <strong>testSet.txt</strong> 文件中。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/21/64b96c157a0ab.png" alt="image-20230721011706980" style="zoom:67%;" /><h2 id="训练算法：使用梯度上升找到最佳参数"><a href="#训练算法：使用梯度上升找到最佳参数" class="headerlink" title="训练算法：使用梯度上升找到最佳参数"></a>训练算法：使用梯度上升找到最佳参数</h2><p>上图中共有 100 个样本点，每个点包含两个数值型特征：$X_1$ 和 $X_2$ 。在此数据集上，我们将通过使用梯度上升法找到最佳回归系数，也就是拟合出 Logistic 回归模型的最佳参数。梯度上升法的伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每个回归系数初始化为1</span><br><span class="line">重复 R 次</span><br><span class="line">计算整个数据集的梯度</span><br><span class="line">使用 alpha × 梯度 更新回归系数的向量</span><br><span class="line">返回回归系数</span><br></pre></td></tr></table></figure><p>现在我们使用 PyCharm 创建名称为 logRegres.py 的文件，输入如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadDataSet</span>():</span><br><span class="line">    dataMat = []; labelMat = []</span><br><span class="line">    <span class="comment"># 获取文件指针</span></span><br><span class="line">    fr = <span class="built_in">open</span>(<span class="string">&#x27;testSet.txt&#x27;</span>)</span><br><span class="line">    <span class="comment"># 读取文件</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        <span class="comment"># 将数据按行读取拆分</span></span><br><span class="line">        lineArr = line.strip().split()</span><br><span class="line">        <span class="comment"># 初始化数据列表，最佳系数=1，特征1，特征2</span></span><br><span class="line">        dataMat.append([<span class="number">1.0</span>, <span class="built_in">float</span>(lineArr[<span class="number">0</span>]), <span class="built_in">float</span>(lineArr[<span class="number">1</span>])])</span><br><span class="line">        <span class="comment"># 初始化目标值列表</span></span><br><span class="line">        labelMat.append(<span class="built_in">int</span>(lineArr[<span class="number">2</span>]))</span><br><span class="line">    <span class="comment"># 返回处理好的数据和目标值列表</span></span><br><span class="line">    <span class="keyword">return</span> dataMat,labelMat</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sigmoid函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">inX</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1</span>+exp(-inX))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算最佳回归系数，传入基本数据和目标值列表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradAscent</span>(<span class="params">dataMatIn, classLabels</span>):</span><br><span class="line">    <span class="comment"># 将输入数据转换为矩阵</span></span><br><span class="line">    dataMatrix = mat(dataMatIn)</span><br><span class="line">    <span class="comment"># 将目标值矩阵转置为了后面的矩阵乘法</span></span><br><span class="line">    labelMat = mat(classLabels).transpose()</span><br><span class="line">    <span class="comment"># 获取输入数据的维度</span></span><br><span class="line">    m,n = shape(dataMatrix)</span><br><span class="line">    <span class="comment"># 步长</span></span><br><span class="line">    alpha = <span class="number">0.001</span></span><br><span class="line">    <span class="comment"># 循环次数/迭代次数</span></span><br><span class="line">    maxCycles = <span class="number">500</span></span><br><span class="line">    <span class="comment"># 回归系数初始化</span></span><br><span class="line">    weights = ones((n,<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 重复 maxCycles 次</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(maxCycles):</span><br><span class="line">        <span class="comment"># 执行 Sigmoid 函数</span></span><br><span class="line">        h = sigmoid(dataMatrix*weights)</span><br><span class="line">        <span class="comment"># 损失函数</span></span><br><span class="line">        error = (labelMat - h)</span><br><span class="line">        <span class="comment"># ⭐计算新的回归系数</span></span><br><span class="line">        weights = weights + alpha * dataMatrix.transpose()* error</span><br><span class="line">    <span class="comment"># 返回迭代完成的“最佳回归系数”</span></span><br><span class="line">    <span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure><p>其中，上述注释中 ⭐ 的地方运用的公式：$\large 新回归系数&#x3D;旧回归系数+学习率×输入数据转置矩阵×误差$ </p><p>这个公式你也许会一头雾水，你不是一个人，它是根据前面的数学公式进行相关运算推理出来的公式，此处暂时省略推导过程，因为我目前还没有精力去学习并写一个推导的过程。</p><p>现在我们来使用如下代码，来测试一下上述代码的实际效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dataArr,labelMat = loadDataSet()</span><br><span class="line"><span class="built_in">print</span>(gradAscent(dataArr,labelMat))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[[ <span class="number">4.12414349</span>]</span><br><span class="line"> [ <span class="number">0.48007329</span>]</span><br><span class="line"> [-<span class="number">0.6168482</span> ]]</span><br></pre></td></tr></table></figure><h2 id="分析数据：画出决策边界"><a href="#分析数据：画出决策边界" class="headerlink" title="分析数据：画出决策边界"></a>分析数据：画出决策边界</h2><p>上面的代码解出了最佳回归系数，它确定了不同类别数据之间的分割线。现在我们来将它可视化表达出来，在我们的 <strong>logRegres.py</strong> 文件中添加如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制决策边界</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plotBestFit</span>(<span class="params">weights</span>):</span><br><span class="line">    <span class="comment"># 导入绘图包</span></span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">    <span class="comment"># 读取数据</span></span><br><span class="line">    dataMat,labelMat=loadDataSet()</span><br><span class="line">    dataArr = array(dataMat)</span><br><span class="line">    n = shape(dataArr)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 类别1的 x,y</span></span><br><span class="line">    xcord1 = []; ycord1 = []</span><br><span class="line">    <span class="comment"># 类别2的x,y</span></span><br><span class="line">    xcord2 = []; ycord2 = []</span><br><span class="line">    <span class="comment"># 读取数据保存到对应的列表中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(labelMat[i])== <span class="number">1</span>:</span><br><span class="line">            xcord1.append(dataArr[i,<span class="number">1</span>]); ycord1.append(dataArr[i,<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            xcord2.append(dataArr[i,<span class="number">1</span>]); ycord2.append(dataArr[i,<span class="number">2</span>])</span><br><span class="line">    <span class="comment"># 创建一个绘图窗口</span></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    <span class="comment"># 设置图像样式</span></span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    <span class="comment"># 添加数据点</span></span><br><span class="line">    ax.scatter(xcord1, ycord1, s=<span class="number">30</span>, c=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">    ax.scatter(xcord2, ycord2, s=<span class="number">30</span>, c=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">    <span class="comment"># 生成一个范围从 -3到 3 的步长为 0.1 的列表</span></span><br><span class="line">    x = arange(-<span class="number">3.0</span>, <span class="number">3.0</span>, <span class="number">0.1</span>)</span><br><span class="line">    <span class="comment"># ⭐拟合曲线</span></span><br><span class="line">    y = (-weights[<span class="number">0</span>]-weights[<span class="number">1</span>]*x)/weights[<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 绘出线性“曲线”</span></span><br><span class="line">    ax.plot(x, y)</span><br><span class="line">    <span class="comment"># 设置坐标轴标签</span></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;X1&#x27;</span>); plt.ylabel(<span class="string">&#x27;X2&#x27;</span>);</span><br><span class="line">    <span class="comment"># 显示绘制的图像</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>对于上式中的 ⭐ 的地方，我知道你也一定好奇它是怎能来的，决策边界（拟合曲线）是如下的形式：$\Large z&#x3D;w_0+w_1 \times x_1+ w_2 \times x_2$ ，其中，$w_0$，$w_1$，$w_2$ 是回归系数，$z$ 是模型的预测结果。</p><p>为了绘制决策边界，我们希望找到在模型中使得 $z＝0$ 的点。当 $z＝0$ 时，表示这个点处于决策边界上。</p><p>为了找到 $z＝0$ 的点，我们将上面的方程改写为：$\Large 0&#x3D;w_0+w_1 \times x_1+w_2 \times x_2$ 。接着，我们将 $x_2$ 表达式解出：$\Large x_2 &#x3D; \frac {-(wo+w_ {1}\times x_ {1})}{w_ {2}} $ 。这就是公式 $\Large y &#x3D; \frac {-(wo+w_ {1}\times x_ {1})}{w_ {2}} $。</p><p>现在我们运行如下代码，来绘制图形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataArr,labelMat = loadDataSet()</span><br><span class="line">plotBestFit(stocGradAscent0(dataArr,labelMat).getA())</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/22/64bbf84f819cb.png" alt="image-20230722233954799" style="zoom:67%;" /><p>可以看到，分类结果只分错了 2-4 个点。尽管例子直观数据相对很小，但是却要进行大量的计算，接下来，我们将会对这个算法进行改进，从而使得它可以用在真实的数据集上。</p><h2 id="训练算法：随机梯度上升"><a href="#训练算法：随机梯度上升" class="headerlink" title="训练算法：随机梯度上升"></a>训练算法：随机梯度上升</h2><p>梯度上升算法在每次更新回归系数时都需要遍历整个数据集，该方法在处理 100 个左右的数据集的时候尚可，但是如果存在数十亿的样本或者千万种特征，那么这种方法的计算复杂度太高了。<strong>一种改进方法是一次仅用一个样本来更新回归系数，该方法称为 随机梯度上升算法（Stochastic Gradient Ascent）</strong>。由于可以在新样本到来时对分类器进行增量式更新，因而随机梯度上升算法是一个<strong>在线学习算法</strong>。与“在线学习”相对应，一次处理所有数据被称作是“批处理”。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机梯度上升算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stocGradAscent0</span>(<span class="params">dataMatrix, classLabels</span>):</span><br><span class="line">    m,n = shape(dataMatrix)</span><br><span class="line">    alpha = <span class="number">0.01</span></span><br><span class="line">    weights = ones(n)</span><br><span class="line">    <span class="comment"># 每次选取一个样本</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        h = sigmoid(<span class="built_in">sum</span>(dataMatrix[i]*weights))</span><br><span class="line">        error = classLabels[i] - h</span><br><span class="line">        weights = weights + alpha * error * dataMatrix[i]</span><br><span class="line">    <span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure><p>可以看到随机梯度上升算法与梯度上升算法在代码上很相似，但是也有一些区别。现在使用如下代码验证我们的算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataArr,labelMat = loadDataSet()</span><br><span class="line">plotBestFit(stocGradAscent0(array(dataArr),labelMat))</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/23/64bbff874cf90.png" alt="image-20230723000906845" style="zoom:67%;" /><p>可以看到，拟合出来的直线效果还不错，但是并不像之前迭代的那样完美，这里的分类器分错了三分之一的样本。</p><p>现在我们来改进随机梯度上升算法来更加拟合前面 500 次迭代的效果，代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改进随机梯度上升算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stocGradAscent1</span>(<span class="params">dataMatrix, classLabels, numIter=<span class="number">150</span></span>):</span><br><span class="line">    m,n = shape(dataMatrix)</span><br><span class="line">    weights = ones(n)</span><br><span class="line">    <span class="comment"># numIter表示迭代次数</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(numIter):</span><br><span class="line">        dataIndex = <span class="built_in">list</span>(<span class="built_in">range</span>(m))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="comment"># 在每次迭代中，引入动态学习率 alpha 的概念，它随着迭代次数 j 和样本索引 i 的变化而动态调整</span></span><br><span class="line">            <span class="comment"># alpha 的值随着迭代次数增加而逐渐减小，使得前期的更新步长较大，后期的更新步长较小，有助于算法更好地收敛到最优解</span></span><br><span class="line">            alpha = <span class="number">4</span>/(<span class="number">1.0</span>+j+i)+<span class="number">0.0001</span></span><br><span class="line">            <span class="comment"># 在每次迭代时，随机选择一个样本来更新回归系数，依次使用打乱后的样本</span></span><br><span class="line">            randIndex = dataIndex[i]</span><br><span class="line">            h = sigmoid(<span class="built_in">sum</span>(dataMatrix[randIndex]*weights))</span><br><span class="line">            error = classLabels[randIndex] - h</span><br><span class="line">            weights = weights + alpha * error * dataMatrix[randIndex]</span><br><span class="line">    <span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure><p>现在我们使用如下代码测试分类效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataArr,labelMat = loadDataSet()</span><br><span class="line">plotBestFit(stocGradAscent1(array(dataArr),labelMat))</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/23/64bc020d17a48.png" alt="image-20230723002129914" style="zoom:67%;" /><p>默认迭代次数是 150 次，可以看到拟合直线已经和之前 500 次迭代的效果差不多了，但是计算量更少。</p><h1 id="示例：从疝气病症预测病马的死亡率"><a href="#示例：从疝气病症预测病马的死亡率" class="headerlink" title="示例：从疝气病症预测病马的死亡率"></a>示例：从疝气病症预测病马的死亡率</h1><blockquote><p>示例所用的数据集<a href="https://wwam.lanzouj.com/b0136j4la">点我下载</a>；密码：fgi0</p></blockquote><p>疝气病是描述马肠胃痛的术语，然而这种病不一定源于马的肠胃问题，其他问题也可能引起马的疝气病。该数据集中包含了医院检测疝气病的一些指标。</p><p>另外，需要说明的是，该数据存在一个问题，数据集中有 30% 的值是缺失的。</p><h2 id="准备数据：处理数据中的缺失值"><a href="#准备数据：处理数据中的缺失值" class="headerlink" title="准备数据：处理数据中的缺失值"></a>准备数据：处理数据中的缺失值</h2><p><strong>数据中的缺失值是个非常棘手的问题</strong>，有很多文献都致力于解决这个问题。假设有 100 个样本和 20 个特征，这些数据都是机器收集回来的，若机器上的某个传感器损坏导致一个特征无效时怎么办？是否要扔掉整个数据？另外 19 个特征怎么办？它们是否还可用？答案是肯定的。因为有时候数据很珍贵，扔掉和重新获取都是不可取的，所以必须要采用一些方法来解决这个问题。</p><p>下面给出了一些可选的做法：</p><ul><li>使用可用特征的均值来填补缺失值</li><li>使用特殊值来填补缺失值，例如 $-1$ </li><li>忽略有缺失值的样本</li><li>使用显示样本的均值来填补缺失值</li><li>使用另外的机器学习算法预测缺失值</li></ul><p>现在我们要对我们的数据集做一些预处理，我们需要用一个实数值来替换缺失值，因为我们使用的 NumPy 数据类型不允许包含缺失值，这里选择实数 0 来替换所有缺失值。</p><p>另外，如果在测试数据集的时候发现了一条数据的类别标签已经丢失，那么最简单的做法就是将该数据丢弃。类别标签不同于特征标签，它很难用某个合适的值替换。</p><p>现在我们有了一个“干净”的数据集和一个不错的算法，接下来训练一个分类器来解决病马的生死问题。</p><h2 id="测试算法：用-Logistic-回归进行分类"><a href="#测试算法：用-Logistic-回归进行分类" class="headerlink" title="测试算法：用 Logistic 回归进行分类"></a>测试算法：用 Logistic 回归进行分类</h2><blockquote><p>使用数据集的时候，请确保其文件在 Python 脚本同目录下。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">classifyVector</span>(<span class="params">inX, weights</span>):</span><br><span class="line">    prob = sigmoid(<span class="built_in">sum</span>(inX*weights))</span><br><span class="line">    <span class="keyword">if</span> prob &gt; <span class="number">0.5</span>: <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">colicTest</span>():</span><br><span class="line">    frTrain = <span class="built_in">open</span>(<span class="string">&#x27;horseColicTraining.txt&#x27;</span>); frTest = <span class="built_in">open</span>(<span class="string">&#x27;horseColicTest.txt&#x27;</span>)</span><br><span class="line">    trainingSet = []; trainingLabels = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> frTrain.readlines():</span><br><span class="line">        currLine = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        lineArr =[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>):</span><br><span class="line">            lineArr.append(<span class="built_in">float</span>(currLine[i]))</span><br><span class="line">        trainingSet.append(lineArr)</span><br><span class="line">        trainingLabels.append(<span class="built_in">float</span>(currLine[<span class="number">21</span>]))</span><br><span class="line">    trainWeights = stocGradAscent1(array(trainingSet), trainingLabels, <span class="number">1000</span>)</span><br><span class="line">    errorCount = <span class="number">0</span>; numTestVec = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> frTest.readlines():</span><br><span class="line">        numTestVec += <span class="number">1.0</span></span><br><span class="line">        currLine = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        lineArr =[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>):</span><br><span class="line">            lineArr.append(<span class="built_in">float</span>(currLine[i]))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(classifyVector(array(lineArr), trainWeights))!= <span class="built_in">int</span>(currLine[<span class="number">21</span>]):</span><br><span class="line">            errorCount += <span class="number">1</span></span><br><span class="line">    errorRate = (<span class="built_in">float</span>(errorCount)/numTestVec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该测试的错误率为: %f&quot;</span> % errorRate)</span><br><span class="line">    <span class="keyword">return</span> errorRate</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiTest</span>():</span><br><span class="line">    numTests = <span class="number">10</span>; errorSum=<span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(numTests):</span><br><span class="line">        errorSum += colicTest()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;经过 %d 次数的迭代后的平均错误率为: %f&quot;</span> % (numTests, errorSum/<span class="built_in">float</span>(numTests)))</span><br></pre></td></tr></table></figure><p>我们使用如下代码进行测试分类器效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiTest()</span><br></pre></td></tr></table></figure><p>运行后可能会报错 <code>RuntimeWarning: overflow encountered in exp</code> 。这说明在计算 Sigmoid 函数的时候遇到了数值溢出的问题。现在我们对 Sigmoid 函数做小小修改，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sigmoid函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">inX</span>):</span><br><span class="line">    <span class="comment"># 使用数值稳定性技巧，避免指数溢出</span></span><br><span class="line">    <span class="keyword">if</span> inX &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1</span> + exp(-inX))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> exp(inX) / (<span class="number">1</span> + exp(inX))</span><br></pre></td></tr></table></figure><p>现在再次测试，其输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出</span></span><br><span class="line">该测试的错误率为: <span class="number">0.328358</span></span><br><span class="line">该测试的错误率为: <span class="number">0.328358</span></span><br><span class="line">该测试的错误率为: <span class="number">0.328358</span></span><br><span class="line">该测试的错误率为: <span class="number">0.328358</span></span><br><span class="line">该测试的错误率为: <span class="number">0.328358</span></span><br><span class="line">该测试的错误率为: <span class="number">0.328358</span></span><br><span class="line">该测试的错误率为: <span class="number">0.328358</span></span><br><span class="line">该测试的错误率为: <span class="number">0.328358</span></span><br><span class="line">该测试的错误率为: <span class="number">0.328358</span></span><br><span class="line">该测试的错误率为: <span class="number">0.328358</span></span><br><span class="line">经过 <span class="number">10</span> 次数的迭代后的平均错误率为: <span class="number">0.328358</span></span><br></pre></td></tr></table></figure><p>可以看到 10 次迭代后的平均错误率在 35 左右，事实上在 30% 的缺失数据情况下这个训练结果并不差。当然，如果我们调整迭代次数和步长相关参数，平均错误率可以降到 20% 左右。</p><h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><h2 id="strip"><a href="#strip" class="headerlink" title="strip()"></a><code>strip()</code></h2><p><code>strip()</code> 是一个字符串方法，它通常用于<strong>移除字符串两端的空白字符</strong>（例如空格、制表符、换行符等）。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&quot;   Hello, World!   &quot;</span></span><br><span class="line">stripped_text = text.strip()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(stripped_text)  </span><br><span class="line"><span class="comment"># 输出: &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><h2 id="mat"><a href="#mat" class="headerlink" title="mat()"></a><code>mat()</code></h2><p><code>mat()</code> 不是内置函数，它是 NumPy 库中的函数，<code>numpy.mat()</code> 函数<strong>用于将输入数据转换为矩阵对象</strong>。它接受列表或字符串的输入，并返回一个NumPy矩阵。这个函数在处理线性代数和矩阵运算时特别有用。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个矩阵</span></span><br><span class="line">data = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">matrix = np.mat(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(matrix)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># [[1 2]</span></span><br><span class="line"><span class="comment">#  [3 4]]</span></span><br></pre></td></tr></table></figure><h2 id="transpose"><a href="#transpose" class="headerlink" title="transpose()"></a><code>transpose()</code></h2><p>在NumPy库中，可以使用 <code>numpy.transpose()</code> 函数<strong>来进行矩阵的转置操作</strong>。<code>transpose()</code> 函数将矩阵的行和列进行交换，返回转置后的新矩阵。</p><blockquote><p>不了解什么是转置的请查看线性代数，矩阵的转置</p></blockquote><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>学不动，真的学不动，我感觉要先把《智能之门》中的反向传播，梯度下降，损失函数先写出来。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/23/64bc099762adf.png" alt="image-20230723005339614" style="zoom: 33%;" /><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">线性代数的乘法运算，不了解的可以查看 <a href="https://jingyan.baidu.com/article/4ae03de3d2b8c13eff9e6b1e.html">线性代数：矩阵运算之乘法？</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 逻辑回归 </tag>
            
            <tag> 梯度上升 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【4.0】基于概率论的分类方法：朴素贝叶斯</title>
      <link href="/2023/07/15/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%904-0%E3%80%91%E5%9F%BA%E4%BA%8E%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
      <url>/2023/07/15/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%904-0%E3%80%91%E5%9F%BA%E4%BA%8E%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面的算法我们要求分类器对于“该数据属于哪一个分类”这类问题做出明确回答。不过，分类器有时会产生错误结果，这时<strong>可以要求分类器给出一个最优的类别猜测结果，同时给出这个猜测的概率估计值</strong>。</p><p>概率论是许多机器学习算法的基础，所以深刻理解这一主题就显得十分重要。</p><h1 id="基于贝叶斯决策理论的分类方法"><a href="#基于贝叶斯决策理论的分类方法" class="headerlink" title="基于贝叶斯决策理论的分类方法"></a>基于贝叶斯决策理论的分类方法</h1><p>朴素贝叶斯</p><ul><li>优点：在数据较少的情况下依然有效，可以处理多类别问题</li><li>缺点：对于输入数据的准备方式较为敏感</li><li>适用数据类型：<strong>标称型数据</strong>。</li></ul><p>朴素贝叶斯是贝叶斯决策论的一部分，所以在讲述朴素贝叶斯之前有必要快速了解一下贝叶斯决策理论。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/14/64b16ec169357.png" alt="image-20230714235024816" style="zoom:67%;" /><p>假设有人找到了描述图中两类数据的统计参数<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。现在我们使用 $P_1(x,y)$ 表示数据。点 $(x,y)$ 属于类别 1 （图中用圆形表示的类别）的概率，用 $P_2(x,y)$ 表示数据点 $(x,y)$ 属于类别 2 （图中用菱形表示的类别）的概率。那么对于一个新的数据点 $(x,y)$ ，可以使用下面的规则来判断它的类别：</p><ul><li>如果 $\large P_1(x,y) &gt; P_2(x,y)$ ，那么类别为 1</li><li>如果 $\large P_2(x,y) &gt; P_1(x,y)$ ，那么类别为 2</li></ul><p>也就是说，我们<strong>会选择高概率对应的类型</strong>。这就是贝叶斯<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>决策理论的核心思想，即选择具有高概率的决策。</p><p>接下来，我们必须要讲述 $P_1$ 及其概率的计算方法了。为了能够计算 $P_1$ 和 $P_2$ ，有必要讨论一下条件概率。</p><h1 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h1><p>接下来，我们花点时间来讲述概率和条件概率。如果你对于 $P(x,y|c_1)$ 符号很熟悉，就可以跳过这个部分。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/14/64b16d6bd424c.png" alt="image-20230714234433771" style="zoom:80%;" /><p>如上图所示，现在我们盒子里有 7 个球，我们根据初中的知识就可以很清楚的得到，取出黑色球的概率是：$\large \frac{3}{7}$  （其概率值可以通过黑色球的数目除以总数来得到）。同样的，对于下面的情况我们也可以快速的计算出“ B 桶摸出出黑球的概率”。不难得到：$\large P_A &#x3D; \frac{2}{4}$ ，$\large P_B &#x3D; \frac{1}{3}$ 。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/14/64b16dd2175a9.png" alt="image-20230714234624133" style="zoom:80%;" /><p>我们可以通过条件概率公式得到如上结果：$\large P(黑球|B桶) &#x3D; \frac{P(黑球 且 B桶)}{P(B桶)}$  ，不难得到 $\large P(黑球 且 B桶) &#x3D; \frac{1}{7}$ ，$\large P(B桶)&#x3D;\frac{3}{7}$，从而得到 $\large P(黑球|B桶)&#x3D;\frac{1}{3}$。虽然这个公式对于这个简单的例子来说有些“多此一举”，但是当存在更多特征的时候它会非常有效。</p><p>另一种有效计算条件概率的方法称为<strong>贝叶斯准则</strong>（贝叶斯公式），贝叶斯准则告诉我们如何交互条件概率中的条件与结果（某种程度上来说，贝叶斯公式是根据结果来计算某个条件发生的概率），即如果已知 $\large P(x|c)$ 要求 $\large P(c|x)$ ，那么就可以使用这个计算方法：$\large P(c|x) &#x3D; \frac{P(x|c)P(c)}{P(x)}$ 。</p><blockquote><p>如果你对此还是感到疑惑，不需要烦恼，因为它确实挺绕的，可以参考 <a href="https://www.bilibili.com/video/BV1NA411h7iy/">使用贝叶斯公式的正确姿势</a> 和 <a href="https://www.bilibili.com/video/BV1a4411B7B4/">「一个模型」教你搞定贝叶斯和全概率公式</a> 就可以大大帮助你来理解，另外一个有趣的三门问题，如果你感兴趣的话，也可以查看<a href="https://www.bilibili.com/video/BV1Tf4y167H8/">【三门问题】条件概率｜贝叶斯统计｜manim动画</a> （我记得我在学习《智慧之门》这本书的时候，它的第一个抛砖引玉的问题就是这个，非常有趣）</p></blockquote><p>接下来我们来讨论如何结合贝叶斯决策理论使用条件概率，如果将其应用到分类器中。</p><h1 id="使用条件概率来分类"><a href="#使用条件概率来分类" class="headerlink" title="使用条件概率来分类"></a>使用条件概率来分类</h1><p>前面我们提到贝叶斯决策理论要求计算两个概率 $P_1(x,y)$ 和 $P_2(x,y)$ ：</p><ul><li>如果 $\large P_1(x,y) &gt; P_2(x,y)$ ，那么类别为 1</li><li>如果 $\large P_2(x,y) &gt; P_1(x,y)$ ，那么类别为 2</li></ul><p>但是这两个准则并不是贝叶斯决策理论的所有内容。使用 $P_1()$ 和 $P_2()$ 只是为了尽可能简化描述，而真正需要计算和比较的是 $P(c_1 | x,y)$ 和 $P(c_2 |x,y)$ 。这些符号所代表的具体意义是：<strong>给定某个由 x , y 表示的数据点，那么该数据点来自类别 $c_1$ 的概率是多少？数据点来自 $c_2$ 的概率又是多少？</strong>注意，这些概率和之前给出的概率 $p(x,y|c_1)$ 并不一样，不过<strong>可以使用贝叶斯准则（贝叶斯公式）来交互概率中的条件与结果。</strong>具体的来说：$\large P(c_i|x,y) &#x3D; \frac{P(x,y|c_i)P(c_i)}{P(x,y)}$ 。</p><p>使用这些定义，可以定义贝叶斯分类准则为：</p><ul><li>如果 $\large P(c_1|x,y) &gt; P(c_2|x,y)$ ，那么就属于类别 $\large c_1$ </li><li>如果 $\large P(c_1|x,y) &lt; P(c_2|x,y)$ ，那么就属于类别 $\large c_2$</li></ul><p><strong>使用贝叶斯准则（公式），可以通过已知的三个概率值来计算未知的概率值</strong>。后面就会给出利用贝叶斯准则来计算概率并对数据进行分类的代码。</p><h1 id="使用朴素贝叶斯进行文档分类"><a href="#使用朴素贝叶斯进行文档分类" class="headerlink" title="使用朴素贝叶斯进行文档分类"></a>使用朴素贝叶斯进行文档分类</h1><p>机器学习的一个重要应用就是文档的自动分类。在文档分类中，整个文档是实例，而文档中的某些元素则构成特征。我们可以观察文档中出现的词，并把每个词的出现或者不出现作为一个特征，这样的得到的特征数目就会跟词汇表中的词语一样多。<strong>朴素贝叶斯是贝叶斯分类器的一个拓展，是用于文档分类的常用算法</strong>。</p><p>使用每个词作为特征并观察它们是否出现，这样得到的特征数目有多少呢？就英语而言，据估计，英文的单词总数就有超过 500000 个。为了能够进行英文阅读，估计需要掌握数千个单词。</p><p>假设词汇表有 1000 个单词。要得到好的概率分布，就需要足够的数据样本，假定样本数为 N 。<strong>由统计学可知，如果每个特征需要 N 个样本，那么对于 10 个特征将需要 $N^{10}$ 个样本</strong>，对于包含 1000 个特征的词汇表将需要 $N^1000$ 个样本<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。可以看到，所需要的样本数量会随着特征数目的增大而迅速增大。</p><p>如果特征之间相互独立，那么样本数就可以从 $N^{1000}$ 减少到 $N \times 1000$ 。所谓<strong>独立，指的是统计意义上的独立，即一个特征或者单词出现的可能性与它和其他单词相邻没有关系</strong>。举例子来讲，假设单词  bacon<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> 出现在 unhealthy 后面与出现在 delicious 后面的概率相同。当然，我们知道这种假设并不正确，bacon 经常出现在 delicious 附件，而很少出现在 unhealthy 附件，这个假设正是朴素贝叶斯分类器中<strong>朴素</strong>一词的含义。<strong>朴素贝叶斯分类器中的另一个假设是，每个特征同等重要</strong><sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>。其实这个假设也有问题。如果要判断留言板的留言是否得当，那么可能不需要看完所有的 1000 个单词，只需要看 10-20 个特征就足以做出判断了。尽管上述假设有一些小瑕疵，但朴素贝叶斯的实际效果却很好。</p><p>到目前为止，你已经了解足够多的知识，可以开始编写代码了。如果还不清楚，那么了解代码的实际效果也会有助于你的理解。</p><h1 id="使用-Python-进行文本分类"><a href="#使用-Python-进行文本分类" class="headerlink" title="使用 Python 进行文本分类"></a>使用 Python 进行文本分类</h1><p>要从文本中获取特征，需要先拆分文本。具体如何做呢？这里的<strong>特征是来自文本的词条（token</strong>），一个词条是字符的任意组合。可以把词条想象为单词，也可以使用非单词词条，例如 URL，IP地址或者任意其他字符串。然后<strong>将每一个文本片段表示为一个词条向量</strong>，其中值为 1 表示词条出现在文档中，0 表示词条未出现。</p><p>以在线社区的留言板为例。为了不影响社区的发展，我们要屏蔽侮辱性言论，所以要构建一个快速过滤器，如果某条留言使用了负面或者侮辱性的言语，那么就将该留言表示为内容不当。过滤这类内容是一个很常见的需求。<strong>对此问题建立两个类别：侮辱类和非侮辱类，使用 1 和 0 分别表示</strong>。</p><h2 id="准备数据：从文本中构建词向量"><a href="#准备数据：从文本中构建词向量" class="headerlink" title="准备数据：从文本中构建词向量"></a>准备数据：从文本中构建词向量</h2><p>我们将文本看成单词向量或者词条向量，也就是说将句子转换为向量。考虑出现在所有文档中的所有单词，再决定将哪些词汇或者说所要的词汇集合，然后必须要将每一篇文档转换为词汇表上的向量。现在我们打开编辑器，创建一个 <code>bayes.py</code> 的文件，写入下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载数据，返回词条向量和对应的类别</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadDataSet</span>():</span><br><span class="line">    postingList = [[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;has&#x27;</span>, <span class="string">&#x27;flea&#x27;</span>, <span class="string">&#x27;problems&#x27;</span>, <span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;please&#x27;</span>],</span><br><span class="line">                   [<span class="string">&#x27;maybe&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;take&#x27;</span>, <span class="string">&#x27;him&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;park&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>],</span><br><span class="line">                   [<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;so&#x27;</span>, <span class="string">&#x27;cute&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;him&#x27;</span>],</span><br><span class="line">                   [<span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;posting&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;worthless&#x27;</span>, <span class="string">&#x27;garbage&#x27;</span>],</span><br><span class="line">                   [<span class="string">&#x27;mr&#x27;</span>, <span class="string">&#x27;licks&#x27;</span>, <span class="string">&#x27;ate&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;steak&#x27;</span>, <span class="string">&#x27;how&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;him&#x27;</span>],</span><br><span class="line">                   [<span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;buying&#x27;</span>, <span class="string">&#x27;worthless&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>]]</span><br><span class="line">    <span class="comment"># 1表示有侮辱性，0表示没有侮辱性</span></span><br><span class="line">    classVec = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> postingList, classVec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回词条向量唯一值集合</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createVocabList</span>(<span class="params">dataSet</span>):</span><br><span class="line">    <span class="comment"># 创建空变量</span></span><br><span class="line">    vocabSet = <span class="built_in">set</span>([])</span><br><span class="line">    <span class="comment"># 遍历数据集</span></span><br><span class="line">    <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="comment"># 将数据集中的词条向量合并成不重复的数据集</span></span><br><span class="line">        vocabSet = vocabSet | <span class="built_in">set</span>(document)</span><br><span class="line">    <span class="comment"># 返回该具有唯一性的数据集</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(vocabSet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入文档和词汇表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setOfWords2Vec</span>(<span class="params">vocabList, inputSet</span>):</span><br><span class="line">    <span class="comment"># 创建一个和唯一值集合相同大小的列表，初始化为 0</span></span><br><span class="line">    returnVec = [<span class="number">0</span>] * <span class="built_in">len</span>(vocabList)</span><br><span class="line">    <span class="comment"># 遍历词汇表中每个单词</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">        <span class="comment"># 如果单词在唯一值集合（文档）中</span></span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">            <span class="comment"># 就让这个返回值列表对应的位置值=1，1表示出现了该单词</span></span><br><span class="line">            returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 否则就输出文档中并不存在词汇表的词语</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;the word: %s is not in my Vocabulary!&quot;</span> % word)</span><br><span class="line">    <span class="comment"># 返回向量化后的列表</span></span><br><span class="line">    <span class="keyword">return</span> returnVec</span><br></pre></td></tr></table></figure><p>第一个函数<code>loadDataSet()</code>负责返回文档及其特征标签（人工标注），即这些文本是不是有侮辱性的，具有侮辱性的用 1 表示。其中这个文档来自斑点犬爱好者的留言板中。这些信息是用来训练程序以自动检测侮辱性留言。其中那些留言的翻译如下所示：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;我的狗有跳蚤问题，请帮忙。&quot;,</span><br><span class="line">&quot;也许不要带他去狗公园，太傻了。&quot;,</span><br><span class="line">&quot;我的大麦犬太可爱了，我爱他。&quot;,</span><br><span class="line">&quot;停止发布愚蠢、毫无价值的垃圾。&quot;,</span><br><span class="line">&quot;莱克斯先生吃了我的牛排，怎么阻止他。&quot;,</span><br><span class="line">&quot;不要再买毫无价值的狗粮，太傻了。&quot;</span><br></pre></td></tr></table></figure><p>第二个函数<code>createVocabList()</code>将文档的“词”，唯一化处理，并返回唯一化数据集。需要注意的是，<code>set()</code>唯一化数据集的时候是无序的。</p><p>第三个函数<code>createVocabList()</code>负责将对应文档和我们的词汇表做比较，然后生成一份文档的“量化”表，用 1 表示文档中某个词是词汇表中的，用 0 表示该词没有出现在词汇表中。</p><p>现在我们运行如下代码，进行测试一下，看看运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">listPosts,listClass = loadDataSet()</span><br><span class="line"><span class="comment"># 唯一化数据</span></span><br><span class="line">tempUn = createVocabList(listPosts)</span><br><span class="line"><span class="comment"># 词汇表测试</span></span><br><span class="line"><span class="built_in">print</span>(setOfWords2Vec(tempUn,listPosts[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><p>运行结果：<code>[0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0]</code>。</p><p>这个由文档转换为 <code>0,1</code>被称为词向量（是对于文档中词语的一种量化）。</p><h2 id="训练算法：从词向量计算概率"><a href="#训练算法：从词向量计算概率" class="headerlink" title="训练算法：从词向量计算概率"></a>训练算法：从词向量计算概率</h2><p>前面介绍了如何将一组单词转换为一组数字（量化），接下来看看如何使用这些数字计算概率。现在已经知道一个词是否出现在一篇文档中，也知道该文档所属的类别。还记得前面提到的贝叶斯准则吗？我们现在重写贝叶斯准则，将之前的 $x,y$ 替换为 $\large \textcolor{blue}{\omega}$ ，蓝色 $\large \textcolor{blue}{\omega}$ 表示这是一个向量，即它是由多个数值组成。在这个例子中，数值个数与词汇表中词的个数相同。</p><p>$\Large P(c_i|\textcolor{blue}{\omega}) &#x3D; \frac{P(\textcolor{blue}{\omega}|c_i)P(c_i)}{P(\textcolor{blue}{\omega})}$ </p><p>我们将使用上述公式，<strong>对每个类别计算该值，然后比较这两个概率值的大小</strong>。如何计算呢？首先可以通过类别 $i$ （侮辱性或者非侮辱性留言）中的词数除以总的词数来计算概率 $P(c_i)$ 。接下来计算 $P(\textcolor{blue}{\omega}|C_i)$ ，这里就要用到朴素贝叶斯假设。如果 $\textcolor{blue}{\omega}$ 展开为一个个独立特征，那么就可以将上述概率写作 $P(\textcolor{blue}{\omega_1}, \textcolor{blue}{\omega_2},\textcolor{blue}{\omega_3}…|C_i)$ 。这里假设所有词都相互独立，它就<strong>意味着可以使用 $p(\textcolor{blue}{\omega_0}|c_i)p(\textcolor{blue}{\omega_1}|c_i)p(\textcolor{blue}{\omega_2}|c_i)…$ 来计算上述概率</strong>，这就极大的简化了计算的过程。</p><blockquote><p>什么？看不懂？没关系，可以参考一下这个视频有助于理解 <a href="https://www.bilibili.com/video/BV1eT411V7jM/">[5分钟学算法] #02 朴素贝叶斯 写作业还得看小明</a> 或者 <a href="https://www.bilibili.com/video/BV18s4y1m74s/">【机器学习】动画讲解贝叶斯分类器</a> ，虽然后者是盗的 Youtube 上博主的视频，还不知廉耻的打上水印盖住，但是学习的角度，可以参考，行为就算了</p></blockquote><p>现在我们来用代码实现上述过程，将下面的代码，添加到之前创建的 <code>bayes.py</code> 文件中，请确保在此之前，将 <code>from numpy import *</code> 写在了文件的开头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trainNB0</span>(<span class="params">trainMatrix,trainCategory</span>):</span><br><span class="line">    <span class="comment"># 词总数</span></span><br><span class="line">    numTrainDocs = <span class="built_in">len</span>(trainMatrix)</span><br><span class="line">    <span class="comment"># 拿到文档第一行</span></span><br><span class="line">    numWords = <span class="built_in">len</span>(trainMatrix[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 计算某个类别的概率</span></span><br><span class="line">    pAbusive = <span class="built_in">sum</span>(trainCategory)/<span class="built_in">float</span>(numTrainDocs)</span><br><span class="line">    <span class="comment"># 用来记录分类 0 的每个词总数</span></span><br><span class="line">    p0Num = zeros(numWords)</span><br><span class="line">    <span class="comment"># 用来记录分类 1 的每个词词总数</span></span><br><span class="line">    p1Num = zeros(numWords)</span><br><span class="line">    <span class="comment"># 用来记录分类 0 的词汇总数</span></span><br><span class="line">    p0Denom = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 用来记录分类 1 的词汇总数</span></span><br><span class="line">    p1Denom = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 遍历所有文档</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numTrainDocs):</span><br><span class="line">        <span class="comment"># 判断是侮辱性类别吗</span></span><br><span class="line">        <span class="keyword">if</span> trainCategory[i] == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 记录每个词的次数</span></span><br><span class="line">            p1Num += trainMatrix[i]</span><br><span class="line">            <span class="comment"># 记录统计总数</span></span><br><span class="line">            p1Denom += <span class="built_in">sum</span>(trainMatrix[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 记录每个词的次数</span></span><br><span class="line">            p0Num += trainMatrix[i]</span><br><span class="line">            <span class="comment"># 记录统计总数</span></span><br><span class="line">            p0Denom += <span class="built_in">sum</span>(trainMatrix[i])</span><br><span class="line">    <span class="comment"># 计算类别 1 的条件概率</span></span><br><span class="line">    p1Vect = p1Num/p1Denom</span><br><span class="line">    <span class="comment"># 计算类别 0 的条件概率</span></span><br><span class="line">    p0Vect = p0Num/p0Denom</span><br><span class="line">    <span class="keyword">return</span> p0Vect,p1Vect,pAbusive</span><br></pre></td></tr></table></figure><p>因为这是一个二分类问题，可以通过 $1-P(1)$ 得到 $P(0)$ 。对于多分类问题，代码则需要稍加修改。现在我们使用如下代码，来测试上述代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">listPosts,listClass = loadDataSet()</span><br><span class="line"><span class="comment"># 唯一化数据</span></span><br><span class="line">myVocabList = createVocabList(listPosts)</span><br><span class="line">trainMat=[]</span><br><span class="line"><span class="keyword">for</span> postinDoc <span class="keyword">in</span> listPosts:</span><br><span class="line">    trainMat.append(setOfWords2Vec(myVocabList,postinDoc))</span><br><span class="line"><span class="built_in">print</span>(trainNB0(trainMat,listClass))</span><br></pre></td></tr></table></figure><p>其输出结果如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(array([<span class="number">0.04166667</span>, <span class="number">0.04166667</span>, <span class="number">0.04166667</span>, <span class="number">0.04166667</span>, <span class="number">0.</span>        ,</span><br><span class="line">       <span class="number">0.04166667</span>, <span class="number">0.04166667</span>, <span class="number">0.04166667</span>, <span class="number">0.</span>        , <span class="number">0.08333333</span>,</span><br><span class="line">       <span class="number">0.04166667</span>, <span class="number">0.04166667</span>, <span class="number">0.04166667</span>, <span class="number">0.</span>        , <span class="number">0.04166667</span>,</span><br><span class="line">       <span class="number">0.04166667</span>, <span class="number">0.04166667</span>, <span class="number">0.</span>        , <span class="number">0.</span>        , <span class="number">0.04166667</span>,</span><br><span class="line">       <span class="number">0.04166667</span>, <span class="number">0.</span>        , <span class="number">0.04166667</span>, <span class="number">0.</span>        , <span class="number">0.125</span>     ,</span><br><span class="line">       <span class="number">0.</span>        , <span class="number">0.</span>        , <span class="number">0.04166667</span>, <span class="number">0.04166667</span>, <span class="number">0.</span>        ,</span><br><span class="line">       <span class="number">0.04166667</span>, <span class="number">0.</span>        ]), array([<span class="number">0.</span>        , <span class="number">0.10526316</span>, <span class="number">0.</span>        , <span class="number">0.</span>        , <span class="number">0.10526316</span>,</span><br><span class="line">       <span class="number">0.</span>        , <span class="number">0.05263158</span>, <span class="number">0.</span>        , <span class="number">0.15789474</span>, <span class="number">0.05263158</span>,</span><br><span class="line">       <span class="number">0.</span>        , <span class="number">0.</span>        , <span class="number">0.</span>        , <span class="number">0.05263158</span>, <span class="number">0.</span>        ,</span><br><span class="line">       <span class="number">0.</span>        , <span class="number">0.05263158</span>, <span class="number">0.05263158</span>, <span class="number">0.05263158</span>, <span class="number">0.</span>        ,</span><br><span class="line">       <span class="number">0.</span>        , <span class="number">0.05263158</span>, <span class="number">0.</span>        , <span class="number">0.05263158</span>, <span class="number">0.</span>        ,</span><br><span class="line">       <span class="number">0.05263158</span>, <span class="number">0.05263158</span>, <span class="number">0.</span>        , <span class="number">0.</span>        , <span class="number">0.05263158</span>,</span><br><span class="line">       <span class="number">0.</span>        , <span class="number">0.05263158</span>]), <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>可以以看到，语句属于侮辱类的概率是 $0.5$ ，该值是正确的。解析下来看看个别词汇的概率，例如：$0.15789474$ 的下标对应的 <code>myVocabList</code> 位置的词语是 <code>&#39;stupid&#39;</code> ，这意味着 <code>&#39;stupid&#39;</code> 是最能代表类别 1（侮辱性）的词汇。</p><p>在使用该函数进行分类之前，我们还需要解决函数中的一些缺陷。</p><h2 id="测试算法：根据现实情况修改分类器"><a href="#测试算法：根据现实情况修改分类器" class="headerlink" title="测试算法：根据现实情况修改分类器"></a>测试算法：根据现实情况修改分类器</h2><p>利用贝叶斯分类器对文档进行分类时，要计算多个概率的乘积以获得文档属于某个类别的概率，即计算 $p(\textcolor{blue}{\omega_0}|c_i)p(\textcolor{blue}{\omega_1}|c_i)p(\textcolor{blue}{\omega_2}|c_i)…$ 。如果其中一个的概率值为 0，那么最后的乘积也为 0。为降低这种影响，可以将所有单词的出现数初始化为 1，并将分母初始化为 2。</p><blockquote><p>其中 “将所有单词的出现数初始化为 1，并将分母初始化为 2” 这个操作被称为 **拉普拉斯平滑<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>**。</p><p>在拉普拉斯平滑中，我们<strong>将所有特征的出现数初始化为1</strong>，这样即使某个特征在训练数据中没有出现，它的概率也不会变为零。同时，<strong>为了保持概率的总和为1，我们将分母初始化为特征总数加上特征的可能取值个数</strong>。</p></blockquote><p>现在将我们的代码，其中的相关部分修改为如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉普拉斯平滑处理</span></span><br><span class="line">p0Num = ones(numWords)</span><br><span class="line">p1Num = ones(numWords)</span><br><span class="line">p0Denom = <span class="number">2.0</span></span><br><span class="line">p1Denom = <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>另一个遇到的问题就是<strong>下溢出</strong>，这是由于太多太小的数相乘造成的。当计算 $p(\textcolor{blue}{\omega_0}|c_i)p(\textcolor{blue}{\omega_1}|c_i)p(\textcolor{blue}{\omega_2}|c_i)…$ 时，由于大部分因子都非常小，所以程序会下溢出或者得到不正确的答案。</p><p><strong>一种解决办法是对乘积取自然对数</strong>。在代数中有 $\large \ln{(ab)} &#x3D; \ln{a} + \ln{b}$ ，于是通过求对数可以避免下溢出的问题。同时采用自然对数进行处理不会有任何损失。如下图所示，将原函数用 $log$ 处理后，它们的极值点是一致的，且增加或者减少的区域是相同的。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/15/64b29388bb2e2.png" alt="image-20230715203924182" style="zoom:50%;" /><blockquote><p><strong>对数可以将乘法问题转换为加法问题</strong>，这样可以避免非常小的概率相乘导致的下溢出问题。如果并不了解我说的什么意思，可以查看这个视频 <a href="https://www.bilibili.com/video/BV1b8411373c/">对数运算到底方便在哪里？</a> </p></blockquote><p>现在我们修改原来 <code>bayes.py</code> 文件中的代码为如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算类别 1 的条件概率</span></span><br><span class="line">p1Vect = log(p1Num/p1Denom)</span><br><span class="line"><span class="comment"># 计算类别 0 的条件概率</span></span><br><span class="line">p0Vect = log(p0Num/p0Denom)</span><br></pre></td></tr></table></figure><p>现在已经准备好构建完整分类器了，继续向 <code>bayes.py</code> 文件中添加如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># classifyNB 的英文全称是 &quot;Naive Bayes Classifier&quot;「朴素贝叶斯分类器」。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classifyNB</span>(<span class="params">vec2Classify, p0Vec, p1Vec, pClass1</span>):</span><br><span class="line">    <span class="comment"># 我不理解他为什么要加起来，虽然是log(ab)=log(a)+log(b)，但是前面点积说不通</span></span><br><span class="line">    p1 = <span class="built_in">sum</span>(vec2Classify * p1Vec) + log(pClass1)</span><br><span class="line">    p0 = <span class="built_in">sum</span>(vec2Classify * p0Vec) + log(<span class="number">1.0</span> - pClass1)</span><br><span class="line">    <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试分类器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testingNB</span>():</span><br><span class="line">    <span class="comment"># 准备数据</span></span><br><span class="line">    listOPosts,listClasses = loadDataSet()</span><br><span class="line">    myVocabList = createVocabList(listOPosts)</span><br><span class="line">    trainMat=[]</span><br><span class="line">    <span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:</span><br><span class="line">        trainMat.append(setOfWords2Vec(myVocabList, postinDoc))</span><br><span class="line">    p0V,p1V,pAb = trainNB0(array(trainMat),array(listClasses))</span><br><span class="line">    testEntry = [<span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>]</span><br><span class="line">    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</span><br><span class="line">    <span class="built_in">print</span>(testEntry,<span class="string">&#x27;类别是: &#x27;</span>,classifyNB(thisDoc,p0V,p1V,pAb))</span><br><span class="line">    testEntry = [<span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;garbage&#x27;</span>]</span><br><span class="line">    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</span><br><span class="line">    <span class="built_in">print</span>(testEntry,<span class="string">&#x27;类别是 &#x27;</span>,classifyNB(thisDoc,p0V,p1V,pAb))</span><br></pre></td></tr></table></figure><p>运行测试分类器<code>tesingNB()</code>后，其结果如下所示：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;love&#x27;, &#x27;my&#x27;, &#x27;dalmation&#x27;] 类别是:  0</span><br><span class="line">[&#x27;stupid&#x27;, &#x27;garbage&#x27;] 类别是  1</span><br></pre></td></tr></table></figure><p>这个例子展示了朴素贝叶斯分类器的工作原理，接下来，对代码做些修改，使分类器工作更好。</p><h2 id="准备数据：文档词袋模型"><a href="#准备数据：文档词袋模型" class="headerlink" title="准备数据：文档词袋模型"></a>准备数据：文档词袋模型</h2><p>目前为止，我们<strong>将一个词是否出现作为特征，这可以描述为词集模型（set of words model）</strong>。**如果一个词在文档中不止出现一次，我们需要多次记录被称为词袋模型(bag of words model)**。为了适应词袋模型，需要对<code>setOfWords2Vec()</code>函数做一些修改，新修改的函数称为<code>bagOfWords2VecMN()</code>。</p><p>下面的代码给出了基于词袋模型的朴素贝叶斯代码，它与<code>setOfWords2Vec()</code>函数几乎完全相同，唯一不同的是每当遇到一个单词时，它会增加词向量中的对应值，而不是只将对应的数值设为 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 词袋模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bagOfWords2VecMN</span>(<span class="params">vocabList, inputSet</span>):</span><br><span class="line">    <span class="comment"># 创建同等长度初始化为 0 的列表</span></span><br><span class="line">    returnVec = [<span class="number">0</span>]*<span class="built_in">len</span>(vocabList)</span><br><span class="line">    <span class="comment"># 遍历记录出现次数</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">            returnVec[vocabList.index(word)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> returnVec</span><br></pre></td></tr></table></figure><p>现在分类器已经构建好了，我们接下来利用这个分类器来过滤垃圾邮件。</p><h1 id="使用朴素贝叶斯过滤垃圾邮件"><a href="#使用朴素贝叶斯过滤垃圾邮件" class="headerlink" title="使用朴素贝叶斯过滤垃圾邮件"></a>使用朴素贝叶斯过滤垃圾邮件</h1><h2 id="准备数据：切分文本"><a href="#准备数据：切分文本" class="headerlink" title="准备数据：切分文本"></a>准备数据：切分文本</h2><p>前面介绍了如何创建词向量，并基于这些词向量进行朴素贝叶斯分类的过程。前面的部分词向量是预先给定的，下面介绍如何从文本文档中构建自己的词列表。</p><p>对于一个文本字符串，可以使用 Python 的 <code>string.split()</code> 方法将其切分。下面是运行效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="string">&quot;This book , is the best book&quot;</span></span><br><span class="line"><span class="built_in">print</span>(txt.split())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="string">&#x27;This&#x27;</span>, <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;best&#x27;</span>, <span class="string">&#x27;book&#x27;</span>]</span><br></pre></td></tr></table></figure><p>可以看到，切分的结果不错，但是标点符号也被当成了词的一部分。可以使用正则表达式来切分句子，其中分隔符是除单词，数字外的任意字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">txt = <span class="string">&quot;This book , is the best book&quot;</span></span><br><span class="line">regEx = re.<span class="built_in">compile</span>(<span class="string">&#x27;\\W+&#x27;</span>)</span><br><span class="line">listTokens = regEx.split(txt)</span><br><span class="line"><span class="built_in">print</span>(listTokens)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;This&#x27;</span>, <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;best&#x27;</span>, <span class="string">&#x27;book&#x27;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>如果你不了解什么是正则表达式，可以查看 <a href="https://www.helloseraphine.top/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a> 。</p></blockquote><p>现在还需要解决的一个问题就是第一个单词是大写的，如果是按词袋来比较的话，我们需要让词的形式统一起来，不论它们是在什么位置。</p><p>Python 中有一些内嵌的方法，可以将字符串全部转换成小写（<code>.lower()</code>）或者大写（<code>.upper()</code>），借助这些方法可以达到我们的目的。于是，我们可以做如下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">txt = <span class="string">&quot;This book , is the best book&quot;</span></span><br><span class="line">regEx = re.<span class="built_in">compile</span>(<span class="string">&#x27;\\W+&#x27;</span>)</span><br><span class="line">listTokens = regEx.split(txt)</span><br><span class="line"><span class="built_in">print</span>([token.lower() <span class="keyword">for</span> token <span class="keyword">in</span> listTokens])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="string">&#x27;this&#x27;</span>, <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;best&#x27;</span>, <span class="string">&#x27;book&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="测试算法：使用朴素贝叶斯进行交叉验证"><a href="#测试算法：使用朴素贝叶斯进行交叉验证" class="headerlink" title="测试算法：使用朴素贝叶斯进行交叉验证"></a>测试算法：使用朴素贝叶斯进行交叉验证</h2><p>测试使用的数据 <a href="https://wwam.lanzouj.com/ig3fx12l9m8j">点我下载</a> 。将文件解压缩到和 <code>bayes.py</code> 同路径下。交叉验证的代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">textParse</span>(<span class="params">bigString</span>):  <span class="comment"># input is big string, #output is word list</span></span><br><span class="line">    <span class="keyword">import</span> re</span><br><span class="line">    listOfTokens = re.split(<span class="string">r&#x27;\W*&#x27;</span>, bigString)</span><br><span class="line">    <span class="keyword">return</span> [tok.lower() <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> <span class="built_in">len</span>(tok) &gt; <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spamTest</span>():</span><br><span class="line">    docList = []</span><br><span class="line">    classList = []</span><br><span class="line">    fullText = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">26</span>):</span><br><span class="line">        wordList = textParse(<span class="built_in">open</span>(<span class="string">&#x27;email/spam/%d.txt&#x27;</span> % i).read())</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">1</span>)</span><br><span class="line">        wordList = textParse(<span class="built_in">open</span>(<span class="string">&#x27;email/ham/%d.txt&#x27;</span> % i).read())</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">0</span>)</span><br><span class="line">    vocabList = createVocabList(docList)</span><br><span class="line">    trainingSet = <span class="built_in">range</span>(<span class="number">50</span>)</span><br><span class="line">    testSet = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        randIndex = <span class="built_in">int</span>(random.uniform(<span class="number">0</span>, <span class="built_in">len</span>(trainingSet)))</span><br><span class="line">        testSet.append(trainingSet[randIndex])</span><br><span class="line">        <span class="keyword">del</span> (trainingSet[randIndex])</span><br><span class="line">    trainMat = []</span><br><span class="line">    trainClasses = []</span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> trainingSet:</span><br><span class="line">        trainMat.append(bagOfWords2VecMN(vocabList, docList[docIndex]))</span><br><span class="line">        trainClasses.append(classList[docIndex])</span><br><span class="line">    p0V, p1V, pSpam = trainNB0(array(trainMat), array(trainClasses))</span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:</span><br><span class="line">        wordVector = bagOfWords2VecMN(vocabList, docList[docIndex])</span><br><span class="line">        <span class="keyword">if</span> classifyNB(array(wordVector), p0V, p1V, pSpam) != classList[docIndex]:</span><br><span class="line">            errorCount += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;classification error&quot;</span>, docList[docIndex])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;the error rate is: &#x27;</span>, <span class="built_in">float</span>(errorCount) / <span class="built_in">len</span>(testSet))</span><br></pre></td></tr></table></figure><p>如上代码是《机器学习实战》中作者给的代码，他使用的是<code>python2.x</code>版本，所以我在尝试运行这段代码，全是报错，主要问题在于读取文本的格式问题，我在尝试使用<code>UTF-8</code>编码后，无果。遂放弃了尝试这段代码。</p><blockquote><p>如果你感兴趣的话，可以尝试修改正确，我放弃了😥</p></blockquote><h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><h2 id="ones"><a href="#ones" class="headerlink" title="ones()"></a><code>ones()</code></h2><p><code>ones()</code> 是一个NumPy库中的函数，用于创建一个由1组成的数组。它的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.ones(shape, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li><code>shape</code>：表示数组的形状，可以是一个整数或一个整数元组。例如，<code>shape</code> 为 5 表示创建一个包含5个元素的一维数组，<code>shape</code> 为 (2, 3) 表示创建一个2行3列的二维数组。</li><li><code>dtype</code>：可选参数，表示数组的数据类型。默认为 <code>None</code>，即使用默认的数据类型。</li><li><code>order</code>：可选参数，表示数组的存储顺序。默认为 <code>&#39;C&#39;</code>，表示按行主序存储。</li></ul><p>下面是一个简单的示例，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含5个元素的一维数组</span></span><br><span class="line">arr1 = np.ones(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="comment"># 输出: [1. 1. 1. 1. 1.]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个2行3列的二维数组</span></span><br><span class="line">arr2 = np.ones((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># [[1. 1. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 1. 1.]]</span></span><br></pre></td></tr></table></figure><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">统计参数是用于描述一个数据集的特征的数值指标。它们提供了对数据分布、中心趋势和变异程度的总体概括。例如：均值，中位数，反差等。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">托马斯·贝叶斯（Thomas Bayes，1702-1761） [2] ，18世纪英国神学家、数学家、数理统计学家和哲学家，<a href="https://baike.baidu.com/item/%E6%A6%82%E7%8E%87%E8%AE%BA/829122?fromModule=lemma_inlink">概率论</a>理论创始人，<a href="https://baike.baidu.com/item/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1/3431194?fromModule=lemma_inlink">贝叶斯统计</a>的创立者，“归纳地”运用数学概率，“从特殊推论一般、从样本推论全体”的第一人。</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">著名的机器学习西瓜书中也有提到：如果假设了标签是由 m 个特征，每个特征有 n 种可能取值决定的，那么假设空间就包含假设的所有可能取值的组合形成。大小=$(n+1)^{m+1}$。</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">熏猪肉；咸肉；腌肉</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">朴素贝叶斯分类器通常有两种实现方式：一种基于贝努利模型实现，一种基于多项式模型实现。这里采用前一种实现方式。该实现方式并不考虑词在文档中出现的次数，只考虑出不出现，因此在这个意义上相当于假设词是等权重的。——李鹏</span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;">为了避免在计算条件概率时出现概率为零的情况，通常会使用平滑技术来处理。其中一种常见的平滑技术是拉普拉斯平滑（Laplace smoothing），也称为加一平滑（add-one smoothing）。</span><a href="#fnref:6" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【3.0】决策树</title>
      <link href="/2023/07/12/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%903-0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/2023/07/12/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%903-0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你以前没有接触过决策树，也不需要担心，它的概念非常简单。即使不知道它也可以通过简单的图形了解其中的工作原理，下图的流程图就是一个决策树，长方形代表<strong>判断模块（decision block）</strong>，椭圆形代表<strong>终止模块（terminating block）</strong>，表示这已经得出结论，可以终止运行。从判断模块引出的左右箭头称为<strong>分支（branch）</strong>，它可以到达另一个判断模块或者终止模块。该流程图构造了一个假想的邮件分类系统，它首先检测发生邮件域名地址。如果地址为 myEmployer.com ，则将其放在分类 “无聊时需要阅读的邮件”，其他同理分类。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abff8909e9f.png" alt="image-20230709002848184" style="zoom: 80%;" /><p>K-近邻算法已经可以完成很多分类任务，但是它最大的缺点就是<strong>无法给出数据的内在含义</strong>，<strong>决策树的主要优势就是在于数据形式非常容易理解</strong>。决策树可以使用不熟悉的数据集合，并从中提取出一系列规则，这些机器根据数据集创建规则的过程，就是机器学习的过程。</p><blockquote><p><strong>前排提醒：在接下来的代码示例中，有看不懂的函数，可以尝试在下面的 函数相关说明 处查看</strong></p></blockquote><h1 id="决策树的构造"><a href="#决策树的构造" class="headerlink" title="决策树的构造"></a>决策树的构造</h1><p>决策树的优缺点</p><ul><li>优点：计算复杂度不高，输出结果容易理解，对中间值的缺失并不敏感，可以处理不相关特征数据。</li><li>缺点：可能会产生过度匹配的问题</li><li>适用数据类型：<strong>数值型和标称型</strong>。</li></ul><p>首先，我们讨论数学上如何使用信息论划分数据集，然后编写代码将理论应用到具体的数据集上，最后编写代码构建决策树。</p><p>在构造决策树时，我们需要解决的第一个问题：<strong>当前数据集上哪个特征在划分数据分类时起决定性作用。</strong> 为了找到决定性的特征，划分出最好的结果，我们必须评估每个特征。完成测试之后，原始数据集就被划分为几个数据子集。这些数据子集会分布在第一个决策点的所有分支上。如果某个分支下的数据属于同一类型，则不需要再分割了。如果某分支下的数据不属于同一类型，则需要重复划分数据子集，直到所有相同类型的数据被划分为各自的子集中。</p><p>创建分支的伪代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">检测数据集中的每个子项是否属于同一分类</span><br><span class="line">If true <span class="keyword">return</span> 类标签</span><br><span class="line">Else</span><br><span class="line">    寻找划分数据集的最好特征</span><br><span class="line">        划分数据集</span><br><span class="line">        创建分支节点</span><br><span class="line">        <span class="keyword">for</span> 每个划分的子集</span><br><span class="line">            调用函数自己(递归)</span><br><span class="line">    <span class="keyword">return</span> 分支节点</span><br></pre></td></tr></table></figure><p>这个伪代码函数是一个递归函数，后续我们会使用<code>python</code>代码来实现这段伪代码。一些决策树采用二分法划分数据，本文并不采用这种方法。本文将使用 <strong>ID3</strong> 算法划分数据集。每次划分数据集时，我们只选取一个特征属性，如果训练集中存在 20 个特征，<strong>第一次我们选择哪个特征作为划分的参考属性呢？</strong>。</p><blockquote><p>一些常见的决策树算法：</p><ol><li>ID3（Iterative Dichotomiser 3）：ID3 是最早的决策树算法之一，它使用信息增益来选择最优的特征进行分裂。然而，ID3 倾向于选择具有更多取值的特征，因此在实践中往往使用其他算法。</li><li>C4.5：C4.5 是 ID3 的改进版本，它使用信息增益比来选择最优的特征。相对于 ID3，C4.5 能够处理连续特征和缺失数据，并且可以生成具有更好泛化能力的决策树。</li><li>CART（Classification and Regression Trees）：CART 是一种常用的决策树算法，可以用于分类和回归问题。CART 使用基尼系数（Gini Index）来选择最优的特征进行分裂，它生成的决策树是二叉树结构。</li><li>CHAID（Chi-squared Automatic Interaction Detection）：CHAID 是一种基于卡方检验的决策树算法，适用于分类问题。它可以处理离散和连续特征，并且能够检测特征之间的交互作用。</li><li>Random Forest（随机森林）：随机森林是一种集成学习方法，基于多个决策树进行预测。每个决策树都是通过随机选择样本和特征进行训练的，最后的预测结果由多个决策树的投票或平均值得出。</li><li>Gradient Boosting Trees（梯度提升树）：梯度提升树也是一种集成学习方法，通过迭代地训练决策树来提高预测性能。每个决策树都是在前一棵树的残差基础上进行训练的，最终的预测结果是多个决策树的加权和。</li></ol></blockquote><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p><strong>划分数据集的大原则是：将无序的数据变得更加有序</strong>。组织杂乱无章数据的一种方法就是使用信息论度量信息，信息论是量化处理信息的分支科学。</p><p><strong>在划分数据集之前之后信息发生的变化称为：信息增益</strong>，知道如何计算信息增益，我们就可以计算每个特征值划分数据集获得的信息增益，<strong>获得信息增益最高的特征就是最好的选择</strong>。</p><p>在评测哪种数据划分方式是最好的数据划分之前，我们必须学习如何计算信息增益。<strong>集合信息的度量方式称为香农熵或者简称为熵</strong>，这个名字来源于信息论之父<a href="httpss://baike.baidu.com/link?url=OBTxVKAwWRgVgEUea1-c5iy-Mo13TR_X-i9DQEgwJbRwhTSKPOidanFqVPBhvJI6IE1SZnif79yrhmrDaLO8T2MZEZ_ljkJrR1WfXC8tCisjO7Ub4VH9UfUOWXNRm2XjS0WCXWDGEbftOopABp0ncNE6nd_z2tQvxYt-fjkIygVwYQhvdtWnY7mkCuHAL6xhmZP5A3NmElsPc2Uq0h_Usa">克劳德·艾尔伍德·香农</a>。</p><p>如果看不明白什么是<strong>信息增益和熵</strong>，也不需要着急——它们自诞生的那一天起，就注定令人费解。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64ac0afed3fd5.jpeg" alt="59f433e711f04e0cae3e7eca648e8980" style="zoom:50%;" /><p><strong>熵的定义为信息的期望值</strong>，在明晰这个概念之前，我们必须知道信息的定义。如果待分类的事务可能划分在多个分类之中，则符合 $x_i$ 的信息定义为：$\large l(x_i) &#x3D; - log_2{p(x_i)}$ ，其中 $\large p(x_i)$ 是选择该分类的概率。</p><p>为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，通过下面的公式得到：</p><p>$\large H &#x3D; - \sum^{n}_{i&#x3D;1}p(x_i) \log_2{p(x_i)}$，其中 $n$ 是分类的数目。</p><blockquote><p>关于这两个公式的理解可以参考<a href="httpss://www.bilibili.com/video/BV1oX4y1w7aG/">如何理解信息熵</a></p></blockquote><p>下面我们将学习如何使用<code>python</code>计算信息熵，创建名称为<code>trees.py</code>的文件，如下代码为计算给定数据集的熵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="comment"># 计算香农信息熵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calcShannonEnt</span>(<span class="params">dataSet</span>):</span><br><span class="line">    <span class="comment"># 获取数据的长度（或者说有多少条数据）</span></span><br><span class="line">    numEntries = <span class="built_in">len</span>(dataSet)</span><br><span class="line">    <span class="comment"># 创建一个空的字典</span></span><br><span class="line">    labelCounts = &#123;&#125;</span><br><span class="line">    <span class="comment"># 遍历每条数据</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="comment"># 拿到数据的最后一项，即标签项</span></span><br><span class="line">        currentLabel = featVec[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 如果这个标签不在我们创建的字典中，我们就创建它</span></span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys(): labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 在字典中，计数标签+1</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 香农信息熵默认为 0</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 遍历特征在字典中（所有特征）</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">        <span class="comment"># 计算每个类型特征所占用比例（概率）</span></span><br><span class="line">        prob = <span class="built_in">float</span>(labelCounts[key])/numEntries</span><br><span class="line">        <span class="comment"># 带入香农信息熵公式</span></span><br><span class="line">        shannonEnt -= prob * log(prob,<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 返回计算的信息熵结果</span></span><br><span class="line">    <span class="keyword">return</span> shannonEnt</span><br></pre></td></tr></table></figure><p>现在我们使用如下数据来测试一下我们的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataSet = [[<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;n&#x27;</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(calcShannonEnt(dataSet))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">0.9709505944546686</span></span><br></pre></td></tr></table></figure><p><strong>熵越高，则混合的数据也越多</strong>，我们可以在测试数据集中添加更多的分类，观察熵的变化，现在我们增加第三个名为<code>z</code>的分类，测试熵的变化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataSet = [[<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;n&#x27;</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;z&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(calcShannonEnt(dataSet))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">1.4591479170272448</span></span><br></pre></td></tr></table></figure><p>得到熵之后，我们就可以按照获取最大信息增益的方法划分数据集，下个部分我们将具体学习如何划分数据集以及如何度量信息增益。</p><p><strong>另一个度量集合无序程度的方法是<a href="httpss://baike.baidu.com/item/%E5%9F%BA%E5%B0%BC%E4%B8%8D%E7%BA%AF%E5%BA%A6/22046808">基尼不纯度</a>，简单来说就是从一个数据集中随机选取子项，度量其被错误分类到其他分组里的概率</strong>。本文不采用基尼不纯度方法，这里不做更多说明。</p><h2 id="划分数据集"><a href="#划分数据集" class="headerlink" title="划分数据集"></a>划分数据集</h2><p>上个部分我们学习了如何度量数据集的无序程度，分类算法除了需要测量信息熵，还需要划分数据集，度量划分数据集的熵，以便判断是否正确地划分了数据集。<strong>我们将对每个特征划分数据集的结果计算一次信息熵，然后判断按照哪个特征划分数据集是最好的划分方式</strong>。</p><p>现在我们使用如下代码按照特征来划分数据集，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#划分数据集,传入数据集，特征在数据集的位置，要划分的特征</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">splitDataSet</span>(<span class="params">dataSet, axis, value</span>):</span><br><span class="line">    <span class="comment"># 创建空的列表返回划分好的结果</span></span><br><span class="line">    retDataSet = []</span><br><span class="line">    <span class="comment"># 开始遍历数据集划分数据集</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="comment"># 判断特征值是不是要划分的标准</span></span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            <span class="comment"># 创建划分对应特征的集合</span></span><br><span class="line">            reducedFeatVec = featVec[:axis]</span><br><span class="line">            <span class="comment"># 将划分特征数据后续复制到创建的新集合中</span></span><br><span class="line">            reducedFeatVec.extend(featVec[axis+<span class="number">1</span>:])</span><br><span class="line">            <span class="comment"># 将划分的集合添加到分类集合中</span></span><br><span class="line">            retDataSet.append(reducedFeatVec)</span><br><span class="line">    <span class="comment"># 返回划分好的集合</span></span><br><span class="line">    <span class="keyword">return</span> retDataSet</span><br></pre></td></tr></table></figure><p>现在我们来测试上述代码，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataSet = [[<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;n&#x27;</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;z&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(splitDataSet(dataSet,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[[<span class="number">0</span>, <span class="string">&#x27;y&#x27;</span>], [<span class="number">0</span>, <span class="string">&#x27;y&#x27;</span>]]</span><br></pre></td></tr></table></figure><p>接下来我们将会遍历整个数据集，循环计算香农熵和<code>splitDataSet()</code>函数（划分数据集），找到最好的特征划分方式。<strong>熵计算会告诉我们如何划分数据集是最好的数据组织方式</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 香农熵划分最佳数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chooseBestFeatureToSplit</span>(<span class="params">dataSet</span>):</span><br><span class="line">    <span class="comment"># 获取特征数量（总数）</span></span><br><span class="line">    numFeatures = <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 获取当前没分类的信息熵</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line">    <span class="comment"># 定义最好的信息熵值</span></span><br><span class="line">    bestInfoGain = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 定义最好的分类特征</span></span><br><span class="line">    bestFeature = -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 遍历每个特征</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeatures):</span><br><span class="line">        <span class="comment"># 获取当前特征的所有值</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">        <span class="comment"># 去重，获取单一且不重复的当前特征枚举值</span></span><br><span class="line">        uniqueVals = <span class="built_in">set</span>(featList)</span><br><span class="line">        <span class="comment"># 定义新的信息熵</span></span><br><span class="line">        newEntropy = <span class="number">0.0</span></span><br><span class="line">        <span class="comment"># 开始遍历计算每个当前特征枚举值的信息熵，最后公式加和得到当前特征值分类后的信息熵</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            <span class="comment"># 根据当前特征去重的枚举值分割数据集</span></span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">            <span class="comment"># 获取当前枚举值的概率</span></span><br><span class="line">            prob = <span class="built_in">len</span>(subDataSet)/<span class="built_in">float</span>(<span class="built_in">len</span>(dataSet))</span><br><span class="line">            <span class="comment"># 根据概率*信息熵最终加和得到当前特征值的信息熵</span></span><br><span class="line">            newEntropy += prob * calcShannonEnt(subDataSet)</span><br><span class="line">        <span class="comment"># 用基础的信息熵-分类后的信息熵，得到新的信息熵差异</span></span><br><span class="line">        infoGain = baseEntropy - newEntropy</span><br><span class="line">        <span class="comment"># 如果这个差异是正数，即大于零，意味着按当前特征分类后的信息熵降低了，不混乱了</span></span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):</span><br><span class="line">            <span class="comment"># 记录当前最好的信息熵</span></span><br><span class="line">            bestInfoGain = infoGain</span><br><span class="line">            <span class="comment"># 记录获得最好信息熵的特征索引</span></span><br><span class="line">            bestFeature = i</span><br><span class="line">    <span class="comment"># 返回得到的分类当前数据集最好的特征索引</span></span><br><span class="line">    <span class="keyword">return</span> bestFeature</span><br></pre></td></tr></table></figure><p>如果你实在觉得绕看不懂，可以单步调试，或者在关键的地方让它输出看看结果，多次尝试就明白了。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/11/64ac45d1811c5.jpeg" alt="b9fae566feea6c184c43c992a07be226" style="zoom: 25%;" /><h2 id="递归构建决策树"><a href="#递归构建决策树" class="headerlink" title="递归构建决策树"></a>递归构建决策树</h2><p>目前我们已经学习了从数据集构造决策树算法所需要的子功能模块，其工作原理如下：<strong>得到原始数据集，然后基于最好的属性值划分数据集，由于特征值可能多于两个，因此可能存在大于两个分支的数据集划分。第一次划分之后，数据将被向下传递到树分支的下一个节点，在这个节点上，我们可以再次划分数据</strong>。因此我们可以采用递归的原则来处理数据集。</p><p>递归的结束条件是：程序遍历完所有划分数据集的属性，或者每个分支下的所有实例都具有相同的分类。如果所有实例具有相同的分类，则得到一个叶子节点或者终止块。任何到达叶子节点的数据必然属于叶子节点的分类。例如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abff8909e9f.png" alt="image-20230709002848184" style="zoom: 80%;" /><p>第一个结束条件可以使得算法可以终止，我们甚至可以设置算法可以划分的最大分组数目。后续还会说明其他决策树算法，例如 <strong>C4.5 和 CART</strong>，这些算法在运行时并不总是在每次划分分组时都会消耗特征。由于特征数目并不是在每次划分数据时减少，因此这些算法在实际使用时候可能会引起一些问题。目前我们并不需要考虑这个问题，<strong>只需要在算法开始运行计算列的数目，查看算法是否使用了所有属性即可</strong>。如果数据集已经处理了所有属性，但是类标签依然不是唯一的，此时我们需要决定如何定义该叶子节点，在这种情况下，我们通常会采用多数表决的方法决定改叶子节点的分类。</p><p>现在我们打开<code>tree.py</code>文件，在文件头部添加<code>import operator</code>，然后在文本中添加如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标签投票分类(如果数据集已经处理了所有属性，但是类标签依然不是唯一的，我们需要决定如何定义该叶子节点)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">majorityCnt</span>(<span class="params">classList</span>):</span><br><span class="line">    <span class="comment"># 创建一个空的标签字典</span></span><br><span class="line">    classCount=&#123;&#125;</span><br><span class="line">    <span class="comment"># 遍历数据集中的标签</span></span><br><span class="line">    <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">        <span class="comment"># 如果标签不存在字典中，则创建标签，其初始值为 0</span></span><br><span class="line">        <span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys(): classCount[vote] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 对应标签的值+1</span></span><br><span class="line">        classCount[vote] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将字典标签按值排序</span></span><br><span class="line">    sortedClassCount = <span class="built_in">sorted</span>(classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 返回数量最多的一个标签</span></span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>现在我们来在文件中添加最后的递归相关的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建决策树，传入数据集和标签列表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createTree</span>(<span class="params">dataSet,labels</span>):</span><br><span class="line">    <span class="comment"># 获取所有数据集最后一列的数据(标签)</span></span><br><span class="line">    classList = [example[-<span class="number">1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="comment"># 如果传入的数据集都是一个类别，就直接返回节点</span></span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == <span class="built_in">len</span>(classList):</span><br><span class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 如果已经遍历完所有特征，只剩下标签列，则返回样本中出现次数最多的类别作为叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">    <span class="comment"># 划分最佳数据集</span></span><br><span class="line">    bestFeat = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">    <span class="comment"># 得到划分最佳数据集的标签</span></span><br><span class="line">    bestFeatLabel = labels[bestFeat]</span><br><span class="line">    <span class="comment"># 创建一个字典，以最佳特征的标签为键，值为空字典，用于构建决策树</span></span><br><span class="line">    myTree = &#123;bestFeatLabel:&#123;&#125;&#125; </span><br><span class="line">    <span class="comment"># 删除已选择的最佳特征的标签，以便在递归调用时传递给下一层</span></span><br><span class="line">    <span class="keyword">del</span>(labels[bestFeat])</span><br><span class="line">    <span class="comment"># 获取数据集中最佳特征的所有取值</span></span><br><span class="line">    featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="comment"># 获取最佳特征的唯一取值集合</span></span><br><span class="line">    uniqueVals = <span class="built_in">set</span>(featValues)</span><br><span class="line">    <span class="comment"># 递归遍历</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">        <span class="comment"># 创建一个副本，以便在递归调用时传递给下一层</span></span><br><span class="line">        subLabels = labels[:]</span><br><span class="line">        <span class="comment"># 递归调用createTree函数，传递划分后的子数据集和剩余特征的标签，将返回的子树作为当前节点的值</span></span><br><span class="line">        myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value),subLabels)</span><br><span class="line">    <span class="comment"># 返回构建好的决策树</span></span><br><span class="line">    <span class="keyword">return</span> myTree</span><br></pre></td></tr></table></figure><p>内容很多，很抽象是吧🤣，我也觉得很抽象，理解上面的整个代码运行过程，我们来举一个实例来理解这段代码，现在我们有如下的数据，我们需要对它们进行分类。</p><table><thead><tr><th align="center">是否有脚</th><th align="center">是否有鳞片</th><th align="center">是否有鳃</th><th align="center">是否有尾巴</th><th align="center">【特征值】</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">非鱼类</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">鱼类</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">鱼类</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">非鱼类</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">鱼类</td></tr></tbody></table><p>我们将上述数据转换成运行的<code>python</code>代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dataSet = data = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;非鱼类&#x27;</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;鱼类&#x27;</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;鱼类&#x27;</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;非鱼类&#x27;</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;鱼类&#x27;</span>]</span><br><span class="line">]</span><br><span class="line">createTree(dataSet,[<span class="string">&#x27;是否有脚&#x27;</span>,<span class="string">&#x27;是否有鳞片&#x27;</span>,<span class="string">&#x27;是否有鳃&#x27;</span>,<span class="string">&#x27;是否有尾巴&#x27;</span>])</span><br></pre></td></tr></table></figure><p>很明显的看出，上面的递归代码中的<code>labels</code>就是表格的表头，它是用来给每一列数据进行标注的，或者说是用来解释数据的，对于计算机来说这一列并没有参考性，但是对于我们来说是有参考意义的。</p><p>现在我们运行这段代码，运行到这里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有数据集最后一列的数据(标签)</span></span><br><span class="line">classList = [example[-<span class="number">1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br></pre></td></tr></table></figure><p>我们得到<code>classList = [&#39;非鱼类&#39;, &#39;鱼类&#39;, &#39;鱼类&#39;, &#39;非鱼类&#39;, &#39;鱼类&#39;]</code>，也就说明它提取了我们的所有数据的特征。</p><p>现在运行到下面的代码部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果传入的数据集都是一个类别，就直接返回节点</span></span><br><span class="line"><span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == <span class="built_in">len</span>(classList):</span><br><span class="line">    <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 如果已经遍历完所有特征，只剩下标签列，则返回样本中出现次数最多的类别作为叶子节点</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> majorityCnt(classList)</span><br></pre></td></tr></table></figure><p>这两个部分对应的处理就是我们前面说的递归的结束情况，代码第一个<code>if</code>部分判断，如果给定的数据集类别中，第一个类别的数量等于该数据集所有类别的数量，就说明它们都是一个类别的，已经不需要分类了（<em>递归的结束条件是：程序遍历完所有划分数据集的属性，或者每个分支下的所有实例都具有相同的分类</em>）。</p><p>第二个<code>if</code>部分判断的是，如果我们的整个数据集只有一列了，那就说明只剩下了最右侧的特征值列，说明已经把属性都分类完了，这个时候也不再需要分类了（<em>如果数据集已经处理了所有属性，但是类标签依然不是唯一的，此时我们需要决定如何定义该叶子节点，在这种情况下，我们通常会采用多数表决的方法决定改叶子节点的分类</em>）。</p><p>现在来继续往下执行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 划分最佳数据集</span></span><br><span class="line">bestFeat = chooseBestFeatureToSplit(dataSet)</span><br></pre></td></tr></table></figure><p>现在我们将我们的数据集进行第一次划分，形象点来说就是决策树第一次分叉，执行<code>chooseBestFeatureToSplit()</code>函数后，我们的输出结果：<code>bestFeat = 0</code>，它告诉了我们这个数据集的第一次划分最好的属性索引是 <code>0</code>，对应索引的是<code>是否有脚</code>。</p><blockquote><p>具体划分原理，参考前面的<strong>信息增益部分</strong>。</p></blockquote><p>现在我们知道了第一次应该按什么属性来划分，代码继续运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到划分最佳数据集的标签</span></span><br><span class="line">bestFeatLabel = labels[bestFeat]</span><br></pre></td></tr></table></figure><p>通过这个，就得到了前面我说的最佳划分属性的标签，就是<code>是否有脚</code>。我们在知道第一次划分的属性后，接下来构建决策树的雏形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个字典，以最佳特征的标签为键，值为空字典，用于构建决策树</span></span><br><span class="line">myTree = &#123;bestFeatLabel:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><p>现在我们创建了一个变量<code>myTree</code>来存储决策树，其中它的类型是字典类型，存储了一个<code>key = bestFeatLabel</code>也就是<code>key = &#39;是否有脚&#39;</code>的<code>key</code>，它对应的<code>value</code>是一个空的字典，也就是代码中的<code>&#123;&#125;</code>，这行代码的其最终的结果：<code>myTree = &#123;&#39;是否有脚&#39;: &#123;&#125;&#125;</code>。</p><p>现在代码继续执行到如下位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除已选择的最佳特征的标签，以便在递归调用时传递给下一层</span></span><br><span class="line"><span class="keyword">del</span>(labels[bestFeat])</span><br></pre></td></tr></table></figure><p>它删除了我们标签中的第一次分叉属性，也就是由之前的<code>[&#39;是否有脚&#39;, &#39;是否有鳞片&#39;, &#39;是否有鳃&#39;, &#39;是否有尾巴&#39;]</code>变成了<code>[&#39;是否有鳞片&#39;, &#39;是否有鳃&#39;, &#39;是否有尾巴&#39;]</code>。</p><p>接下来代码继续执行到如下位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数据集中最佳特征的所有取值</span></span><br><span class="line">featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br></pre></td></tr></table></figure><p>这句代码右侧是列表推导式，这句代码运行结果是：<code>[1, 1, 0, 1, 0]</code>，它提取所有第一个分叉最佳属性的所有值，因为我们接下来要根据值来继续划分数据集了。</p><blockquote><p>具体列表推导式是什么参考下面的<strong>相关函数说明</strong></p></blockquote><p>代码继续执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取最佳特征的唯一取值集合</span></span><br><span class="line">uniqueVals = <span class="built_in">set</span>(featValues)</span><br></pre></td></tr></table></figure><p>这句代码执行结果就是去重，它的执行结果是：<code>&#123;0, 1&#125;</code>，这样我们就得到了当前最佳属性的唯一取值集合，接下来就是“分叉”，第一个“叉”是按 0 来分的，第二个“叉”是按 1 来分的。</p><p>代码继续执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归遍历</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">    <span class="comment"># 创建一个副本，以便在递归调用时传递给下一层</span></span><br><span class="line">    subLabels = labels[:]</span><br><span class="line">    <span class="comment"># 递归调用createTree函数，传递划分后的子数据集和剩余特征的标签，将返回的子树作为当前节点的值</span></span><br><span class="line">    myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value),subLabels)</span><br></pre></td></tr></table></figure><p>现在我们遍历第一个“叉”，即<code>value = 0</code>，我们先是完全拷贝了一份<code>labels</code>给<code>subLabels</code>，接下来，我们对于</p><p>第一个分叉，先做了一个划分，即<code>splitDataSet(dataSet, bestFeat, value)</code>，它的运行结果是返回了：<code>[[1, 0, 1, &#39;鱼类&#39;], [1, 0, 0, &#39;鱼类&#39;]]</code>，也就是第一列所有<code>value = 0</code>的值划分的一组（去除了第一列的值），然后形成的这个新的分组就是<code>[[1, 0, 1, &#39;鱼类&#39;], [1, 0, 0, &#39;鱼类&#39;]]</code>，转换成表格如下所示：</p><table><thead><tr><th>是否有鳞片</th><th>是否有鳃</th><th>是否有尾巴</th><th>【特征值】</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>1</td><td>鱼类</td></tr><tr><td>1</td><td>0</td><td>0</td><td>鱼类</td></tr></tbody></table><p>然后这组数据再次执行<code>createTree(splitDataSet(dataSet, bestFeat, value),subLabels)</code>进行分类构建，但是它很明显特征值都是一个类型的，即鱼类，所以它在执行到如下代码就返回了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果传入的数据集都是一个类别，就直接返回节点</span></span><br><span class="line"><span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == <span class="built_in">len</span>(classList):</span><br><span class="line">    <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后接下来回到递归遍历的地方，此时<code>value = 1</code>，也就是右分叉再次执行这个循环，知道满足前面说的两个结束条件，然后才会结束，最后返回分类好的决策树。</p><p>**最终的运行结果是：<code>&#123;&#39;是否有脚&#39;: &#123;0: &#39;鱼类&#39;, 1: &#123;&#39;是否有鳃&#39;: &#123;0: &#39;非鱼类&#39;, 1: &#39;鱼类&#39;&#125;&#125;&#125;&#125;</code>**。这个结果很难直观的来理解是吧，现在将其可视化，就是如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/14/64b1498eec392.jpg" alt="Snipaste_2023-07-13_00-49-24" style="zoom:50%;" /><p>好了，现在你应该已经了解了如何构造决策树了，对于晦涩难懂的输出，图更加帮助我们理解分类器的内在逻辑，接下来我们来绘制决策树，来可视化我们的决策树。</p><h1 id="使用Graphviz绘制树形图"><a href="#使用Graphviz绘制树形图" class="headerlink" title="使用Graphviz绘制树形图"></a>使用<code>Graphviz</code>绘制树形图</h1><p>需要说明的是 Python 本身并不具备绘制图形&#x2F;图表的能力，我们需要通过拓展包来实现相关功能，在 Python 中有一些常用的包提供绘图相关操作：</p><ol><li>Matplotlib：Matplotlib是一个功能强大的绘图库，可以用于绘制各种类型的图表，包括树形图。</li><li>NetworkX：NetworkX是一个专门用于创建、操作和研究复杂网络的Python库。它提供了一些功能强大的函数和算法，用于绘制树形图、图形布局和节点样式设置。</li><li>Graphviz：Graphviz是一个开源的图形可视化工具包，可以用于绘制各种类型的图形，包括树形图。它使用DOT语言描述图形结构，并提供了Python接口供调用。</li><li>anytree：anytree是一个轻量级的Python库，用于处理和操作树形数据结构。它提供了创建、遍历和操作树形结构的功能，并支持将树形结构可视化为文本、图形或其他格式。anytree提供了一些可选的渲染器，可以将树形结构绘制为图形。</li></ol><p>从简单程度来说，使用<code>Graphviz</code>包是比较简单的，所以我采用该包进行树形图绘制演示。</p><p>如何下载安装该包，此处不再做演示，绘制图形代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建有向图</span></span><br><span class="line">dot = graphviz.Digraph()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置节点和边的字体</span></span><br><span class="line">dot.attr(<span class="string">&#x27;node&#x27;</span>, fontname=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">dot.attr(<span class="string">&#x27;edge&#x27;</span>, fontname=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加节点</span></span><br><span class="line">dot.node(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;是否有脚&#x27;</span>)</span><br><span class="line">dot.node(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;鱼类&#x27;</span>)</span><br><span class="line">dot.node(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;是否有鳃&#x27;</span>)</span><br><span class="line">dot.node(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;非鱼类&#x27;</span>)</span><br><span class="line">dot.node(<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;鱼类&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加边</span></span><br><span class="line">dot.edge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>,label=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">dot.edge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>,label=<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">dot.edge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>,label=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">dot.edge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>,label=<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 渲染并保存图形</span></span><br><span class="line">dot.render(<span class="string">&#x27;tree&#x27;</span>, <span class="built_in">format</span>=<span class="string">&#x27;png&#x27;</span>, view=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>其渲染结果如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/14/64b1499fbd475.jpg" alt="Snipaste_2023-07-13_01-47-35" style="zoom:80%;" /><h1 id="序列化决策树"><a href="#序列化决策树" class="headerlink" title="序列化决策树"></a>序列化决策树</h1><p>构造决策树是很耗时的任务，如果面对的数据集很大，将会耗费更多的计算时间。然后<strong>如果我们使用创建好的决策树解决分类问题，将会大大节约时间</strong>。因此为了节省时间，最好是能够在每次执行分类时调用已经构造好的决策树。</p><p>为了解决这个问题，需要<strong>使用 Python 模块 <code>pickle</code>序列化对象</strong>，代码如下所示。序列化对象可以在磁盘上存储，并在我们需要的时候读取出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 序列化决策树</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">storeTree</span>(<span class="params">inputTree, filename</span>):</span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    <span class="comment"># 获取文件指针，打开文件</span></span><br><span class="line">    fw = <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    <span class="comment"># 写入文件</span></span><br><span class="line">    pickle.dump(inputTree, fw)</span><br><span class="line">    <span class="comment"># 关闭文件</span></span><br><span class="line">    fw.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载序列化的决策树</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grabTree</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    <span class="comment"># 打开文件</span></span><br><span class="line">    fr = <span class="built_in">open</span>(filename,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    <span class="comment"># 反序列化并返回对象</span></span><br><span class="line">    <span class="keyword">return</span> pickle.load(fr)</span><br></pre></td></tr></table></figure><p>这样我们在构建决策树的时候就可以序列化存储起来，然后需要的时候调用出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dataSet = data = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;非鱼类&#x27;</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;鱼类&#x27;</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;鱼类&#x27;</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;非鱼类&#x27;</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;鱼类&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 序列化决策树</span></span><br><span class="line">storeTree(createTree(dataSet,[<span class="string">&#x27;是否有脚&#x27;</span>,<span class="string">&#x27;是否有鳞片&#x27;</span>,<span class="string">&#x27;是否有鳃&#x27;</span>,<span class="string">&#x27;是否有尾巴&#x27;</span>]),<span class="string">&#x27;Modeltree.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line">model = grabTree(<span class="string">&#x27;Modeltree.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure><p>代码的输出结果：<code>&#123;&#39;是否有脚&#39;: &#123;0: &#39;鱼类&#39;, 1: &#123;&#39;是否有鳃&#39;: &#123;0: &#39;非鱼类&#39;, 1: &#39;鱼类&#39;&#125;&#125;&#125;&#125;</code>。</p><p>通过上面的代码，我们可以将分类器存储在磁盘上，不必每次都需要学习一下，这也是决策树的优点之一，而相对于上一篇说明的<code>KNN</code>（k-近邻算法）就无法持久化分类器。</p><h1 id="使用决策树预测隐形眼镜类型"><a href="#使用决策树预测隐形眼镜类型" class="headerlink" title="使用决策树预测隐形眼镜类型"></a>使用决策树预测隐形眼镜类型</h1><p>使用小数据集，我们就可以利用决策树学到很多知识：眼科医生是如何判断患者需要佩戴的镜片类型？一旦理解了决策树的工作原理，我们甚至也可以帮助人们判断需要佩戴的镜片类型。</p><blockquote><p>关于隐形眼镜的数据集在文本的最后，相关数据部分，将数据记得保存在一个<code>txt</code>中。</p></blockquote><p>现在我们在 Python 中调用如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取数据集</span></span><br><span class="line">fr = <span class="built_in">open</span>(<span class="string">&#x27;treedata.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># 处理成需要的格式</span></span><br><span class="line">lenses=[inst.strip().split(<span class="string">&#x27;\t&#x27;</span>) <span class="keyword">for</span> inst <span class="keyword">in</span> fr.readlines()]</span><br><span class="line"><span class="comment"># 对应的标签</span></span><br><span class="line">lensesLabels=[<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;prescript&#x27;</span>, <span class="string">&#x27;astigmatic&#x27;</span>, <span class="string">&#x27;tearRate&#x27;</span>]</span><br><span class="line"><span class="comment"># 生成决策树</span></span><br><span class="line"><span class="built_in">print</span>(createTree (lenses,lensesLabels))</span><br></pre></td></tr></table></figure><p>输出结果：<code>&#123;&#39;tearRate&#39;: &#123;&#39;normal&#39;: &#123;&#39;astigmatic&#39;: &#123;&#39;yes&#39;: &#123;&#39;prescript&#39;: &#123;&#39;hyper&#39;: &#123;&#39;age&#39;: &#123;&#39;young&#39;: &#39;hard&#39;, &#39;presbyopic&#39;: &#39;no lenses&#39;, &#39;pre&#39;: &#39;no lenses&#39;&#125;&#125;, &#39;myope&#39;: &#39;hard&#39;&#125;&#125;, &#39;no&#39;: &#123;&#39;age&#39;: &#123;&#39;young&#39;: &#39;soft&#39;, &#39;presbyopic&#39;: &#123;&#39;prescript&#39;: &#123;&#39;hyper&#39;: &#39;soft&#39;, &#39;myope&#39;: &#39;no lenses&#39;&#125;&#125;, &#39;pre&#39;: &#39;soft&#39;&#125;&#125;&#125;&#125;, &#39;reduced&#39;: &#39;no lenses&#39;&#125;&#125;</code>。可视化后如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/14/64b149ae65e35.jpg" alt="Snipaste_2023-07-13_02-26-53" style="zoom: 67%;" /><p>从上图我们也可以发现，医生最多需要四个问题就能确定患者需要佩戴哪种类型的隐形眼镜。</p><p>上图的决策树也非常好的匹配了实验数据，然而这些匹配选项可能太多了。我们将这种问题称之为<strong>过度匹配</strong>。为了减少过度匹配，我们可以裁剪决策树，去掉一些不必要的叶子节点。如果叶子节点只能增加少量信息，则可以删除该节点，将它并入其他叶子节点中。我们将会在后续讨论这个问题。</p><h1 id="相关函数说明"><a href="#相关函数说明" class="headerlink" title="相关函数说明"></a>相关函数说明</h1><h2 id="extend"><a href="#extend" class="headerlink" title="extend()"></a><code>extend()</code></h2><p><code>extend()</code> 是 Python 列表对象的一个方法，<strong>用于将一个可迭代对象中的元素逐个添加到列表中</strong>。它会修改原始列表，将可迭代对象中的元素追加到列表的末尾。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">another_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">my_list.extend(another_list)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><blockquote><p>你会发现它和<code>append()</code>函数很像，具体不同看下面</p></blockquote><h2 id="append"><a href="#append" class="headerlink" title="append()"></a><code>append()</code></h2><p><code>append()</code> 是 Python 列表对象的一个方法，<strong>用于将一个元素添加到列表的末尾。它会修改原始列表，将元素追加到列表的最后一个位置</strong>。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">a.append(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br></pre></td></tr></table></figure><h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>在划分数据集中，<code>featList = [example[i] for example in dataSet]</code>这就是一个<strong>列表推导式，它用于提取数据集中每个样本的第 i 个特征的取值</strong>。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dataSet = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>([i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> dataSet])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set()"></a><code>set()</code></h2><p><code>set()</code> 是一个Python内置函数，<strong>用于创建一个无序、不重复元素的集合</strong>。集合是一种可变的数据类型，它可以存储各种不同的元素，但不允许有重复的元素。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(numbers))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="相关数据"><a href="#相关数据" class="headerlink" title="相关数据"></a>相关数据</h1><h2 id="隐形眼镜数据集"><a href="#隐形眼镜数据集" class="headerlink" title="隐形眼镜数据集"></a>隐形眼镜数据集</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">youngmyopenoreducedno lenses</span><br><span class="line">youngmyopenonormalsoft</span><br><span class="line">youngmyopeyesreducedno lenses</span><br><span class="line">youngmyopeyesnormalhard</span><br><span class="line">younghypernoreducedno lenses</span><br><span class="line">younghypernonormalsoft</span><br><span class="line">younghyperyesreducedno lenses</span><br><span class="line">younghyperyesnormalhard</span><br><span class="line">premyopenoreducedno lenses</span><br><span class="line">premyopenonormalsoft</span><br><span class="line">premyopeyesreducedno lenses</span><br><span class="line">premyopeyesnormalhard</span><br><span class="line">prehypernoreducedno lenses</span><br><span class="line">prehypernonormalsoft</span><br><span class="line">prehyperyesreducedno lenses</span><br><span class="line">prehyperyesnormalno lenses</span><br><span class="line">presbyopicmyopenoreducedno lenses</span><br><span class="line">presbyopicmyopenonormalno lenses</span><br><span class="line">presbyopicmyopeyesreducedno lenses</span><br><span class="line">presbyopicmyopeyesnormalhard</span><br><span class="line">presbyopichypernoreducedno lenses</span><br><span class="line">presbyopichypernonormalsoft</span><br><span class="line">presbyopichyperyesreducedno lenses</span><br><span class="line">presbyopichyperyesnormalno lenses</span><br></pre></td></tr></table></figure><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>本文使用的算法是 <strong>ID3</strong> ，它是一个好的算法但是并不完美。<strong>ID3</strong> 算法无法直接处理数值型数据，尽管我们可以量化的方法将数值型数据转换为标称型数值，但是如果存在太多特征划分，<strong>ID3</strong> 算法仍然面临其他问题。</p><p>后续我们将会学习另一个构造决策树的算法 <strong>CART</strong>，它使用基尼系数（Gini Index）来选择最优的特征进行分裂。</p>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【2.0】K-近邻算法</title>
      <link href="/2023/07/08/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%902.0%E3%80%91K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2023/07/08/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%902.0%E3%80%91K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>众所周知，电影可以按照题材进行分类，然后题材分类本身是如何定义的？动作片中会存在接吻镜头，而爱情片中也会存在打斗场景，我们不能单单依靠是否存在打斗和亲吻来判断影片类型。但是爱情片中的接吻镜头会更多，动作片中的打斗场景会更加频繁，基于场景的出现次数我们就可以进行电影分类。</p><p>这部分将会使用<strong>K-近邻算法</strong>来自动划分电影的题材类型。</p><p><strong>注：本实例使用的<code>python</code>版本为：v3.10，理论上你只要使用 v3.x 的任意版本即可运行</strong>。</p><h1 id="K-近邻算法概述"><a href="#K-近邻算法概述" class="headerlink" title="K-近邻算法概述"></a>K-近邻算法概述</h1><p>简单来说，<strong>K-近邻算法采用测量不同特征值之间的距离方法进行分类</strong>。</p><ul><li>优点：<strong>精度高，对异常值不敏感，无数据输入假定</strong></li><li>缺点：计算复杂度高，空间复杂度高</li><li>适用数据范围：数值型和标称型</li></ul><p>K-近邻算法（KNN）的工作原理是：<strong>存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一个数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。</strong>一般来说，我们只选择样本数据集中前 k 个最相似的数据，这就是 k-近邻算法中 k 的出处，通常 k 是不大于 20 的整数。最后，选择 k 个最相似数据中出现次数最多的分类，作为新数据的分类。</p><p>现在我们回到前面电影分类的例子，使用 k-近邻算法分类爱情片和动作片。如下图显示 6 部电影的打斗和接吻镜头数。假如一部未看过的电影，如何确定它是爱情片还是动作片？我们可以使用 KNN 来解决这个问题。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadb7b5135a.png" alt="image-20230707172748618" style="zoom:80%;" /><p>首先我们需要知道这个未知电影存在多个个打斗镜头和接吻镜头，上图为图形化展示，下表为数值表：</p><table><thead><tr><th align="left">电影名称</th><th align="center">打斗镜头</th><th align="center">接吻镜头</th><th align="center">电影类型</th></tr></thead><tbody><tr><td align="left">California Man</td><td align="center">3</td><td align="center">104</td><td align="center">爱情片</td></tr><tr><td align="left">He’s Not Really into Dudes</td><td align="center">2</td><td align="center">100</td><td align="center">爱情片</td></tr><tr><td align="left">Beautifiul Woman</td><td align="center">1</td><td align="center">81</td><td align="center">爱情片</td></tr><tr><td align="left">Kevin Longblade</td><td align="center">101</td><td align="center">10</td><td align="center">动作片</td></tr><tr><td align="left">Robo Slayer 3000</td><td align="center">99</td><td align="center">5</td><td align="center">动作片</td></tr><tr><td align="left">Amped II</td><td align="center">98</td><td align="center">2</td><td align="center">动作片</td></tr><tr><td align="left">?</td><td align="center">18</td><td align="center">90</td><td align="center">未知</td></tr></tbody></table><p>即使不知道未知电影属于哪种类型，我们也可以通过某种方法计算出来。首先计算未知电影与样本集中其他电影的距离，如下表所示。此时暂时不需要要关心如何计算得到这些距离值，使用<code>python</code>实现电影分类应用时，会提供具体计算方法。</p><table><thead><tr><th>电影名称</th><th align="center">与未知电影的距离</th></tr></thead><tbody><tr><td>California Man</td><td align="center">20.5</td></tr><tr><td>He’s Not Really into Dudes</td><td align="center">18.7</td></tr><tr><td>Beautiful Woman</td><td align="center">19.2</td></tr><tr><td>Kevin Longblade</td><td align="center">115.3</td></tr><tr><td>Robo Slayer 3000</td><td align="center">117.4</td></tr><tr><td>Amped II</td><td align="center">118.9</td></tr></tbody></table><p>现在我们得到了样本集中所有电影与未知电影的距离，按照距离递增排序，可以找到 k 个距离最近的电影。假定 $k&#x3D;3$ ，则三个最靠近的电影依次是California Man，He’s Not Really into Dudes和Beautiful Woman。k-近邻算法按照距离最近的三部电影的类型，决定未知电影的类型，而这三部电影全是爱情片，因此我们判定未知电影是爱情片。</p><h1 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h1><p>现在请创建一个新的<code>python</code>环境，然后新建一个<code>KNN.py</code>的文件，这部分的代码将会保存至该文件夹中，在该文件中输入如下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入numpy包的所有内容，这样就可以直接使用包内的函数等，不需要numpy.name来调用</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 导入python的operator，这样可以简化很多操作</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个方法，返回训练数据矩阵group和其对应标签列表labels</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createDataSet</span>():</span><br><span class="line">    <span class="comment"># 存储训练数据为矩阵</span></span><br><span class="line">    group = array([[<span class="number">1.0</span>,<span class="number">1.1</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0.1</span>]])</span><br><span class="line">    <span class="comment"># 其对应标签为列表</span></span><br><span class="line">    labels = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span>  group,labels</span><br></pre></td></tr></table></figure><p>上述代码的可视化图表如下所示，它给出了四个点，每两个的一组属于一个标签信息。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadb80de3c4.png" alt="image-20230707180941662" style="zoom: 67%;" /><blockquote><p>图片是由<code>R</code>语言生成，如果你感兴趣的话，其代码如下所示：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">group <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1.0</span><span class="punctuation">,</span> <span class="number">1.1</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">labels <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;A&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;A&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;B&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;B&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建散点图</span></span><br><span class="line">plot<span class="punctuation">(</span>group<span class="punctuation">,</span> col <span class="operator">=</span> ifelse<span class="punctuation">(</span>labels <span class="operator">==</span> <span class="string">&#x27;A&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;red&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;blue&#x27;</span><span class="punctuation">)</span><span class="punctuation">,</span> pch <span class="operator">=</span> <span class="number">16</span><span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="string">&#x27;X&#x27;</span><span class="punctuation">,</span> ylab <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整标签的位置</span></span><br><span class="line">text<span class="punctuation">(</span>group<span class="punctuation">,</span> labels<span class="punctuation">,</span> pos <span class="operator">=</span> ifelse<span class="punctuation">(</span>labels <span class="operator">==</span> <span class="string">&#x27;A&#x27;</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></blockquote><p>现在我们准备好数据后，解析来将使用 KNN 来完成分类。</p><h1 id="实施-KNN-分类算法"><a href="#实施-KNN-分类算法" class="headerlink" title="实施 KNN 分类算法"></a>实施 KNN 分类算法</h1><p>KNN 算法内容的伪代码如下：</p><p>对于未知类别属性的数据集中的每个点依次执行以下操作：</p><ol><li>计算已知类别数据集中的点与当前点之间的距离</li><li>按照距离递增次序排序</li><li>选取与当前点距离最小的 k 个点</li><li>确定前 k 个点所在的类别的出现频率</li><li>返回前 k 个点出现频率最高的类别作为当前点的预测分类</li></ol><p>其代码实现如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传入四个参数，分别是：预测集合，已知集合，及其对应标签，k值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify0</span>(<span class="params">inX, dataSet, labels, k</span>):</span><br><span class="line">    <span class="comment"># 获取训练集合（矩阵）的行数</span></span><br><span class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 获取训练集合和预测集合的差异矩阵</span></span><br><span class="line">    diffMat = tile(inX, (dataSetSize,<span class="number">1</span>)) - dataSet</span><br><span class="line">    <span class="comment"># 给矩阵里每个数值做平方</span></span><br><span class="line">    sqDiffMat = diffMat**<span class="number">2</span></span><br><span class="line">    <span class="comment"># 将矩阵按行分别相加并返回一个向量</span></span><br><span class="line">    sqDistances = sqDiffMat.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 将返回的结果做平方根</span></span><br><span class="line">    distances = sqDistances**<span class="number">0.5</span></span><br><span class="line">    <span class="comment"># 将最终结果根据大小替换按升序根据索引排列</span></span><br><span class="line">    sortedDistIndicies = distances.argsort()</span><br><span class="line">    <span class="comment"># 定义了一个字典用来存放最后的结果</span></span><br><span class="line">    classCount=&#123;&#125;</span><br><span class="line">    <span class="comment"># 遍历前 k 个元素，然后统计每个标签的出现次数写入刚刚创建的字典里</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        <span class="comment"># 获取前 k 个元素对应的标签</span></span><br><span class="line">        voteIlabel = labels[sortedDistIndicies[i]]</span><br><span class="line">        <span class="comment"># 将标签出现次数写入字典，即出现一次+1</span></span><br><span class="line">        classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将字典的结果按降序排列，即出现次数最多的标签排列在前</span></span><br><span class="line">    sortedClassCount = <span class="built_in">sorted</span>(classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 返回第一个标签，即前 k 个出现次数最多的标签</span></span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><blockquote><p>⭐<strong>如果你对算法中的一些函数并不了解，可以参考本文最后的相关函数说明</strong>。</p></blockquote><p>其中，计算距离使用的是欧式距离公式，计算两个向量点 $x_a$ 和 $x_b$ 之间的距离（PS：高中的两点间距离公式）：$\large d &#x3D; \sqrt{(x_{a_0}-x_{b_0})^2 + (x_{a_1} - x_{b_1})^2}$ 。</p><p>我们可以通过如下代码进行测试算法结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取训练数据及其对应标签</span></span><br><span class="line">dataSet,labels = createDataSet()</span><br><span class="line"><span class="comment"># 给定测试数据，训练数据，及其对应标签，k值</span></span><br><span class="line"><span class="built_in">print</span>(classify0([<span class="number">0</span>,<span class="number">0</span>],dataSet,labels,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">B</span><br></pre></td></tr></table></figure><p>到现在为止，我们已经构造了一个分类器，使用了这个分类器可以完成很多分类任务。</p><h1 id="使用-k-近邻算法改进约会网站配对效果"><a href="#使用-k-近邻算法改进约会网站配对效果" class="headerlink" title="使用 k-近邻算法改进约会网站配对效果"></a>使用 k-近邻算法改进约会网站配对效果</h1><p>现在海伦在通过约会网站寻找适合自己的约会对象，尽管约会网站会推荐不同的人选，但是这位朋友也不一定会喜欢每一个人。经过总结，她发现她曾交往过三种类型的人：</p><ul><li>不喜欢的人</li><li>魅力一般的人</li><li>极具魅力的人</li></ul><p>尽管发现了上述规律，但是海伦依然无法将约会网站推荐的匹配对象归入恰当的类别，海伦希望我们的分类软件可以更好的帮助匹配对象划分到确切的分类中。此外海伦还收集了一些约会网站未曾记录的数据信息，她认为这些数据更有助于匹配对象的归类。</p><h2 id="准备数据-1"><a href="#准备数据-1" class="headerlink" title="准备数据"></a>准备数据</h2><p>海伦的约会数据将会放到本文的最后，其中每个样本数据占据一行，总共有1000行。将数据放入脚本文件夹下的<code>txt</code>文件中，海伦的样本主要包含如下三种特征：</p><ul><li>每年获得的飞行常客里程数</li><li>玩视频游戏所消耗的时间百分比</li><li>每周消费的冰淇淋公升数</li></ul><p>将上述这些数据输入到分类器之前，我们需要先将数据处理成分类器可以接受的格式。现在在<code>KNN.py</code>中增加如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该函数传入数据文件的名称（数据文件和.py文件处于同一目录下）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file2matrix</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="comment"># 读取文件</span></span><br><span class="line">    fr = <span class="built_in">open</span>(filename)</span><br><span class="line">    <span class="comment"># 获取文件行数</span></span><br><span class="line">    numberOfLines = <span class="built_in">len</span>(fr.readlines())         </span><br><span class="line">    <span class="comment"># 根据行数创建 行数，3列 的 0 矩阵</span></span><br><span class="line">    returnMat = zeros((numberOfLines,<span class="number">3</span>))        </span><br><span class="line">    <span class="comment"># 创建一个空的列表</span></span><br><span class="line">    classLabelVector = []</span><br><span class="line">    <span class="comment"># 读取文件。这次读取是为了确保文件指针在文件的开头</span></span><br><span class="line">    fr = <span class="built_in">open</span>(filename)</span><br><span class="line">    <span class="comment"># 索引设置为 0 （最开始）</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        <span class="comment"># 移除每一行行末的空格和换行符</span></span><br><span class="line">        line = line.strip()</span><br><span class="line">        <span class="comment"># 使用制表符将每一行拆分成列表</span></span><br><span class="line">        listFromLine = line.split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="comment"># 将列表的前三项赋值到对应矩阵的行数列数</span></span><br><span class="line">        returnMat[index,:] = listFromLine[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">        <span class="comment"># 将数据的最后一列元素转换为整数存储到列表classLabelVector中</span></span><br><span class="line">        classLabelVector.append(<span class="built_in">int</span>(listFromLine[-<span class="number">1</span>]))</span><br><span class="line">        <span class="comment"># 索引+1</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 返回处理好的数据矩阵及其对应的标签列表</span></span><br><span class="line">    <span class="keyword">return</span> returnMat,classLabelVector</span><br></pre></td></tr></table></figure><p>现在我们来执行如下代码，来测试是否可以正常读取我们想要的格式数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data.txt 应替换成你的文本文件的名称</span></span><br><span class="line"><span class="built_in">print</span>(file2matrix(<span class="string">&#x27;data.txt&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">array([[<span class="number">4.0920000e+04</span>, <span class="number">8.3269760e+00</span>, <span class="number">9.5395200e-01</span>],</span><br><span class="line">       [<span class="number">1.4488000e+04</span>, <span class="number">7.1534690e+00</span>, <span class="number">1.6739040e+00</span>],</span><br><span class="line">       [<span class="number">2.6052000e+04</span>, <span class="number">1.4418710e+00</span>, <span class="number">8.0512400e-01</span>],</span><br><span class="line">       ...,</span><br><span class="line">       [<span class="number">2.6575000e+04</span>, <span class="number">1.0650102e+01</span>, <span class="number">8.6662700e-01</span>],</span><br><span class="line">       [<span class="number">4.8111000e+04</span>, <span class="number">9.1345280e+00</span>, <span class="number">7.2804500e-01</span>],</span><br><span class="line">       [<span class="number">4.3757000e+04</span>, <span class="number">7.8826010e+00</span>, <span class="number">1.3324460e+00</span>]]), [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>,.....省略</span><br></pre></td></tr></table></figure><p>输出结果如上所示即说明正确读取并且转换了格式，接下来我们需要了解数据的真实含义。当然我们可以直接浏览文本文件，但是这种方式非常的不友好，一般来说，我们会采用图形化的方式直观的展示数据。下面来使用<code>python</code>图形化工具来展示数据内容。</p><h2 id="分析数据：绘制图形"><a href="#分析数据：绘制图形" class="headerlink" title="分析数据：绘制图形"></a>分析数据：绘制图形</h2><p>首先按照<code>Matplotlib</code>包，可以通过<code>pip</code>命令安装，也可以通过 PyCharm 或者 Anaconda 来完成安装，安装过程省略。在安装完成后，执行如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 读取数据返回对应格式的数据</span></span><br><span class="line">datingDataMat,datingLabels = file2matrix(<span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建画布</span></span><br><span class="line">fig  = plt.figure()</span><br><span class="line"><span class="comment"># 在画布上创建子图，其格式为1行1列1个子图</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"><span class="comment"># 在子图上绘制点，前者表示x轴数据，后者为y轴数据</span></span><br><span class="line">ax.scatter(datingDataMat[:,<span class="number">1</span>],datingDataMat[:,<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 显示绘图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>其绘制结果如下图所示，其中横轴为：玩视频游戏所消耗时间百分比，纵轴是每周消耗的冰淇淋公升数。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadb89a60c8.png" alt="image-20230708194040311" style="zoom: 67%;" /><p>由于没有使用样本分类的特征值，我们很难从上图中看到任何有用的数据模式信息。现在我们采用彩色或者其他记号来区分样本分类，现在修改上面的代码，使用如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">datingDataMat,datingLabels = file2matrix(<span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line">fig  = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"><span class="comment"># 增加两个参数，第一个参数表示散点的大小，第二个参数表示散点颜色</span></span><br><span class="line">ax.scatter(datingDataMat[:,<span class="number">1</span>],datingDataMat[:,<span class="number">2</span>],<span class="number">10</span>*array(datingLabels),array(datingLabels))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果如下所示，目前来收，可视化的部分将会比之前相对清晰更多了。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadb8e27830.png" alt="image-20230708195025534" style="zoom:67%;" /><h2 id="准备数据：归一化数值"><a href="#准备数据：归一化数值" class="headerlink" title="准备数据：归一化数值"></a>准备数据：归一化数值</h2><table><thead><tr><th align="center">玩视频游戏所耗时间百分比</th><th align="center">每年获得的飞行常客里程数</th><th align="center">每周消费的冰淇淋公升数</th><th align="center">样本分类</th></tr></thead><tbody><tr><td align="center">0.8</td><td align="center">400</td><td align="center">0.5</td><td align="center">1</td></tr><tr><td align="center">12</td><td align="center">134,000</td><td align="center">0.9</td><td align="center">3</td></tr><tr><td align="center">0</td><td align="center">20,000</td><td align="center">1.1</td><td align="center">2</td></tr><tr><td align="center">67</td><td align="center">32,000</td><td align="center">0.1</td><td align="center">2</td></tr></tbody></table><p>上表提取了四组数据，如果我们希望计算样本 3 和样本 4 之间的距离，可以使用公式：$\large \sqrt{(0-67)^2 + (20000-32000)^2 + (1.1-0.1)^2}$  </p><p>我们很容易发现，<strong>上面方程中数字差值最大的属性对计算结果的影响最大</strong>。也就是说，每年获取的飞行常客里程数对于计算结果的影响远远大于上表中的其他两个特征的影响。而<strong>产生这种现象的唯一原因，仅仅是因为飞行常客里程数大于其他特征值</strong>。但是海伦认为它们是同等重要的，因此<strong>作为三个等权重的特征之一，飞行常客里程数不应该如此严重的影响计算结果</strong>。</p><p><strong>处理这种不同取值范围的特征值时</strong>，我们通常采用的方法是<strong>将数字归一化</strong>。例如：将取值范围处理为 0 到 1 或者 -1 到 1 之间。<strong>下面的公式可以将任意取值范围的特征值转换为 0 到 1 区间内的值</strong>：</p><p>$\Large newValue &#x3D; \frac{oldValue - \ min}{max - \ min}$ </p><p>使用<strong>如下公式可以将数值缩放到 1 到 -1 之间</strong>：</p><p>$\Large newValue &#x3D; \frac{(oldValue - \ min) \times 2}{max - \ min} -1$  </p><blockquote><p>请注意，在该公式中如果最小值和最大值相等，则除数为 0，这种情况下可能会出现错误。因此，在实际应用中，需要确保最大值和最小值不相等，或者兼容处理这种特殊情况。</p></blockquote><p>现在我们需要在<code>KNN.py</code>中增加一个新行数<code>autoNorm()</code>，该行数可以自动将数字特征转换为 0 到 1 的区间。代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归一化特征值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">autoNorm</span>(<span class="params">dataSet</span>):</span><br><span class="line">    <span class="comment"># 获取最小值</span></span><br><span class="line">    minVals = dataSet.<span class="built_in">min</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 获取最大值</span></span><br><span class="line">    maxVals = dataSet.<span class="built_in">max</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 获取差异</span></span><br><span class="line">    ranges = maxVals - minVals</span><br><span class="line">    <span class="comment"># 创建同等大小维度的 0 矩阵</span></span><br><span class="line">    normDataSet = zeros(shape(dataSet))</span><br><span class="line">    <span class="comment"># 获取传入矩阵的维度</span></span><br><span class="line">    m = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 获取公式的分子</span></span><br><span class="line">    normDataSet = dataSet - tile(minVals,(m,<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 用获取的分子/分母得到归一化矩阵</span></span><br><span class="line">    normDataSet = normDataSet / tile(ranges,(m,<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 返回归一化矩阵</span></span><br><span class="line">    <span class="keyword">return</span>  normDataSet</span><br></pre></td></tr></table></figure><p>完成归一化后，我们可以使用如下代码测试运行一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">datingDataMat, datingLabels = file2matrix(<span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># 归一化处理输出</span></span><br><span class="line"><span class="built_in">print</span>(autoNorm(datingDataMat))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[[<span class="number">0.44832535</span> <span class="number">0.39805139</span> <span class="number">0.56233353</span>]</span><br><span class="line"> [<span class="number">0.15873259</span> <span class="number">0.34195467</span> <span class="number">0.98724416</span>]</span><br><span class="line"> [<span class="number">0.28542943</span> <span class="number">0.06892523</span> <span class="number">0.47449629</span>]</span><br><span class="line"> ...</span><br><span class="line"> [<span class="number">0.29115949</span> <span class="number">0.50910294</span> <span class="number">0.51079493</span>]</span><br><span class="line"> [<span class="number">0.52711097</span> <span class="number">0.43665451</span> <span class="number">0.4290048</span> ]</span><br><span class="line"> [<span class="number">0.47940793</span> <span class="number">0.3768091</span>  <span class="number">0.78571804</span>]]</span><br></pre></td></tr></table></figure><h2 id="测试算法"><a href="#测试算法" class="headerlink" title="测试算法"></a>测试算法</h2><p>上部分我们已经将数据按照需求进行了处理，现在我们来测试分类器的效果，如果分类器的正确率满足要求，海伦就可以使用这个软件来处理约会网站提供的约会名单。<strong>机器学习算法一个很重要的工作就是评估算法的正确率</strong>，通常我们只提供已有数据的 90% 作为训练样本来训练分类器，而剩余 10% 数据去测试分类器的正确率。</p><p>需要注意的是，10% 的测试数据应该是随机选择的，由于海伦提供的数据没有按照特定目的排序，所以我们可以随意选择 10% 数据而不影响其随机性。</p><p>对于分类器来说，错误率就是分类器给出错误结果的次数除以测试数据的总数，完美分类器的错误率为 0，而错误率为 1 的分类器不会给出任何正确的分类结果。</p><p>为了测试分类器的效果，在<code>KNN.py</code>文件中创建函数<code>datingClassTest</code>，代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试分类器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">datingClassTest</span>():</span><br><span class="line">    <span class="comment"># 测试样本（集合）大小，即测试样本的数量占训练样本的比例</span></span><br><span class="line">    hoRatio = <span class="number">0.10</span></span><br><span class="line">    <span class="comment"># 读取数据，这里的 data.txt 请修改成你的文件名称</span></span><br><span class="line">    datingDataMat,datingLabels = file2matrix(<span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line">    <span class="comment"># 归一化数据</span></span><br><span class="line">    normMat = autoNorm(datingDataMat)</span><br><span class="line">    <span class="comment"># 读取数据维度（行数）</span></span><br><span class="line">    m = normMat.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 统计要测试多少样本</span></span><br><span class="line">    numTestVecs = <span class="built_in">int</span>(m*hoRatio)</span><br><span class="line">    <span class="comment"># 出错数量统计</span></span><br><span class="line">    errorCount = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 根据测试数量进行遍历测试</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numTestVecs):</span><br><span class="line">        <span class="comment"># 进行分类器分类</span></span><br><span class="line">        classifierResult = classify0(normMat[i, :], normMat[numTestVecs:m, :], datingLabels[numTestVecs:m], <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 输出结果</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;分类器分类结果为: %d, 正确答案为: %d&quot;</span> % (classifierResult, datingLabels[i]))</span><br><span class="line">        <span class="comment"># 如果答案错误则记录出错数量</span></span><br><span class="line">        <span class="keyword">if</span> classifierResult != datingLabels[i]:</span><br><span class="line">            errorCount += <span class="number">1.0</span></span><br><span class="line">    <span class="comment"># 统计最终的出错率</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;分类器最终出错率为: %f&quot;</span> % (errorCount / <span class="built_in">float</span>(numTestVecs)))</span><br><span class="line">    <span class="comment"># 出错数量</span></span><br><span class="line">    <span class="built_in">print</span>(errorCount)</span><br></pre></td></tr></table></figure><p>运行测试结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">datingClassTest()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">....</span><br><span class="line">分类器分类结果为: <span class="number">2</span>, 正确答案为: <span class="number">2</span></span><br><span class="line">分类器分类结果为: <span class="number">1</span>, 正确答案为: <span class="number">1</span></span><br><span class="line">分类器分类结果为: <span class="number">3</span>, 正确答案为: <span class="number">3</span></span><br><span class="line">分类器分类结果为: <span class="number">3</span>, 正确答案为: <span class="number">3</span></span><br><span class="line">分类器分类结果为: <span class="number">2</span>, 正确答案为: <span class="number">2</span></span><br><span class="line">分类器分类结果为: <span class="number">1</span>, 正确答案为: <span class="number">1</span></span><br><span class="line">分类器分类结果为: <span class="number">3</span>, 正确答案为: <span class="number">1</span></span><br><span class="line">分类器最终出错率为: <span class="number">0.050000</span></span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure><p>这个分类器处理约会数据集的错误率是 5%，这是一个不错的结果。同理可以改变<code>hoRation</code>和变量<code>k</code>的值，可以测试错误率是否会因为参数的改变而发生改变。</p><h1 id="相关函数说明"><a href="#相关函数说明" class="headerlink" title="相关函数说明"></a>相关函数说明</h1><h2 id="array"><a href="#array" class="headerlink" title="array()"></a><code>array()</code></h2><p><code>array()</code>是一个函数，是 NumPy 库中的一个函数。它用于将输入的数据转换为 NumPy 数组。</p><p><code>array()</code>函数的参数可以是 Python 的序列对象（例如列表、元组），也可以是 Python 的迭代器对象（例如 range对象）。它会将输入的数据转换为 NumPy 数组，并返回一个包含输入数据的新的 NumPy 数组。</p><p>可以通过如下代码创建 NumPy 的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 NumPy 包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建列表</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment"># 转换成 NumPy 数组</span></span><br><span class="line">np.array(a)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h2 id="shape"><a href="#shape" class="headerlink" title="shape[]"></a><code>shape[]</code></h2><p><code>shape[]</code>是用来<strong>获取 NumPy 数组的形状信息的属性</strong>。</p><p>在 NumPy 中，每个数组都有一个<strong>形状（shape），用于描述数组的维度和各个维度的大小</strong>。<code>shape[]</code>可以用于查看数组的形状。它返回一个元组，其中包含数组的维度信息。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="built_in">print</span>(np.array(a).shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：(2, 4)</span></span><br></pre></td></tr></table></figure><p>其输出结果表示该数组有两个维度，每个维度有四个向量。</p><h2 id="tile"><a href="#tile" class="headerlink" title="tile()"></a><code>tile()</code></h2><p><code>tile()</code>是NumPy库中的一个函数，<strong>用于在指定方向上复制多个副本来扩展数组</strong>。</p><p>这个函数的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.tile(arr, reps)</span><br></pre></td></tr></table></figure><p>其中，<code>arr</code>是被复制的数组，<code>reps</code>是指定复制次数的参数。</p><p><code>reps</code>参数可以有不同的形式：</p><ul><li>若<code>reps</code>是一个整数，则表示在各个维度上复制的次数都相同。</li><li>若<code>reps</code>是一个元组，则表示在各个维度上复制的次数可以不同，元组的长度应该和<code>arr</code>数组的维度一致。</li></ul><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">my_array = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># 表示矩阵 my_array 复制两个维度（行），每个维度复制一份</span></span><br><span class="line">tiled_array = np.tile(my_array, [<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tiled_array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[[1 2 3] [1 2 3]]</span></span><br></pre></td></tr></table></figure><h2 id="argsort"><a href="#argsort" class="headerlink" title="argsort()"></a><code>argsort()</code></h2><p><code>argsort()</code>是NumPy库中的一个函数，用于返回数组排序后的索引。</p><p>这个函数的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.argsort(arr, axis=-<span class="number">1</span>, kind=<span class="string">&#x27;quicksort&#x27;</span>, order=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>其中，<code>arr</code>是待排序的数组，<code>axis</code>表示按照哪个轴进行排序（默认为最后一个轴），<code>kind</code>表示排序算法的类型（默认为快速排序），<code>order</code>是指定排序的字段。</p><p><strong><code>argsort()</code>函数返回一个索引数组，这个数组显示了对输入数组进行排序后的索引顺序</strong>。该索引数组可以用于根据排序结果来访问原始数据。</p><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">my_array = np.array([<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>])</span><br><span class="line">sorted_indices = np.argsort(my_array)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sorted_indices)  <span class="comment"># 输出: [2 0 4 1 3]</span></span><br><span class="line"><span class="built_in">print</span>(my_array[sorted_indices])  <span class="comment"># 输出: [1 2 4 5 8]</span></span><br></pre></td></tr></table></figure><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a><code>sorted()</code></h2><p><code>sorted()</code>是Python内置函数，<strong>用于对可迭代对象进行排序</strong>。</p><p>该函数的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(iterable, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>其中，<code>iterable</code>是要进行排序的可迭代对象，如列表、元组等。<code>key</code>是可选参数，用于指定排序的关键字（例如，根据某个属性或函数的返回值进行排序）。<code>reverse</code>是一个布尔值，表示是否按降序排序（默认为升序排序）。</p><p><code>sorted()</code>函数会返回一个新的已排序的列表，而不会修改原始可迭代对象。</p><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">sorted_list = <span class="built_in">sorted</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sorted_list)  <span class="comment"># 输出: [1, 2, 4, 5, 8]</span></span><br></pre></td></tr></table></figure><h2 id="add-subplot"><a href="#add-subplot" class="headerlink" title="add_subplot()"></a><code>add_subplot()</code></h2><p><code>fig.add_subplot()</code>是用于在一个图形对象中创建子图（subplot）的方法。<strong>它允许我们在一个图形窗口中显示多个子图，每个子图可以具有自己的特点和设置</strong>。</p><p><code>fig.add_subplot()</code>方法的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig.add_subplot(nrows, ncols, index)</span><br></pre></td></tr></table></figure><p>其中，<code>nrows</code>和<code>ncols</code>是整数，用于指定子图的行数和列数。<code>index</code>是一个整数或一个3位的数字，用于指定子图在整个图形对象中的位置。子图的位置是从左到右，从上到下计数的。</p><h2 id="scatter"><a href="#scatter" class="headerlink" title="scatter()"></a><code>scatter()</code></h2><p><code>scatter()</code>函数是Matplotlib库中用于创建散点图的函数。</p><p>它的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scatter(x, y, s=<span class="literal">None</span>, c=<span class="literal">None</span>, marker=<span class="literal">None</span>, cmap=<span class="literal">None</span>, alpha=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>x</code>：x轴的数据，可以是列表、数组或Series。</li><li><code>y</code>：y轴的数据，可以是列表、数组或Series。</li><li><code>s</code>（可选）：散点的大小。可以是一个标量值或与<code>x</code>和<code>y</code>长度相同的数组。</li><li><code>c</code>（可选）：散点的颜色。可以是一个颜色名称的字符串，或一个颜色名称的列表，或与<code>x</code>和<code>y</code>长度相同的数组。</li><li><code>marker</code>（可选）：散点的标记形状。例如，’o’表示圆形，’^’表示三角形。默认为’o’。</li><li><code>cmap</code>（可选）：颜色映射，用于将数值映射到颜色。只在<code>c</code>参数为数值时使用。</li><li><code>alpha</code>（可选）：散点的透明度，取值范围为[0, 1]。默认为1（不透明）。</li></ul><h1 id="相关数据"><a href="#相关数据" class="headerlink" title="相关数据"></a>相关数据</h1><h2 id="海伦的约会数据"><a href="#海伦的约会数据" class="headerlink" title="海伦的约会数据"></a>海伦的约会数据</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">40920</span><span class="number">8.326976</span><span class="number">0.953952</span><span class="number">3</span></span><br><span class="line"><span class="number">14488</span><span class="number">7.153469</span><span class="number">1.673904</span><span class="number">2</span></span><br><span class="line"><span class="number">26052</span><span class="number">1.441871</span><span class="number">0.805124</span><span class="number">1</span></span><br><span class="line"><span class="number">75136</span><span class="number">13.147394</span><span class="number">0.428964</span><span class="number">1</span></span><br><span class="line"><span class="number">38344</span><span class="number">1.669788</span><span class="number">0.134296</span><span class="number">1</span></span><br><span class="line"><span class="number">72993</span><span class="number">10.141740</span><span class="number">1.032955</span><span class="number">1</span></span><br><span class="line"><span class="number">35948</span><span class="number">6.830792</span><span class="number">1.213192</span><span class="number">3</span></span><br><span class="line"><span class="number">42666</span><span class="number">13.276369</span><span class="number">0.543880</span><span class="number">3</span></span><br><span class="line"><span class="number">67497</span><span class="number">8.631577</span><span class="number">0.749278</span><span class="number">1</span></span><br><span class="line"><span class="number">35483</span><span class="number">12.273169</span><span class="number">1.508053</span><span class="number">3</span></span><br><span class="line"><span class="number">50242</span><span class="number">3.723498</span><span class="number">0.831917</span><span class="number">1</span></span><br><span class="line"><span class="number">63275</span><span class="number">8.385879</span><span class="number">1.669485</span><span class="number">1</span></span><br><span class="line"><span class="number">5569</span><span class="number">4.875435</span><span class="number">0.728658</span><span class="number">2</span></span><br><span class="line"><span class="number">51052</span><span class="number">4.680098</span><span class="number">0.625224</span><span class="number">1</span></span><br><span class="line"><span class="number">77372</span><span class="number">15.299570</span><span class="number">0.331351</span><span class="number">1</span></span><br><span class="line"><span class="number">43673</span><span class="number">1.889461</span><span class="number">0.191283</span><span class="number">1</span></span><br><span class="line"><span class="number">61364</span><span class="number">7.516754</span><span class="number">1.269164</span><span class="number">1</span></span><br><span class="line"><span class="number">69673</span><span class="number">14.239195</span><span class="number">0.261333</span><span class="number">1</span></span><br><span class="line"><span class="number">15669</span><span class="number">0.000000</span><span class="number">1.250185</span><span class="number">2</span></span><br><span class="line"><span class="number">28488</span><span class="number">10.528555</span><span class="number">1.304844</span><span class="number">3</span></span><br><span class="line"><span class="number">6487</span><span class="number">3.540265</span><span class="number">0.822483</span><span class="number">2</span></span><br><span class="line"><span class="number">37708</span><span class="number">2.991551</span><span class="number">0.833920</span><span class="number">1</span></span><br><span class="line"><span class="number">22620</span><span class="number">5.297865</span><span class="number">0.638306</span><span class="number">2</span></span><br><span class="line"><span class="number">28782</span><span class="number">6.593803</span><span class="number">0.187108</span><span class="number">3</span></span><br><span class="line"><span class="number">19739</span><span class="number">2.816760</span><span class="number">1.686209</span><span class="number">2</span></span><br><span class="line"><span class="number">36788</span><span class="number">12.458258</span><span class="number">0.649617</span><span class="number">3</span></span><br><span class="line"><span class="number">5741</span><span class="number">0.000000</span><span class="number">1.656418</span><span class="number">2</span></span><br><span class="line"><span class="number">28567</span><span class="number">9.968648</span><span class="number">0.731232</span><span class="number">3</span></span><br><span class="line"><span class="number">6808</span><span class="number">1.364838</span><span class="number">0.640103</span><span class="number">2</span></span><br><span class="line"><span class="number">41611</span><span class="number">0.230453</span><span class="number">1.151996</span><span class="number">1</span></span><br><span class="line"><span class="number">36661</span><span class="number">11.865402</span><span class="number">0.882810</span><span class="number">3</span></span><br><span class="line"><span class="number">43605</span><span class="number">0.120460</span><span class="number">1.352013</span><span class="number">1</span></span><br><span class="line"><span class="number">15360</span><span class="number">8.545204</span><span class="number">1.340429</span><span class="number">3</span></span><br><span class="line"><span class="number">63796</span><span class="number">5.856649</span><span class="number">0.160006</span><span class="number">1</span></span><br><span class="line"><span class="number">10743</span><span class="number">9.665618</span><span class="number">0.778626</span><span class="number">2</span></span><br><span class="line"><span class="number">70808</span><span class="number">9.778763</span><span class="number">1.084103</span><span class="number">1</span></span><br><span class="line"><span class="number">72011</span><span class="number">4.932976</span><span class="number">0.632026</span><span class="number">1</span></span><br><span class="line"><span class="number">5914</span><span class="number">2.216246</span><span class="number">0.587095</span><span class="number">2</span></span><br><span class="line"><span class="number">14851</span><span class="number">14.305636</span><span class="number">0.632317</span><span class="number">3</span></span><br><span class="line"><span class="number">33553</span><span class="number">12.591889</span><span class="number">0.686581</span><span class="number">3</span></span><br><span class="line"><span class="number">44952</span><span class="number">3.424649</span><span class="number">1.004504</span><span class="number">1</span></span><br><span class="line"><span class="number">17934</span><span class="number">0.000000</span><span class="number">0.147573</span><span class="number">2</span></span><br><span class="line"><span class="number">27738</span><span class="number">8.533823</span><span class="number">0.205324</span><span class="number">3</span></span><br><span class="line"><span class="number">29290</span><span class="number">9.829528</span><span class="number">0.238620</span><span class="number">3</span></span><br><span class="line"><span class="number">42330</span><span class="number">11.492186</span><span class="number">0.263499</span><span class="number">3</span></span><br><span class="line"><span class="number">36429</span><span class="number">3.570968</span><span class="number">0.832254</span><span class="number">1</span></span><br><span class="line"><span class="number">39623</span><span class="number">1.771228</span><span class="number">0.207612</span><span class="number">1</span></span><br><span class="line"><span class="number">32404</span><span class="number">3.513921</span><span class="number">0.991854</span><span class="number">1</span></span><br><span class="line"><span class="number">27268</span><span class="number">4.398172</span><span class="number">0.975024</span><span class="number">1</span></span><br><span class="line"><span class="number">5477</span><span class="number">4.276823</span><span class="number">1.174874</span><span class="number">2</span></span><br><span class="line"><span class="number">14254</span><span class="number">5.946014</span><span class="number">1.614244</span><span class="number">2</span></span><br><span class="line"><span class="number">68613</span><span class="number">13.798970</span><span class="number">0.724375</span><span class="number">1</span></span><br><span class="line"><span class="number">41539</span><span class="number">10.393591</span><span class="number">1.663724</span><span class="number">3</span></span><br><span class="line"><span class="number">7917</span><span class="number">3.007577</span><span class="number">0.297302</span><span class="number">2</span></span><br><span class="line"><span class="number">21331</span><span class="number">1.031938</span><span class="number">0.486174</span><span class="number">2</span></span><br><span class="line"><span class="number">8338</span><span class="number">4.751212</span><span class="number">0.064693</span><span class="number">2</span></span><br><span class="line"><span class="number">5176</span><span class="number">3.692269</span><span class="number">1.655113</span><span class="number">2</span></span><br><span class="line"><span class="number">18983</span><span class="number">10.448091</span><span class="number">0.267652</span><span class="number">3</span></span><br><span class="line"><span class="number">68837</span><span class="number">10.585786</span><span class="number">0.329557</span><span class="number">1</span></span><br><span class="line"><span class="number">13438</span><span class="number">1.604501</span><span class="number">0.069064</span><span class="number">2</span></span><br><span class="line"><span class="number">48849</span><span class="number">3.679497</span><span class="number">0.961466</span><span class="number">1</span></span><br><span class="line"><span class="number">12285</span><span class="number">3.795146</span><span class="number">0.696694</span><span class="number">2</span></span><br><span class="line"><span class="number">7826</span><span class="number">2.531885</span><span class="number">1.659173</span><span class="number">2</span></span><br><span class="line"><span class="number">5565</span><span class="number">9.733340</span><span class="number">0.977746</span><span class="number">2</span></span><br><span class="line"><span class="number">10346</span><span class="number">6.093067</span><span class="number">1.413798</span><span class="number">2</span></span><br><span class="line"><span class="number">1823</span><span class="number">7.712960</span><span class="number">1.054927</span><span class="number">2</span></span><br><span class="line"><span class="number">9744</span><span class="number">11.470364</span><span class="number">0.760461</span><span class="number">3</span></span><br><span class="line"><span class="number">16857</span><span class="number">2.886529</span><span class="number">0.934416</span><span class="number">2</span></span><br><span class="line"><span class="number">39336</span><span class="number">10.054373</span><span class="number">1.138351</span><span class="number">3</span></span><br><span class="line"><span class="number">65230</span><span class="number">9.972470</span><span class="number">0.881876</span><span class="number">1</span></span><br><span class="line"><span class="number">2463</span><span class="number">2.335785</span><span class="number">1.366145</span><span class="number">2</span></span><br><span class="line"><span class="number">27353</span><span class="number">11.375155</span><span class="number">1.528626</span><span class="number">3</span></span><br><span class="line"><span class="number">16191</span><span class="number">0.000000</span><span class="number">0.605619</span><span class="number">2</span></span><br><span class="line"><span class="number">12258</span><span class="number">4.126787</span><span class="number">0.357501</span><span class="number">2</span></span><br><span class="line"><span class="number">42377</span><span class="number">6.319522</span><span class="number">1.058602</span><span class="number">1</span></span><br><span class="line"><span class="number">25607</span><span class="number">8.680527</span><span class="number">0.086955</span><span class="number">3</span></span><br><span class="line"><span class="number">77450</span><span class="number">14.856391</span><span class="number">1.129823</span><span class="number">1</span></span><br><span class="line"><span class="number">58732</span><span class="number">2.454285</span><span class="number">0.222380</span><span class="number">1</span></span><br><span class="line"><span class="number">46426</span><span class="number">7.292202</span><span class="number">0.548607</span><span class="number">3</span></span><br><span class="line"><span class="number">32688</span><span class="number">8.745137</span><span class="number">0.857348</span><span class="number">3</span></span><br><span class="line"><span class="number">64890</span><span class="number">8.579001</span><span class="number">0.683048</span><span class="number">1</span></span><br><span class="line"><span class="number">8554</span><span class="number">2.507302</span><span class="number">0.869177</span><span class="number">2</span></span><br><span class="line"><span class="number">28861</span><span class="number">11.415476</span><span class="number">1.505466</span><span class="number">3</span></span><br><span class="line"><span class="number">42050</span><span class="number">4.838540</span><span class="number">1.680892</span><span class="number">1</span></span><br><span class="line"><span class="number">32193</span><span class="number">10.339507</span><span class="number">0.583646</span><span class="number">3</span></span><br><span class="line"><span class="number">64895</span><span class="number">6.573742</span><span class="number">1.151433</span><span class="number">1</span></span><br><span class="line"><span class="number">2355</span><span class="number">6.539397</span><span class="number">0.462065</span><span class="number">2</span></span><br><span class="line"><span class="number">0</span><span class="number">2.209159</span><span class="number">0.723567</span><span class="number">2</span></span><br><span class="line"><span class="number">70406</span><span class="number">11.196378</span><span class="number">0.836326</span><span class="number">1</span></span><br><span class="line"><span class="number">57399</span><span class="number">4.229595</span><span class="number">0.128253</span><span class="number">1</span></span><br><span class="line"><span class="number">41732</span><span class="number">9.505944</span><span class="number">0.005273</span><span class="number">3</span></span><br><span class="line"><span class="number">11429</span><span class="number">8.652725</span><span class="number">1.348934</span><span class="number">3</span></span><br><span class="line"><span class="number">75270</span><span class="number">17.101108</span><span class="number">0.490712</span><span class="number">1</span></span><br><span class="line"><span class="number">5459</span><span class="number">7.871839</span><span class="number">0.717662</span><span class="number">2</span></span><br><span class="line"><span class="number">73520</span><span class="number">8.262131</span><span class="number">1.361646</span><span class="number">1</span></span><br><span class="line"><span class="number">40279</span><span class="number">9.015635</span><span class="number">1.658555</span><span class="number">3</span></span><br><span class="line"><span class="number">21540</span><span class="number">9.215351</span><span class="number">0.806762</span><span class="number">3</span></span><br><span class="line"><span class="number">17694</span><span class="number">6.375007</span><span class="number">0.033678</span><span class="number">2</span></span><br><span class="line"><span class="number">22329</span><span class="number">2.262014</span><span class="number">1.022169</span><span class="number">1</span></span><br><span class="line"><span class="number">46570</span><span class="number">5.677110</span><span class="number">0.709469</span><span class="number">1</span></span><br><span class="line"><span class="number">42403</span><span class="number">11.293017</span><span class="number">0.207976</span><span class="number">3</span></span><br><span class="line"><span class="number">33654</span><span class="number">6.590043</span><span class="number">1.353117</span><span class="number">1</span></span><br><span class="line"><span class="number">9171</span><span class="number">4.711960</span><span class="number">0.194167</span><span class="number">2</span></span><br><span class="line"><span class="number">28122</span><span class="number">8.768099</span><span class="number">1.108041</span><span class="number">3</span></span><br><span class="line"><span class="number">34095</span><span class="number">11.502519</span><span class="number">0.545097</span><span class="number">3</span></span><br><span class="line"><span class="number">1774</span><span class="number">4.682812</span><span class="number">0.578112</span><span class="number">2</span></span><br><span class="line"><span class="number">40131</span><span class="number">12.446578</span><span class="number">0.300754</span><span class="number">3</span></span><br><span class="line"><span class="number">13994</span><span class="number">12.908384</span><span class="number">1.657722</span><span class="number">3</span></span><br><span class="line"><span class="number">77064</span><span class="number">12.601108</span><span class="number">0.974527</span><span class="number">1</span></span><br><span class="line"><span class="number">11210</span><span class="number">3.929456</span><span class="number">0.025466</span><span class="number">2</span></span><br><span class="line"><span class="number">6122</span><span class="number">9.751503</span><span class="number">1.182050</span><span class="number">3</span></span><br><span class="line"><span class="number">15341</span><span class="number">3.043767</span><span class="number">0.888168</span><span class="number">2</span></span><br><span class="line"><span class="number">44373</span><span class="number">4.391522</span><span class="number">0.807100</span><span class="number">1</span></span><br><span class="line"><span class="number">28454</span><span class="number">11.695276</span><span class="number">0.679015</span><span class="number">3</span></span><br><span class="line"><span class="number">63771</span><span class="number">7.879742</span><span class="number">0.154263</span><span class="number">1</span></span><br><span class="line"><span class="number">9217</span><span class="number">5.613163</span><span class="number">0.933632</span><span class="number">2</span></span><br><span class="line"><span class="number">69076</span><span class="number">9.140172</span><span class="number">0.851300</span><span class="number">1</span></span><br><span class="line"><span class="number">24489</span><span class="number">4.258644</span><span class="number">0.206892</span><span class="number">1</span></span><br><span class="line"><span class="number">16871</span><span class="number">6.799831</span><span class="number">1.221171</span><span class="number">2</span></span><br><span class="line"><span class="number">39776</span><span class="number">8.752758</span><span class="number">0.484418</span><span class="number">3</span></span><br><span class="line"><span class="number">5901</span><span class="number">1.123033</span><span class="number">1.180352</span><span class="number">2</span></span><br><span class="line"><span class="number">40987</span><span class="number">10.833248</span><span class="number">1.585426</span><span class="number">3</span></span><br><span class="line"><span class="number">7479</span><span class="number">3.051618</span><span class="number">0.026781</span><span class="number">2</span></span><br><span class="line"><span class="number">38768</span><span class="number">5.308409</span><span class="number">0.030683</span><span class="number">3</span></span><br><span class="line"><span class="number">4933</span><span class="number">1.841792</span><span class="number">0.028099</span><span class="number">2</span></span><br><span class="line"><span class="number">32311</span><span class="number">2.261978</span><span class="number">1.605603</span><span class="number">1</span></span><br><span class="line"><span class="number">26501</span><span class="number">11.573696</span><span class="number">1.061347</span><span class="number">3</span></span><br><span class="line"><span class="number">37433</span><span class="number">8.038764</span><span class="number">1.083910</span><span class="number">3</span></span><br><span class="line"><span class="number">23503</span><span class="number">10.734007</span><span class="number">0.103715</span><span class="number">3</span></span><br><span class="line"><span class="number">68607</span><span class="number">9.661909</span><span class="number">0.350772</span><span class="number">1</span></span><br><span class="line"><span class="number">27742</span><span class="number">9.005850</span><span class="number">0.548737</span><span class="number">3</span></span><br><span class="line"><span class="number">11303</span><span class="number">0.000000</span><span class="number">0.539131</span><span class="number">2</span></span><br><span class="line"><span class="number">0</span><span class="number">5.757140</span><span class="number">1.062373</span><span class="number">2</span></span><br><span class="line"><span class="number">32729</span><span class="number">9.164656</span><span class="number">1.624565</span><span class="number">3</span></span><br><span class="line"><span class="number">24619</span><span class="number">1.318340</span><span class="number">1.436243</span><span class="number">1</span></span><br><span class="line"><span class="number">42414</span><span class="number">14.075597</span><span class="number">0.695934</span><span class="number">3</span></span><br><span class="line"><span class="number">20210</span><span class="number">10.107550</span><span class="number">1.308398</span><span class="number">3</span></span><br><span class="line"><span class="number">33225</span><span class="number">7.960293</span><span class="number">1.219760</span><span class="number">3</span></span><br><span class="line"><span class="number">54483</span><span class="number">6.317292</span><span class="number">0.018209</span><span class="number">1</span></span><br><span class="line"><span class="number">18475</span><span class="number">12.664194</span><span class="number">0.595653</span><span class="number">3</span></span><br><span class="line"><span class="number">33926</span><span class="number">2.906644</span><span class="number">0.581657</span><span class="number">1</span></span><br><span class="line"><span class="number">43865</span><span class="number">2.388241</span><span class="number">0.913938</span><span class="number">1</span></span><br><span class="line"><span class="number">26547</span><span class="number">6.024471</span><span class="number">0.486215</span><span class="number">3</span></span><br><span class="line"><span class="number">44404</span><span class="number">7.226764</span><span class="number">1.255329</span><span class="number">3</span></span><br><span class="line"><span class="number">16674</span><span class="number">4.183997</span><span class="number">1.275290</span><span class="number">2</span></span><br><span class="line"><span class="number">8123</span><span class="number">11.850211</span><span class="number">1.096981</span><span class="number">3</span></span><br><span class="line"><span class="number">42747</span><span class="number">11.661797</span><span class="number">1.167935</span><span class="number">3</span></span><br><span class="line"><span class="number">56054</span><span class="number">3.574967</span><span class="number">0.494666</span><span class="number">1</span></span><br><span class="line"><span class="number">10933</span><span class="number">0.000000</span><span class="number">0.107475</span><span class="number">2</span></span><br><span class="line"><span class="number">18121</span><span class="number">7.937657</span><span class="number">0.904799</span><span class="number">3</span></span><br><span class="line"><span class="number">11272</span><span class="number">3.365027</span><span class="number">1.014085</span><span class="number">2</span></span><br><span class="line"><span class="number">16297</span><span class="number">0.000000</span><span class="number">0.367491</span><span class="number">2</span></span><br><span class="line"><span class="number">28168</span><span class="number">13.860672</span><span class="number">1.293270</span><span class="number">3</span></span><br><span class="line"><span class="number">40963</span><span class="number">10.306714</span><span class="number">1.211594</span><span class="number">3</span></span><br><span class="line"><span class="number">31685</span><span class="number">7.228002</span><span class="number">0.670670</span><span class="number">3</span></span><br><span class="line"><span class="number">55164</span><span class="number">4.508740</span><span class="number">1.036192</span><span class="number">1</span></span><br><span class="line"><span class="number">17595</span><span class="number">0.366328</span><span class="number">0.163652</span><span class="number">2</span></span><br><span class="line"><span class="number">1862</span><span class="number">3.299444</span><span class="number">0.575152</span><span class="number">2</span></span><br><span class="line"><span class="number">57087</span><span class="number">0.573287</span><span class="number">0.607915</span><span class="number">1</span></span><br><span class="line"><span class="number">63082</span><span class="number">9.183738</span><span class="number">0.012280</span><span class="number">1</span></span><br><span class="line"><span class="number">51213</span><span class="number">7.842646</span><span class="number">1.060636</span><span class="number">3</span></span><br><span class="line"><span class="number">6487</span><span class="number">4.750964</span><span class="number">0.558240</span><span class="number">2</span></span><br><span class="line"><span class="number">4805</span><span class="number">11.438702</span><span class="number">1.556334</span><span class="number">3</span></span><br><span class="line"><span class="number">30302</span><span class="number">8.243063</span><span class="number">1.122768</span><span class="number">3</span></span><br><span class="line"><span class="number">68680</span><span class="number">7.949017</span><span class="number">0.271865</span><span class="number">1</span></span><br><span class="line"><span class="number">17591</span><span class="number">7.875477</span><span class="number">0.227085</span><span class="number">2</span></span><br><span class="line"><span class="number">74391</span><span class="number">9.569087</span><span class="number">0.364856</span><span class="number">1</span></span><br><span class="line"><span class="number">37217</span><span class="number">7.750103</span><span class="number">0.869094</span><span class="number">3</span></span><br><span class="line"><span class="number">42814</span><span class="number">0.000000</span><span class="number">1.515293</span><span class="number">1</span></span><br><span class="line"><span class="number">14738</span><span class="number">3.396030</span><span class="number">0.633977</span><span class="number">2</span></span><br><span class="line"><span class="number">19896</span><span class="number">11.916091</span><span class="number">0.025294</span><span class="number">3</span></span><br><span class="line"><span class="number">14673</span><span class="number">0.460758</span><span class="number">0.689586</span><span class="number">2</span></span><br><span class="line"><span class="number">32011</span><span class="number">13.087566</span><span class="number">0.476002</span><span class="number">3</span></span><br><span class="line"><span class="number">58736</span><span class="number">4.589016</span><span class="number">1.672600</span><span class="number">1</span></span><br><span class="line"><span class="number">54744</span><span class="number">8.397217</span><span class="number">1.534103</span><span class="number">1</span></span><br><span class="line"><span class="number">29482</span><span class="number">5.562772</span><span class="number">1.689388</span><span class="number">1</span></span><br><span class="line"><span class="number">27698</span><span class="number">10.905159</span><span class="number">0.619091</span><span class="number">3</span></span><br><span class="line"><span class="number">11443</span><span class="number">1.311441</span><span class="number">1.169887</span><span class="number">2</span></span><br><span class="line"><span class="number">56117</span><span class="number">10.647170</span><span class="number">0.980141</span><span class="number">3</span></span><br><span class="line"><span class="number">39514</span><span class="number">0.000000</span><span class="number">0.481918</span><span class="number">1</span></span><br><span class="line"><span class="number">26627</span><span class="number">8.503025</span><span class="number">0.830861</span><span class="number">3</span></span><br><span class="line"><span class="number">16525</span><span class="number">0.436880</span><span class="number">1.395314</span><span class="number">2</span></span><br><span class="line"><span class="number">24368</span><span class="number">6.127867</span><span class="number">1.102179</span><span class="number">1</span></span><br><span class="line"><span class="number">22160</span><span class="number">12.112492</span><span class="number">0.359680</span><span class="number">3</span></span><br><span class="line"><span class="number">6030</span><span class="number">1.264968</span><span class="number">1.141582</span><span class="number">2</span></span><br><span class="line"><span class="number">6468</span><span class="number">6.067568</span><span class="number">1.327047</span><span class="number">2</span></span><br><span class="line"><span class="number">22945</span><span class="number">8.010964</span><span class="number">1.681648</span><span class="number">3</span></span><br><span class="line"><span class="number">18520</span><span class="number">3.791084</span><span class="number">0.304072</span><span class="number">2</span></span><br><span class="line"><span class="number">34914</span><span class="number">11.773195</span><span class="number">1.262621</span><span class="number">3</span></span><br><span class="line"><span class="number">6121</span><span class="number">8.339588</span><span class="number">1.443357</span><span class="number">2</span></span><br><span class="line"><span class="number">38063</span><span class="number">2.563092</span><span class="number">1.464013</span><span class="number">1</span></span><br><span class="line"><span class="number">23410</span><span class="number">5.954216</span><span class="number">0.953782</span><span class="number">1</span></span><br><span class="line"><span class="number">35073</span><span class="number">9.288374</span><span class="number">0.767318</span><span class="number">3</span></span><br><span class="line"><span class="number">52914</span><span class="number">3.976796</span><span class="number">1.043109</span><span class="number">1</span></span><br><span class="line"><span class="number">16801</span><span class="number">8.585227</span><span class="number">1.455708</span><span class="number">3</span></span><br><span class="line"><span class="number">9533</span><span class="number">1.271946</span><span class="number">0.796506</span><span class="number">2</span></span><br><span class="line"><span class="number">16721</span><span class="number">0.000000</span><span class="number">0.242778</span><span class="number">2</span></span><br><span class="line"><span class="number">5832</span><span class="number">0.000000</span><span class="number">0.089749</span><span class="number">2</span></span><br><span class="line"><span class="number">44591</span><span class="number">11.521298</span><span class="number">0.300860</span><span class="number">3</span></span><br><span class="line"><span class="number">10143</span><span class="number">1.139447</span><span class="number">0.415373</span><span class="number">2</span></span><br><span class="line"><span class="number">21609</span><span class="number">5.699090</span><span class="number">1.391892</span><span class="number">2</span></span><br><span class="line"><span class="number">23817</span><span class="number">2.449378</span><span class="number">1.322560</span><span class="number">1</span></span><br><span class="line"><span class="number">15640</span><span class="number">0.000000</span><span class="number">1.228380</span><span class="number">2</span></span><br><span class="line"><span class="number">8847</span><span class="number">3.168365</span><span class="number">0.053993</span><span class="number">2</span></span><br><span class="line"><span class="number">50939</span><span class="number">10.428610</span><span class="number">1.126257</span><span class="number">3</span></span><br><span class="line"><span class="number">28521</span><span class="number">2.943070</span><span class="number">1.446816</span><span class="number">1</span></span><br><span class="line"><span class="number">32901</span><span class="number">10.441348</span><span class="number">0.975283</span><span class="number">3</span></span><br><span class="line"><span class="number">42850</span><span class="number">12.478764</span><span class="number">1.628726</span><span class="number">3</span></span><br><span class="line"><span class="number">13499</span><span class="number">5.856902</span><span class="number">0.363883</span><span class="number">2</span></span><br><span class="line"><span class="number">40345</span><span class="number">2.476420</span><span class="number">0.096075</span><span class="number">1</span></span><br><span class="line"><span class="number">43547</span><span class="number">1.826637</span><span class="number">0.811457</span><span class="number">1</span></span><br><span class="line"><span class="number">70758</span><span class="number">4.324451</span><span class="number">0.328235</span><span class="number">1</span></span><br><span class="line"><span class="number">19780</span><span class="number">1.376085</span><span class="number">1.178359</span><span class="number">2</span></span><br><span class="line"><span class="number">44484</span><span class="number">5.342462</span><span class="number">0.394527</span><span class="number">1</span></span><br><span class="line"><span class="number">54462</span><span class="number">11.835521</span><span class="number">0.693301</span><span class="number">3</span></span><br><span class="line"><span class="number">20085</span><span class="number">12.423687</span><span class="number">1.424264</span><span class="number">3</span></span><br><span class="line"><span class="number">42291</span><span class="number">12.161273</span><span class="number">0.071131</span><span class="number">3</span></span><br><span class="line"><span class="number">47550</span><span class="number">8.148360</span><span class="number">1.649194</span><span class="number">3</span></span><br><span class="line"><span class="number">11938</span><span class="number">1.531067</span><span class="number">1.549756</span><span class="number">2</span></span><br><span class="line"><span class="number">40699</span><span class="number">3.200912</span><span class="number">0.309679</span><span class="number">1</span></span><br><span class="line"><span class="number">70908</span><span class="number">8.862691</span><span class="number">0.530506</span><span class="number">1</span></span><br><span class="line"><span class="number">73989</span><span class="number">6.370551</span><span class="number">0.369350</span><span class="number">1</span></span><br><span class="line"><span class="number">11872</span><span class="number">2.468841</span><span class="number">0.145060</span><span class="number">2</span></span><br><span class="line"><span class="number">48463</span><span class="number">11.054212</span><span class="number">0.141508</span><span class="number">3</span></span><br><span class="line"><span class="number">15987</span><span class="number">2.037080</span><span class="number">0.715243</span><span class="number">2</span></span><br><span class="line"><span class="number">70036</span><span class="number">13.364030</span><span class="number">0.549972</span><span class="number">1</span></span><br><span class="line"><span class="number">32967</span><span class="number">10.249135</span><span class="number">0.192735</span><span class="number">3</span></span><br><span class="line"><span class="number">63249</span><span class="number">10.464252</span><span class="number">1.669767</span><span class="number">1</span></span><br><span class="line"><span class="number">42795</span><span class="number">9.424574</span><span class="number">0.013725</span><span class="number">3</span></span><br><span class="line"><span class="number">14459</span><span class="number">4.458902</span><span class="number">0.268444</span><span class="number">2</span></span><br><span class="line"><span class="number">19973</span><span class="number">0.000000</span><span class="number">0.575976</span><span class="number">2</span></span><br><span class="line"><span class="number">5494</span><span class="number">9.686082</span><span class="number">1.029808</span><span class="number">3</span></span><br><span class="line"><span class="number">67902</span><span class="number">13.649402</span><span class="number">1.052618</span><span class="number">1</span></span><br><span class="line"><span class="number">25621</span><span class="number">13.181148</span><span class="number">0.273014</span><span class="number">3</span></span><br><span class="line"><span class="number">27545</span><span class="number">3.877472</span><span class="number">0.401600</span><span class="number">1</span></span><br><span class="line"><span class="number">58656</span><span class="number">1.413952</span><span class="number">0.451380</span><span class="number">1</span></span><br><span class="line"><span class="number">7327</span><span class="number">4.248986</span><span class="number">1.430249</span><span class="number">2</span></span><br><span class="line"><span class="number">64555</span><span class="number">8.779183</span><span class="number">0.845947</span><span class="number">1</span></span><br><span class="line"><span class="number">8998</span><span class="number">4.156252</span><span class="number">0.097109</span><span class="number">2</span></span><br><span class="line"><span class="number">11752</span><span class="number">5.580018</span><span class="number">0.158401</span><span class="number">2</span></span><br><span class="line"><span class="number">76319</span><span class="number">15.040440</span><span class="number">1.366898</span><span class="number">1</span></span><br><span class="line"><span class="number">27665</span><span class="number">12.793870</span><span class="number">1.307323</span><span class="number">3</span></span><br><span class="line"><span class="number">67417</span><span class="number">3.254877</span><span class="number">0.669546</span><span class="number">1</span></span><br><span class="line"><span class="number">21808</span><span class="number">10.725607</span><span class="number">0.588588</span><span class="number">3</span></span><br><span class="line"><span class="number">15326</span><span class="number">8.256473</span><span class="number">0.765891</span><span class="number">2</span></span><br><span class="line"><span class="number">20057</span><span class="number">8.033892</span><span class="number">1.618562</span><span class="number">3</span></span><br><span class="line"><span class="number">79341</span><span class="number">10.702532</span><span class="number">0.204792</span><span class="number">1</span></span><br><span class="line"><span class="number">15636</span><span class="number">5.062996</span><span class="number">1.132555</span><span class="number">2</span></span><br><span class="line"><span class="number">35602</span><span class="number">10.772286</span><span class="number">0.668721</span><span class="number">3</span></span><br><span class="line"><span class="number">28544</span><span class="number">1.892354</span><span class="number">0.837028</span><span class="number">1</span></span><br><span class="line"><span class="number">57663</span><span class="number">1.019966</span><span class="number">0.372320</span><span class="number">1</span></span><br><span class="line"><span class="number">78727</span><span class="number">15.546043</span><span class="number">0.729742</span><span class="number">1</span></span><br><span class="line"><span class="number">68255</span><span class="number">11.638205</span><span class="number">0.409125</span><span class="number">1</span></span><br><span class="line"><span class="number">14964</span><span class="number">3.427886</span><span class="number">0.975616</span><span class="number">2</span></span><br><span class="line"><span class="number">21835</span><span class="number">11.246174</span><span class="number">1.475586</span><span class="number">3</span></span><br><span class="line"><span class="number">7487</span><span class="number">0.000000</span><span class="number">0.645045</span><span class="number">2</span></span><br><span class="line"><span class="number">8700</span><span class="number">0.000000</span><span class="number">1.424017</span><span class="number">2</span></span><br><span class="line"><span class="number">26226</span><span class="number">8.242553</span><span class="number">0.279069</span><span class="number">3</span></span><br><span class="line"><span class="number">65899</span><span class="number">8.700060</span><span class="number">0.101807</span><span class="number">1</span></span><br><span class="line"><span class="number">6543</span><span class="number">0.812344</span><span class="number">0.260334</span><span class="number">2</span></span><br><span class="line"><span class="number">46556</span><span class="number">2.448235</span><span class="number">1.176829</span><span class="number">1</span></span><br><span class="line"><span class="number">71038</span><span class="number">13.230078</span><span class="number">0.616147</span><span class="number">1</span></span><br><span class="line"><span class="number">47657</span><span class="number">0.236133</span><span class="number">0.340840</span><span class="number">1</span></span><br><span class="line"><span class="number">19600</span><span class="number">11.155826</span><span class="number">0.335131</span><span class="number">3</span></span><br><span class="line"><span class="number">37422</span><span class="number">11.029636</span><span class="number">0.505769</span><span class="number">3</span></span><br><span class="line"><span class="number">1363</span><span class="number">2.901181</span><span class="number">1.646633</span><span class="number">2</span></span><br><span class="line"><span class="number">26535</span><span class="number">3.924594</span><span class="number">1.143120</span><span class="number">1</span></span><br><span class="line"><span class="number">47707</span><span class="number">2.524806</span><span class="number">1.292848</span><span class="number">1</span></span><br><span class="line"><span class="number">38055</span><span class="number">3.527474</span><span class="number">1.449158</span><span class="number">1</span></span><br><span class="line"><span class="number">6286</span><span class="number">3.384281</span><span class="number">0.889268</span><span class="number">2</span></span><br><span class="line"><span class="number">10747</span><span class="number">0.000000</span><span class="number">1.107592</span><span class="number">2</span></span><br><span class="line"><span class="number">44883</span><span class="number">11.898890</span><span class="number">0.406441</span><span class="number">3</span></span><br><span class="line"><span class="number">56823</span><span class="number">3.529892</span><span class="number">1.375844</span><span class="number">1</span></span><br><span class="line"><span class="number">68086</span><span class="number">11.442677</span><span class="number">0.696919</span><span class="number">1</span></span><br><span class="line"><span class="number">70242</span><span class="number">10.308145</span><span class="number">0.422722</span><span class="number">1</span></span><br><span class="line"><span class="number">11409</span><span class="number">8.540529</span><span class="number">0.727373</span><span class="number">2</span></span><br><span class="line"><span class="number">67671</span><span class="number">7.156949</span><span class="number">1.691682</span><span class="number">1</span></span><br><span class="line"><span class="number">61238</span><span class="number">0.720675</span><span class="number">0.847574</span><span class="number">1</span></span><br><span class="line"><span class="number">17774</span><span class="number">0.229405</span><span class="number">1.038603</span><span class="number">2</span></span><br><span class="line"><span class="number">53376</span><span class="number">3.399331</span><span class="number">0.077501</span><span class="number">1</span></span><br><span class="line"><span class="number">30930</span><span class="number">6.157239</span><span class="number">0.580133</span><span class="number">1</span></span><br><span class="line"><span class="number">28987</span><span class="number">1.239698</span><span class="number">0.719989</span><span class="number">1</span></span><br><span class="line"><span class="number">13655</span><span class="number">6.036854</span><span class="number">0.016548</span><span class="number">2</span></span><br><span class="line"><span class="number">7227</span><span class="number">5.258665</span><span class="number">0.933722</span><span class="number">2</span></span><br><span class="line"><span class="number">40409</span><span class="number">12.393001</span><span class="number">1.571281</span><span class="number">3</span></span><br><span class="line"><span class="number">13605</span><span class="number">9.627613</span><span class="number">0.935842</span><span class="number">2</span></span><br><span class="line"><span class="number">26400</span><span class="number">11.130453</span><span class="number">0.597610</span><span class="number">3</span></span><br><span class="line"><span class="number">13491</span><span class="number">8.842595</span><span class="number">0.349768</span><span class="number">3</span></span><br><span class="line"><span class="number">30232</span><span class="number">10.690010</span><span class="number">1.456595</span><span class="number">3</span></span><br><span class="line"><span class="number">43253</span><span class="number">5.714718</span><span class="number">1.674780</span><span class="number">3</span></span><br><span class="line"><span class="number">55536</span><span class="number">3.052505</span><span class="number">1.335804</span><span class="number">1</span></span><br><span class="line"><span class="number">8807</span><span class="number">0.000000</span><span class="number">0.059025</span><span class="number">2</span></span><br><span class="line"><span class="number">25783</span><span class="number">9.945307</span><span class="number">1.287952</span><span class="number">3</span></span><br><span class="line"><span class="number">22812</span><span class="number">2.719723</span><span class="number">1.142148</span><span class="number">1</span></span><br><span class="line"><span class="number">77826</span><span class="number">11.154055</span><span class="number">1.608486</span><span class="number">1</span></span><br><span class="line"><span class="number">38172</span><span class="number">2.687918</span><span class="number">0.660836</span><span class="number">1</span></span><br><span class="line"><span class="number">31676</span><span class="number">10.037847</span><span class="number">0.962245</span><span class="number">3</span></span><br><span class="line"><span class="number">74038</span><span class="number">12.404762</span><span class="number">1.112080</span><span class="number">1</span></span><br><span class="line"><span class="number">44738</span><span class="number">10.237305</span><span class="number">0.633422</span><span class="number">3</span></span><br><span class="line"><span class="number">17410</span><span class="number">4.745392</span><span class="number">0.662520</span><span class="number">2</span></span><br><span class="line"><span class="number">5688</span><span class="number">4.639461</span><span class="number">1.569431</span><span class="number">2</span></span><br><span class="line"><span class="number">36642</span><span class="number">3.149310</span><span class="number">0.639669</span><span class="number">1</span></span><br><span class="line"><span class="number">29956</span><span class="number">13.406875</span><span class="number">1.639194</span><span class="number">3</span></span><br><span class="line"><span class="number">60350</span><span class="number">6.068668</span><span class="number">0.881241</span><span class="number">1</span></span><br><span class="line"><span class="number">23758</span><span class="number">9.477022</span><span class="number">0.899002</span><span class="number">3</span></span><br><span class="line"><span class="number">25780</span><span class="number">3.897620</span><span class="number">0.560201</span><span class="number">2</span></span><br><span class="line"><span class="number">11342</span><span class="number">5.463615</span><span class="number">1.203677</span><span class="number">2</span></span><br><span class="line"><span class="number">36109</span><span class="number">3.369267</span><span class="number">1.575043</span><span class="number">1</span></span><br><span class="line"><span class="number">14292</span><span class="number">5.234562</span><span class="number">0.825954</span><span class="number">2</span></span><br><span class="line"><span class="number">11160</span><span class="number">0.000000</span><span class="number">0.722170</span><span class="number">2</span></span><br><span class="line"><span class="number">23762</span><span class="number">12.979069</span><span class="number">0.504068</span><span class="number">3</span></span><br><span class="line"><span class="number">39567</span><span class="number">5.376564</span><span class="number">0.557476</span><span class="number">1</span></span><br><span class="line"><span class="number">25647</span><span class="number">13.527910</span><span class="number">1.586732</span><span class="number">3</span></span><br><span class="line"><span class="number">14814</span><span class="number">2.196889</span><span class="number">0.784587</span><span class="number">2</span></span><br><span class="line"><span class="number">73590</span><span class="number">10.691748</span><span class="number">0.007509</span><span class="number">1</span></span><br><span class="line"><span class="number">35187</span><span class="number">1.659242</span><span class="number">0.447066</span><span class="number">1</span></span><br><span class="line"><span class="number">49459</span><span class="number">8.369667</span><span class="number">0.656697</span><span class="number">3</span></span><br><span class="line"><span class="number">31657</span><span class="number">13.157197</span><span class="number">0.143248</span><span class="number">3</span></span><br><span class="line"><span class="number">6259</span><span class="number">8.199667</span><span class="number">0.908508</span><span class="number">2</span></span><br><span class="line"><span class="number">33101</span><span class="number">4.441669</span><span class="number">0.439381</span><span class="number">3</span></span><br><span class="line"><span class="number">27107</span><span class="number">9.846492</span><span class="number">0.644523</span><span class="number">3</span></span><br><span class="line"><span class="number">17824</span><span class="number">0.019540</span><span class="number">0.977949</span><span class="number">2</span></span><br><span class="line"><span class="number">43536</span><span class="number">8.253774</span><span class="number">0.748700</span><span class="number">3</span></span><br><span class="line"><span class="number">67705</span><span class="number">6.038620</span><span class="number">1.509646</span><span class="number">1</span></span><br><span class="line"><span class="number">35283</span><span class="number">6.091587</span><span class="number">1.694641</span><span class="number">3</span></span><br><span class="line"><span class="number">71308</span><span class="number">8.986820</span><span class="number">1.225165</span><span class="number">1</span></span><br><span class="line"><span class="number">31054</span><span class="number">11.508473</span><span class="number">1.624296</span><span class="number">3</span></span><br><span class="line"><span class="number">52387</span><span class="number">8.807734</span><span class="number">0.713922</span><span class="number">3</span></span><br><span class="line"><span class="number">40328</span><span class="number">0.000000</span><span class="number">0.816676</span><span class="number">1</span></span><br><span class="line"><span class="number">34844</span><span class="number">8.889202</span><span class="number">1.665414</span><span class="number">3</span></span><br><span class="line"><span class="number">11607</span><span class="number">3.178117</span><span class="number">0.542752</span><span class="number">2</span></span><br><span class="line"><span class="number">64306</span><span class="number">7.013795</span><span class="number">0.139909</span><span class="number">1</span></span><br><span class="line"><span class="number">32721</span><span class="number">9.605014</span><span class="number">0.065254</span><span class="number">3</span></span><br><span class="line"><span class="number">33170</span><span class="number">1.230540</span><span class="number">1.331674</span><span class="number">1</span></span><br><span class="line"><span class="number">37192</span><span class="number">10.412811</span><span class="number">0.890803</span><span class="number">3</span></span><br><span class="line"><span class="number">13089</span><span class="number">0.000000</span><span class="number">0.567161</span><span class="number">2</span></span><br><span class="line"><span class="number">66491</span><span class="number">9.699991</span><span class="number">0.122011</span><span class="number">1</span></span><br><span class="line"><span class="number">15941</span><span class="number">0.000000</span><span class="number">0.061191</span><span class="number">2</span></span><br><span class="line"><span class="number">4272</span><span class="number">4.455293</span><span class="number">0.272135</span><span class="number">2</span></span><br><span class="line"><span class="number">48812</span><span class="number">3.020977</span><span class="number">1.502803</span><span class="number">1</span></span><br><span class="line"><span class="number">28818</span><span class="number">8.099278</span><span class="number">0.216317</span><span class="number">3</span></span><br><span class="line"><span class="number">35394</span><span class="number">1.157764</span><span class="number">1.603217</span><span class="number">1</span></span><br><span class="line"><span class="number">71791</span><span class="number">10.105396</span><span class="number">0.121067</span><span class="number">1</span></span><br><span class="line"><span class="number">40668</span><span class="number">11.230148</span><span class="number">0.408603</span><span class="number">3</span></span><br><span class="line"><span class="number">39580</span><span class="number">9.070058</span><span class="number">0.011379</span><span class="number">3</span></span><br><span class="line"><span class="number">11786</span><span class="number">0.566460</span><span class="number">0.478837</span><span class="number">2</span></span><br><span class="line"><span class="number">19251</span><span class="number">0.000000</span><span class="number">0.487300</span><span class="number">2</span></span><br><span class="line"><span class="number">56594</span><span class="number">8.956369</span><span class="number">1.193484</span><span class="number">3</span></span><br><span class="line"><span class="number">54495</span><span class="number">1.523057</span><span class="number">0.620528</span><span class="number">1</span></span><br><span class="line"><span class="number">11844</span><span class="number">2.749006</span><span class="number">0.169855</span><span class="number">2</span></span><br><span class="line"><span class="number">45465</span><span class="number">9.235393</span><span class="number">0.188350</span><span class="number">3</span></span><br><span class="line"><span class="number">31033</span><span class="number">10.555573</span><span class="number">0.403927</span><span class="number">3</span></span><br><span class="line"><span class="number">16633</span><span class="number">6.956372</span><span class="number">1.519308</span><span class="number">2</span></span><br><span class="line"><span class="number">13887</span><span class="number">0.636281</span><span class="number">1.273984</span><span class="number">2</span></span><br><span class="line"><span class="number">52603</span><span class="number">3.574737</span><span class="number">0.075163</span><span class="number">1</span></span><br><span class="line"><span class="number">72000</span><span class="number">9.032486</span><span class="number">1.461809</span><span class="number">1</span></span><br><span class="line"><span class="number">68497</span><span class="number">5.958993</span><span class="number">0.023012</span><span class="number">1</span></span><br><span class="line"><span class="number">35135</span><span class="number">2.435300</span><span class="number">1.211744</span><span class="number">1</span></span><br><span class="line"><span class="number">26397</span><span class="number">10.539731</span><span class="number">1.638248</span><span class="number">3</span></span><br><span class="line"><span class="number">7313</span><span class="number">7.646702</span><span class="number">0.056513</span><span class="number">2</span></span><br><span class="line"><span class="number">91273</span><span class="number">20.919349</span><span class="number">0.644571</span><span class="number">1</span></span><br><span class="line"><span class="number">24743</span><span class="number">1.424726</span><span class="number">0.838447</span><span class="number">1</span></span><br><span class="line"><span class="number">31690</span><span class="number">6.748663</span><span class="number">0.890223</span><span class="number">3</span></span><br><span class="line"><span class="number">15432</span><span class="number">2.289167</span><span class="number">0.114881</span><span class="number">2</span></span><br><span class="line"><span class="number">58394</span><span class="number">5.548377</span><span class="number">0.402238</span><span class="number">1</span></span><br><span class="line"><span class="number">33962</span><span class="number">6.057227</span><span class="number">0.432666</span><span class="number">1</span></span><br><span class="line"><span class="number">31442</span><span class="number">10.828595</span><span class="number">0.559955</span><span class="number">3</span></span><br><span class="line"><span class="number">31044</span><span class="number">11.318160</span><span class="number">0.271094</span><span class="number">3</span></span><br><span class="line"><span class="number">29938</span><span class="number">13.265311</span><span class="number">0.633903</span><span class="number">3</span></span><br><span class="line"><span class="number">9875</span><span class="number">0.000000</span><span class="number">1.496715</span><span class="number">2</span></span><br><span class="line"><span class="number">51542</span><span class="number">6.517133</span><span class="number">0.402519</span><span class="number">3</span></span><br><span class="line"><span class="number">11878</span><span class="number">4.934374</span><span class="number">1.520028</span><span class="number">2</span></span><br><span class="line"><span class="number">69241</span><span class="number">10.151738</span><span class="number">0.896433</span><span class="number">1</span></span><br><span class="line"><span class="number">37776</span><span class="number">2.425781</span><span class="number">1.559467</span><span class="number">1</span></span><br><span class="line"><span class="number">68997</span><span class="number">9.778962</span><span class="number">1.195498</span><span class="number">1</span></span><br><span class="line"><span class="number">67416</span><span class="number">12.219950</span><span class="number">0.657677</span><span class="number">1</span></span><br><span class="line"><span class="number">59225</span><span class="number">7.394151</span><span class="number">0.954434</span><span class="number">1</span></span><br><span class="line"><span class="number">29138</span><span class="number">8.518535</span><span class="number">0.742546</span><span class="number">3</span></span><br><span class="line"><span class="number">5962</span><span class="number">2.798700</span><span class="number">0.662632</span><span class="number">2</span></span><br><span class="line"><span class="number">10847</span><span class="number">0.637930</span><span class="number">0.617373</span><span class="number">2</span></span><br><span class="line"><span class="number">70527</span><span class="number">10.750490</span><span class="number">0.097415</span><span class="number">1</span></span><br><span class="line"><span class="number">9610</span><span class="number">0.625382</span><span class="number">0.140969</span><span class="number">2</span></span><br><span class="line"><span class="number">64734</span><span class="number">10.027968</span><span class="number">0.282787</span><span class="number">1</span></span><br><span class="line"><span class="number">25941</span><span class="number">9.817347</span><span class="number">0.364197</span><span class="number">3</span></span><br><span class="line"><span class="number">2763</span><span class="number">0.646828</span><span class="number">1.266069</span><span class="number">2</span></span><br><span class="line"><span class="number">55601</span><span class="number">3.347111</span><span class="number">0.914294</span><span class="number">1</span></span><br><span class="line"><span class="number">31128</span><span class="number">11.816892</span><span class="number">0.193798</span><span class="number">3</span></span><br><span class="line"><span class="number">5181</span><span class="number">0.000000</span><span class="number">1.480198</span><span class="number">2</span></span><br><span class="line"><span class="number">69982</span><span class="number">10.945666</span><span class="number">0.993219</span><span class="number">1</span></span><br><span class="line"><span class="number">52440</span><span class="number">10.244706</span><span class="number">0.280539</span><span class="number">3</span></span><br><span class="line"><span class="number">57350</span><span class="number">2.579801</span><span class="number">1.149172</span><span class="number">1</span></span><br><span class="line"><span class="number">57869</span><span class="number">2.630410</span><span class="number">0.098869</span><span class="number">1</span></span><br><span class="line"><span class="number">56557</span><span class="number">11.746200</span><span class="number">1.695517</span><span class="number">3</span></span><br><span class="line"><span class="number">42342</span><span class="number">8.104232</span><span class="number">1.326277</span><span class="number">3</span></span><br><span class="line"><span class="number">15560</span><span class="number">12.409743</span><span class="number">0.790295</span><span class="number">3</span></span><br><span class="line"><span class="number">34826</span><span class="number">12.167844</span><span class="number">1.328086</span><span class="number">3</span></span><br><span class="line"><span class="number">8569</span><span class="number">3.198408</span><span class="number">0.299287</span><span class="number">2</span></span><br><span class="line"><span class="number">77623</span><span class="number">16.055513</span><span class="number">0.541052</span><span class="number">1</span></span><br><span class="line"><span class="number">78184</span><span class="number">7.138659</span><span class="number">0.158481</span><span class="number">1</span></span><br><span class="line"><span class="number">7036</span><span class="number">4.831041</span><span class="number">0.761419</span><span class="number">2</span></span><br><span class="line"><span class="number">69616</span><span class="number">10.082890</span><span class="number">1.373611</span><span class="number">1</span></span><br><span class="line"><span class="number">21546</span><span class="number">10.066867</span><span class="number">0.788470</span><span class="number">3</span></span><br><span class="line"><span class="number">36715</span><span class="number">8.129538</span><span class="number">0.329913</span><span class="number">3</span></span><br><span class="line"><span class="number">20522</span><span class="number">3.012463</span><span class="number">1.138108</span><span class="number">2</span></span><br><span class="line"><span class="number">42349</span><span class="number">3.720391</span><span class="number">0.845974</span><span class="number">1</span></span><br><span class="line"><span class="number">9037</span><span class="number">0.773493</span><span class="number">1.148256</span><span class="number">2</span></span><br><span class="line"><span class="number">26728</span><span class="number">10.962941</span><span class="number">1.037324</span><span class="number">3</span></span><br><span class="line"><span class="number">587</span><span class="number">0.177621</span><span class="number">0.162614</span><span class="number">2</span></span><br><span class="line"><span class="number">48915</span><span class="number">3.085853</span><span class="number">0.967899</span><span class="number">1</span></span><br><span class="line"><span class="number">9824</span><span class="number">8.426781</span><span class="number">0.202558</span><span class="number">2</span></span><br><span class="line"><span class="number">4135</span><span class="number">1.825927</span><span class="number">1.128347</span><span class="number">2</span></span><br><span class="line"><span class="number">9666</span><span class="number">2.185155</span><span class="number">1.010173</span><span class="number">2</span></span><br><span class="line"><span class="number">59333</span><span class="number">7.184595</span><span class="number">1.261338</span><span class="number">1</span></span><br><span class="line"><span class="number">36198</span><span class="number">0.000000</span><span class="number">0.116525</span><span class="number">1</span></span><br><span class="line"><span class="number">34909</span><span class="number">8.901752</span><span class="number">1.033527</span><span class="number">3</span></span><br><span class="line"><span class="number">47516</span><span class="number">2.451497</span><span class="number">1.358795</span><span class="number">1</span></span><br><span class="line"><span class="number">55807</span><span class="number">3.213631</span><span class="number">0.432044</span><span class="number">1</span></span><br><span class="line"><span class="number">14036</span><span class="number">3.974739</span><span class="number">0.723929</span><span class="number">2</span></span><br><span class="line"><span class="number">42856</span><span class="number">9.601306</span><span class="number">0.619232</span><span class="number">3</span></span><br><span class="line"><span class="number">64007</span><span class="number">8.363897</span><span class="number">0.445341</span><span class="number">1</span></span><br><span class="line"><span class="number">59428</span><span class="number">6.381484</span><span class="number">1.365019</span><span class="number">1</span></span><br><span class="line"><span class="number">13730</span><span class="number">0.000000</span><span class="number">1.403914</span><span class="number">2</span></span><br><span class="line"><span class="number">41740</span><span class="number">9.609836</span><span class="number">1.438105</span><span class="number">3</span></span><br><span class="line"><span class="number">63546</span><span class="number">9.904741</span><span class="number">0.985862</span><span class="number">1</span></span><br><span class="line"><span class="number">30417</span><span class="number">7.185807</span><span class="number">1.489102</span><span class="number">3</span></span><br><span class="line"><span class="number">69636</span><span class="number">5.466703</span><span class="number">1.216571</span><span class="number">1</span></span><br><span class="line"><span class="number">64660</span><span class="number">0.000000</span><span class="number">0.915898</span><span class="number">1</span></span><br><span class="line"><span class="number">14883</span><span class="number">4.575443</span><span class="number">0.535671</span><span class="number">2</span></span><br><span class="line"><span class="number">7965</span><span class="number">3.277076</span><span class="number">1.010868</span><span class="number">2</span></span><br><span class="line"><span class="number">68620</span><span class="number">10.246623</span><span class="number">1.239634</span><span class="number">1</span></span><br><span class="line"><span class="number">8738</span><span class="number">2.341735</span><span class="number">1.060235</span><span class="number">2</span></span><br><span class="line"><span class="number">7544</span><span class="number">3.201046</span><span class="number">0.498843</span><span class="number">2</span></span><br><span class="line"><span class="number">6377</span><span class="number">6.066013</span><span class="number">0.120927</span><span class="number">2</span></span><br><span class="line"><span class="number">36842</span><span class="number">8.829379</span><span class="number">0.895657</span><span class="number">3</span></span><br><span class="line"><span class="number">81046</span><span class="number">15.833048</span><span class="number">1.568245</span><span class="number">1</span></span><br><span class="line"><span class="number">67736</span><span class="number">13.516711</span><span class="number">1.220153</span><span class="number">1</span></span><br><span class="line"><span class="number">32492</span><span class="number">0.664284</span><span class="number">1.116755</span><span class="number">1</span></span><br><span class="line"><span class="number">39299</span><span class="number">6.325139</span><span class="number">0.605109</span><span class="number">3</span></span><br><span class="line"><span class="number">77289</span><span class="number">8.677499</span><span class="number">0.344373</span><span class="number">1</span></span><br><span class="line"><span class="number">33835</span><span class="number">8.188005</span><span class="number">0.964896</span><span class="number">3</span></span><br><span class="line"><span class="number">71890</span><span class="number">9.414263</span><span class="number">0.384030</span><span class="number">1</span></span><br><span class="line"><span class="number">32054</span><span class="number">9.196547</span><span class="number">1.138253</span><span class="number">3</span></span><br><span class="line"><span class="number">38579</span><span class="number">10.202968</span><span class="number">0.452363</span><span class="number">3</span></span><br><span class="line"><span class="number">55984</span><span class="number">2.119439</span><span class="number">1.481661</span><span class="number">1</span></span><br><span class="line"><span class="number">72694</span><span class="number">13.635078</span><span class="number">0.858314</span><span class="number">1</span></span><br><span class="line"><span class="number">42299</span><span class="number">0.083443</span><span class="number">0.701669</span><span class="number">1</span></span><br><span class="line"><span class="number">26635</span><span class="number">9.149096</span><span class="number">1.051446</span><span class="number">3</span></span><br><span class="line"><span class="number">8579</span><span class="number">1.933803</span><span class="number">1.374388</span><span class="number">2</span></span><br><span class="line"><span class="number">37302</span><span class="number">14.115544</span><span class="number">0.676198</span><span class="number">3</span></span><br><span class="line"><span class="number">22878</span><span class="number">8.933736</span><span class="number">0.943352</span><span class="number">3</span></span><br><span class="line"><span class="number">4364</span><span class="number">2.661254</span><span class="number">0.946117</span><span class="number">2</span></span><br><span class="line"><span class="number">4985</span><span class="number">0.988432</span><span class="number">1.305027</span><span class="number">2</span></span><br><span class="line"><span class="number">37068</span><span class="number">2.063741</span><span class="number">1.125946</span><span class="number">1</span></span><br><span class="line"><span class="number">41137</span><span class="number">2.220590</span><span class="number">0.690754</span><span class="number">1</span></span><br><span class="line"><span class="number">67759</span><span class="number">6.424849</span><span class="number">0.806641</span><span class="number">1</span></span><br><span class="line"><span class="number">11831</span><span class="number">1.156153</span><span class="number">1.613674</span><span class="number">2</span></span><br><span class="line"><span class="number">34502</span><span class="number">3.032720</span><span class="number">0.601847</span><span class="number">1</span></span><br><span class="line"><span class="number">4088</span><span class="number">3.076828</span><span class="number">0.952089</span><span class="number">2</span></span><br><span class="line"><span class="number">15199</span><span class="number">0.000000</span><span class="number">0.318105</span><span class="number">2</span></span><br><span class="line"><span class="number">17309</span><span class="number">7.750480</span><span class="number">0.554015</span><span class="number">3</span></span><br><span class="line"><span class="number">42816</span><span class="number">10.958135</span><span class="number">1.482500</span><span class="number">3</span></span><br><span class="line"><span class="number">43751</span><span class="number">10.222018</span><span class="number">0.488678</span><span class="number">3</span></span><br><span class="line"><span class="number">58335</span><span class="number">2.367988</span><span class="number">0.435741</span><span class="number">1</span></span><br><span class="line"><span class="number">75039</span><span class="number">7.686054</span><span class="number">1.381455</span><span class="number">1</span></span><br><span class="line"><span class="number">42878</span><span class="number">11.464879</span><span class="number">1.481589</span><span class="number">3</span></span><br><span class="line"><span class="number">42770</span><span class="number">11.075735</span><span class="number">0.089726</span><span class="number">3</span></span><br><span class="line"><span class="number">8848</span><span class="number">3.543989</span><span class="number">0.345853</span><span class="number">2</span></span><br><span class="line"><span class="number">31340</span><span class="number">8.123889</span><span class="number">1.282880</span><span class="number">3</span></span><br><span class="line"><span class="number">41413</span><span class="number">4.331769</span><span class="number">0.754467</span><span class="number">3</span></span><br><span class="line"><span class="number">12731</span><span class="number">0.120865</span><span class="number">1.211961</span><span class="number">2</span></span><br><span class="line"><span class="number">22447</span><span class="number">6.116109</span><span class="number">0.701523</span><span class="number">3</span></span><br><span class="line"><span class="number">33564</span><span class="number">7.474534</span><span class="number">0.505790</span><span class="number">3</span></span><br><span class="line"><span class="number">48907</span><span class="number">8.819454</span><span class="number">0.649292</span><span class="number">3</span></span><br><span class="line"><span class="number">8762</span><span class="number">6.802144</span><span class="number">0.615284</span><span class="number">2</span></span><br><span class="line"><span class="number">46696</span><span class="number">12.666325</span><span class="number">0.931960</span><span class="number">3</span></span><br><span class="line"><span class="number">36851</span><span class="number">8.636180</span><span class="number">0.399333</span><span class="number">3</span></span><br><span class="line"><span class="number">67639</span><span class="number">11.730991</span><span class="number">1.289833</span><span class="number">1</span></span><br><span class="line"><span class="number">171</span><span class="number">8.132449</span><span class="number">0.039062</span><span class="number">2</span></span><br><span class="line"><span class="number">26674</span><span class="number">10.296589</span><span class="number">1.496144</span><span class="number">3</span></span><br><span class="line"><span class="number">8739</span><span class="number">7.583906</span><span class="number">1.005764</span><span class="number">2</span></span><br><span class="line"><span class="number">66668</span><span class="number">9.777806</span><span class="number">0.496377</span><span class="number">1</span></span><br><span class="line"><span class="number">68732</span><span class="number">8.833546</span><span class="number">0.513876</span><span class="number">1</span></span><br><span class="line"><span class="number">69995</span><span class="number">4.907899</span><span class="number">1.518036</span><span class="number">1</span></span><br><span class="line"><span class="number">82008</span><span class="number">8.362736</span><span class="number">1.285939</span><span class="number">1</span></span><br><span class="line"><span class="number">25054</span><span class="number">9.084726</span><span class="number">1.606312</span><span class="number">3</span></span><br><span class="line"><span class="number">33085</span><span class="number">14.164141</span><span class="number">0.560970</span><span class="number">3</span></span><br><span class="line"><span class="number">41379</span><span class="number">9.080683</span><span class="number">0.989920</span><span class="number">3</span></span><br><span class="line"><span class="number">39417</span><span class="number">6.522767</span><span class="number">0.038548</span><span class="number">3</span></span><br><span class="line"><span class="number">12556</span><span class="number">3.690342</span><span class="number">0.462281</span><span class="number">2</span></span><br><span class="line"><span class="number">39432</span><span class="number">3.563706</span><span class="number">0.242019</span><span class="number">1</span></span><br><span class="line"><span class="number">38010</span><span class="number">1.065870</span><span class="number">1.141569</span><span class="number">1</span></span><br><span class="line"><span class="number">69306</span><span class="number">6.683796</span><span class="number">1.456317</span><span class="number">1</span></span><br><span class="line"><span class="number">38000</span><span class="number">1.712874</span><span class="number">0.243945</span><span class="number">1</span></span><br><span class="line"><span class="number">46321</span><span class="number">13.109929</span><span class="number">1.280111</span><span class="number">3</span></span><br><span class="line"><span class="number">66293</span><span class="number">11.327910</span><span class="number">0.780977</span><span class="number">1</span></span><br><span class="line"><span class="number">22730</span><span class="number">4.545711</span><span class="number">1.233254</span><span class="number">1</span></span><br><span class="line"><span class="number">5952</span><span class="number">3.367889</span><span class="number">0.468104</span><span class="number">2</span></span><br><span class="line"><span class="number">72308</span><span class="number">8.326224</span><span class="number">0.567347</span><span class="number">1</span></span><br><span class="line"><span class="number">60338</span><span class="number">8.978339</span><span class="number">1.442034</span><span class="number">1</span></span><br><span class="line"><span class="number">13301</span><span class="number">5.655826</span><span class="number">1.582159</span><span class="number">2</span></span><br><span class="line"><span class="number">27884</span><span class="number">8.855312</span><span class="number">0.570684</span><span class="number">3</span></span><br><span class="line"><span class="number">11188</span><span class="number">6.649568</span><span class="number">0.544233</span><span class="number">2</span></span><br><span class="line"><span class="number">56796</span><span class="number">3.966325</span><span class="number">0.850410</span><span class="number">1</span></span><br><span class="line"><span class="number">8571</span><span class="number">1.924045</span><span class="number">1.664782</span><span class="number">2</span></span><br><span class="line"><span class="number">4914</span><span class="number">6.004812</span><span class="number">0.280369</span><span class="number">2</span></span><br><span class="line"><span class="number">10784</span><span class="number">0.000000</span><span class="number">0.375849</span><span class="number">2</span></span><br><span class="line"><span class="number">39296</span><span class="number">9.923018</span><span class="number">0.092192</span><span class="number">3</span></span><br><span class="line"><span class="number">13113</span><span class="number">2.389084</span><span class="number">0.119284</span><span class="number">2</span></span><br><span class="line"><span class="number">70204</span><span class="number">13.663189</span><span class="number">0.133251</span><span class="number">1</span></span><br><span class="line"><span class="number">46813</span><span class="number">11.434976</span><span class="number">0.321216</span><span class="number">3</span></span><br><span class="line"><span class="number">11697</span><span class="number">0.358270</span><span class="number">1.292858</span><span class="number">2</span></span><br><span class="line"><span class="number">44183</span><span class="number">9.598873</span><span class="number">0.223524</span><span class="number">3</span></span><br><span class="line"><span class="number">2225</span><span class="number">6.375275</span><span class="number">0.608040</span><span class="number">2</span></span><br><span class="line"><span class="number">29066</span><span class="number">11.580532</span><span class="number">0.458401</span><span class="number">3</span></span><br><span class="line"><span class="number">4245</span><span class="number">5.319324</span><span class="number">1.598070</span><span class="number">2</span></span><br><span class="line"><span class="number">34379</span><span class="number">4.324031</span><span class="number">1.603481</span><span class="number">1</span></span><br><span class="line"><span class="number">44441</span><span class="number">2.358370</span><span class="number">1.273204</span><span class="number">1</span></span><br><span class="line"><span class="number">2022</span><span class="number">0.000000</span><span class="number">1.182708</span><span class="number">2</span></span><br><span class="line"><span class="number">26866</span><span class="number">12.824376</span><span class="number">0.890411</span><span class="number">3</span></span><br><span class="line"><span class="number">57070</span><span class="number">1.587247</span><span class="number">1.456982</span><span class="number">1</span></span><br><span class="line"><span class="number">32932</span><span class="number">8.510324</span><span class="number">1.520683</span><span class="number">3</span></span><br><span class="line"><span class="number">51967</span><span class="number">10.428884</span><span class="number">1.187734</span><span class="number">3</span></span><br><span class="line"><span class="number">44432</span><span class="number">8.346618</span><span class="number">0.042318</span><span class="number">3</span></span><br><span class="line"><span class="number">67066</span><span class="number">7.541444</span><span class="number">0.809226</span><span class="number">1</span></span><br><span class="line"><span class="number">17262</span><span class="number">2.540946</span><span class="number">1.583286</span><span class="number">2</span></span><br><span class="line"><span class="number">79728</span><span class="number">9.473047</span><span class="number">0.692513</span><span class="number">1</span></span><br><span class="line"><span class="number">14259</span><span class="number">0.352284</span><span class="number">0.474080</span><span class="number">2</span></span><br><span class="line"><span class="number">6122</span><span class="number">0.000000</span><span class="number">0.589826</span><span class="number">2</span></span><br><span class="line"><span class="number">76879</span><span class="number">12.405171</span><span class="number">0.567201</span><span class="number">1</span></span><br><span class="line"><span class="number">11426</span><span class="number">4.126775</span><span class="number">0.871452</span><span class="number">2</span></span><br><span class="line"><span class="number">2493</span><span class="number">0.034087</span><span class="number">0.335848</span><span class="number">2</span></span><br><span class="line"><span class="number">19910</span><span class="number">1.177634</span><span class="number">0.075106</span><span class="number">2</span></span><br><span class="line"><span class="number">10939</span><span class="number">0.000000</span><span class="number">0.479996</span><span class="number">2</span></span><br><span class="line"><span class="number">17716</span><span class="number">0.994909</span><span class="number">0.611135</span><span class="number">2</span></span><br><span class="line"><span class="number">31390</span><span class="number">11.053664</span><span class="number">1.180117</span><span class="number">3</span></span><br><span class="line"><span class="number">20375</span><span class="number">0.000000</span><span class="number">1.679729</span><span class="number">2</span></span><br><span class="line"><span class="number">26309</span><span class="number">2.495011</span><span class="number">1.459589</span><span class="number">1</span></span><br><span class="line"><span class="number">33484</span><span class="number">11.516831</span><span class="number">0.001156</span><span class="number">3</span></span><br><span class="line"><span class="number">45944</span><span class="number">9.213215</span><span class="number">0.797743</span><span class="number">3</span></span><br><span class="line"><span class="number">4249</span><span class="number">5.332865</span><span class="number">0.109288</span><span class="number">2</span></span><br><span class="line"><span class="number">6089</span><span class="number">0.000000</span><span class="number">1.689771</span><span class="number">2</span></span><br><span class="line"><span class="number">7513</span><span class="number">0.000000</span><span class="number">1.126053</span><span class="number">2</span></span><br><span class="line"><span class="number">27862</span><span class="number">12.640062</span><span class="number">1.690903</span><span class="number">3</span></span><br><span class="line"><span class="number">39038</span><span class="number">2.693142</span><span class="number">1.317518</span><span class="number">1</span></span><br><span class="line"><span class="number">19218</span><span class="number">3.328969</span><span class="number">0.268271</span><span class="number">2</span></span><br><span class="line"><span class="number">62911</span><span class="number">7.193166</span><span class="number">1.117456</span><span class="number">1</span></span><br><span class="line"><span class="number">77758</span><span class="number">6.615512</span><span class="number">1.521012</span><span class="number">1</span></span><br><span class="line"><span class="number">27940</span><span class="number">8.000567</span><span class="number">0.835341</span><span class="number">3</span></span><br><span class="line"><span class="number">2194</span><span class="number">4.017541</span><span class="number">0.512104</span><span class="number">2</span></span><br><span class="line"><span class="number">37072</span><span class="number">13.245859</span><span class="number">0.927465</span><span class="number">3</span></span><br><span class="line"><span class="number">15585</span><span class="number">5.970616</span><span class="number">0.813624</span><span class="number">2</span></span><br><span class="line"><span class="number">25577</span><span class="number">11.668719</span><span class="number">0.886902</span><span class="number">3</span></span><br><span class="line"><span class="number">8777</span><span class="number">4.283237</span><span class="number">1.272728</span><span class="number">2</span></span><br><span class="line"><span class="number">29016</span><span class="number">10.742963</span><span class="number">0.971401</span><span class="number">3</span></span><br><span class="line"><span class="number">21910</span><span class="number">12.326672</span><span class="number">1.592608</span><span class="number">3</span></span><br><span class="line"><span class="number">12916</span><span class="number">0.000000</span><span class="number">0.344622</span><span class="number">2</span></span><br><span class="line"><span class="number">10976</span><span class="number">0.000000</span><span class="number">0.922846</span><span class="number">2</span></span><br><span class="line"><span class="number">79065</span><span class="number">10.602095</span><span class="number">0.573686</span><span class="number">1</span></span><br><span class="line"><span class="number">36759</span><span class="number">10.861859</span><span class="number">1.155054</span><span class="number">3</span></span><br><span class="line"><span class="number">50011</span><span class="number">1.229094</span><span class="number">1.638690</span><span class="number">1</span></span><br><span class="line"><span class="number">1155</span><span class="number">0.410392</span><span class="number">1.313401</span><span class="number">2</span></span><br><span class="line"><span class="number">71600</span><span class="number">14.552711</span><span class="number">0.616162</span><span class="number">1</span></span><br><span class="line"><span class="number">30817</span><span class="number">14.178043</span><span class="number">0.616313</span><span class="number">3</span></span><br><span class="line"><span class="number">54559</span><span class="number">14.136260</span><span class="number">0.362388</span><span class="number">1</span></span><br><span class="line"><span class="number">29764</span><span class="number">0.093534</span><span class="number">1.207194</span><span class="number">1</span></span><br><span class="line"><span class="number">69100</span><span class="number">10.929021</span><span class="number">0.403110</span><span class="number">1</span></span><br><span class="line"><span class="number">47324</span><span class="number">11.432919</span><span class="number">0.825959</span><span class="number">3</span></span><br><span class="line"><span class="number">73199</span><span class="number">9.134527</span><span class="number">0.586846</span><span class="number">1</span></span><br><span class="line"><span class="number">44461</span><span class="number">5.071432</span><span class="number">1.421420</span><span class="number">1</span></span><br><span class="line"><span class="number">45617</span><span class="number">11.460254</span><span class="number">1.541749</span><span class="number">3</span></span><br><span class="line"><span class="number">28221</span><span class="number">11.620039</span><span class="number">1.103553</span><span class="number">3</span></span><br><span class="line"><span class="number">7091</span><span class="number">4.022079</span><span class="number">0.207307</span><span class="number">2</span></span><br><span class="line"><span class="number">6110</span><span class="number">3.057842</span><span class="number">1.631262</span><span class="number">2</span></span><br><span class="line"><span class="number">79016</span><span class="number">7.782169</span><span class="number">0.404385</span><span class="number">1</span></span><br><span class="line"><span class="number">18289</span><span class="number">7.981741</span><span class="number">0.929789</span><span class="number">3</span></span><br><span class="line"><span class="number">43679</span><span class="number">4.601363</span><span class="number">0.268326</span><span class="number">1</span></span><br><span class="line"><span class="number">22075</span><span class="number">2.595564</span><span class="number">1.115375</span><span class="number">1</span></span><br><span class="line"><span class="number">23535</span><span class="number">10.049077</span><span class="number">0.391045</span><span class="number">3</span></span><br><span class="line"><span class="number">25301</span><span class="number">3.265444</span><span class="number">1.572970</span><span class="number">2</span></span><br><span class="line"><span class="number">32256</span><span class="number">11.780282</span><span class="number">1.511014</span><span class="number">3</span></span><br><span class="line"><span class="number">36951</span><span class="number">3.075975</span><span class="number">0.286284</span><span class="number">1</span></span><br><span class="line"><span class="number">31290</span><span class="number">1.795307</span><span class="number">0.194343</span><span class="number">1</span></span><br><span class="line"><span class="number">38953</span><span class="number">11.106979</span><span class="number">0.202415</span><span class="number">3</span></span><br><span class="line"><span class="number">35257</span><span class="number">5.994413</span><span class="number">0.800021</span><span class="number">1</span></span><br><span class="line"><span class="number">25847</span><span class="number">9.706062</span><span class="number">1.012182</span><span class="number">3</span></span><br><span class="line"><span class="number">32680</span><span class="number">10.582992</span><span class="number">0.836025</span><span class="number">3</span></span><br><span class="line"><span class="number">62018</span><span class="number">7.038266</span><span class="number">1.458979</span><span class="number">1</span></span><br><span class="line"><span class="number">9074</span><span class="number">0.023771</span><span class="number">0.015314</span><span class="number">2</span></span><br><span class="line"><span class="number">33004</span><span class="number">12.823982</span><span class="number">0.676371</span><span class="number">3</span></span><br><span class="line"><span class="number">44588</span><span class="number">3.617770</span><span class="number">0.493483</span><span class="number">1</span></span><br><span class="line"><span class="number">32565</span><span class="number">8.346684</span><span class="number">0.253317</span><span class="number">3</span></span><br><span class="line"><span class="number">38563</span><span class="number">6.104317</span><span class="number">0.099207</span><span class="number">1</span></span><br><span class="line"><span class="number">75668</span><span class="number">16.207776</span><span class="number">0.584973</span><span class="number">1</span></span><br><span class="line"><span class="number">9069</span><span class="number">6.401969</span><span class="number">1.691873</span><span class="number">2</span></span><br><span class="line"><span class="number">53395</span><span class="number">2.298696</span><span class="number">0.559757</span><span class="number">1</span></span><br><span class="line"><span class="number">28631</span><span class="number">7.661515</span><span class="number">0.055981</span><span class="number">3</span></span><br><span class="line"><span class="number">71036</span><span class="number">6.353608</span><span class="number">1.645301</span><span class="number">1</span></span><br><span class="line"><span class="number">71142</span><span class="number">10.442780</span><span class="number">0.335870</span><span class="number">1</span></span><br><span class="line"><span class="number">37653</span><span class="number">3.834509</span><span class="number">1.346121</span><span class="number">1</span></span><br><span class="line"><span class="number">76839</span><span class="number">10.998587</span><span class="number">0.584555</span><span class="number">1</span></span><br><span class="line"><span class="number">9916</span><span class="number">2.695935</span><span class="number">1.512111</span><span class="number">2</span></span><br><span class="line"><span class="number">38889</span><span class="number">3.356646</span><span class="number">0.324230</span><span class="number">1</span></span><br><span class="line"><span class="number">39075</span><span class="number">14.677836</span><span class="number">0.793183</span><span class="number">3</span></span><br><span class="line"><span class="number">48071</span><span class="number">1.551934</span><span class="number">0.130902</span><span class="number">1</span></span><br><span class="line"><span class="number">7275</span><span class="number">2.464739</span><span class="number">0.223502</span><span class="number">2</span></span><br><span class="line"><span class="number">41804</span><span class="number">1.533216</span><span class="number">1.007481</span><span class="number">1</span></span><br><span class="line"><span class="number">35665</span><span class="number">12.473921</span><span class="number">0.162910</span><span class="number">3</span></span><br><span class="line"><span class="number">67956</span><span class="number">6.491596</span><span class="number">0.032576</span><span class="number">1</span></span><br><span class="line"><span class="number">41892</span><span class="number">10.506276</span><span class="number">1.510747</span><span class="number">3</span></span><br><span class="line"><span class="number">38844</span><span class="number">4.380388</span><span class="number">0.748506</span><span class="number">1</span></span><br><span class="line"><span class="number">74197</span><span class="number">13.670988</span><span class="number">1.687944</span><span class="number">1</span></span><br><span class="line"><span class="number">14201</span><span class="number">8.317599</span><span class="number">0.390409</span><span class="number">2</span></span><br><span class="line"><span class="number">3908</span><span class="number">0.000000</span><span class="number">0.556245</span><span class="number">2</span></span><br><span class="line"><span class="number">2459</span><span class="number">0.000000</span><span class="number">0.290218</span><span class="number">2</span></span><br><span class="line"><span class="number">32027</span><span class="number">10.095799</span><span class="number">1.188148</span><span class="number">3</span></span><br><span class="line"><span class="number">12870</span><span class="number">0.860695</span><span class="number">1.482632</span><span class="number">2</span></span><br><span class="line"><span class="number">9880</span><span class="number">1.557564</span><span class="number">0.711278</span><span class="number">2</span></span><br><span class="line"><span class="number">72784</span><span class="number">10.072779</span><span class="number">0.756030</span><span class="number">1</span></span><br><span class="line"><span class="number">17521</span><span class="number">0.000000</span><span class="number">0.431468</span><span class="number">2</span></span><br><span class="line"><span class="number">50283</span><span class="number">7.140817</span><span class="number">0.883813</span><span class="number">3</span></span><br><span class="line"><span class="number">33536</span><span class="number">11.384548</span><span class="number">1.438307</span><span class="number">3</span></span><br><span class="line"><span class="number">9452</span><span class="number">3.214568</span><span class="number">1.083536</span><span class="number">2</span></span><br><span class="line"><span class="number">37457</span><span class="number">11.720655</span><span class="number">0.301636</span><span class="number">3</span></span><br><span class="line"><span class="number">17724</span><span class="number">6.374475</span><span class="number">1.475925</span><span class="number">3</span></span><br><span class="line"><span class="number">43869</span><span class="number">5.749684</span><span class="number">0.198875</span><span class="number">3</span></span><br><span class="line"><span class="number">264</span><span class="number">3.871808</span><span class="number">0.552602</span><span class="number">2</span></span><br><span class="line"><span class="number">25736</span><span class="number">8.336309</span><span class="number">0.636238</span><span class="number">3</span></span><br><span class="line"><span class="number">39584</span><span class="number">9.710442</span><span class="number">1.503735</span><span class="number">3</span></span><br><span class="line"><span class="number">31246</span><span class="number">1.532611</span><span class="number">1.433898</span><span class="number">1</span></span><br><span class="line"><span class="number">49567</span><span class="number">9.785785</span><span class="number">0.984614</span><span class="number">3</span></span><br><span class="line"><span class="number">7052</span><span class="number">2.633627</span><span class="number">1.097866</span><span class="number">2</span></span><br><span class="line"><span class="number">35493</span><span class="number">9.238935</span><span class="number">0.494701</span><span class="number">3</span></span><br><span class="line"><span class="number">10986</span><span class="number">1.205656</span><span class="number">1.398803</span><span class="number">2</span></span><br><span class="line"><span class="number">49508</span><span class="number">3.124909</span><span class="number">1.670121</span><span class="number">1</span></span><br><span class="line"><span class="number">5734</span><span class="number">7.935489</span><span class="number">1.585044</span><span class="number">2</span></span><br><span class="line"><span class="number">65479</span><span class="number">12.746636</span><span class="number">1.560352</span><span class="number">1</span></span><br><span class="line"><span class="number">77268</span><span class="number">10.732563</span><span class="number">0.545321</span><span class="number">1</span></span><br><span class="line"><span class="number">28490</span><span class="number">3.977403</span><span class="number">0.766103</span><span class="number">1</span></span><br><span class="line"><span class="number">13546</span><span class="number">4.194426</span><span class="number">0.450663</span><span class="number">2</span></span><br><span class="line"><span class="number">37166</span><span class="number">9.610286</span><span class="number">0.142912</span><span class="number">3</span></span><br><span class="line"><span class="number">16381</span><span class="number">4.797555</span><span class="number">1.260455</span><span class="number">2</span></span><br><span class="line"><span class="number">10848</span><span class="number">1.615279</span><span class="number">0.093002</span><span class="number">2</span></span><br><span class="line"><span class="number">35405</span><span class="number">4.614771</span><span class="number">1.027105</span><span class="number">1</span></span><br><span class="line"><span class="number">15917</span><span class="number">0.000000</span><span class="number">1.369726</span><span class="number">2</span></span><br><span class="line"><span class="number">6131</span><span class="number">0.608457</span><span class="number">0.512220</span><span class="number">2</span></span><br><span class="line"><span class="number">67432</span><span class="number">6.558239</span><span class="number">0.667579</span><span class="number">1</span></span><br><span class="line"><span class="number">30354</span><span class="number">12.315116</span><span class="number">0.197068</span><span class="number">3</span></span><br><span class="line"><span class="number">69696</span><span class="number">7.014973</span><span class="number">1.494616</span><span class="number">1</span></span><br><span class="line"><span class="number">33481</span><span class="number">8.822304</span><span class="number">1.194177</span><span class="number">3</span></span><br><span class="line"><span class="number">43075</span><span class="number">10.086796</span><span class="number">0.570455</span><span class="number">3</span></span><br><span class="line"><span class="number">38343</span><span class="number">7.241614</span><span class="number">1.661627</span><span class="number">3</span></span><br><span class="line"><span class="number">14318</span><span class="number">4.602395</span><span class="number">1.511768</span><span class="number">2</span></span><br><span class="line"><span class="number">5367</span><span class="number">7.434921</span><span class="number">0.079792</span><span class="number">2</span></span><br><span class="line"><span class="number">37894</span><span class="number">10.467570</span><span class="number">1.595418</span><span class="number">3</span></span><br><span class="line"><span class="number">36172</span><span class="number">9.948127</span><span class="number">0.003663</span><span class="number">3</span></span><br><span class="line"><span class="number">40123</span><span class="number">2.478529</span><span class="number">1.568987</span><span class="number">1</span></span><br><span class="line"><span class="number">10976</span><span class="number">5.938545</span><span class="number">0.878540</span><span class="number">2</span></span><br><span class="line"><span class="number">12705</span><span class="number">0.000000</span><span class="number">0.948004</span><span class="number">2</span></span><br><span class="line"><span class="number">12495</span><span class="number">5.559181</span><span class="number">1.357926</span><span class="number">2</span></span><br><span class="line"><span class="number">35681</span><span class="number">9.776654</span><span class="number">0.535966</span><span class="number">3</span></span><br><span class="line"><span class="number">46202</span><span class="number">3.092056</span><span class="number">0.490906</span><span class="number">1</span></span><br><span class="line"><span class="number">11505</span><span class="number">0.000000</span><span class="number">1.623311</span><span class="number">2</span></span><br><span class="line"><span class="number">22834</span><span class="number">4.459495</span><span class="number">0.538867</span><span class="number">1</span></span><br><span class="line"><span class="number">49901</span><span class="number">8.334306</span><span class="number">1.646600</span><span class="number">3</span></span><br><span class="line"><span class="number">71932</span><span class="number">11.226654</span><span class="number">0.384686</span><span class="number">1</span></span><br><span class="line"><span class="number">13279</span><span class="number">3.904737</span><span class="number">1.597294</span><span class="number">2</span></span><br><span class="line"><span class="number">49112</span><span class="number">7.038205</span><span class="number">1.211329</span><span class="number">3</span></span><br><span class="line"><span class="number">77129</span><span class="number">9.836120</span><span class="number">1.054340</span><span class="number">1</span></span><br><span class="line"><span class="number">37447</span><span class="number">1.990976</span><span class="number">0.378081</span><span class="number">1</span></span><br><span class="line"><span class="number">62397</span><span class="number">9.005302</span><span class="number">0.485385</span><span class="number">1</span></span><br><span class="line"><span class="number">0</span><span class="number">1.772510</span><span class="number">1.039873</span><span class="number">2</span></span><br><span class="line"><span class="number">15476</span><span class="number">0.458674</span><span class="number">0.819560</span><span class="number">2</span></span><br><span class="line"><span class="number">40625</span><span class="number">10.003919</span><span class="number">0.231658</span><span class="number">3</span></span><br><span class="line"><span class="number">36706</span><span class="number">0.520807</span><span class="number">1.476008</span><span class="number">1</span></span><br><span class="line"><span class="number">28580</span><span class="number">10.678214</span><span class="number">1.431837</span><span class="number">3</span></span><br><span class="line"><span class="number">25862</span><span class="number">4.425992</span><span class="number">1.363842</span><span class="number">1</span></span><br><span class="line"><span class="number">63488</span><span class="number">12.035355</span><span class="number">0.831222</span><span class="number">1</span></span><br><span class="line"><span class="number">33944</span><span class="number">10.606732</span><span class="number">1.253858</span><span class="number">3</span></span><br><span class="line"><span class="number">30099</span><span class="number">1.568653</span><span class="number">0.684264</span><span class="number">1</span></span><br><span class="line"><span class="number">13725</span><span class="number">2.545434</span><span class="number">0.024271</span><span class="number">2</span></span><br><span class="line"><span class="number">36768</span><span class="number">10.264062</span><span class="number">0.982593</span><span class="number">3</span></span><br><span class="line"><span class="number">64656</span><span class="number">9.866276</span><span class="number">0.685218</span><span class="number">1</span></span><br><span class="line"><span class="number">14927</span><span class="number">0.142704</span><span class="number">0.057455</span><span class="number">2</span></span><br><span class="line"><span class="number">43231</span><span class="number">9.853270</span><span class="number">1.521432</span><span class="number">3</span></span><br><span class="line"><span class="number">66087</span><span class="number">6.596604</span><span class="number">1.653574</span><span class="number">1</span></span><br><span class="line"><span class="number">19806</span><span class="number">2.602287</span><span class="number">1.321481</span><span class="number">2</span></span><br><span class="line"><span class="number">41081</span><span class="number">10.411776</span><span class="number">0.664168</span><span class="number">3</span></span><br><span class="line"><span class="number">10277</span><span class="number">7.083449</span><span class="number">0.622589</span><span class="number">2</span></span><br><span class="line"><span class="number">7014</span><span class="number">2.080068</span><span class="number">1.254441</span><span class="number">2</span></span><br><span class="line"><span class="number">17275</span><span class="number">0.522844</span><span class="number">1.622458</span><span class="number">2</span></span><br><span class="line"><span class="number">31600</span><span class="number">10.362000</span><span class="number">1.544827</span><span class="number">3</span></span><br><span class="line"><span class="number">59956</span><span class="number">3.412967</span><span class="number">1.035410</span><span class="number">1</span></span><br><span class="line"><span class="number">42181</span><span class="number">6.796548</span><span class="number">1.112153</span><span class="number">3</span></span><br><span class="line"><span class="number">51743</span><span class="number">4.092035</span><span class="number">0.075804</span><span class="number">1</span></span><br><span class="line"><span class="number">5194</span><span class="number">2.763811</span><span class="number">1.564325</span><span class="number">2</span></span><br><span class="line"><span class="number">30832</span><span class="number">12.547439</span><span class="number">1.402443</span><span class="number">3</span></span><br><span class="line"><span class="number">7976</span><span class="number">5.708052</span><span class="number">1.596152</span><span class="number">2</span></span><br><span class="line"><span class="number">14602</span><span class="number">4.558025</span><span class="number">0.375806</span><span class="number">2</span></span><br><span class="line"><span class="number">41571</span><span class="number">11.642307</span><span class="number">0.438553</span><span class="number">3</span></span><br><span class="line"><span class="number">55028</span><span class="number">3.222443</span><span class="number">0.121399</span><span class="number">1</span></span><br><span class="line"><span class="number">5837</span><span class="number">4.736156</span><span class="number">0.029871</span><span class="number">2</span></span><br><span class="line"><span class="number">39808</span><span class="number">10.839526</span><span class="number">0.836323</span><span class="number">3</span></span><br><span class="line"><span class="number">20944</span><span class="number">4.194791</span><span class="number">0.235483</span><span class="number">2</span></span><br><span class="line"><span class="number">22146</span><span class="number">14.936259</span><span class="number">0.888582</span><span class="number">3</span></span><br><span class="line"><span class="number">42169</span><span class="number">3.310699</span><span class="number">1.521855</span><span class="number">1</span></span><br><span class="line"><span class="number">7010</span><span class="number">2.971931</span><span class="number">0.034321</span><span class="number">2</span></span><br><span class="line"><span class="number">3807</span><span class="number">9.261667</span><span class="number">0.537807</span><span class="number">2</span></span><br><span class="line"><span class="number">29241</span><span class="number">7.791833</span><span class="number">1.111416</span><span class="number">3</span></span><br><span class="line"><span class="number">52696</span><span class="number">1.480470</span><span class="number">1.028750</span><span class="number">1</span></span><br><span class="line"><span class="number">42545</span><span class="number">3.677287</span><span class="number">0.244167</span><span class="number">1</span></span><br><span class="line"><span class="number">24437</span><span class="number">2.202967</span><span class="number">1.370399</span><span class="number">1</span></span><br><span class="line"><span class="number">16037</span><span class="number">5.796735</span><span class="number">0.935893</span><span class="number">2</span></span><br><span class="line"><span class="number">8493</span><span class="number">3.063333</span><span class="number">0.144089</span><span class="number">2</span></span><br><span class="line"><span class="number">68080</span><span class="number">11.233094</span><span class="number">0.492487</span><span class="number">1</span></span><br><span class="line"><span class="number">59016</span><span class="number">1.965570</span><span class="number">0.005697</span><span class="number">1</span></span><br><span class="line"><span class="number">11810</span><span class="number">8.616719</span><span class="number">0.137419</span><span class="number">2</span></span><br><span class="line"><span class="number">68630</span><span class="number">6.609989</span><span class="number">1.083505</span><span class="number">1</span></span><br><span class="line"><span class="number">7629</span><span class="number">1.712639</span><span class="number">1.086297</span><span class="number">2</span></span><br><span class="line"><span class="number">71992</span><span class="number">10.117445</span><span class="number">1.299319</span><span class="number">1</span></span><br><span class="line"><span class="number">13398</span><span class="number">0.000000</span><span class="number">1.104178</span><span class="number">2</span></span><br><span class="line"><span class="number">26241</span><span class="number">9.824777</span><span class="number">1.346821</span><span class="number">3</span></span><br><span class="line"><span class="number">11160</span><span class="number">1.653089</span><span class="number">0.980949</span><span class="number">2</span></span><br><span class="line"><span class="number">76701</span><span class="number">18.178822</span><span class="number">1.473671</span><span class="number">1</span></span><br><span class="line"><span class="number">32174</span><span class="number">6.781126</span><span class="number">0.885340</span><span class="number">3</span></span><br><span class="line"><span class="number">45043</span><span class="number">8.206750</span><span class="number">1.549223</span><span class="number">3</span></span><br><span class="line"><span class="number">42173</span><span class="number">10.081853</span><span class="number">1.376745</span><span class="number">3</span></span><br><span class="line"><span class="number">69801</span><span class="number">6.288742</span><span class="number">0.112799</span><span class="number">1</span></span><br><span class="line"><span class="number">41737</span><span class="number">3.695937</span><span class="number">1.543589</span><span class="number">1</span></span><br><span class="line"><span class="number">46979</span><span class="number">6.726151</span><span class="number">1.069380</span><span class="number">3</span></span><br><span class="line"><span class="number">79267</span><span class="number">12.969999</span><span class="number">1.568223</span><span class="number">1</span></span><br><span class="line"><span class="number">4615</span><span class="number">2.661390</span><span class="number">1.531933</span><span class="number">2</span></span><br><span class="line"><span class="number">32907</span><span class="number">7.072764</span><span class="number">1.117386</span><span class="number">3</span></span><br><span class="line"><span class="number">37444</span><span class="number">9.123366</span><span class="number">1.318988</span><span class="number">3</span></span><br><span class="line"><span class="number">569</span><span class="number">3.743946</span><span class="number">1.039546</span><span class="number">2</span></span><br><span class="line"><span class="number">8723</span><span class="number">2.341300</span><span class="number">0.219361</span><span class="number">2</span></span><br><span class="line"><span class="number">6024</span><span class="number">0.541913</span><span class="number">0.592348</span><span class="number">2</span></span><br><span class="line"><span class="number">52252</span><span class="number">2.310828</span><span class="number">1.436753</span><span class="number">1</span></span><br><span class="line"><span class="number">8358</span><span class="number">6.226597</span><span class="number">1.427316</span><span class="number">2</span></span><br><span class="line"><span class="number">26166</span><span class="number">7.277876</span><span class="number">0.489252</span><span class="number">3</span></span><br><span class="line"><span class="number">18471</span><span class="number">0.000000</span><span class="number">0.389459</span><span class="number">2</span></span><br><span class="line"><span class="number">3386</span><span class="number">7.218221</span><span class="number">1.098828</span><span class="number">2</span></span><br><span class="line"><span class="number">41544</span><span class="number">8.777129</span><span class="number">1.111464</span><span class="number">3</span></span><br><span class="line"><span class="number">10480</span><span class="number">2.813428</span><span class="number">0.819419</span><span class="number">2</span></span><br><span class="line"><span class="number">5894</span><span class="number">2.268766</span><span class="number">1.412130</span><span class="number">2</span></span><br><span class="line"><span class="number">7273</span><span class="number">6.283627</span><span class="number">0.571292</span><span class="number">2</span></span><br><span class="line"><span class="number">22272</span><span class="number">7.520081</span><span class="number">1.626868</span><span class="number">3</span></span><br><span class="line"><span class="number">31369</span><span class="number">11.739225</span><span class="number">0.027138</span><span class="number">3</span></span><br><span class="line"><span class="number">10708</span><span class="number">3.746883</span><span class="number">0.877350</span><span class="number">2</span></span><br><span class="line"><span class="number">69364</span><span class="number">12.089835</span><span class="number">0.521631</span><span class="number">1</span></span><br><span class="line"><span class="number">37760</span><span class="number">12.310404</span><span class="number">0.259339</span><span class="number">3</span></span><br><span class="line"><span class="number">13004</span><span class="number">0.000000</span><span class="number">0.671355</span><span class="number">2</span></span><br><span class="line"><span class="number">37885</span><span class="number">2.728800</span><span class="number">0.331502</span><span class="number">1</span></span><br><span class="line"><span class="number">52555</span><span class="number">10.814342</span><span class="number">0.607652</span><span class="number">3</span></span><br><span class="line"><span class="number">38997</span><span class="number">12.170268</span><span class="number">0.844205</span><span class="number">3</span></span><br><span class="line"><span class="number">69698</span><span class="number">6.698371</span><span class="number">0.240084</span><span class="number">1</span></span><br><span class="line"><span class="number">11783</span><span class="number">3.632672</span><span class="number">1.643479</span><span class="number">2</span></span><br><span class="line"><span class="number">47636</span><span class="number">10.059991</span><span class="number">0.892361</span><span class="number">3</span></span><br><span class="line"><span class="number">15744</span><span class="number">1.887674</span><span class="number">0.756162</span><span class="number">2</span></span><br><span class="line"><span class="number">69058</span><span class="number">8.229125</span><span class="number">0.195886</span><span class="number">1</span></span><br><span class="line"><span class="number">33057</span><span class="number">7.817082</span><span class="number">0.476102</span><span class="number">3</span></span><br><span class="line"><span class="number">28681</span><span class="number">12.277230</span><span class="number">0.076805</span><span class="number">3</span></span><br><span class="line"><span class="number">34042</span><span class="number">10.055337</span><span class="number">1.115778</span><span class="number">3</span></span><br><span class="line"><span class="number">29928</span><span class="number">3.596002</span><span class="number">1.485952</span><span class="number">1</span></span><br><span class="line"><span class="number">9734</span><span class="number">2.755530</span><span class="number">1.420655</span><span class="number">2</span></span><br><span class="line"><span class="number">7344</span><span class="number">7.780991</span><span class="number">0.513048</span><span class="number">2</span></span><br><span class="line"><span class="number">7387</span><span class="number">0.093705</span><span class="number">0.391834</span><span class="number">2</span></span><br><span class="line"><span class="number">33957</span><span class="number">8.481567</span><span class="number">0.520078</span><span class="number">3</span></span><br><span class="line"><span class="number">9936</span><span class="number">3.865584</span><span class="number">0.110062</span><span class="number">2</span></span><br><span class="line"><span class="number">36094</span><span class="number">9.683709</span><span class="number">0.779984</span><span class="number">3</span></span><br><span class="line"><span class="number">39835</span><span class="number">10.617255</span><span class="number">1.359970</span><span class="number">3</span></span><br><span class="line"><span class="number">64486</span><span class="number">7.203216</span><span class="number">1.624762</span><span class="number">1</span></span><br><span class="line"><span class="number">0</span><span class="number">7.601414</span><span class="number">1.215605</span><span class="number">2</span></span><br><span class="line"><span class="number">39539</span><span class="number">1.386107</span><span class="number">1.417070</span><span class="number">1</span></span><br><span class="line"><span class="number">66972</span><span class="number">9.129253</span><span class="number">0.594089</span><span class="number">1</span></span><br><span class="line"><span class="number">15029</span><span class="number">1.363447</span><span class="number">0.620841</span><span class="number">2</span></span><br><span class="line"><span class="number">44909</span><span class="number">3.181399</span><span class="number">0.359329</span><span class="number">1</span></span><br><span class="line"><span class="number">38183</span><span class="number">13.365414</span><span class="number">0.217011</span><span class="number">3</span></span><br><span class="line"><span class="number">37372</span><span class="number">4.207717</span><span class="number">1.289767</span><span class="number">1</span></span><br><span class="line"><span class="number">0</span><span class="number">4.088395</span><span class="number">0.870075</span><span class="number">2</span></span><br><span class="line"><span class="number">17786</span><span class="number">3.327371</span><span class="number">1.142505</span><span class="number">2</span></span><br><span class="line"><span class="number">39055</span><span class="number">1.303323</span><span class="number">1.235650</span><span class="number">1</span></span><br><span class="line"><span class="number">37045</span><span class="number">7.999279</span><span class="number">1.581763</span><span class="number">3</span></span><br><span class="line"><span class="number">6435</span><span class="number">2.217488</span><span class="number">0.864536</span><span class="number">2</span></span><br><span class="line"><span class="number">72265</span><span class="number">7.751808</span><span class="number">0.192451</span><span class="number">1</span></span><br><span class="line"><span class="number">28152</span><span class="number">14.149305</span><span class="number">1.591532</span><span class="number">3</span></span><br><span class="line"><span class="number">25931</span><span class="number">8.765721</span><span class="number">0.152808</span><span class="number">3</span></span><br><span class="line"><span class="number">7538</span><span class="number">3.408996</span><span class="number">0.184896</span><span class="number">2</span></span><br><span class="line"><span class="number">1315</span><span class="number">1.251021</span><span class="number">0.112340</span><span class="number">2</span></span><br><span class="line"><span class="number">12292</span><span class="number">6.160619</span><span class="number">1.537165</span><span class="number">2</span></span><br><span class="line"><span class="number">49248</span><span class="number">1.034538</span><span class="number">1.585162</span><span class="number">1</span></span><br><span class="line"><span class="number">9025</span><span class="number">0.000000</span><span class="number">1.034635</span><span class="number">2</span></span><br><span class="line"><span class="number">13438</span><span class="number">2.355051</span><span class="number">0.542603</span><span class="number">2</span></span><br><span class="line"><span class="number">69683</span><span class="number">6.614543</span><span class="number">0.153771</span><span class="number">1</span></span><br><span class="line"><span class="number">25374</span><span class="number">10.245062</span><span class="number">1.450903</span><span class="number">3</span></span><br><span class="line"><span class="number">55264</span><span class="number">3.467074</span><span class="number">1.231019</span><span class="number">1</span></span><br><span class="line"><span class="number">38324</span><span class="number">7.487678</span><span class="number">1.572293</span><span class="number">3</span></span><br><span class="line"><span class="number">69643</span><span class="number">4.624115</span><span class="number">1.185192</span><span class="number">1</span></span><br><span class="line"><span class="number">44058</span><span class="number">8.995957</span><span class="number">1.436479</span><span class="number">3</span></span><br><span class="line"><span class="number">41316</span><span class="number">11.564476</span><span class="number">0.007195</span><span class="number">3</span></span><br><span class="line"><span class="number">29119</span><span class="number">3.440948</span><span class="number">0.078331</span><span class="number">1</span></span><br><span class="line"><span class="number">51656</span><span class="number">1.673603</span><span class="number">0.732746</span><span class="number">1</span></span><br><span class="line"><span class="number">3030</span><span class="number">4.719341</span><span class="number">0.699755</span><span class="number">2</span></span><br><span class="line"><span class="number">35695</span><span class="number">10.304798</span><span class="number">1.576488</span><span class="number">3</span></span><br><span class="line"><span class="number">1537</span><span class="number">2.086915</span><span class="number">1.199312</span><span class="number">2</span></span><br><span class="line"><span class="number">9083</span><span class="number">6.338220</span><span class="number">1.131305</span><span class="number">2</span></span><br><span class="line"><span class="number">47744</span><span class="number">8.254926</span><span class="number">0.710694</span><span class="number">3</span></span><br><span class="line"><span class="number">71372</span><span class="number">16.067108</span><span class="number">0.974142</span><span class="number">1</span></span><br><span class="line"><span class="number">37980</span><span class="number">1.723201</span><span class="number">0.310488</span><span class="number">1</span></span><br><span class="line"><span class="number">42385</span><span class="number">3.785045</span><span class="number">0.876904</span><span class="number">1</span></span><br><span class="line"><span class="number">22687</span><span class="number">2.557561</span><span class="number">0.123738</span><span class="number">1</span></span><br><span class="line"><span class="number">39512</span><span class="number">9.852220</span><span class="number">1.095171</span><span class="number">3</span></span><br><span class="line"><span class="number">11885</span><span class="number">3.679147</span><span class="number">1.557205</span><span class="number">2</span></span><br><span class="line"><span class="number">4944</span><span class="number">9.789681</span><span class="number">0.852971</span><span class="number">2</span></span><br><span class="line"><span class="number">73230</span><span class="number">14.958998</span><span class="number">0.526707</span><span class="number">1</span></span><br><span class="line"><span class="number">17585</span><span class="number">11.182148</span><span class="number">1.288459</span><span class="number">3</span></span><br><span class="line"><span class="number">68737</span><span class="number">7.528533</span><span class="number">1.657487</span><span class="number">1</span></span><br><span class="line"><span class="number">13818</span><span class="number">5.253802</span><span class="number">1.378603</span><span class="number">2</span></span><br><span class="line"><span class="number">31662</span><span class="number">13.946752</span><span class="number">1.426657</span><span class="number">3</span></span><br><span class="line"><span class="number">86686</span><span class="number">15.557263</span><span class="number">1.430029</span><span class="number">1</span></span><br><span class="line"><span class="number">43214</span><span class="number">12.483550</span><span class="number">0.688513</span><span class="number">3</span></span><br><span class="line"><span class="number">24091</span><span class="number">2.317302</span><span class="number">1.411137</span><span class="number">1</span></span><br><span class="line"><span class="number">52544</span><span class="number">10.069724</span><span class="number">0.766119</span><span class="number">3</span></span><br><span class="line"><span class="number">61861</span><span class="number">5.792231</span><span class="number">1.615483</span><span class="number">1</span></span><br><span class="line"><span class="number">47903</span><span class="number">4.138435</span><span class="number">0.475994</span><span class="number">1</span></span><br><span class="line"><span class="number">37190</span><span class="number">12.929517</span><span class="number">0.304378</span><span class="number">3</span></span><br><span class="line"><span class="number">6013</span><span class="number">9.378238</span><span class="number">0.307392</span><span class="number">2</span></span><br><span class="line"><span class="number">27223</span><span class="number">8.361362</span><span class="number">1.643204</span><span class="number">3</span></span><br><span class="line"><span class="number">69027</span><span class="number">7.939406</span><span class="number">1.325042</span><span class="number">1</span></span><br><span class="line"><span class="number">78642</span><span class="number">10.735384</span><span class="number">0.705788</span><span class="number">1</span></span><br><span class="line"><span class="number">30254</span><span class="number">11.592723</span><span class="number">0.286188</span><span class="number">3</span></span><br><span class="line"><span class="number">21704</span><span class="number">10.098356</span><span class="number">0.704748</span><span class="number">3</span></span><br><span class="line"><span class="number">34985</span><span class="number">9.299025</span><span class="number">0.545337</span><span class="number">3</span></span><br><span class="line"><span class="number">31316</span><span class="number">11.158297</span><span class="number">0.218067</span><span class="number">3</span></span><br><span class="line"><span class="number">76368</span><span class="number">16.143900</span><span class="number">0.558388</span><span class="number">1</span></span><br><span class="line"><span class="number">27953</span><span class="number">10.971700</span><span class="number">1.221787</span><span class="number">3</span></span><br><span class="line"><span class="number">152</span><span class="number">0.000000</span><span class="number">0.681478</span><span class="number">2</span></span><br><span class="line"><span class="number">9146</span><span class="number">3.178961</span><span class="number">1.292692</span><span class="number">2</span></span><br><span class="line"><span class="number">75346</span><span class="number">17.625350</span><span class="number">0.339926</span><span class="number">1</span></span><br><span class="line"><span class="number">26376</span><span class="number">1.995833</span><span class="number">0.267826</span><span class="number">1</span></span><br><span class="line"><span class="number">35255</span><span class="number">10.640467</span><span class="number">0.416181</span><span class="number">3</span></span><br><span class="line"><span class="number">19198</span><span class="number">9.628339</span><span class="number">0.985462</span><span class="number">3</span></span><br><span class="line"><span class="number">12518</span><span class="number">4.662664</span><span class="number">0.495403</span><span class="number">2</span></span><br><span class="line"><span class="number">25453</span><span class="number">5.754047</span><span class="number">1.382742</span><span class="number">2</span></span><br><span class="line"><span class="number">12530</span><span class="number">0.000000</span><span class="number">0.037146</span><span class="number">2</span></span><br><span class="line"><span class="number">62230</span><span class="number">9.334332</span><span class="number">0.198118</span><span class="number">1</span></span><br><span class="line"><span class="number">9517</span><span class="number">3.846162</span><span class="number">0.619968</span><span class="number">2</span></span><br><span class="line"><span class="number">71161</span><span class="number">10.685084</span><span class="number">0.678179</span><span class="number">1</span></span><br><span class="line"><span class="number">1593</span><span class="number">4.752134</span><span class="number">0.359205</span><span class="number">2</span></span><br><span class="line"><span class="number">33794</span><span class="number">0.697630</span><span class="number">0.966786</span><span class="number">1</span></span><br><span class="line"><span class="number">39710</span><span class="number">10.365836</span><span class="number">0.505898</span><span class="number">3</span></span><br><span class="line"><span class="number">16941</span><span class="number">0.461478</span><span class="number">0.352865</span><span class="number">2</span></span><br><span class="line"><span class="number">69209</span><span class="number">11.339537</span><span class="number">1.068740</span><span class="number">1</span></span><br><span class="line"><span class="number">4446</span><span class="number">5.420280</span><span class="number">0.127310</span><span class="number">2</span></span><br><span class="line"><span class="number">9347</span><span class="number">3.469955</span><span class="number">1.619947</span><span class="number">2</span></span><br><span class="line"><span class="number">55635</span><span class="number">8.517067</span><span class="number">0.994858</span><span class="number">3</span></span><br><span class="line"><span class="number">65889</span><span class="number">8.306512</span><span class="number">0.413690</span><span class="number">1</span></span><br><span class="line"><span class="number">10753</span><span class="number">2.628690</span><span class="number">0.444320</span><span class="number">2</span></span><br><span class="line"><span class="number">7055</span><span class="number">0.000000</span><span class="number">0.802985</span><span class="number">2</span></span><br><span class="line"><span class="number">7905</span><span class="number">0.000000</span><span class="number">1.170397</span><span class="number">2</span></span><br><span class="line"><span class="number">53447</span><span class="number">7.298767</span><span class="number">1.582346</span><span class="number">3</span></span><br><span class="line"><span class="number">9194</span><span class="number">7.331319</span><span class="number">1.277988</span><span class="number">2</span></span><br><span class="line"><span class="number">61914</span><span class="number">9.392269</span><span class="number">0.151617</span><span class="number">1</span></span><br><span class="line"><span class="number">15630</span><span class="number">5.541201</span><span class="number">1.180596</span><span class="number">2</span></span><br><span class="line"><span class="number">79194</span><span class="number">15.149460</span><span class="number">0.537540</span><span class="number">1</span></span><br><span class="line"><span class="number">12268</span><span class="number">5.515189</span><span class="number">0.250562</span><span class="number">2</span></span><br><span class="line"><span class="number">33682</span><span class="number">7.728898</span><span class="number">0.920494</span><span class="number">3</span></span><br><span class="line"><span class="number">26080</span><span class="number">11.318785</span><span class="number">1.510979</span><span class="number">3</span></span><br><span class="line"><span class="number">19119</span><span class="number">3.574709</span><span class="number">1.531514</span><span class="number">2</span></span><br><span class="line"><span class="number">30902</span><span class="number">7.350965</span><span class="number">0.026332</span><span class="number">3</span></span><br><span class="line"><span class="number">63039</span><span class="number">7.122363</span><span class="number">1.630177</span><span class="number">1</span></span><br><span class="line"><span class="number">51136</span><span class="number">1.828412</span><span class="number">1.013702</span><span class="number">1</span></span><br><span class="line"><span class="number">35262</span><span class="number">10.117989</span><span class="number">1.156862</span><span class="number">3</span></span><br><span class="line"><span class="number">42776</span><span class="number">11.309897</span><span class="number">0.086291</span><span class="number">3</span></span><br><span class="line"><span class="number">64191</span><span class="number">8.342034</span><span class="number">1.388569</span><span class="number">1</span></span><br><span class="line"><span class="number">15436</span><span class="number">0.241714</span><span class="number">0.715577</span><span class="number">2</span></span><br><span class="line"><span class="number">14402</span><span class="number">10.482619</span><span class="number">1.694972</span><span class="number">2</span></span><br><span class="line"><span class="number">6341</span><span class="number">9.289510</span><span class="number">1.428879</span><span class="number">2</span></span><br><span class="line"><span class="number">14113</span><span class="number">4.269419</span><span class="number">0.134181</span><span class="number">2</span></span><br><span class="line"><span class="number">6390</span><span class="number">0.000000</span><span class="number">0.189456</span><span class="number">2</span></span><br><span class="line"><span class="number">8794</span><span class="number">0.817119</span><span class="number">0.143668</span><span class="number">2</span></span><br><span class="line"><span class="number">43432</span><span class="number">1.508394</span><span class="number">0.652651</span><span class="number">1</span></span><br><span class="line"><span class="number">38334</span><span class="number">9.359918</span><span class="number">0.052262</span><span class="number">3</span></span><br><span class="line"><span class="number">34068</span><span class="number">10.052333</span><span class="number">0.550423</span><span class="number">3</span></span><br><span class="line"><span class="number">30819</span><span class="number">11.111660</span><span class="number">0.989159</span><span class="number">3</span></span><br><span class="line"><span class="number">22239</span><span class="number">11.265971</span><span class="number">0.724054</span><span class="number">3</span></span><br><span class="line"><span class="number">28725</span><span class="number">10.383830</span><span class="number">0.254836</span><span class="number">3</span></span><br><span class="line"><span class="number">57071</span><span class="number">3.878569</span><span class="number">1.377983</span><span class="number">1</span></span><br><span class="line"><span class="number">72420</span><span class="number">13.679237</span><span class="number">0.025346</span><span class="number">1</span></span><br><span class="line"><span class="number">28294</span><span class="number">10.526846</span><span class="number">0.781569</span><span class="number">3</span></span><br><span class="line"><span class="number">9896</span><span class="number">0.000000</span><span class="number">0.924198</span><span class="number">2</span></span><br><span class="line"><span class="number">65821</span><span class="number">4.106727</span><span class="number">1.085669</span><span class="number">1</span></span><br><span class="line"><span class="number">7645</span><span class="number">8.118856</span><span class="number">1.470686</span><span class="number">2</span></span><br><span class="line"><span class="number">71289</span><span class="number">7.796874</span><span class="number">0.052336</span><span class="number">1</span></span><br><span class="line"><span class="number">5128</span><span class="number">2.789669</span><span class="number">1.093070</span><span class="number">2</span></span><br><span class="line"><span class="number">13711</span><span class="number">6.226962</span><span class="number">0.287251</span><span class="number">2</span></span><br><span class="line"><span class="number">22240</span><span class="number">10.169548</span><span class="number">1.660104</span><span class="number">3</span></span><br><span class="line"><span class="number">15092</span><span class="number">0.000000</span><span class="number">1.370549</span><span class="number">2</span></span><br><span class="line"><span class="number">5017</span><span class="number">7.513353</span><span class="number">0.137348</span><span class="number">2</span></span><br><span class="line"><span class="number">10141</span><span class="number">8.240793</span><span class="number">0.099735</span><span class="number">2</span></span><br><span class="line"><span class="number">35570</span><span class="number">14.612797</span><span class="number">1.247390</span><span class="number">3</span></span><br><span class="line"><span class="number">46893</span><span class="number">3.562976</span><span class="number">0.445386</span><span class="number">1</span></span><br><span class="line"><span class="number">8178</span><span class="number">3.230482</span><span class="number">1.331698</span><span class="number">2</span></span><br><span class="line"><span class="number">55783</span><span class="number">3.612548</span><span class="number">1.551911</span><span class="number">1</span></span><br><span class="line"><span class="number">1148</span><span class="number">0.000000</span><span class="number">0.332365</span><span class="number">2</span></span><br><span class="line"><span class="number">10062</span><span class="number">3.931299</span><span class="number">0.487577</span><span class="number">2</span></span><br><span class="line"><span class="number">74124</span><span class="number">14.752342</span><span class="number">1.155160</span><span class="number">1</span></span><br><span class="line"><span class="number">66603</span><span class="number">10.261887</span><span class="number">1.628085</span><span class="number">1</span></span><br><span class="line"><span class="number">11893</span><span class="number">2.787266</span><span class="number">1.570402</span><span class="number">2</span></span><br><span class="line"><span class="number">50908</span><span class="number">15.112319</span><span class="number">1.324132</span><span class="number">3</span></span><br><span class="line"><span class="number">39891</span><span class="number">5.184553</span><span class="number">0.223382</span><span class="number">3</span></span><br><span class="line"><span class="number">65915</span><span class="number">3.868359</span><span class="number">0.128078</span><span class="number">1</span></span><br><span class="line"><span class="number">65678</span><span class="number">3.507965</span><span class="number">0.028904</span><span class="number">1</span></span><br><span class="line"><span class="number">62996</span><span class="number">11.019254</span><span class="number">0.427554</span><span class="number">1</span></span><br><span class="line"><span class="number">36851</span><span class="number">3.812387</span><span class="number">0.655245</span><span class="number">1</span></span><br><span class="line"><span class="number">36669</span><span class="number">11.056784</span><span class="number">0.378725</span><span class="number">3</span></span><br><span class="line"><span class="number">38876</span><span class="number">8.826880</span><span class="number">1.002328</span><span class="number">3</span></span><br><span class="line"><span class="number">26878</span><span class="number">11.173861</span><span class="number">1.478244</span><span class="number">3</span></span><br><span class="line"><span class="number">46246</span><span class="number">11.506465</span><span class="number">0.421993</span><span class="number">3</span></span><br><span class="line"><span class="number">12761</span><span class="number">7.798138</span><span class="number">0.147917</span><span class="number">3</span></span><br><span class="line"><span class="number">35282</span><span class="number">10.155081</span><span class="number">1.370039</span><span class="number">3</span></span><br><span class="line"><span class="number">68306</span><span class="number">10.645275</span><span class="number">0.693453</span><span class="number">1</span></span><br><span class="line"><span class="number">31262</span><span class="number">9.663200</span><span class="number">1.521541</span><span class="number">3</span></span><br><span class="line"><span class="number">34754</span><span class="number">10.790404</span><span class="number">1.312679</span><span class="number">3</span></span><br><span class="line"><span class="number">13408</span><span class="number">2.810534</span><span class="number">0.219962</span><span class="number">2</span></span><br><span class="line"><span class="number">30365</span><span class="number">9.825999</span><span class="number">1.388500</span><span class="number">3</span></span><br><span class="line"><span class="number">10709</span><span class="number">1.421316</span><span class="number">0.677603</span><span class="number">2</span></span><br><span class="line"><span class="number">24332</span><span class="number">11.123219</span><span class="number">0.809107</span><span class="number">3</span></span><br><span class="line"><span class="number">45517</span><span class="number">13.402206</span><span class="number">0.661524</span><span class="number">3</span></span><br><span class="line"><span class="number">6178</span><span class="number">1.212255</span><span class="number">0.836807</span><span class="number">2</span></span><br><span class="line"><span class="number">10639</span><span class="number">1.568446</span><span class="number">1.297469</span><span class="number">2</span></span><br><span class="line"><span class="number">29613</span><span class="number">3.343473</span><span class="number">1.312266</span><span class="number">1</span></span><br><span class="line"><span class="number">22392</span><span class="number">5.400155</span><span class="number">0.193494</span><span class="number">1</span></span><br><span class="line"><span class="number">51126</span><span class="number">3.818754</span><span class="number">0.590905</span><span class="number">1</span></span><br><span class="line"><span class="number">53644</span><span class="number">7.973845</span><span class="number">0.307364</span><span class="number">3</span></span><br><span class="line"><span class="number">51417</span><span class="number">9.078824</span><span class="number">0.734876</span><span class="number">3</span></span><br><span class="line"><span class="number">24859</span><span class="number">0.153467</span><span class="number">0.766619</span><span class="number">1</span></span><br><span class="line"><span class="number">61732</span><span class="number">8.325167</span><span class="number">0.028479</span><span class="number">1</span></span><br><span class="line"><span class="number">71128</span><span class="number">7.092089</span><span class="number">1.216733</span><span class="number">1</span></span><br><span class="line"><span class="number">27276</span><span class="number">5.192485</span><span class="number">1.094409</span><span class="number">3</span></span><br><span class="line"><span class="number">30453</span><span class="number">10.340791</span><span class="number">1.087721</span><span class="number">3</span></span><br><span class="line"><span class="number">18670</span><span class="number">2.077169</span><span class="number">1.019775</span><span class="number">2</span></span><br><span class="line"><span class="number">70600</span><span class="number">10.151966</span><span class="number">0.993105</span><span class="number">1</span></span><br><span class="line"><span class="number">12683</span><span class="number">0.046826</span><span class="number">0.809614</span><span class="number">2</span></span><br><span class="line"><span class="number">81597</span><span class="number">11.221874</span><span class="number">1.395015</span><span class="number">1</span></span><br><span class="line"><span class="number">69959</span><span class="number">14.497963</span><span class="number">1.019254</span><span class="number">1</span></span><br><span class="line"><span class="number">8124</span><span class="number">3.554508</span><span class="number">0.533462</span><span class="number">2</span></span><br><span class="line"><span class="number">18867</span><span class="number">3.522673</span><span class="number">0.086725</span><span class="number">2</span></span><br><span class="line"><span class="number">80886</span><span class="number">14.531655</span><span class="number">0.380172</span><span class="number">1</span></span><br><span class="line"><span class="number">55895</span><span class="number">3.027528</span><span class="number">0.885457</span><span class="number">1</span></span><br><span class="line"><span class="number">31587</span><span class="number">1.845967</span><span class="number">0.488985</span><span class="number">1</span></span><br><span class="line"><span class="number">10591</span><span class="number">10.226164</span><span class="number">0.804403</span><span class="number">3</span></span><br><span class="line"><span class="number">70096</span><span class="number">10.965926</span><span class="number">1.212328</span><span class="number">1</span></span><br><span class="line"><span class="number">53151</span><span class="number">2.129921</span><span class="number">1.477378</span><span class="number">1</span></span><br><span class="line"><span class="number">11992</span><span class="number">0.000000</span><span class="number">1.606849</span><span class="number">2</span></span><br><span class="line"><span class="number">33114</span><span class="number">9.489005</span><span class="number">0.827814</span><span class="number">3</span></span><br><span class="line"><span class="number">7413</span><span class="number">0.000000</span><span class="number">1.020797</span><span class="number">2</span></span><br><span class="line"><span class="number">10583</span><span class="number">0.000000</span><span class="number">1.270167</span><span class="number">2</span></span><br><span class="line"><span class="number">58668</span><span class="number">6.556676</span><span class="number">0.055183</span><span class="number">1</span></span><br><span class="line"><span class="number">35018</span><span class="number">9.959588</span><span class="number">0.060020</span><span class="number">3</span></span><br><span class="line"><span class="number">70843</span><span class="number">7.436056</span><span class="number">1.479856</span><span class="number">1</span></span><br><span class="line"><span class="number">14011</span><span class="number">0.404888</span><span class="number">0.459517</span><span class="number">2</span></span><br><span class="line"><span class="number">35015</span><span class="number">9.952942</span><span class="number">1.650279</span><span class="number">3</span></span><br><span class="line"><span class="number">70839</span><span class="number">15.600252</span><span class="number">0.021935</span><span class="number">1</span></span><br><span class="line"><span class="number">3024</span><span class="number">2.723846</span><span class="number">0.387455</span><span class="number">2</span></span><br><span class="line"><span class="number">5526</span><span class="number">0.513866</span><span class="number">1.323448</span><span class="number">2</span></span><br><span class="line"><span class="number">5113</span><span class="number">0.000000</span><span class="number">0.861859</span><span class="number">2</span></span><br><span class="line"><span class="number">20851</span><span class="number">7.280602</span><span class="number">1.438470</span><span class="number">2</span></span><br><span class="line"><span class="number">40999</span><span class="number">9.161978</span><span class="number">1.110180</span><span class="number">3</span></span><br><span class="line"><span class="number">15823</span><span class="number">0.991725</span><span class="number">0.730979</span><span class="number">2</span></span><br><span class="line"><span class="number">35432</span><span class="number">7.398380</span><span class="number">0.684218</span><span class="number">3</span></span><br><span class="line"><span class="number">53711</span><span class="number">12.149747</span><span class="number">1.389088</span><span class="number">3</span></span><br><span class="line"><span class="number">64371</span><span class="number">9.149678</span><span class="number">0.874905</span><span class="number">1</span></span><br><span class="line"><span class="number">9289</span><span class="number">9.666576</span><span class="number">1.370330</span><span class="number">2</span></span><br><span class="line"><span class="number">60613</span><span class="number">3.620110</span><span class="number">0.287767</span><span class="number">1</span></span><br><span class="line"><span class="number">18338</span><span class="number">5.238800</span><span class="number">1.253646</span><span class="number">2</span></span><br><span class="line"><span class="number">22845</span><span class="number">14.715782</span><span class="number">1.503758</span><span class="number">3</span></span><br><span class="line"><span class="number">74676</span><span class="number">14.445740</span><span class="number">1.211160</span><span class="number">1</span></span><br><span class="line"><span class="number">34143</span><span class="number">13.609528</span><span class="number">0.364240</span><span class="number">3</span></span><br><span class="line"><span class="number">14153</span><span class="number">3.141585</span><span class="number">0.424280</span><span class="number">2</span></span><br><span class="line"><span class="number">9327</span><span class="number">0.000000</span><span class="number">0.120947</span><span class="number">2</span></span><br><span class="line"><span class="number">18991</span><span class="number">0.454750</span><span class="number">1.033280</span><span class="number">2</span></span><br><span class="line"><span class="number">9193</span><span class="number">0.510310</span><span class="number">0.016395</span><span class="number">2</span></span><br><span class="line"><span class="number">2285</span><span class="number">3.864171</span><span class="number">0.616349</span><span class="number">2</span></span><br><span class="line"><span class="number">9493</span><span class="number">6.724021</span><span class="number">0.563044</span><span class="number">2</span></span><br><span class="line"><span class="number">2371</span><span class="number">4.289375</span><span class="number">0.012563</span><span class="number">2</span></span><br><span class="line"><span class="number">13963</span><span class="number">0.000000</span><span class="number">1.437030</span><span class="number">2</span></span><br><span class="line"><span class="number">2299</span><span class="number">3.733617</span><span class="number">0.698269</span><span class="number">2</span></span><br><span class="line"><span class="number">5262</span><span class="number">2.002589</span><span class="number">1.380184</span><span class="number">2</span></span><br><span class="line"><span class="number">4659</span><span class="number">2.502627</span><span class="number">0.184223</span><span class="number">2</span></span><br><span class="line"><span class="number">17582</span><span class="number">6.382129</span><span class="number">0.876581</span><span class="number">2</span></span><br><span class="line"><span class="number">27750</span><span class="number">8.546741</span><span class="number">0.128706</span><span class="number">3</span></span><br><span class="line"><span class="number">9868</span><span class="number">2.694977</span><span class="number">0.432818</span><span class="number">2</span></span><br><span class="line"><span class="number">18333</span><span class="number">3.951256</span><span class="number">0.333300</span><span class="number">2</span></span><br><span class="line"><span class="number">3780</span><span class="number">9.856183</span><span class="number">0.329181</span><span class="number">2</span></span><br><span class="line"><span class="number">18190</span><span class="number">2.068962</span><span class="number">0.429927</span><span class="number">2</span></span><br><span class="line"><span class="number">11145</span><span class="number">3.410627</span><span class="number">0.631838</span><span class="number">2</span></span><br><span class="line"><span class="number">68846</span><span class="number">9.974715</span><span class="number">0.669787</span><span class="number">1</span></span><br><span class="line"><span class="number">26575</span><span class="number">10.650102</span><span class="number">0.866627</span><span class="number">3</span></span><br><span class="line"><span class="number">48111</span><span class="number">9.134528</span><span class="number">0.728045</span><span class="number">3</span></span><br><span class="line"><span class="number">43757</span><span class="number">7.882601</span><span class="number">1.332446</span><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>K-近邻算法的执行效率并不高，算法每次要进行大量的运算，那么是否存在一种算法减少存储空间和计算时间的开销呢？k 决策树就是 k-近邻算法的优化版，可以节省大量的计算开销。</p><p>K-近邻算法的另一个缺陷就是它无法给出任何数据的基础结构信息，因此我们也无法知晓平均实例样本和典型实例样本具体有什么特征。</p>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【1.0】机器学习基础</title>
      <link href="/2023/07/07/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%901.0%E3%80%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/07/07/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E3%80%901.0%E3%80%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我尝试从线性代数的部分写起，但是我发现这样太拖拉了，对于我的学习来说很不利，所以我打算就不写线性代数和高等数学的内容了，在学习机器学习之前请确保你已经对如下内容有一定的基础：</p><ul><li><strong><code>python</code>语言</strong>：如果不会请参考我的一些 python 内容或者自行网络上学习</li><li>线性代数：考研数学即可</li><li>高等数学：考研数学即可</li></ul><p>本系列内容参考自：<strong>Peter Harrington 的 《Machine Learning in Action》和《智能之门》</strong>以及哔哩哔哩，网络上相内容上结合本人实践编写。</p><h1 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h1><p>除了一些无关紧要的情况，<strong>人们很难直接从原始数据本身获取所需的信息</strong>。例如：对于垃圾邮件的检测，侦测一个单词是否存在没有太大的作用，然后当多个特定单词同时出现，再根据邮件的时间长度等其他因素，就可以快速的判断该邮件是否为垃圾邮件。<strong>简单的来说，机器学习就是把无序的数据转换为有用的信息</strong>。</p><p>机器学习用到了统计学知识，在大多数人看来，统计学不过是企业用以炫耀产品功能的一种统计而已。那么我们为什么还需要利用统计学呢？就工程实践来说，它是利用科学知识来解决具体的问题。在某些情况下，我们会面对很多需要确凿解法，或者说一成不变的解决方案，例如自动售卖机，我们投币，然后购买商品即可。</p><p>但是现实生活中，往往存在大量的问题并没有确凿的解决方案，或者说没有足够的计算资源来确立方案的模型。为了解决这些问题，我们就需要利用到统计学的相关知识。</p><h1 id="关键术语"><a href="#关键术语" class="headerlink" title="关键术语"></a>关键术语</h1><p>在研究机器学习算法之前，必须先了解一些基本的术语。通过构建下面的鸟类分类系统，我们将接触机器学习涉及的常用术语。这类系统非常有趣，通常与机器学习中的**专家系统<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>**有关。开发出能够识别鸟类的计算机软件，鸟类学者就可以退休了（笑🤣）。因为鸟类学者是研究鸟类的专家，因此我们说创建的是一个专家系统。</p><p>如下表是我们用于区分不同鸟类需要使用的四个不同的属性值，我们选择使用体重，翼展，有无脚蹼以及背后颜色作为评测基准。现实中，你可能会想测量更多的值。通常做法是测量所有可测属性，然后再挑选重要的部分。下面测量的四种值称之为<strong>特征</strong>，也可以称作：<strong>属性</strong>。</p><table><thead><tr><th align="center">序号</th><th align="center">体重(克)</th><th align="center">翼展(厘米)</th><th align="center">脚蹼</th><th align="center">后背颜色</th><th align="center">种属</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1000.1</td><td align="center">125.0</td><td align="center">无</td><td align="center">棕色</td><td align="center">红尾鹭</td></tr><tr><td align="center">2</td><td align="center">3000.7</td><td align="center">200.0</td><td align="center">无</td><td align="center">灰色</td><td align="center">鹭鹰</td></tr><tr><td align="center">3</td><td align="center">3300.0</td><td align="center">220.3</td><td align="center">无</td><td align="center">灰色</td><td align="center">鹭鹰</td></tr><tr><td align="center">4</td><td align="center">4100.0</td><td align="center">136.0</td><td align="center">有</td><td align="center">黑色</td><td align="center">普通潜鸟</td></tr><tr><td align="center">5</td><td align="center">3.0</td><td align="center">11.0</td><td align="center">无</td><td align="center">绿色</td><td align="center">瑰丽蜂鸟</td></tr><tr><td align="center">6</td><td align="center">570.0</td><td align="center">75.0</td><td align="center">无</td><td align="center">黑色</td><td align="center">象牙喙啄木鸟</td></tr></tbody></table><p>上表中前两种特征是数值型，可以使用十进制数字；第三种特征是二值型，只可以取 0 或者 1；第四种特征是基于自定义调色板的枚举类型，这里仅选择一些常用的颜色。</p><p><strong>机器学习的主要任务就是：分类</strong>。我们将会介绍如何使用上表进行分类。如果我们希望在众多的鸟类中识别出象牙喙啄木鸟，最简单的做法就是雇佣一个鸟类学者，让他们在鸟类进食的地方蹲守查看识别。但是这种方法成本过于昂贵，而且专家一次只能在一个地方蹲守。</p><p>我们可以自动化的处理上述过程，在鸟类进食的地点放置多台摄像机，然后通过各种传感器获得鸟类的特征，然后接下来的任务就是<strong>根据传感器获取的数据进行分类</strong>，有很多机器学习的算法善于分类。具体到本例，就是善于区分是否为象牙喙啄木鸟。</p><p>最终我们决定使用某个机器学习算法来分类，<strong>首先需要做的是算法训练</strong>，即学习如何分类，通常我们<strong>为算法输入大量已分类数据作为算法的训练集，每个训练样本有四种特征，一个目标变量，</strong>如下图所示。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae1295aa73.png" alt="image-20230706215727892" style="zoom:80%;" /><p><strong>目标变量就是机器学习算法的预测结果</strong>，在分类算法中目标变量的类型通常是标称型<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>的，而在回归算法中通常是连续型<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。训练样本集必须确定知道目标变量的值，以便机器学习算法可以发现特征和目标变量之间的关系。正如前面说的，目标变量是物种，也可以简化为标称型的数值。我们通常<strong>将分类问题中的目标变量称为类别</strong>，并假定分类问题只存在有限个数的类别。</p><p>为了测试机器学习算法的效果，通常使用两套独立的样本集：<strong>训练数据和测试数据</strong>。当机器学习程序开始运行时，使用训练样本集作为算法的输入，训练完成之后输入测试样本。输入测试样本时并不提供测试样本的目标变量，由程序决定样本属于哪个类别。比较测试样本预测的目标变量值和实际样本类别之间的差别，就可以得到算法的实际精确度。</p><p>假定这个鸟类分类程序，经过测试满足精度要求，是否我们就可以看到机器已经学会如何区分不同的鸟类了呢？这部分工作称之为：<strong>知识表示</strong>，某些算法可以产生很容易理解的知识表示，而某些算法的知识表示也许只能被计算机所理解。在某些场合下，人们可能并不小建立一个专家系统，而仅仅对机器学习算法获取的信息感兴趣。此时，采用何种方式表示知识就显得非常重要了。</p><h1 id="机器学习的主要任务"><a href="#机器学习的主要任务" class="headerlink" title="机器学习的主要任务"></a>机器学习的主要任务</h1><p>上面的例子介绍了机器学习如何解决分类问题的，它的主要任务是将实例数据划分到合适的分类中。<strong>机器学习的另一项任务是：回归，它主要用于预测数值型数据。</strong>大多数人可能都见过回归的例子——数据拟合曲线：通过给定数据点，拟合最优的曲线。<strong>分类和回归属于监督学习</strong>，之所以称之为监督学习，是因为这类算法必须知道预测什么，即目标变量的分类信息。</p><p>与监督学习对应的是<strong>无监督学习，此时数据没有类别信息，也不会给定目标值</strong>。<strong>在无监督学习中，将数据集合分成由类似的对象组成的多个类的过程被称为聚类</strong>；将寻找描述数据统计值的过程称为<strong>密度估计</strong>。此外，<strong>无监督学习可以减少数据特征的维度</strong>，以便我们可以使用二维或者三维图形更加直观的展示数据信息。如下表列出了机器学习的主要任务及其相关算法：</p><table><thead><tr><th>监督学习</th><th>无监督学习</th></tr></thead><tbody><tr><td>K-近邻算法</td><td>K-均值</td></tr><tr><td>朴素贝叶斯算法</td><td>DBSCAN</td></tr><tr><td>支持向量机</td><td>最大期望算法</td></tr><tr><td>决策树</td><td>Parzen 窗设计</td></tr><tr><td>线性回归</td><td></td></tr><tr><td>局部加权线性回归</td><td></td></tr><tr><td>Ridge 回归</td><td></td></tr><tr><td>Lasso 最小回归系数估计</td><td></td></tr></tbody></table><p>你可能注意到上表中很多算法可以解决同样的问题，有心人会关心：为什么解决同一个问题存在四种方法？精通其中一种算法，是否可以处理所有类似的问题？下面将会解答一些疑问。</p><h1 id="如何选择合适的算法"><a href="#如何选择合适的算法" class="headerlink" title="如何选择合适的算法"></a>如何选择合适的算法</h1><p>上表中所列的算法中选择实际可用的算法，必须考虑下面两个问题：</p><ol><li>使用机器字习算法的目的，想要算法完成何种任务，比如是预测明天下雨的概率还是对投票者按照兴趣分组；</li><li>需要分析或收集的数据是什么。</li></ol><p><strong>首先考虑使用机器学习算法的目的</strong>。如果想要预测目标变量的值，则可以选择监督学习算法，否则可以选择无监督学习算法。确定选择监督学习算法之后，需要进一步确定目标变量类型，如果目标变量是离散型，如是／否、1／2／3、A／B／C或者红／黄／黑等，则可以选择分类算法；如果目标变量是连续型的数值，如0.0～100.00、—999～999或者＋00～—00等，则需要选择回归算法。</p><p>如果不想预测目标变量的值，则可以选择无监督学习算法。进一步分析是否需要将数据划分为离散的组。如果这是唯一的需求，则使用聚类算法；如果还需要估计数据与每个分组的相似程度，则需要使用密度估计算法。</p><p>在大多数情况下，上面给出的选择方法都能帮助读者选择恰当的机器学习算法，但这也并非一成不变。</p><p>其次需要考虑的是数据问题。我们应该充分了解数据，对实际数据了解得越充分，越容易创建符合实际需求的应用程序。主要应该了解数据的以下特性：特征值是离散型变量还是连续型变量，特征值是否存在缺省值，何种原因造成的缺省，是否存在异常值等等。充分了解上面提到的数据特征可以缩短选择机器学习算法的时间。</p><p>我们只能在一定程度上缩小算法的选择范围，一般并不存在最好的算法或者可以给出最好结果的算法，同时还要尝试不同算的执行效果。</p><h1 id="开发机器学习应用程序的步骤"><a href="#开发机器学习应用程序的步骤" class="headerlink" title="开发机器学习应用程序的步骤"></a>开发机器学习应用程序的步骤</h1><ul><li>收集数据：用多种方法获取样本数据</li><li>准备输入数据：获取数据后确保样本的格式符合要求</li><li>分析输入数据：此步骤是人工分析数据，检测数据中的值是否正常，有没有垃圾数据，没没有空值等</li><li>训练算法</li><li>测试算法</li><li>使用算法</li></ul><h1 id="Python相关"><a href="#Python相关" class="headerlink" title="Python相关"></a>Python相关</h1><p>关于 Python 相关的基础内容和说明可以参考<a href="https://www.helloseraphine.top/2023/04/11/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%901.0%E3%80%91Python%E5%85%A5%E9%97%A8/">【1.0】Python入门</a>，此处我不在赘述，还需要说明的一点就是本系列内容将会使用到<code>NumPy</code>函数库，它包含大量的线代数学相关函数以供使用，具体安装也不再赘述，可以参考<a href="https://www.helloseraphine.top/2023/06/30/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%906.0%E3%80%91%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/">【6.0】虚拟环境和包</a>。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>现在数据越来越重要了，从程序的角度，由原来的事件驱动，到现在的数据驱动，数据是核心，而从数据中分析出相关结果是算法。</p><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">专家系统是一种具有专门知识和经验的计算机智能程序系统，它采用知识表示和知识推理技术来模拟通常由领域专家才能解决的复杂问题。专家系统由知识库和推理机组成，知识库存储着逻辑推理的规则，推理机则从外部输入的问题中提取相关知识并进行推理，最终给出答案或解决方案。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">标称型变量是一种表示不同类别或类型的变量，其中每个类别都是独立且没有内在顺序或数量关系的。标称型变量的取值只能用于区分不同的类别，而不能进行比较或排序。</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">与标称型变量不同，连续型变量是基于数值的，具有无限个可能的取值。这种变量通常表示一种度量、数量或连续范围内的观测或测量结果。连续型变量的取值可以是实数，可以包括小数和分数，并且在可能的取值范围内可以存在无限个可能值。</span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Python的一些工具</title>
      <link href="/2023/07/05/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E5%85%B3%E4%BA%8EPython%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/07/05/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E5%85%B3%E4%BA%8EPython%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想了一阵，还是觉得这个标题有些不太对，或者说不太切题。关于这篇内容，我主要是想说明如果使用<strong>Anaconda</strong>来更加方便的管理<code>python</code>环境，对于机器学习相关方便更是大有帮助。另外来简单搭建使用<code>PyQt</code>来开发跨平台桌面软件。</p><p>大概如此，标题果然还是有些太大了。</p><h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><p>关于<code>python</code>的环境配置相关内容基础，我已经在之前的<code>python</code>文章中做了说明，对于繁杂的环境操作，我们可以使用<code>Anaconda</code>来更加方便的管理我们的<code>python</code>环境，对于做机器学习相关的伙伴来说更加方便，它包含了大量的机器学习相关的包，可以某种程度上避免国内网络问题导致某些包无法安装的问题。</p><h2 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h2><p>你可以通过访问<a href="httpss://www.anaconda.com/">Anaconda官网</a>来访问下载安装对应系统的<code>Anaconda</code>，此处省略下载安装。</p><p>安装完成后，运行<code>Anaconda Navigator</code>，它会做一些初始化工作，期间屏幕会闪出一些命令窗口是正常的，仅需要等待软件启动即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf14d0e2d.png" alt="image-20230705211928932" style="zoom:80%;" /><p>进入软件后，界面如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf18217f3.png" alt="image-20230705213124365" style="zoom: 67%;" /><p>你可以在主页中，配置相关工具，例如如果你下载了<code>PyCharm</code>或者<code>VS code</code>都可以在这里配置，其中有一个<code>jupyter</code>这个工具，我会在后面说明，它是一个特殊的“笔记本”，它集成了笔迹和代码运行两个功能，它使用起来会大大方便相关功能文档等的说明。</p><h2 id="管理-Python-环境"><a href="#管理-Python-环境" class="headerlink" title="管理 Python 环境"></a>管理 Python 环境</h2><p>现在，将功能聚焦到<code>python</code>环境上面来，进入<strong>Environments</strong>界面后，如果你是第一次下载安装，中间则只存在<code>base</code>环境，如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf1bbb35c.png" alt="image-20230705213423603" style="zoom:67%;" /><p>这是<code>Anaconda</code>默认自带的初始<code>python</code>环境，如果你需要创建一个新的项目，则可以点击下面的<code>create</code>来创建新的环境，新环境的路径默认在你的<code>Anaconda</code>安装路径下的<code>envs</code>文件夹中，在创建好对应的新环境后，可以点击该环境来切换到该环境。</p><p>在该环境中，你需要安装的包都可以通过右侧来搜索安装，当然会存在一些包并不能搜索到，这是因为这里的包都是在<code>Anaconda</code>中搜索的。如果你希望安装一些搜索不到的包，可以通过命令行来进行安装。</p><h2 id="通过命令行操作"><a href="#通过命令行操作" class="headerlink" title="通过命令行操作"></a>通过命令行操作</h2><p>我们在安装完成<strong>Anaconda</strong>后，伴随着还会存在一个名称为<strong>Anaconda Prompt</strong>的桌面快捷方式，双击运行后会出现和<code>CMD</code>一样的命令行窗口。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf1f488cd.png" alt="image-20230705214107164" style="zoom:67%;" /><p>这是<strong>Anaconda</strong>的命令行窗口，左侧默认<code>(base)</code>的意思是当前激活环境为<code>base</code>环境，同样的你也可以通过可视化的<strong>Anaconda Navigator</strong>中看到并管理这个环境，如下是一些常用的<code>Anaconda</code>命令：</p><table><thead><tr><th>命令</th><th>说明</th><th>类别</th></tr></thead><tbody><tr><td><code>conda create --name myenv</code></td><td>创建一个新环境。</td><td>环境管理</td></tr><tr><td><code>conda create --name myenv python=3.8</code></td><td>创建特定版本的Python环境。</td><td>环境管理</td></tr><tr><td><code>conda create --name myenv numpy pandas</code></td><td>创建包含特定包的环境。</td><td>环境管理</td></tr><tr><td><code>conda env create --file environment.yml</code></td><td>通过环境文件创建环境。</td><td>环境管理</td></tr><tr><td><code>conda activate myenv</code></td><td>激活环境。</td><td>环境管理</td></tr><tr><td><code>conda deactivate</code></td><td>退出环境。</td><td>环境管理</td></tr><tr><td><code>conda remove --name myenv --all</code></td><td>删除环境。</td><td>环境管理</td></tr><tr><td><code>conda install package_name</code></td><td>安装包。</td><td>包管理</td></tr><tr><td><code>conda install package_name=1.0</code></td><td>安装特定版本的包。</td><td>包管理</td></tr><tr><td><code>conda update package_name</code></td><td>更新包。</td><td>包管理</td></tr><tr><td><code>conda remove package_name</code></td><td>移除包。</td><td>包管理</td></tr><tr><td><code>conda search package_name</code></td><td>搜索包。</td><td>包管理</td></tr><tr><td><code>conda list</code></td><td>列出已安装的包。</td><td>包管理</td></tr><tr><td><code>conda env export &gt; environment.yml</code></td><td>导出环境到文件。</td><td>环境管理</td></tr><tr><td><code>conda create --name new_env --clone old_env</code></td><td>克隆环境。</td><td>环境管理</td></tr><tr><td><code>conda env list</code></td><td>查看已创建的环境。</td><td>环境管理</td></tr></tbody></table><p>现在我们通过命令<code>conda activate myenv</code>来激活我们希望安装包的环境，如果你不知道环境的名称，可以通过使用命令<code>conda env list</code>来查看，在激活对应环境后，左侧的<code>(base)</code>会变成对应环境的名称。</p><p>接下来，通过对应安装包的<code>pip</code>命令来安装对应的包即可，在安装完成后，可以通过命令<code>conda list</code>来查看环境中已安装的包。</p><h1 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h1><p>在安装和了解<strong>Anaconda</strong>后，现在来了解一款<code>python</code>的<strong>IDE</strong>——<code>PyCharm</code>，你也可以通过访问<a href="httpss://www.jetbrains.com/zh-cn/pycharm/">PyCharm官网</a>来下载安装对应平台的软件，需要注意的是，<strong>社区版是免费的，而专业版是收费的</strong>，对于一般大部分情况下，我们使用社区版就可以了。</p><blockquote><p>关于<strong>PyCharm</strong>的说明：<strong>它的提示词是大小写敏感的</strong>。</p></blockquote><h2 id="汉化-PyCharm"><a href="#汉化-PyCharm" class="headerlink" title="汉化 PyCharm"></a>汉化 PyCharm</h2><p>对于不喜欢英文操作环境的伙伴来说，可以通过<strong>点击【设置】</strong>，选择【插件】，然后搜索【Chinese】，选择安装，然后重启<strong>PyCharm</strong>即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf23d98fa.png" alt="image-20230705221602179" style="zoom:50%;" /><h2 id="引入-Anaconda-创建的环境"><a href="#引入-Anaconda-创建的环境" class="headerlink" title="引入 Anaconda 创建的环境"></a>引入 Anaconda 创建的环境</h2><p>在下载安装完成后，我们希望创建的项目使用我们在<code>Anaconda</code>中配置的环境，可以通过选择<strong>【先前配置的解释器】</strong>，如果你是第一次创建新项目，则解释器部分为空白，你需要点击<strong>【添加解释器】</strong>，然后在对应的环境下，选择对应的<code>python.exe</code>。</p><blockquote><p>这个路径就是你环境的路径，默认是你<code>Anaconda</code>安装目录下的<code>env</code>文件夹下。</p></blockquote><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf2794fbf.png" alt="image-20230705221100698" style="zoom:67%;" /><p>这样就完成了新项目使用<code>Anaconda</code>创建的环境。而前面的选项【使用此工具创建新环境】是创建新环境的操作，此处不做赘述。</p><h2 id="找不到-Conda-可执行文件问题"><a href="#找不到-Conda-可执行文件问题" class="headerlink" title="找不到 Conda 可执行文件问题"></a>找不到 Conda 可执行文件问题</h2><p>如果你使用的是新版的（2023）的 PyCharm 在创建项目的时候，可能会遇到找不到 Conda可执行文件，解决办法如下图所示：</p><ul><li>找到 Anaconda 安装目录的 <strong>_conda.bat</strong> 文件。然后点击加载环境</li><li>然后选择现有环境，选择你要使用的 Python 环境即可</li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/22/64bbcb0567dd9.png" alt="image-20230722202631462" style="zoom:80%;" /><h2 id="安装包后，PyCharm-找不到包的问题"><a href="#安装包后，PyCharm-找不到包的问题" class="headerlink" title="安装包后，PyCharm 找不到包的问题"></a>安装包后，PyCharm 找不到包的问题</h2><p>这个问题出现在使用 Anaconda 的可视化安装界面完成对应环境中的指定包安装，然后使用 PyCharm 调用相关包的时候报错包不存在，而且在 PyCharm 的包管理器界面确实看不到安装的包，但是 Anaconda 却显示安装。即使重启 PyCharm 后依旧如此。</p><p>解决办法：使用 <strong>Anaconda Prompt</strong> <strong>通过命令行(<code>pip</code>)的方式来安装即可解决</strong>。</p><h1 id="Jupyter"><a href="#Jupyter" class="headerlink" title="Jupyter"></a>Jupyter</h1><p><strong>Jupyrer</strong>是一个开源项目，如果你了解<strong>Github</strong>的话，请给这个项目一个<strong>Star</strong>，<a href="httpss://github.com/jupyter/jupyter">点我访问项目</a>。</p><h2 id="安装-Jupyter"><a href="#安装-Jupyter" class="headerlink" title="安装 Jupyter"></a>安装 Jupyter</h2><p>当然你如果只是一个基本的使用者，可以并不需要关注这些，你需要在对应的环境中点击【install(安装)】来安装<strong>Jupyter</strong>，安装完成后，按钮就会变成【Launch(启动)】如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf2b3192a.png" alt="image-20230705222342270" style="zoom:67%;" /><p>在安装完成后，点击启动即可，它会拉起你的浏览器，界面如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf2fb0792.png" alt="image-20230705222519662" style="zoom:67%;" /><p>其中默认的文件是这台电脑中，目前用户的文件夹。</p><h2 id="使用-Jupyter"><a href="#使用-Jupyter" class="headerlink" title="使用 Jupyter"></a>使用 Jupyter</h2><p>你可以通过右上角，单击【New】按钮来创建新的笔记本，记得确定对应的文件保存路径，点击创建：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf33af4f5.png" alt="image-20230705222723679" style="zoom: 80%;" /><p>默认页面如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf36eee6c.png" alt="image-20230705222803123" style="zoom:80%;" /><p>每一行内容都存在一种类型属性，在<strong>Jupyter</strong>中，存在四种类型，分别是：</p><ul><li><strong>Markdown</strong></li><li><strong>代码</strong></li><li><strong>原生 NBConvert</strong></li><li><strong>标题</strong>：已不支持，合并到<code>Markdown</code>中了</li></ul><p>我们可以通过选中对应的“行”，然后选择其类型，如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf3aae0e3.png" alt="image-20230705223047708" style="zoom:80%;" /><p>关于代码类型，即你也可以在里面编写对应的<code>python</code>代码，其中代码会按照某种规则高亮显示，并且你在点击【运行】后，可以在下面展现运行结果，例如，我们使用<code>print(&quot;Hello,World&quot;)</code>来测试，如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf3e2edca.png" alt="image-20230705223238264" style="zoom:80%;" /><p>现在我们来使用<code>markdown</code>类型，其中内容如下所示：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这是一个标题</span></span><br><span class="line"><span class="strong">**这是黑体**</span>，这是正常字体，<span class="emphasis">*这是斜体*</span></span><br><span class="line">| 这是表头 | 这也是表头 |</span><br><span class="line">| :-: | :-: |</span><br><span class="line">| 这是内容 | 这也是内容 |</span><br></pre></td></tr></table></figure><p>在编写完成后，点击【运行】就会显示如下效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf41dbe6b.png" alt="image-20230705223409360" style="zoom:80%;" /><p>如果你并不了解<code>markdown</code>可以在网上查询并学习，其学习成本大概半个小时既可以掌握使用</p><blockquote><p>我以为我自己写过<code>markdown</code>相关内容，现在发现我并没有写基础的语法相关，仅找到<a href="https://blog.helloseraphine.top:8090/archives/markdown%E8%BF%9B%E9%98%B6">markdown进阶</a>这部分内容，里面的内容是2年前写的了，可能部分内容已经不适了，请自行参考。</p></blockquote><h1 id="PyQt"><a href="#PyQt" class="headerlink" title="PyQt"></a>PyQt</h1><p>PyQt是一个跨平台可视化 GUI 开发框架，它是使用<code>python</code>来封装调用原<code>QT</code>(C++)的相关内容来完成开发。</p><p><strong>PyQt</strong>目前两个版本，目前完善且流行的<strong>PyQt5</strong>，以及<strong>PyQt6</strong>，目前我们仅使用<strong>PyQt5</strong>做说明。</p><h2 id="安装-PyQt"><a href="#安装-PyQt" class="headerlink" title="安装 PyQt"></a>安装 PyQt</h2><p>我们需要安装<code>PyQt5</code>和<code>PyQt5-sip</code>两个包，通过使用<strong>Anaconda Prompt</strong>来安装，需要注意的是：请先激活要按安装的环境，然后使用如下命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install PyQt5</span><br><span class="line">pip3 install PyQt5-sip</span><br></pre></td></tr></table></figure><p>安装完成后，你可以使用命令<code>conda list</code>或者在<strong>PyCharm</strong>中查看到对应的包，另外，我们还需要专门下载一个<strong>Qt designer</strong>来负责完成可视化 GUI 的界面设计。你可以通过点击<a href="httpss://build-system.fman.io/qt-designer-download">访问官网</a>来下载安装对应平台的软件。</p><p>下载完成后，界面如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf45ec23d.png" alt="image-20230705230412451" style="zoom:80%;" /><h2 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h2><p>现在，创建一个新的<code>py</code>文件，名称任意，然后编写并运行如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QWidget, QApplication</span><br><span class="line"></span><br><span class="line">app = QApplication(sys.argv)</span><br><span class="line">widget = QWidget()</span><br><span class="line">widget.resize(<span class="number">640</span>, <span class="number">480</span>)</span><br><span class="line">widget.setWindowTitle(<span class="string">&quot;Hello, PyQt5!&quot;</span>)</span><br><span class="line">widget.show()</span><br><span class="line">sys.exit(app.<span class="built_in">exec</span>())</span><br></pre></td></tr></table></figure><p>点击运行后，会弹出一个窗体，并且其标题为<code>Hello,PyQt5!</code>，即表示安装运行一切正常且完成。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbf49c55c4.png" alt="image-20230705230648381" style="zoom:80%;" /><p>剩下的关于<strong>Qt designer</strong>的使用和<strong>PyQT5</strong>开发则是另外的内容了，如果感兴趣的话可以自行百度或者查找相关资料学习。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>这部分算是给我的<code>Python</code>一个结尾，接下来的<code>python</code>内容分为两个方向，一个是机器学习方面，一个是<code>PyQt</code>跨平台开发方面，祝看到这里的小伙伴前程似锦呀🥰</p><p>⭐如下是本篇涉及的参考文档：</p><ul><li><a href="https://blog.csdn.net/JJxiao520/article/details/129412630">23年最新版pycharm找不到conda可执行文件解决办法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【6.0】虚拟环境和包</title>
      <link href="/2023/06/30/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%906.0%E3%80%91%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/"/>
      <url>/2023/06/30/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%906.0%E3%80%91%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Python应用程序通常会使用不在标准库内的软件包和模块。应用程序有时需要特定版本的库，因为应用程序可能需要修复特定的错误，或者可以使用库的过时版本的接口编写应用程序。</p><p>这意味着一个Python安装可能无法满足每个应用程序的要求。如果应用程序A需要特定模块的1.0版本但应用程序B需要2.0版本，则需求存在冲突，安装版本1.0或2.0将导致某一个应用程序无法运行。</p><p><strong>这个问题的解决方案是创建一个 <a href="httpss://docs.python.org/zh-cn/3.8/glossary.html#term-virtual-environment">virtual environment</a>，一个目录树，其中安装有特定Python版本，以及许多其他包。</strong></p><p>然后，不同的应用将可以使用不同的虚拟环境。 要解决先前需求相冲突的例子，应用程序 A 可以拥有自己的 安装了 1.0 版本的虚拟环境，而应用程序 B 则拥有安装了 2.0 版本的另一个虚拟环境。 如果应用程序 B 要求将某个库升级到 3.0 版本，也不会影响应用程序 A 的环境。</p><h1 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h1><p>用于创建和管理虚拟环境的模块称为 <a href="httpss://docs.python.org/zh-cn/3.8/library/venv.html#module-venv"><code>venv</code></a>。<a href="httpss://docs.python.org/zh-cn/3.8/library/venv.html#module-venv"><code>venv</code></a> 通常会安装你可用的最新版本的 Python。如果您的系统上有多个版本的 Python，您可以通过在系统变量中设置然后通过自定义命令来选择特定的Python版本。</p><blockquote><p>关于系统变量相关内容，可以查看<a href="https://blog.helloseraphine.top:8090/archives/huan-jing-bian-liang-na-xie-shi">环境变量那些事</a></p></blockquote><p>要创建虚拟环境，其<strong>在命令行状态下</strong>，请确定要放置它的目录，并将 <a href="httpss://docs.python.org/zh-cn/3.8/library/venv.html#module-venv"><code>venv</code></a> 模块作为脚本运行目录路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m venv tutorial-env</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">其中tutorial-env你可以自定义其他名称</span></span><br></pre></td></tr></table></figure><p>这行命令将会在你要放置的目录下创建一个名称为<code>tutorial-env</code>的文件夹并且在其中创建包含Python解释器，标准库和各种支持文件的副本的目录。</p><p>创建虚拟环境后，您可以激活它。</p><p>在Windows上，运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tutorial-env\Scripts\activate.bat</span><br></pre></td></tr></table></figure><p>在Unix或MacOS上，运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source tutorial-env/bin/activate</span><br></pre></td></tr></table></figure><p>激活虚拟环境将改变你所用终端的提示符，以显示你正在使用的虚拟环境，并修改环境以使 <code>python</code> 命令所运行的将是已安装的特定 Python 版本。 例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/envs/tutorial-env/<span class="built_in">bin</span>/activate</span><br><span class="line">(tutorial-env) $ python</span><br><span class="line">Python <span class="number">3.5</span><span class="number">.1</span> (default, May  <span class="number">6</span> <span class="number">2016</span>, <span class="number">10</span>:<span class="number">59</span>:<span class="number">36</span>)</span><br><span class="line">  ...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;/usr/local/lib/python35.zip&#x27;</span>, ...,</span><br><span class="line"><span class="string">&#x27;~/envs/tutorial-env/lib/python3.5/site-packages&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h1 id="使用pip管理包"><a href="#使用pip管理包" class="headerlink" title="使用pip管理包"></a>使用<code>pip</code>管理包</h1><p>你可以<strong>使用一个名为 pip 的程序来安装、升级和移除软件包</strong>。 默认情况下 <code>pip</code> 将从 <a href="httpss://pypi.org">Python Package Index</a> 安装软件包。 你可以在你的 web 浏览器中查看 Python Package Index (PyPI)。</p><p><code>pip</code> 有许多子命令: “install”, “uninstall”, “freeze” 等等。</p><p>您可以通过指定包的名称来安装最新版本的包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ pip install novas</span><br><span class="line">Collecting novas</span><br><span class="line">  Downloading novas-3.1.1.3.tar.gz (136kB)</span><br><span class="line">Installing collected packages: novas</span><br><span class="line">  Running setup.py install for novas</span><br><span class="line">Successfully installed novas-3.1.1.3</span><br></pre></td></tr></table></figure><p>您还可以通过提供包名称后跟 <code>==</code> 和版本号来安装特定版本的包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ pip install requests==2.6.0</span><br><span class="line">Collecting requests==2.6.0</span><br><span class="line">  Using cached requests-2.6.0-py2.py3-none-any.whl</span><br><span class="line">Installing collected packages: requests</span><br><span class="line">Successfully installed requests-2.6.0</span><br></pre></td></tr></table></figure><p>如果你重新运行这个命令，<code>pip</code> 会注意到已经安装了所请求的版本并且什么都不做。您可以提供不同的版本号来获取该版本，或者您可以运行 <code>pip install --upgrade</code> 将软件包升级到最新版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ pip install --upgrade requests</span><br><span class="line">Collecting requests</span><br><span class="line">Installing collected packages: requests</span><br><span class="line">  Found existing installation: requests 2.6.0</span><br><span class="line">    Uninstalling requests-2.6.0:</span><br><span class="line">      Successfully uninstalled requests-2.6.0</span><br><span class="line">Successfully installed requests-2.7.0</span><br></pre></td></tr></table></figure><p><code>pip uninstall</code> 后跟一个或多个包名称将从虚拟环境中删除包。</p><p><code>pip show</code> 将显示有关特定包的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ pip show requests</span><br><span class="line">---</span><br><span class="line">Metadata-Version: 2.0</span><br><span class="line">Name: requests</span><br><span class="line">Version: 2.7.0</span><br><span class="line">Summary: Python HTTP for Humans.</span><br><span class="line">Home-page: https://python-requests.org</span><br><span class="line">Author: Kenneth Reitz</span><br><span class="line">Author-email: me@kennethreitz.com</span><br><span class="line">License: Apache 2.0</span><br><span class="line">Location: /Users/akuchling/envs/tutorial-env/lib/python3.4/site-packages</span><br><span class="line">Requires:</span><br></pre></td></tr></table></figure><p><code>pip list</code> 将显示虚拟环境中安装的所有软件包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ pip <span class="built_in">list</span></span><br><span class="line">novas (<span class="number">3.1</span><span class="number">.1</span><span class="number">.3</span>)</span><br><span class="line">numpy (<span class="number">1.9</span><span class="number">.2</span>)</span><br><span class="line">pip (<span class="number">7.0</span><span class="number">.3</span>)</span><br><span class="line">requests (<span class="number">2.7</span><span class="number">.0</span>)</span><br><span class="line">setuptools (<span class="number">16.0</span>)</span><br></pre></td></tr></table></figure><p>当然，<code>pip</code>还有很多命令，有关 <code>pip</code> 的完整文档，请参阅 <a href="httpss://docs.python.org/zh-cn/3.8/installing/index.html#installing-index">安装 Python 模块</a> 指南。当您编写一个包并希望在 Python 包索引中使它可用时，请参考 <a href="httpss://docs.python.org/zh-cn/3.8/distributing/index.html#distributing-index">分发 Python 模块</a> 指南。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>事实上，如果你学习深度学习相关，并不会使用这种直接的虚拟环境方式，可以尝试使用其他第三方工具来更直观更便捷的管理<code>python</code>环境，例如：<a href="httpss://baike.baidu.com/item/anaconda/20407441?fr=ge_ala">Anaconda</a>。</p><p>关于 Anaconda 相关内容，如果我后续有想法的也会记录相关。当然你也可以自行搜索相关进行学习使用。</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【5.0】类</title>
      <link href="/2023/06/30/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%905.0%E3%80%91%E7%B1%BB/"/>
      <url>/2023/06/30/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%905.0%E3%80%91%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>类是一种对象的抽象化描述，它是基于面向对象语言而产生的概念。<strong>类提供了一种组合数据和功能的方法</strong>。 创建一个新类意味着创建一个新的对象 <em>类型</em>，从而允许创建一个该类型的新 <em>实例</em> 。 每个类的实例可以拥有保存自己状态的属性。 一个类的实例也可以有改变自己状态的（定义在类中的）方法。</p><p>Python 的类提供了面向对象编程的所有标准特性：类继承机制允许多个基类，派生类可以覆盖它基类的任何方法，一个方法可以调用基类中相同名称的的方法。对象可以包含任意数量和类型的数据。和模块一样，类也拥有 Python 天然的动态特性：它们在运行时创建，可以在创建后修改。</p><h1 id="初识类"><a href="#初识类" class="headerlink" title="初识类"></a>初识类</h1><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>类的定义语法格式类似于如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line">    <span class="comment">#这是类的内容</span></span><br></pre></td></tr></table></figure><p>当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域 — 因此，所有对局部变量的赋值都是在这个新命名空间之内。 特别的，函数定义会绑定到这里的新函数名称。</p><h2 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h2><p><strong>类对象支持两种操作：属性引用和实例化</strong>。</p><p>属性引用使用 Python 中所有属性引用所使用的标准语法: <code>obj.name</code>。 因此，如果类定义是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line">    “”“这是这个类的描述”“”</span><br><span class="line">    a = <span class="string">&quot;测试&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Test</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;生成对象&quot;</span>)</span><br></pre></td></tr></table></figure><p>那么<code>ClassName.a</code>和<code>ClassName.Test()</code>就是合法有效的属性引用，执行结果将会返回一个字符串和一个函数对象。</p><blockquote><p>你可以通过<code>__doc__</code>属性来查看对应类的描述，即上述代码中的<code>这是这个类的描述</code></p></blockquote><p>类的实例化，代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ClassName()</span><br></pre></td></tr></table></figure><p>其中<code>ClassName()</code>表示执行这个类的实例化，它会生成并返回这个类实例化的对象，我们使用变量<code>a</code>来“承接”这个实例化的对象，本质上变量<code>a</code>是一个指向对象的指针，不过我们并不需要了解这么多，只需要了解如何实例化对象即可。</p><p>在实例化对象的时候，会触发构造函数，听起来可能有点不明所以，通俗来说，就是你在执行<code>ClassName()</code>实例化对象后，这个对象被实例化后执行的第一个函数（方法）被称为构造函数，它在<code>Python</code>中的定义是<code>__init__(self)</code>这个方法，这个构造函数并不是默认存在的，你如果定义了它，那么它就会在对象被实例化后第一个执行，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是这个类的描述&quot;&quot;&quot;</span></span><br><span class="line">    a = <span class="string">&quot;测试&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#这就是构造函数，它会在类实例化后，第一个执行的函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;生成对象&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化类生成对象</span></span><br><span class="line">a = ClassName()</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果</span></span><br><span class="line">生成对象</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是所有面向对象语言所又具有的，派生类的语法格式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>(<span class="title class_ inherited__">BaseClassName</span>):</span><br><span class="line">    <span class="comment">#这是子类的内容</span></span><br></pre></td></tr></table></figure><p> 名称 <code>BaseClassName</code> 必须定义于包含派生类定义的作用域中。 也允许用其他任意表达式代替基类名称所在的位置。 这有时也可能会用得上，例如，当基类定义在另一个模块中的时候:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class SubClassName(modname.BaseClassName):</span><br></pre></td></tr></table></figure><p>派生类定义的执行过程与基类相同。 当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。</p><p>派生类可能会重载其基类的方法。 因为方法在调用同一对象的其他方法时没有特殊权限，调用同一基类中定义的另一方法的基类方法最终可能会调用覆盖它的派生类的方法。</p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>Python 也支持一种多重继承。其语法格式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubClassName</span>(Base1, Base2, Base3):</span><br><span class="line">    <span class="comment">#这是之类的内容</span></span><br></pre></td></tr></table></figure><p>对于多数应用来说，在最简单的情况下，你可以认为搜索从父类所继承属性的操作是深度优先、从左至右的，当层次结构中存在重叠时不会在同一个类中搜索两次。 因此，如果某一属性在 <code>DerivedClassName</code> 中未找到，则会到 <code>Base1</code> 中搜索它，然后（递归地）到 <code>Base1</code> 的基类中搜索，如果在那里未找到，再到 <code>Base2</code> 中搜索，依此类推。</p><p>动态改变顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（即至少有一个父类可通过多条路径被最底层类所访问）。 例如，所有类都是继承自 <a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#object"><code>object</code></a>，因此任何多重继承的情况都提供了一条以上的路径可以通向 <a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#object"><code>object</code></a>。 为了确保基类不会被访问一次以上，动态算法会用一种特殊方式将搜索顺序线性化， 保留每个类所指定的从左至右的顺序，只调用每个父类一次，并且保持单调（即一个类可以被子类化而不影响其父类的优先顺序）。 总而言之，这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。 要了解更多细节，请参阅 httpss:&#x2F;&#x2F;<a href="http://www.python.org/download/releases/2.3/mro/%E3%80%82">www.python.org/download/releases/2.3/mro/。</a></p><h1 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h1><p>那种仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。 但是，大多数 Python 代码都遵循这样一个约定：<strong>带有一个下划线的名称 (例如 <code>_spam</code>) 应该被当作是 API 的非公有部分</strong> (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。</p><p>由于存在对于类私有成员的有效使用场景（例如避免名称与子类所定义的名称相冲突），因此存在对此种机制的有限支持，称为 <em>名称改写</em>。 **任何形式为 <code>__spam</code> 的标识符（至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 <code>_classname__spam</code>**，其中 <code>classname</code> 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。</p><p>名称改写有助于让子类重载方法而不破坏类内方法调用。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mapping</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, iterable</span>):</span><br><span class="line">        self.items_list = []</span><br><span class="line">        self.__update(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, iterable</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">            self.items_list.append(item)</span><br><span class="line"></span><br><span class="line">    __update = update   <span class="comment"># private copy of original update() method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MappingSubclass</span>(<span class="title class_ inherited__">Mapping</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, keys, values</span>):</span><br><span class="line">        <span class="comment"># provides new signature for update()</span></span><br><span class="line">        <span class="comment"># but does not break __init__()</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">zip</span>(keys, values):</span><br><span class="line">            self.items_list.append(item)</span><br></pre></td></tr></table></figure><p>上面的示例即使在 <code>MappingSubclass</code> 引入了一个 <code>__update</code> 标识符的情况下也不会出错，因为它会在 <code>Mapping</code> 类中被替换为 <code>_Mapping__update</code> 而在 <code>MappingSubclass</code> 类中被替换为 <code>_MappingSubclass__update</code>。</p><h1 id="杂项说明"><a href="#杂项说明" class="headerlink" title="杂项说明"></a>杂项说明</h1><p>有时会需要使用类似于 Pascal 的“record”或 C 的“struct”这样的数据类型，将一些命名数据项捆绑在一起。 这种情况适合定义一个空类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">john = Employee()  <span class="comment"># Create an empty employee record</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the fields of the record</span></span><br><span class="line">john.name = <span class="string">&#x27;John Doe&#x27;</span></span><br><span class="line">john.dept = <span class="string">&#x27;computer lab&#x27;</span></span><br><span class="line">john.salary = <span class="number">1000</span></span><br></pre></td></tr></table></figure><blockquote><p><code>pass</code>是一个空的占位符，其并不执行任何操作，仅仅占位保持代码的完整性或者语法的正确性</p></blockquote><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>在平时编写代码中，我们常常使用<code>for</code>来直接循环访问列表等容器对象中的“元素”，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> &#123;<span class="string">&#x27;one&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>:<span class="number">2</span>&#125;:</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">&quot;123&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(char)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&quot;myfile.txt&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(line, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这种访问风格清晰、简洁又方便。 迭代器的使用非常普遍并使得 Python 成为一个统一的整体。 在幕后，<a href="httpss://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#for"><code>for</code></a> 语句会在容器对象上调用 <a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#iter"><code>iter()</code></a>。 该函数返回一个定义了 <a href="httpss://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__"><code>__next__()</code></a> 方法的迭代器对象，此方法将逐一访问容器中的元素。 当元素用尽时，<a href="httpss://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__"><code>__next__()</code></a> 将引发 <a href="httpss://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration"><code>StopIteration</code></a> 异常来通知终止 <code>for</code> 循环。你可以使用 <a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#next"><code>next()</code></a> 内置函数来调用 <a href="httpss://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__"><code>__next__()</code></a> 方法；这个例子显示了它的运作方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = <span class="built_in">iter</span>(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it</span><br><span class="line">&lt;iterator <span class="built_in">object</span> at <span class="number">0x00A1DB50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(it)</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(it)</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(it)</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(it)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">next</span>(it)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>看过迭代器协议的幕后机制，给你的类添加迭代器行为就很容易了。 <strong>定义一个 <a href="httpss://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__"><code>__iter__()</code></a> 方法来返回一个带有 <a href="httpss://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__"><code>__next__()</code></a> 方法的对象</strong>。 如果类已定义了 <code>__next__()</code>，则 <a href="httpss://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__"><code>__iter__()</code></a> 可以简单地返回 <code>self</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Reverse</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = <span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.index = self.index - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.data[self.index]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rev = Reverse(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">iter</span>(rev)</span><br><span class="line">&lt;__main__.Reverse <span class="built_in">object</span> at <span class="number">0x00A1DB50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> rev:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(char)</span><br><span class="line">...</span><br><span class="line">m</span><br><span class="line">a</span><br><span class="line">p</span><br><span class="line">s</span><br></pre></td></tr></table></figure><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p><a href="httpss://docs.python.org/zh-cn/3.8/glossary.html#term-generator">生成器</a> 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似于标准的函数，但当它们要返回数据时会使用 <a href="httpss://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#yield"><code>yield</code></a> 语句。 每次在生成器上调用 <a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#next"><code>next()</code></a> 时，它会从上次离开的位置恢复执行（它会记住上次执行语句时的所有数据值）。 一个显示如何非常容易地创建生成器的示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> data[index]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> reverse(<span class="string">&#x27;golf&#x27;</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(char)</span><br><span class="line">...</span><br><span class="line">f</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">g</span><br></pre></td></tr></table></figure><p>可以用生成器来完成的操作同样可以用前一节所描述的基于类的迭代器来完成。 但生成器的写法更为紧凑，因为它会自动创建 <a href="httpss://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__"><code>__iter__()</code></a> 和 <a href="httpss://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.__next__"><code>__next__()</code></a> 方法。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>类的部分是重点，迭代器了解知道需要使用的时候能会用查文档就好，生成器是为了迭代器方便使用的另一种封装方式，了解即可，需要用的时候再查相关详细文档。</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【4.0】模块</title>
      <link href="/2023/06/28/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%904.0%E3%80%91%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/06/28/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%904.0%E3%80%91%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为<code>Python</code>是解释型的，这就意味着如果你运行后退出再次运行，之前定义的变量及其相关数据都会丢失。因此如果你希望编写一些长的程序，则需要使用文本编辑器来进行，并将编辑好的<code>python</code>代码作为输入运行。这种形式的文件被称为：<strong>脚本</strong>。</p><p>随着编写的内容越来越多，当你希望将其编写的内容拆分成几个不同类型的文件以方便维护；或者你希望经常使用自己的某个函数（方法），而不必要每次都编写一次代码内容。为了支持这些需求，<code>python</code>可以将定义放在一个文件里，并在脚本中交互的时候它们。这种文件被称为：<strong>模块</strong>。</p><p>在我们编写的脚本中，可以导入不同的模块，以实现各种我们所需要的功能。</p><p>模块本质仍是一个包含<code>python</code>语句的文件，其后缀为：<code>.py</code>。在模块内部，模块名称可以通过全局变量<code>__name__</code>的值获得。</p><p>例如，你可以在任意文件路径下，创建一个新的<code>.py</code>文件，其代码内容如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PutText</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure><p>该<code>.py</code>文件中仅仅定义了一个名称为<code>PutText</code>的函数（方法），你可以通过如下代码在另一个<code>.py</code>文件中，调用你定义的这个方法，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#此处路径为你新建那个.py文件的文件夹路径</span></span><br><span class="line">path = <span class="string">&#x27;D:\\DATA\\PythonProject\\Learn001&#x27;</span></span><br><span class="line">sys.path.append(os.path.abspath(path))</span><br><span class="line"></span><br><span class="line"><span class="comment">#此处导入的名称应该为你创建的.py文件的名称，我命名为：Test002</span></span><br><span class="line"><span class="keyword">import</span> Test002</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用文件名称.可以访问并调用其中的内容</span></span><br><span class="line">Test002.PutText()</span><br></pre></td></tr></table></figure><p>如果你经常使用某个函数，你可以将其赋值为一个变量来更快的调用该函数，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun = Test002.PutText</span><br><span class="line">fun()</span><br></pre></td></tr></table></figure><h1 id="更多关于模块的信息"><a href="#更多关于模块的信息" class="headerlink" title="更多关于模块的信息"></a>更多关于模块的信息</h1><p>每个模块都是独立的个体，它们包含了各自的函数或者变量的“表”，并不会与你现模块中的变量等发生冲突。我们可以通过<code>import</code>关键词来导入其他模块，模块被导入后，就可以通过<code>模块名称.变量/函数</code>来调用模块内的变量或者函数等。</p><blockquote><p>从习惯上来说，所有的<code>import</code>语句都应该放在模块&#x2F;脚本的开头</p></blockquote><p>当然，我们也可以直接选择导入模块中的指定函数，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Test002 <span class="keyword">import</span> PutText</span><br><span class="line">PutText()</span><br></pre></td></tr></table></figure><p>此处，我将我的<code>Test002</code>模块中的<code>PutText</code>函数导入到了现模块中，这样可以直接使用<code>PutText</code>来调用函数。需要注意的是，这样引入仅仅引入了<code>PutText</code>，这意味着你并不能调用到<code>Test002</code>这个模块中的其他内容。</p><p>你甚至可以使用如下代码，来直接引入指定模块中所有函数，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Test002 <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p><strong>这样<code>python</code>会调入所有非下划线（<code>_</code>）开头的名称</strong>。不过，在绝大多数情况下，并不会使用这种语句，因为它可能会导致引入模块中的名称覆盖了现模块中已经定义过的东西。</p><p>当然，你也可以通过使用关键词<code>as</code>来为引入的指定模块中的名称做重命名，进行现模块绑定，这么说可能不太好理解，可以通过如下代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Test002 <span class="keyword">import</span> PutText <span class="keyword">as</span> output</span><br><span class="line">output()</span><br></pre></td></tr></table></figure><p>上述代码中，我使用了<code>output</code>来绑定到导入的<code>Test002</code>模块中的<code>PutText</code>函数名称，这样在我希望调用<code>PutText</code>函数的时候，就可以直接使用我绑定的名称<code>output</code>来调用。</p><p>同样的，我们也可以使用<code>as</code>关键字来重命名导入的模块，其代码类似如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">impotimport Test002 <span class="keyword">as</span> newName</span><br><span class="line">newName.PutText()</span><br></pre></td></tr></table></figure><blockquote><p>注：每个模块只会在解释器中导入一次，如果你在执行中改变了你的模块内容，则必须重新启动解释器才能保证你改变的模块内容能正确调用。如果你仅仅是希望在改变后做测试，可以尝试使用 <a href="httpss://docs.python.org/zh-cn/3.8/library/importlib.html#importlib.reload"><code>importlib.reload()</code></a> 函数。</p></blockquote><h2 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h2><p>当你需要导入一个名称为<code>Test001</code>的模块的时候，<strong>解释器首先寻找具有该名称的内置模块</strong>。如果没有找到，然后解释器从 <a href="httpss://docs.python.org/zh-cn/3.8/library/sys.html#sys.path"><code>sys.path</code></a> 变量给出的目录列表里寻找名为 <code>spam.py</code> 的文件。<a href="httpss://docs.python.org/zh-cn/3.8/library/sys.html#sys.path"><code>sys.path</code></a> 初始有这些目录地址：</p><ul><li>包含输入脚本的目录（或者未指定文件时的当前目录）。</li><li><a href="httpss://docs.python.org/zh-cn/3.8/using/cmdline.html#envvar-PYTHONPATH"><code>PYTHONPATH</code></a> （一个拓展目录名称的列表，它和shell变量 <code>PATH</code> 有一样的语法）。</li><li>取决于安装的默认设置</li></ul><blockquote><p>需要注意的是，你可以在运行脚本的时候更改<code>sys.path</code>的列表内容，但是通常来说建议是将新增的目录添加到列表的后面，而不是开头；否则可能会出现优先调用你新添加的目录模块，而不是旧的标准模块。</p></blockquote><h2 id="编译过的Pyhton文件"><a href="#编译过的Pyhton文件" class="headerlink" title="编译过的Pyhton文件"></a>编译过的<code>Pyhton</code>文件</h2><p>为了加速模块载入，<code>Python</code>在 <code>__pycache__</code> 目录里缓存了每个模块的编译后版本，名称为 <code>module.*version*.pyc</code> ，其中名称中的版本字段对编译文件的格式进行编码； 它一般使用<code>Python</code>版本号。例如，我的<code>Test002</code>会被命名为：<code>Test002.cpython-38.pyc</code>。这种命名方式会允许不同版本的<code>Python</code>已编译模块共存。</p><p><code>Python</code>根据编译版本检查源的修改日期，以查看它是否已过期并需要重新编译。这是一个完全自动化的过程。</p><p>Python在两种情况下不会检查缓存。首先，对于从命令行直接载入的模块，它从来都是重新编译并且不存储编译结果；其次，如果没有源模块，它不会检查缓存。为了支持无源文件（仅编译）发行版本， 编译模块必须是在源目录下，并且绝对不能有源模块。</p><h1 id="标准模块"><a href="#标准模块" class="headerlink" title="标准模块"></a>标准模块</h1><p>Python附带了一个标准模块库；一些模块内置于解释器中；它们提供对不属于语言核心但仍然内置的操作的访问，以提高效率或提供对系统调用等操作系统原语的访问。</p><p>这些模块的集合是一个配置选项，它也取决于底层平台。例如，<a href="httpss://docs.python.org/zh-cn/3.8/library/winreg.html#module-winreg"><code>winreg</code></a> 模块只在Windows操作系统上提供。一个特别值得注意的模块 <a href="httpss://docs.python.org/zh-cn/3.8/library/sys.html#module-sys"><code>sys</code></a>，它被内嵌到每一个Python解释器中。变量 <code>sys.ps1</code> 和 <code>sys.ps2</code> 定义用作主要和辅助提示的字符串，例如<code>sys.ps1</code>其是<code>&gt;&gt;&gt;</code>字符，<code>sys.ps2</code>其是<code>...</code>字符。</p><blockquote><p>注：这两个变量只有在编译器是交互模式（命令行）下才被定义。</p></blockquote><p><strong><code>sys.path</code> 变量是一个字符串列表，用于确定解释器的模块搜索路径</strong>。该变量被初始化为从环境变量 <a href="httpss://docs.python.org/zh-cn/3.8/using/cmdline.html#envvar-PYTHONPATH"><code>PYTHONPATH</code></a> 获取的默认路径，或者如果 <a href="httpss://docs.python.org/zh-cn/3.8/using/cmdline.html#envvar-PYTHONPATH"><code>PYTHONPATH</code></a> 未设置，则从内置默认路径初始化。你可以使用标准列表操作对其进行修改，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;这里是你的搜索路径目录&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a><code>dir()</code>函数</h1><p>内置函数 <a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#dir"><code>dir()</code></a> <strong>用于查找模块定义的名称</strong>。 它返回一个排序过的字符串列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">dir</span>(sys):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">__breakpointhook__</span><br><span class="line">__displayhook__</span><br><span class="line">__doc__</span><br><span class="line">__excepthook__</span><br><span class="line">__interactivehook__</span><br><span class="line">__loader__</span><br><span class="line">__name__</span><br><span class="line">__package__</span><br><span class="line">__spec__</span><br><span class="line">__stderr__</span><br><span class="line">__stdin__</span><br><span class="line">__stdout__</span><br><span class="line">__unraisablehook__</span><br><span class="line">_base_executable</span><br><span class="line">_clear_type_cache</span><br><span class="line">_current_frames</span><br><span class="line">_debugmallocstats</span><br><span class="line">_enablelegacywindowsfsencoding</span><br><span class="line">_framework</span><br><span class="line">_getframe</span><br><span class="line">_git</span><br><span class="line">_home</span><br><span class="line">_xoptions</span><br><span class="line">addaudithook</span><br><span class="line">api_version</span><br><span class="line">argv</span><br><span class="line">audit</span><br><span class="line">base_exec_prefix</span><br><span class="line">base_prefix</span><br><span class="line">breakpointhook</span><br><span class="line">builtin_module_names</span><br><span class="line">byteorder</span><br><span class="line">call_tracing</span><br><span class="line">callstats</span><br><span class="line">copyright</span><br><span class="line">displayhook</span><br><span class="line">dllhandle</span><br><span class="line">dont_write_bytecode</span><br><span class="line">exc_info</span><br><span class="line">excepthook</span><br><span class="line">exec_prefix</span><br><span class="line">executable</span><br><span class="line">exit</span><br><span class="line">flags</span><br><span class="line">float_info</span><br><span class="line">float_repr_style</span><br><span class="line">get_asyncgen_hooks</span><br><span class="line">get_coroutine_origin_tracking_depth</span><br><span class="line">getallocatedblocks</span><br><span class="line">getcheckinterval</span><br><span class="line">getdefaultencoding</span><br><span class="line">getfilesystemencodeerrors</span><br><span class="line">getfilesystemencoding</span><br><span class="line">getprofile</span><br><span class="line">getrecursionlimit</span><br><span class="line">getrefcount</span><br><span class="line">getsizeof</span><br><span class="line">getswitchinterval</span><br><span class="line">gettrace</span><br><span class="line">getwindowsversion</span><br><span class="line">hash_info</span><br><span class="line">hexversion</span><br><span class="line">implementation</span><br><span class="line">int_info</span><br><span class="line">intern</span><br><span class="line">is_finalizing</span><br><span class="line">maxsize</span><br><span class="line">maxunicode</span><br><span class="line">meta_path</span><br><span class="line">modules</span><br><span class="line">path</span><br><span class="line">path_hooks</span><br><span class="line">path_importer_cache</span><br><span class="line">platform</span><br><span class="line">prefix</span><br><span class="line">pycache_prefix</span><br><span class="line">set_asyncgen_hooks</span><br><span class="line">set_coroutine_origin_tracking_depth</span><br><span class="line">setcheckinterval</span><br><span class="line">setprofile</span><br><span class="line">setrecursionlimit</span><br><span class="line">setswitchinterval</span><br><span class="line">settrace</span><br><span class="line">stderr</span><br><span class="line">stdin</span><br><span class="line">stdout</span><br><span class="line">thread_info</span><br><span class="line">unraisablehook</span><br><span class="line">version</span><br><span class="line">version_info</span><br><span class="line">warnoptions</span><br><span class="line">winver</span><br></pre></td></tr></table></figure><p><strong>如果没有参数，<a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#dir"><code>dir()</code></a> 会列出你当前定义的名称</strong>。</p><blockquote><p>注：它列出所有类型的名称：变量，模块，函数，等等。</p></blockquote><p><a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#dir"><code>dir()</code></a> <strong>不会列出内置函数和变量的名称</strong>。如果你想要这些，它们的定义是在标准模块 <a href="httpss://docs.python.org/zh-cn/3.8/library/builtins.html#module-builtins"><code>builtins</code></a> 中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="built_in">dir</span>(builtins)  </span><br></pre></td></tr></table></figure><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法。 例如，模块名 <code>A.B</code> 表示 <code>A</code> 包中名为 <code>B</code> 的子模块。</p><p>假设你想为声音文件和声音数据的统一处理，设计一个模块集合（一个“包”）。由于存在很多不同的声音文件格式（通常由它们的扩展名来识别，例如：<code>.wav</code>， <code>.aiff</code>， <code>.au</code>），因此为了不同文件格式间的转换，你可能需要创建和维护一个不断增长的模块集合。 你可能还想对声音数据还做很多不同的处理（例如，混声，添加回声，使用均衡器功能，创造人工立体声效果）， 因此为了实现这些处理，你将另外写一个无穷尽的模块流。这是你的包的可能结构（以分层文件系统的形式表示）：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sound/                          Top-level <span class="keyword">package</span></span><br><span class="line">      __init__.py               Initialize the sound <span class="keyword">package</span></span><br><span class="line">      formats/                  Subpackage <span class="keyword">for</span> <span class="keyword">file</span> <span class="keyword">format</span> conversions</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              aiffread.py</span><br><span class="line">              aiffwrite.py</span><br><span class="line">              auread.py</span><br><span class="line">              auwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects/                  Subpackage <span class="keyword">for</span> sound effects</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters/                  Subpackage <span class="keyword">for</span> filters</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure><p><strong>包必须要有 <code>__init__.py</code> 文件才能让 Python 将包含该文件的目录当作包</strong>。 这样可以防止具有通常名称例如 <code>string</code> 的目录在无意中隐藏稍后在模块搜索路径上出现的有效模块。 在最简单的情况下，<code>__init__.py</code> 可以只是一个空文件，但它也可以执行包的初始化代码或设置 <code>__all__</code> 变量，具体将会在后面说明。</p><p>包的用户可以从包中导入单个模块，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br></pre></td></tr></table></figure><p>这会加载子模块 <code>sound.effects.echo</code> 。但引用它时必须使用它的全名。</p><p>导入子模块的另一种方法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from sound.effects import echo</span><br></pre></td></tr></table></figure><p>这也会加载子模块 <code>echo</code> ，并使其在没有包前缀的情况下可用。</p><p>另一种形式是直接导入所需的函数或变量:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from sound.effects.echo import echofilter</span><br></pre></td></tr></table></figure><p>同样，这也会加载子模块 <code>echo</code>，但这会使其函数 <code>echofilter()</code> 直接可用。</p><p>注意，当使用 <code>from package import item</code> 时，item可以是包的子模块（或子包），也可以是包中定义的其他名称，如函数，类或变量。 <code>import</code> 语句首先测试是否在包中定义了item；如果没有，它假定它是一个模块并尝试加载它。如果找不到它，则引发 <a href="httpss://docs.python.org/zh-cn/3.8/library/exceptions.html#ImportError"><code>ImportError</code></a> 异常。</p><p>相反，当使用 <code>import item.subitem.subsubitem</code> 这样的语法时，除了最后一项之外的每一项都必须是一个包；最后一项可以是模块或包，但不能是前一项中定义的类或函数或变量。</p><h2 id="从包中导入"><a href="#从包中导入" class="headerlink" title="从包中导入 *"></a>从包中导入 *</h2><p>当用户写 <code>from sound.effects import *</code> 会发生什么？理想情况下，人们希望这会以某种方式传递给文件系统，找到包中存在哪些子模块，并将它们全部导入。这可能需要很长时间，导入子模块可能会产生不必要的副作用，这种副作用只有在显式导入子模块时才会发生。</p><p><strong>唯一的解决方案是让包作者提供一个包的显式索引</strong>。<a href="httpss://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import"><code>import</code></a> 语句使用下面的规范：<strong>如果一个包的 <code>__init__.py</code> 代码定义了一个名为 <code>__all__</code> 的列表，它会被视为在遇到 <code>from package import *</code> 时应该导入的模块名列表</strong>。在发布该包的新版本时，包作者可以决定是否让此列表保持更新。包作者如果认为从他们的包中导入 * 的操作没有必要被使用，也可以决定不支持此列表。例如，文件 <code>sound/effects/__init__.py</code> 可以包含以下代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]</span><br></pre></td></tr></table></figure><p>这意味着 <code>from sound.effects import *</code> 将导入 <code>sound</code> 包的三个命名子模块。</p><p>如果没有定义 <code>__all__</code>，<code>from sound.effects import *</code> 语句 <em>不会</em> 从包 <code>sound.effects</code> 中导入所有子模块到当前命名空间；它只确保导入了包 <code>sound.effects</code> （可能运行任何在 <code>__init__.py</code> 中的初始化代码），然后导入包中定义的任何名称。 这包括 <code>__init__.py</code> 定义的任何名称（以及显式加载的子模块）。它还包括由之前的 <a href="httpss://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import"><code>import</code></a> 语句显式加载的包的任何子模块。</p><h2 id="子包参考"><a href="#子包参考" class="headerlink" title="子包参考"></a>子包参考</h2><p>当包被构造成子包时（与示例中的 <code>sound</code> 包一样），你可以使用绝对导入来引用兄弟包的子模块。例如，如果模块 <code>sound.filters.vocoder</code> 需要在 <code>sound.effects</code> 包中使用 <code>echo</code> 模块，它可以使用 <code>from sound.effects import echo</code> 。</p><p>你还可以使用import语句的 <code>from module import name</code> 形式编写相对导入。这些导入使用前导点来指示相对导入中涉及的当前包和父包。例如，从 <code>surround</code> 模块，你可以使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from . import echo</span><br><span class="line">from .. import formats</span><br><span class="line">from ..filters import equalizer</span><br></pre></td></tr></table></figure><blockquote><p>注：相对导入是基于当前模块的名称进行导入的。由于主模块的名称总是 <code>&quot;__main__&quot;</code> ，因此用作Python应用程序主模块的模块必须始终使用绝对导入。</p></blockquote><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>看起来有点冗杂，甚至有些难以理解，大概讲述了基本到模块调用，再到包结构和包的引用，可以不需要全部理解，用的时候慢慢也就能最后学到的</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【3.0】数据结构</title>
      <link href="/2023/06/27/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%903.0%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/06/27/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%903.0%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分会再前面涉及的数据结构的基础上拓展并且说明更多的数据结构，这些数据结构在编程方面就如图画家的画笔，是编程工具或者说小帮手。</p><p>✒️：现在需要说明一个事情，且后面不会再强调说明：<strong>如果方法签名中某些参数两边的方括号（<code>[]</code>）表示这个参数是可选的，而不是要你输入方括号。你会在 Python 参考库中经常看到这种表示方法</strong>。</p><h1 id="列表的更多特性"><a href="#列表的更多特性" class="headerlink" title="列表的更多特性"></a>列表的更多特性</h1><p>前面已经说明了列表的基本概述，其还有很多的方法，如下所示：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>list.append(x)</code></td><td>在列表的末尾添加一个元素</td></tr><tr><td><code>list.extend(iterable)</code></td><td>使用可迭代对象中的所有元素来扩展列表</td></tr><tr><td><code>list.insert(i, x)</code></td><td>在给定的位置插入一个元素。第一个参数是要插入的元素的索引，第二个参数是要插入的元素</td></tr><tr><td><code>list.remove(x)</code></td><td>移除列表中第一个值为 <code>x</code> 的元素。如果没有这样的元素，则抛出 <code>ValueError</code>异常</td></tr><tr><td><code>list.pop([i])</code></td><td>删除列表中给定位置的元素并返回它。如果没有给定位置，<code>a.pop()</code> 将会删除并返回列表中的最后一个元素</td></tr><tr><td><code>list.clear()</code></td><td>移除列表中的所有元素</td></tr><tr><td><code>list.index(x[,start[,end]])</code></td><td>返回列表中第一个值为 <em>x</em> 的元素的从零开始的索引。如果没有这样的元素将会抛出 <code>ValueError</code> 异常<br />可选参数<code>start</code>和<code>end</code>是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 <code>start </code>参数</td></tr><tr><td><code>list.count(x)</code></td><td>返回元素 <code>x</code> 在列表中出现的次数</td></tr><tr><td><code>list.sort(*,key=None,reverse=False)</code></td><td>对列表中的元素进行排序（参数可用于自定义排序，解释请参见 <a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#sorted">sorted</a></td></tr><tr><td><code>list.reverse()</code></td><td>翻转列表中的元素</td></tr><tr><td><code>list.copy()</code></td><td>返回列表的一个浅拷贝</td></tr></tbody></table><h2 id="列表作为栈使用"><a href="#列表作为栈使用" class="headerlink" title="列表作为栈使用"></a>列表作为栈使用</h2><p>列表方法使得列表作为堆栈非常容易，最后一个插入，最先取出（“后进先出”）。要添加一个元素到堆栈的顶端，使用 <code>append()</code> 。要从堆栈顶部取出一个元素，使用 <code>pop()</code> ，不用指定索引。</p><blockquote><p>关于栈的说明，可以参考<a href="https://blog.helloseraphine.top:8090/archives/31%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97">数据结构-栈</a></p></blockquote><h2 id="列表作为队列使用"><a href="#列表作为队列使用" class="headerlink" title="列表作为队列使用"></a>列表作为队列使用</h2><p>列表也可以用作队列，其中先添加的元素被最先取出 (“先进先出”)；然而列表用作这个目的相当低效。因为在列表的末尾添加和弹出元素非常快，但是<strong>在列表的开头插入或弹出元素却很慢</strong> (因为所有的其他元素都必须移动一位)。</p><p>若要实现一个队列，可使用 <code>collections.deque</code>，它被设计成可以快速地从两端添加或弹出元素。</p><h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>列表推导式提供了一个更简单的创建列表的方法。常见的用法是把某种操作应用于序列或可迭代对象的每个元素上，然后使用其结果来创建列表，或者通过满足某些特定条件元素来创建子序列。</p><p>例如，假设我们想创建一个平方列表，像这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    squares.append(x**<span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><h1 id="del语句"><a href="#del语句" class="headerlink" title="del语句"></a><code>del</code>语句</h1><p>有一种方式可以从列表按照给定的索引而不是值来移除一个元素: 那就是 <code>del</code> 语句。 它不同于会返回一个值的 <code>pop()</code> 方法。 <code>del</code> 语句也可以用来从列表中移除切片或者清空整个列表（我们之前用过的方式是将一个空列表赋值给指定的切片）。 例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">66.25</span>, <span class="number">333</span>, <span class="number">333</span>, <span class="number">1234.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">66.25</span>, <span class="number">333</span>, <span class="number">333</span>, <span class="number">1234.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">66.25</span>, <span class="number">1234.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p><strong><code>del</code> 也可以删除整个变量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> a</span><br></pre></td></tr></table></figure><p>此后再引用 <code>a</code> 时会报错。</p><h1 id="元组和序列"><a href="#元组和序列" class="headerlink" title="元组和序列"></a>元组和序列</h1><p>我们看到列表和字符串有很多共同特性，例如索引和切片操作。他们<strong>是序列数据类型中的两种</strong>。随着 Python 语言的发展，其他的序列类型也会被加入其中。这里介绍另一种标准序列类型: <strong>元组</strong>。</p><p>一个元组由几个被逗号隔开的值组成，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>]</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = t, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u</span><br><span class="line">((<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>如你所见，元组在输出时总是被圆括号包围的，以便正确表示嵌套元组。输入时圆括号可有可无，不过经常会是必须的（如果这个元组是一个更大的表达式的一部分）。<strong>给元组中的一个单独的元素赋值是不允许的</strong>，当然你可以创建包含可变对象的元组，例如列表。</p><p>虽然元组可能看起来与列表很像，但它们通常是在不同的场景被使用，并且有着不同的用途。<strong>元组是 immutable ，其序列通常包含不同种类的元素，并且通过解包或者索引来访问</strong>。列表是 mutable ，并且列表中的元素一般是同种类型的，并且通过迭代访问。</p><p>语句 <code>t = 12345, 54321, &#39;hello!&#39;</code> 是元组打包的一个例子：值 <code>12345</code>, <code>54321</code> 和 <code>&#39;hello!&#39;</code> 被打包进元组。其逆操作也是允许的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y, z = t</span><br></pre></td></tr></table></figure><p>这被称为序列解包也是很恰当的，因为解包操作的等号右侧可以是任何序列。<strong>序列解包要求等号左侧的变量数与右侧序列里所含的元素数相同</strong>。注意多重赋值其实也只是元组打包和序列解包的组合。</p><p>总结来说，元组和列表的区别如下：</p><ol><li>不可变性：<strong>元组是不可变的，即元组一旦创建，就不能对其进行修改</strong>，如添加或删除元素。而列表是可变的，可以对其进行修改操作。</li><li>表示方式：元组使用圆括号<code>()</code>进行表示，例如：<code>my_tuple = (1, 2, 3)</code>；而列表使用方括号（[]）表示，例如：<code>my_list = [1, 2, 3]</code>。</li><li>性能：元组的存储空间相对较小，操作速度也比列表快，因为不需要为了维护元素改变而分配额外内存。</li><li>方法：由于列表是可变类型，它具有更多的方法，如append、pop等。而元组只有两个方法：index和count，这是由它们的不可变性决定的。</li></ol><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合是<strong>由不重复元素组成的无序的集</strong>。它的基本用法包括成员检测和消除重复元素。集合对象也支持像 联合，交集，差集，对称差分等数学运算。</p><p><strong>花括号或 <code>set()</code>函数可以用来创建集合</strong>。</p><blockquote><p>注意：要创建一个空集合你只能用 <code>set()</code> 而不能用 <code>&#123;&#125;</code>，因为后者是创建一个空字典。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(basket)                     </span><br><span class="line">&#123;<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;orange&#x27;</span> <span class="keyword">in</span> basket                </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;crabgrass&#x27;</span> <span class="keyword">in</span> basket</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                                  </span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b                             </span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b<span class="comment">#并集           </span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b<span class="comment">#交集</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b <span class="comment">#去掉交集的并集              </span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>总结来说，集合和列表的区别如下：</p><ol><li>无序性：<strong>集合中的元素是无序的</strong>，而列表中的元素是有序的。在集合中，元素的顺序是不重要的。</li><li>唯一性：<strong>集合中的元素是唯一的，不允许出现重复元素</strong>。列表则允许存储重复元素。</li><li>可变性：集合和列表都是可变的数据类型，允许添加、删除和修改元素。</li><li>表示方式：集合使用花括号（{}）表示，例如：<code>my_set = &#123;1, 2, 3&#125;</code>。但如果创建空集合，需要使用<code>set()</code>，如：<code>empty_set = set()</code>。列表使用方括号（[]）表示，例如：<code>my_list = [1, 2, 3]</code>。</li><li>数据类型：集合只支持存储不可变类型（如整数、字符串、元组）的数据，而列表可以存储任何数据类型。</li><li>操作：集合支持集合间的一些数学操作，如交集、并集、差集等。列表不支持这些操作。</li></ol><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典是一个特殊类型的列表，与以连续整数为索引的序列不同，<strong>字典是以关键字为索引的</strong>，关键字可以是<strong>任意不可变类型</strong>，通常是字符串或数字。如果一个元组只包含字符串、数字或元组，那么这个元组也可以用作关键字。但如果元组直接或间接地包含了可变对象，那么它就不能用作关键字。</p><p>理解字典的最好方式，<strong>就是将它看做是一个 键: 值 对的集合，键必须是唯一的（在一个字典中）。一对花括号可以创建一个空字典：<code>&#123;&#125;</code> 。</strong>另一种初始化字典的方式是在一对花括号里放置一些以逗号分隔的键值对，而这也是字典输出的方式。</p><p>字典主要的操作是使用关键字存储和解析值。也可以用 <code>del</code> 来删除一个键值对。如果你使用了一个已经存在的关键字来存储值，那么之前与这个关键字关联的值就会被遗忘。用一个不存在的键来取值则会报错。</p><p>对一个字典执行 <code>list(d)</code> 将<strong>返回包含该字典中所有键的列表</strong>，按插入次序排列 (如需其他排序，则要使用 <code>sorted(d)</code>)。要检查字典中是否存在一个特定键，可使用 <a href="httpss://docs.python.org/zh-cn/3.8/reference/expressions.html#in"><code>in</code></a> 关键字。</p><blockquote><p>注：直接使用<code>in</code>关键字如下所示，在控制台中会输出<code>True</code>，在 IDE 中我们可以使用<code>print</code>来输出结果。</p></blockquote><p>代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="number">2</span>, <span class="string">&quot;test2&quot;</span>: <span class="number">1</span>, <span class="string">&quot;key3&quot;</span>: <span class="string">&quot;你好&quot;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line">&#123;<span class="string">&#x27;key1&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;test2&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;key3&#x27;</span>: <span class="string">&#x27;你好&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">list</span>(a))</span><br><span class="line">[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;test2&#x27;</span>, <span class="string">&#x27;key3&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="number">2</span>, <span class="string">&quot;test2&quot;</span>: <span class="number">1</span>, <span class="string">&quot;key3&quot;</span>: <span class="string">&quot;你好&quot;</span>&#125; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;key1&#x27;</span> <span class="keyword">in</span> a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;1&#x27;</span> <span class="keyword">in</span> a    </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p><a href="httpss://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict"><code>dict()</code></a> 构造函数可以直接从键值对序列里创建字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">dict</span>([(<span class="string">&quot;key1&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;key2&quot;</span>,<span class="number">2</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">&#123;<span class="string">&#x27;key1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>当关键字是简单字符串时，有时直接通过关键字参数来指定键值对更方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">dict</span>(key1 = <span class="number">1</span>,key2 = <span class="number">2</span>,key3=<span class="string">&#x27;text&#x27;</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">&#123;<span class="string">&#x27;key1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;key3&#x27;</span>: <span class="string">&#x27;text&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="循环的技巧"><a href="#循环的技巧" class="headerlink" title="循环的技巧"></a>循环的技巧</h1><p><strong>当在字典中循环时，用 <code>items()</code> 方法可将关键字和对应的值同时取出</strong>，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="number">2</span>, <span class="string">&quot;test2&quot;</span>: <span class="number">1</span>, <span class="string">&quot;key3&quot;</span>: <span class="string">&quot;你好&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> c,v <span class="keyword">in</span> a.items():</span><br><span class="line">    <span class="built_in">print</span>(c,v)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">key1 <span class="number">2</span></span><br><span class="line">test2 <span class="number">1</span></span><br><span class="line">key3 你好</span><br></pre></td></tr></table></figure><p><strong>当在序列中循环时，用 <a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#enumerate"><code>enumerate()</code></a> 函数可以将索引位置和其对应的值同时取出</strong>，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&#x27;测试&#x27;</span>,<span class="string">&#x27;测试2&#x27;</span>,<span class="string">&#x27;测试3&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> c,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">    <span class="built_in">print</span>(c,v)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="number">0</span> 测试</span><br><span class="line"><span class="number">1</span> 测试<span class="number">2</span></span><br><span class="line"><span class="number">2</span> 测试<span class="number">3</span></span><br></pre></td></tr></table></figure><p>当同时在<strong>两个或更多序列</strong>中循环时，可以<strong>用 <a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#zip"><code>zip()</code></a> 函数将其内元素一一匹配</strong>。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&#x27;测试&#x27;</span>,<span class="string">&#x27;测试2&#x27;</span>,<span class="string">&#x27;测试3&#x27;</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> c,v <span class="keyword">in</span> <span class="built_in">zip</span>(b,a):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;num &#123;0&#125;,content &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(c,v))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">num <span class="number">1</span>,content 测试</span><br><span class="line">num <span class="number">2</span>,content 测试<span class="number">2</span></span><br><span class="line">num <span class="number">3</span>,content 测试<span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>使用<code>.format()</code>配合占位符<code>&#123;&#125;</code>可以方便的输出指定字符串</p></blockquote><p><strong>注：当需要在循环时修改列表内容，一般来说改为创建一个新列表是比较简单且安全的</strong>。</p><h1 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h1><p>关键字：<code>in</code>，<code>not in</code>，<code>and</code>，<code>or</code>；</p><p>其使用原理和方法同其他编程语言一致，只是表达关键字改变了。此处不过多赘述。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>这是一个结尾，最近感觉很颓废啊，少年仍需努力。</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【2.0】流程控制工具</title>
      <link href="/2023/04/13/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%902.0%E3%80%91%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/04/13/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%902.0%E3%80%91%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>除了上一部分使用的的 <code>while</code>语句，Python 中也会使用其他语言中常见的流程控制语句，只是稍有变化。</p><h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a><code>while</code>语句</h2><p>语句格式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是基本语法格式</span></span><br><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    执行过程</span><br></pre></td></tr></table></figure><blockquote><p>注：执行过程语句的<strong>缩进是必要</strong>的且<strong>要缩进一致</strong></p></blockquote><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a><code>if</code> 语句</h2><p>这是编程中最基本也是最常用的语句之一了，代码原型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最基本的用法</span></span><br><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">else</span> 条件:</span><br><span class="line">    执行语句</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然你也可以只使用 if 条件</span></span><br><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    执行语句</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然你也可以多条件使用</span></span><br><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">elif</span> 条件:</span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">elif</span> 条件:</span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">else</span> 条件:</span><br><span class="line">    执行语句</span><br></pre></td></tr></table></figure><p>可以有零个或多个 <code>elif</code><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>部分，以及一个可选的 <code>else</code>部分。 </p><blockquote><p>注：python 并不支持 else if 全称写法</p></blockquote><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a><code>for</code>语句</h2><p>Python 的<code>for</code>语句和其他编程语言不太相同，Python 并不是设置步长，循环条件来完成<code>for</code>循环。反而是<strong>对任意序列进行迭代（例如列表或字符串），条目的迭代顺序与它们在序列中出现的顺序一致</strong>。 代码示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbd3c32b76.png" alt="image-20230413003202739" style="zoom:80%;" /><blockquote><p>需要注意的是在遍历列表的时候，不要对列表内容进行修改；如果一定需要，可以选择复制一份副本来进行操作，否则修改列表将会导致循环次数等出现不可预知的问题</p></blockquote><h2 id="break语句和continue语句"><a href="#break语句和continue语句" class="headerlink" title="break语句和continue语句"></a><code>break</code>语句和<code>continue</code>语句</h2><p><strong><code>break</code>语句</strong>，和 C 中的类似，<strong>用于跳出最近的 <code>for</code> 或 <code>while</code>循环</strong>。</p><p><strong><code>continue</code>语句</strong>也是借鉴自 C 语言，<strong>表示继续循环中的下一次迭代</strong>。</p><h2 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a><code>pass</code>语句</h2><p><strong><code>pass</code>语句什么也不做</strong>。当语法上需要一个语句，但程序需要什么动作也不做时，可以使用它。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p>注：执行这段<strong>代码会出现忙等情况或者出现死循环</strong>情况，<strong>使用<kbd>Ctrl</kbd> + <kbd>C</kbd> 来结束</strong>这种情况</p></blockquote><p>这通常用于创建最小的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TempClass</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h1 id="相关常用函数"><a href="#相关常用函数" class="headerlink" title="相关常用函数"></a>相关常用函数</h1><h2 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a><code>range()</code>函数</h2><p>如果你确实需要<strong>遍历一个数字序列</strong>，内置函数 <a href="httpss://docs.python.org/zh-cn/3.8/library/stdtypes.html#range"><code>range()</code></a> 会派上用场。它会生成一个整数型序列，代码示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbd40b43ab.png" alt="image-20230413004159935" style="zoom:80%;" /><p>当然，你也可以<strong>指定步长来生成序列</strong>，其语法格式为：<code>range(初始值，最终值，步长)</code>，代码示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbd4433ae4.png" alt="image-20230413004510374" style="zoom:80%;" /><p>如果你只打印<code>range()</code>函数，则会出现奇怪的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>这是因为<a href="httpss://docs.python.org/zh-cn/3.8/library/stdtypes.html#range"><code>range()</code></a> 所返回的对象在许多方面表现得像一个列表，但<strong>实际上却并不是</strong>。此对象会在你迭代它时基于所希望的序列返回连续的项，但<strong>它没有真正生成列表</strong>，这样就能节省空间。</p><p>我们称这样对象为 iterable<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，也就是说，适合作为这样的目标对象：函数和结构期望从中获取连续的项直到所提供的项全部耗尽。 我们已经看到 <a href="httpss://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#for"><code>for</code></a> 语句就是这样一种结构，而接受可迭代对象的函数的一个例子是 <a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#sum"><code>sum()</code></a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>最后，也许你会很好奇<strong>如何从一个指定范围内获取一个列表</strong>。 以下是解决方案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><blockquote><p>再后面的部分会详细说明<code>list()</code>函数的细节</p></blockquote><h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><p>我们在前面使用例如<code>print()</code>函数是 Python 提供的基本库的函数，同样的我们也可以自定义我们自己的函数，现在我们来定义一个交互两个变量值的函数，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ExchangeValue</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;交互前的值&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(a,b)</span><br><span class="line">    c = a</span><br><span class="line">    a = b</span><br><span class="line">    b = c</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;交互后的值&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(a,b)</span><br><span class="line"></span><br><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">6</span></span><br><span class="line">ExchangeValue(a,b)</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbd49f0222.png" alt="image-20230413133335294" style="zoom:80%;" /><p>在上面的示例中，使用<strong>关键字<code>def</code>来表示定义一个函数</strong>，后面<strong>必须跟其函数名称和形式参数列表</strong>，格式例如：<code>def 函数名称(形式参数1，形式参数2，...):</code>。其函数体的执行语句必须从下一行开始，需要缩进且一致相同缩进。</p><p>函数在执行的时候，<strong>优先使用的是函数内部的局部变量</strong>，例如我们提供的形式参数（以后简称形参），这就意味着如果形参和全局变量名称重复的时候，函数会优先使用形式参数的变量而不是全局变量。如果形参不存在则查找全局变量。</p><p>另外需要注意的是，形式参数是函数执行的时候的临时参数，在执行完成后只会对当时的形参做一定的操作，例如上述代码的交互函数，准确的来说它并不能实现相关功能，因为它只实现了形参变量的值交互，而实际上我们希望的变量<code>a</code>和<code>b</code>的值并没有交互，你可以尝试输出全局变量<code>a</code>和<code>b</code>的值来查看。</p><p>另外，函数也可以被其他变量指向并调用，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">OutPut</span>(<span class="params">string</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(string)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>OutPut</span><br><span class="line">&lt;function OutPut at <span class="number">0x01F91268</span>&gt;  <span class="comment">#这句输出的是函数在内存中的地址，其形式为16进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>OutPut(<span class="string">&quot;Hello,World&quot;</span>)</span><br><span class="line">Hello,World</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func = OutPut<span class="comment">#使用func指向函数OutPut</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="string">&quot;Hello,World&quot;</span>)<span class="comment">#通过func来调用OutPut函数</span></span><br><span class="line">Hello,World</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果你学过其他语言，你可能会认为 <code>OutPut</code> 不是函数而是一个过程，因为它并不返回值。事实上，<strong>即使没有 <code>return</code>语句的函数也会返回一个值</strong>，尽管它是一个相当无聊的值。<strong>这个值称为 <code>None</code></strong> 。一般来说解释器不会打印出单独的返回值 <code>None</code> ，如果你真想看到它，你可以使用 <code>print(函数调用)</code>来查看。</p><h1 id="函数定义的更多形式"><a href="#函数定义的更多形式" class="headerlink" title="函数定义的更多形式"></a>函数定义的更多形式</h1><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>可以在创建函数的时候，给一定的形参设置默认值，这样在调用函数的时候，可以使用尽量少的参数调用函数，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">OutPut</span>(<span class="params">a,b = <span class="string">&quot;这是结束语句&quot;</span>,c=<span class="string">&quot;这是开头语句&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>这个简单的输出函数，可以通过如下几种方式调用：</p><ul><li>只提供必要参数<code>a</code>，即<code>OutPut(&quot;你好世界&quot;)</code></li><li>只提供必要参数和一个指定参数，即<code>OutPut(&quot;你好，世界&quot;,&quot;这是自定义结束语句&quot;)</code></li><li>也可以选择全部重新提供，即<code>OutPut(&quot;你好，世界&quot;,&quot;这是自定义结束语句&quot;,&quot;这是自定义开头语句&quot;)</code></li></ul><p>需要注意的是，函数形参默认值是在定义处计算好的，也就是说对于下面的代码示例来说，其输出的值为<code>5</code>而不是<code>6</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">arg=i</span>):</span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br><span class="line"></span><br><span class="line">i = <span class="number">6</span></span><br><span class="line">f()</span><br></pre></td></tr></table></figure><p>另外还需要注意的是，<strong>默认值只会执行一次</strong>。这条规则在默认值为可变对象（列表、字典以及大多数类实例）时很重要。比如，下面的函数会存储在后续调用中传递给它的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, L=[]</span>):</span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>其输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>如果你不想要在后续调用之间共享默认值，你可以这样写这个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, L=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure><h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>在传递函数参数的时候，我们可以通过形如<code>key = value</code>的方式来传递关键字，这种方法这使得我们可以指定参数的顺序，因为它们不再依赖于它们在函数定义中的位置。例如上面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">OutPut</span>(<span class="params">a,b = <span class="string">&quot;这是结束语句&quot;</span>,c=<span class="string">&quot;这是开头语句&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>如果我们只希望传入参数<code>a</code>和<code>c</code>的值，我们可以直接使用关键字参数传递，而不用管形参<code>c</code>在函数中的位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutPut(<span class="string">&quot;参数a&quot;</span>,c=<span class="string">&quot;参数c&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="特殊参数"><a href="#特殊参数" class="headerlink" title="特殊参数"></a>特殊参数</h2><p>默认情况下，我们函数定义的参数传递是可以使用位置来传递，也可以使用关键字来传递，现在可以使用参数<code>/</code>和<code>*</code>来限定函数的参数传递是通过位置还是关键字来传递。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Func</span>(<span class="params">arg1,arg2,/,temp,*,kwd1,kwd2</span>):</span><br><span class="line">    <span class="comment"># 函数执行代码</span></span><br></pre></td></tr></table></figure><p>其中我们在第一个**特殊参数<code>/</code><strong>前存在两个参数：<code>arg1</code>和<code>arg2</code>；在</strong><code>*</code>**后有两个参数：<code>kwd1</code>和<code>kwd2</code>。</p><h3 id="仅限位置参数"><a href="#仅限位置参数" class="headerlink" title="仅限位置参数"></a>仅限位置参数</h3><p>使用特殊参数<code>/</code>表示参数<code>arg1</code>和<code>arg2</code>只能通过他们位置的先后来传递参数，而不可以通过关键字传递，例如这样是非法的：<code>Func(arg1=&quot;测试&quot;,arg2=&quot;test&quot;)</code>。</p><p> <strong>仅限位置形参要放在 <code>/</code> (正斜杠) 之前。 这个 <code>/</code> 被用来从逻辑上分隔仅限位置形参和其它形参</strong>。 如果函数定义中没有 <code>/</code>，则表示没有仅限位置形参。在 <code>/</code> 之后的形参可以为 <em>位置或关键字</em> 或 <em>仅限关键字</em>。</p><h3 id="仅限关键字参数"><a href="#仅限关键字参数" class="headerlink" title="仅限关键字参数"></a>仅限关键字参数</h3><p>使用特殊参数<code>*</code>表示参数<code>kwd1</code>和<code>kwd2</code>只能通过关键字来传递参数，而不可以通过其形参的先后顺序来定义，例如这样是非法的：<code>Func(省略前面的部分,&quot;测试&quot;,&quot;test&quot;)</code>。</p><p>指明该形参必须以关键字参数的形式传入，**应在参数列表的第一个仅限关键字形参之前放置一个 <code>*</code>**。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>如果你希望形参名称对用户来说不可用，则使用仅限位置形参。 这适用于形参名称没有实际意义，以及当你希望强制规定调用时的参数顺序，或是需要同时收受一些位置形参和任意关键字形参等情况。</li><li>当形参名称有实际意义，以及显式指定形参名称可使函数定义更易理解，或者当你想要防止用户过于依赖传入参数的位置时，则使用仅限关键字形参。</li><li>对于 API 来说，使用仅限位置形参可以防止形参名称在未来被修改时造成破坏性的 API 变动。</li></ul><h2 id="任意的参数列表"><a href="#任意的参数列表" class="headerlink" title="任意的参数列表"></a>任意的参数列表</h2><p>最不常用的选项是可以使用任意数量的参数调用函数。这些参数会被包含在一个元组里。在可变数量的参数之前，可能会出现零个或多个普通参数。</p><p>一般来说，<strong>这些 <code>可变参数</code> 将在形式参数列表的末尾，因为它们收集传递给函数的所有剩余输入参数</strong>。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">concat</span>(<span class="params">*args, sep=<span class="string">&quot;/&quot;</span></span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> sep.join(args)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat(<span class="string">&quot;earth&quot;</span>, <span class="string">&quot;mars&quot;</span>, <span class="string">&quot;venus&quot;</span>)</span><br><span class="line"><span class="string">&#x27;earth/mars/venus&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat(<span class="string">&quot;earth&quot;</span>, <span class="string">&quot;mars&quot;</span>, <span class="string">&quot;venus&quot;</span>, sep=<span class="string">&quot;.&quot;</span>)</span><br><span class="line"><span class="string">&#x27;earth.mars.venus&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>*</code>运算符：在函数定义时使用单个星号作为前缀，可以捕获任意数量的位置参数并将它们封装到一个元组中。</p></blockquote><h2 id="解包参数列表"><a href="#解包参数列表" class="headerlink" title="解包参数列表"></a>解包参数列表</h2><p>Unpacking arguments list（解包参数列表）是指将一个可迭代对象（如列表、元组）作为函数参数，并<strong>使用 * 运算符将它们拆分为单独的位置参数</strong>。这种技巧允许我们在调用函数时更方便地传递多个参数。</p><p>例如：我们有一个函数 <code>my_func()</code>，它接受三个参数：<code>a</code>、<code>b</code> 和 <code>c</code>。现在，如果我们有一个长度为 3 的元组 <code>(1, 2, 3)</code>，我们可以使用解包参数列表来将该元组的值分别传递给函数参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b = &quot;</span>, b)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c = &quot;</span>, c)</span><br><span class="line"></span><br><span class="line">params = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">my_func(*params)</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先定义了一个函数 <code>my_func()</code>，它需要三个参数。然后，我们创建一个元组 <code>params</code> 并将其赋值为 <code>(1, 2, 3)</code>。最后，我们<strong>调用函数 <code>my_func()</code> 并在元组前面使用 * 运算符以解包参数列表的形式传递参数</strong>。</p><p>这样，元组中的每个元素都被视为单独的位置参数，并传递给 <code>my_func()</code> 函数。因此，函数将输出以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这种方法非常方便，因为它允许我们在调用函数时轻松地传递多个参数，而不必手动将它们打包成列表、元组或字典。同时，在函数定义时使用默认参数和关键字参数的情况下，我们可以通过解包参数列表来跳过其中某些参数并只传递特定的参数。</p><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>lambda 表达式是一种创建匿名函数的方式。它<strong>通常用于需要一个简单的函数来完成某些特定的任务，而不必定义一个完整的函数</strong>。</p><p>**lambda 表达式的语法很简单：<code>lambda 参数列表: 表达式（返回值）</code>**，该表达式的结果就是这个匿名函数的返回值。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个 lambda 表达式，将两个数字相加并返回</span></span><br><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lambda 表达式计算两个数字的和</span></span><br><span class="line">result = add(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出 8</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个匿名函数 <code>add</code>，它接受两个参数 <code>x</code> 和 <code>y</code>，并返回这两个参数的和。然后我们调用这个函数来计算 3 和 5 的和，结果为 8。</p><blockquote><p>注：<strong>lambda 表达式只能包含一条表达式，而不能包含多条语句</strong>。如果要编写更复杂的函数，还是需要使用普通的函数定义方式。</p></blockquote><h2 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h2><p>文档字符串（Docstrings）<strong>是一种注释格式</strong>，用于描述函数、类或模块的用途、参数、返回值等信息。文档字符串位于代码块的开头，<strong>紧跟在 <code>def</code> 语句或其他定义语句之后，并使用三个引号 <code>&quot;&quot;&quot;</code> 包围</strong>。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">arg1, arg2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个示例函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    arg1 -- 第一个参数。</span></span><br><span class="line"><span class="string">    arg2 -- 第二个参数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    函数返回两个参数的和。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了文档字符串来描述 <code>my_function()</code> 函数的作用、参数和返回值。文档字符串的格式通常包括以下几个部分：</p><ul><li>第一行：简要介绍函数的作用。</li><li>空行：用于将第一行与后面的详细描述区分开来。</li><li>参数：列出该函数的所有参数及其说明。</li><li>返回值：描述函数的返回值类型及其意义。</li></ul><p>文档字符串是编写可读性高、易于理解的代码的重要工具，也是编写文档的好习惯。</p><blockquote><p>注：我们可以使用<code>help()</code>函数来查看对应函数的文档字符串</p></blockquote><h1 id="编写习惯"><a href="#编写习惯" class="headerlink" title="编写习惯"></a>编写习惯</h1><p>这是一个约定俗成的习惯，仅仅是一些建议。现在你将要写更长，更复杂的 Python 代码，是时候讨论一下代码习惯了。这些习惯是为了保持一种非常易读且令人赏心悦目的编码风格。每个Python开发人员都应该在某个时候阅读它；以下是最重要的几个要点：</p><ul><li><p>使用4个空格缩进，不要使用制表符<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</p><p>4个空格是一个在小缩进（允许更大的嵌套深度）和大缩进（更容易阅读）的一种很好的折中方案。制表符会引入混乱，最好不要使用它。</p></li><li><p>换行，使一行不超过79个字符。</p><p>这有助于使用小型显示器的用户，并且可以在较大的显示器上并排放置多个代码文件。</p></li><li><p>使用空行分隔函数和类，以及函数内的较大的代码块。</p></li><li><p>如果可能，把注释放到单独的一行。</p></li><li><p>使用文档字符串。</p></li><li><p>在运算符前后和逗号后使用空格，但不能直接在括号内使用： <code>a = f(1, 2) + g(3, 4)</code>。</p></li><li><p>以一致的规则为你的类和函数命名；按照惯例应使用 <code>UpperCamelCase</code> 来命名类，而以 <code>lowercase_with_underscores</code> 来命名函数和方法。</p></li><li><p>如果你的代码旨在用于国际环境，请不要使用花哨的编码。Python 默认的 UTF-8 或者纯 ASCII 在任何情况下都能有最好的表现。</p></li><li><p>同样，哪怕只有很小的可能，遇到说不同语言的人阅读或维护代码，也不要在标识符中使用非ASCII字符。</p></li></ul><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>现在你已经掌握基本的语法和控制语句，后面会介绍一些其他的数据结构和更多的用法和拓展。</p><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">关键字 '<code>elif</code>' 是 'else if' 的缩写</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">可迭代对象：能够逐一返回其成员项的对象</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">作为一个<kbd>Tab</kbd> 党，我对此表示抗议</span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【1.0】Python入门</title>
      <link href="/2023/04/11/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%901.0%E3%80%91Python%E5%85%A5%E9%97%A8/"/>
      <url>/2023/04/11/%E8%AF%AD%E8%A8%80%E6%A0%91/Python/%E3%80%901.0%E3%80%91Python%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Python</code> 很容易使用，但它是一种真正的编程语言，提供了很多数据结构，也支持大型程序，远超 <code>shell</code> 脚本或批处理文件的功能。<code>Python</code> 还提供比 <code>C</code> 语言更多的错误检查，而且作为一种 “超高级语言”，它有高级的内置数据类型，比如灵活的数组和字典。</p><p><code>Python</code> 是一种解释型语言，在程序开发阶段可以为你节省大量时间，因为不需要编译和链接。</p><blockquote><p>注：本内容使用的<code>Python</code>版本为 <strong>3.8</strong></p></blockquote><h1 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h1><h2 id="调用解释器"><a href="#调用解释器" class="headerlink" title="调用解释器"></a>调用解释器</h2><p>如果你在安装<code>Python</code>的时候选择了自动添加<code>Python</code>环境变量，则可以在<code>CMD</code>或者直接在桌面空白处右键选择在终端处打开（仅<code>Win11</code>支持），在命令终端中直接输入<code>python</code>即可调用<code>Python</code>解释器。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbdcc89742.png" alt="image-20230411203001381" style="zoom:80%;" /><blockquote><p>如果你并没有配置环境变量，需要先配置对应的环境变量。</p><p>关于环境变量的说明，可以查看<a href="https://blog.helloseraphine.top:8090/archives/huan-jing-bian-liang-na-xie-shi">环境变量那些事</a> </p></blockquote><p>在调用解释器后，每次输入命令的样式变为如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; 这里是你的命令</span></span><br></pre></td></tr></table></figure><p><strong>在<code>Windows</code>系统下，使用<kbd>Ctrl</kbd> + <kbd>z</kbd> 来退出调用解释器或者输入命令<code>quit()</code>来退出调用</strong>。</p><p>解释器运行的时候有点像 Unix 命令行：在一个标准输入 tty<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 设备上调用，它<strong>能交互式地读取和执行命令</strong>；调用时提供文件名参数，或者有个文件重定向到标准输入的话，它就会读取和执行文件中的 <em>脚本</em>。</p><p>当然，和<code>C</code>语言编译器一样，也存在另一种启动解释器的方式是 <code>python -c command [arg] ...</code>，其中 <em><code>command</code></em> 要换成想执行的指令，就像命令行的 <a href="httpss://docs.python.org/zh-cn/3.8/using/cmdline.html#cmdoption-c"><code>-c</code></a> 选项。由于 Python 代码中经常会包含对终端来说比较特殊的字符，通常情况下都建议用英文单引号把 <em><code>command</code></em> 括起来。</p><blockquote><p>关于所有的命令行选项，请参考 <a href="httpss://docs.python.org/zh-cn/3.8/using/cmdline.html#using-on-general">命令行与环境</a>。</p></blockquote><h2 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h2><p>在命令终端输入并执行指令时，我们说解释器是运行在<strong>交互模式（interactive mode）</strong>。在这种模式中，它会显示 <em>主提示符（primary prompt）</em>，<strong>提示输入下一条指令，通常用三个大于号（<code>&gt;&gt;&gt;</code>）表示</strong>；连续输入行的时候，它会显示 <em>次要提示符</em>，<strong>默认是三个点（<code>...</code>）</strong>。进入解释器时，它会先显示欢迎信息、版本信息、版权声明，然后就会出现提示符：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbddc06aa6.png" alt="image-20230411205148783" style="zoom:80%;" /><p>多行指令需要在连续的多行中输入。比如，以 <a href="httpss://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#if"><code>if</code></a> 为例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbddfa910f.png" alt="image-20230411205631445" style="zoom:80%;" /><blockquote><p>有关交互模式的更多内容，请见 <a href="httpss://docs.python.org/zh-cn/3.8/tutorial/appendix.html#tut-interac">交互模式</a>。</p></blockquote><h2 id="源文件的字符编码"><a href="#源文件的字符编码" class="headerlink" title="源文件的字符编码"></a>源文件的字符编码</h2><p>默认情况下，<strong>Python 源码文件以 UTF-8 编码方式处理</strong>。在这种编码方式中，世界上大多数语言的字符都可以同时用于字符串字面值、变量或函数名称以及注释中——<strong>尽管标准库中只用常规的 ASCII 字符作为变量或函数名，而且任何可移植的代码都应该遵守此约定</strong>。要正确显示这些字符，你的编辑器必须能识别 UTF-8 编码，而且必须使用能支持打开的文件中所有字符的字体。</p><p>如果不使用默认编码，要声明文件所使用的编码，<strong>文件的第一行要写成特殊的注释</strong>。语法如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: encoding -*-</span></span><br></pre></td></tr></table></figure><p>其中 <code>encoding</code> 可以是 Python 支持的任意一种 <a href="httpss://docs.python.org/zh-cn/3.8/library/codecs.html#module-codecs"><code>codecs</code></a>。</p><p>比如，要声明使用 Windows-1252 编码，你的源码文件要写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp1252 -*-</span></span><br></pre></td></tr></table></figure><h1 id="Python的非正式介绍"><a href="#Python的非正式介绍" class="headerlink" title="Python的非正式介绍"></a>Python的非正式介绍</h1><p><strong>Python中的注释以井号 <code>#</code> 开头，并且一直延伸到该文本行结束为止</strong>。注释可以出现在一行的开头或者是空白和代码的后边，但是不能出现在字符串中间。字符串中的井号就是井号。<strong>因为注释是用来阐明代码的，不会被 Python 解释</strong>。</p><h2 id="作为计算器使用"><a href="#作为计算器使用" class="headerlink" title="作为计算器使用"></a>作为计算器使用</h2><p>现在来尝试一些简单的 Python 命令。<strong>启动解释器，等待界面中的提示符，<code>&gt;&gt;&gt;</code></strong> </p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p><strong>解释器就像一个简单的计算器一样：你可以在里面输入一个表达式然后它会写出答案</strong>。 表达式的语法很直接：<strong>运算符 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code></strong> 的用法和其他大部分语言一样（比如 Pascal 或者 C 语言）；括号 (<code>()</code>) 用来分组。比如：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbde3b26ba.png" alt="image-20230411211912119" style="zoom:80%;" /><p>**整数（比如 <code>2</code>、<code>4</code>、<code>20</code> ）的类型是 <a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#int"><code>int</code></a>，有小数部分的（比如 <code>5.0</code>、<code>1.6</code> ）的类型是 <a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#float"><code>float</code></a>**。 在后面将会接触到更多的数字类型，此处不一一赘述。</p><p><strong>除法运算 (<code>/</code>) 永远返回浮点数类型</strong>。如果要做 <a href="httpss://docs.python.org/zh-cn/3.8/glossary.html#term-floor-division">floor division<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></a> 得到一个整数结果（忽略小数部分）你可以使用 <code>//</code> 运算符；**如果要计算余数，可以使用 <code>%</code>**。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbde7337a8.png" alt="image-20230411212312342" style="zoom:80%;" /><p>在Python中，可以<strong>使用 <code>**</code> 运算符来计算乘方</strong>，例如<code>2**2</code>表示 $2^2$ 。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbdea962fe.png" alt="image-20230411212428322" style="zoom:80%;" /><blockquote><p>需要注意的是，<code>**</code>运算符具有较高的优先级，在例如<code>1-2**2</code>的表达式，其运算式为 $\large 1-2^2$ 。如果希望其运算式为 $\large (1-2)^2$ 则需要将命令使用括号来表示，即 <code>(1-2)**2</code></p></blockquote><p><strong>等号 (<code>=</code>) 用于给一个变量赋值</strong>。然后在下一个交互提示符之前不会有结果显示出来:</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbdedeebcf.png" alt="image-20230411212721442" style="zoom:80%;" /><p>如果一个变量未定义（未赋值），试图使用它时会向你提示错误。</p><p>Python中提供浮点数的完整支持；<strong>包含多种混合类型运算数的运算会把整数转换为浮点数</strong>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbdf15980c.png" alt="image-20230411214905907" style="zoom:80%;" /><p>**在交互模式下，上一次打印出来的表达式被赋值给变量 <code>_</code>**。这意味着当你把Python用作桌面计算器时，继续计算会相对简单，比如：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbdf46a5e1.png" alt="image-20230411215122982" style="zoom:80%;" /><blockquote><p><strong>这个变量应该被使用者当作是只读类型。不要向它显式地赋值</strong>。</p></blockquote><p>除了 <a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#int"><code>int</code></a> 和 <a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#float"><code>float</code></a>，Python也支持其他类型的数字，例如 <a href="httpss://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal"><code>Decimal</code><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></a> 或者 <a href="httpss://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction"><code>Fraction</code><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></a>。Python 也内置对 <a href="httpss://docs.python.org/zh-cn/3.8/library/stdtypes.html#typesnumeric">复数</a> 的支持，使用后缀 <code>j</code> 或者 <code>J</code> 就可以表示虚数部分（例如 <code>3+5j</code> ）。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>除了数字，Python 也可以操作字符串。字符串有多种形式，<strong>可以使用单引号（<code>&#39;...&#39;</code>），双引号（<code>&quot;...&quot;</code>）都可以获得同样的结果。反斜杠 <code>\</code> 可以用来转义</strong>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbdf809449.png" alt="image-20230411220003073" style="zoom:80%;" /><p><a href="httpss://docs.python.org/zh-cn/3.8/library/functions.html#print"><code>print()</code></a> 函数会生成可读性更强的输出，<strong>即略去两边的引号，并且打印出经过转义的特殊字符</strong>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbdfb281af.png" alt="image-20230411221654277" style="zoom:80%;" /><p>使用<code>print()</code>函数，如果你不希望前置了 <code>\</code> 的字符转义成特殊字符，可以使用 <strong>原始字符串</strong> 方式，<strong>在引号前添加 <code>r</code> 即可</strong>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbdfe79172.png" alt="image-20230411222001484" style="zoom:80%;" /><p>**字符串字面值可以包含多行。 一种实现方式是使用三重引号：<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 或 <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>**。 在使用三重引号表示多行字符串时，Python会自动在每行末尾添加行结束符 <code>\n</code>，可以通过在换行的地方添加一个 <code>\</code> 来避免此情况。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbe0199955.png" alt="image-20230411222448929" style="zoom:80%;" /><p><strong>字符串可以用 <code>+</code> 进行连接（粘到一起），也可以用 <code> 重复次数 *</code> 进行重复</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbe0540fbc.png" alt="image-20230411224650356" style="zoom:80%;" /><p><strong>相邻的两个或多个字符串字面值（引号引起来的字符）将会自动连接到一起</strong>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbe087a377.png" alt="image-20230411224753630" style="zoom:80%;" /><blockquote><p>注：只能对两个字面值这样操作，<strong>变量或表达式不行</strong>，<strong>如果你想连接变量，或者连接变量和字面值，可以用 <code>+</code> 号</strong>。</p></blockquote><p><strong>字符串是可以被 <em>索引</em> （下标访问）的，第一个字符索引是 0</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbe0b732a0.png" alt="image-20230411224956585" style="zoom:80%;" /><p>索引也可以用负数，这种会从右边开始数：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbe0ef0f66.png" alt="image-20230411225027222" style="zoom:80%;" /><blockquote><p>注意 -0 和 0 是一样的，所以负数索引从 -1 开始</p></blockquote><p>除了索引，<strong>字符串还支持切片。索引可以得到单个字符，而切片可以获取子字符串</strong>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbe12a2641.png" alt="image-20230411225157262" style="zoom:80%;" /><p>Python 中的字符串不能被修改，它们是 <a href="httpss://docs.python.org/zh-cn/3.8/glossary.html#term-immutable">immutable<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></a> 的。因此，<strong>向字符串的某个索引位置赋值会产生一个错误</strong>。</p><blockquote><p>注：可以重新赋值，但是不可以修改其中单个字符的内容</p></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Python 中可以<strong>通过组合一些值得到多种复合数据类型</strong>。其中最常用的<strong>列表</strong>，<strong>可以通过方括号括起、逗号分隔的一组值（元素）得到</strong>。一个<strong>列表可以包含不同类型的元素，但通常使用时各个元素类型相同</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbe166a432.png" alt="image-20230411225750747" style="zoom:80%;" /><p>和字符串一样，<strong>列表也支持索引和切片</strong>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbe19cffbf.png" alt="image-20230411225840351" style="zoom:80%;" /><p>所有的切片操作都返回一个包含所请求元素的新列表。 这意味着以下切片操作会返回列表的一个<a href="httpss://docs.python.org/zh-cn/3.8/library/copy.html#shallow-vs-deep-copy">浅拷贝</a>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbe1d4915e.png" alt="image-20230411231203672" style="zoom:80%;" /><blockquote><p>浅拷贝只复制了对象的表面结构，子对象仍然是原对象和拷贝对象共享的；而深拷贝则复制了对象的所有结构，每个对象和对应的拷贝对象是彼此独立的。因此即使修改原对象中的子对象，深拷贝出的对象也不会受到影响。</p></blockquote><p><strong>列表同样支持拼接</strong>操作：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbe20e9740.png" alt="image-20230411231349657" style="zoom:80%;" /><p>与 <a href="httpss://docs.python.org/zh-cn/3.8/glossary.html#term-immutable">immutable</a> 的字符串不同, 列表是一个 <a href="httpss://docs.python.org/zh-cn/3.8/glossary.html#term-mutable">mutable</a> 类型，就是说，它自己的内容可以改变，即可以改变对应位置的元素内容：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbe248bbcc.png" alt="image-20230411231546087" style="zoom:80%;" /><p>也可以<strong>嵌套列表</strong> (创建包含其他列表的列表)或者也可以在列表末尾通过 <code>append()</code> <em>方法</em> 来添加新元素。</p><h1 id="走向编程的第一步"><a href="#走向编程的第一步" class="headerlink" title="走向编程的第一步"></a>走向编程的第一步</h1><p>当然，我们可以将 Python 用于更复杂的任务，而不是仅仅两个和两个一起添加。 例如，我们可以编写斐波那契数列<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>的初始子序列，如下所示:</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbe27c84ab.png" alt="image-20230411232258965" style="zoom:80%;" /><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>关于后续的代码编辑器的使用，你可以选择使用 <strong>PyCharm</strong> 来编写<code>python</code>代码，你也可以使用 <strong>Visual Studio</strong> 来编写，当然你也可以使用 <strong>Visual Studio Code</strong> 链接解释器来使用。</p><blockquote><p>需要注意的是使用上述编辑器，需要下载对应的社区版本是免费的，可以满足绝大部分的需要。</p></blockquote><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">TTY是由<a href="httpss://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E6%8E%A7%E5%88%B6%E5%8F%B0/8671381?fromModule=lemma_inlink">虚拟控制台</a>，串口以及伪<a href="httpss://baike.baidu.com/item/%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87/643738?fromModule=lemma_inlink">终端设备</a>组成的终端设备。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">向下取整除法，向下舍入到最接近的整数的数学除法 。</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">一种可以精确表示小数的数据类型，而不会受到浮点数精度问题的影响。例如，计算 $0.1+0.2$ 时，使用 <code>float</code> 可能会得到 $0.30000000000000004$ 这样不准确的结果，而使用 <code>Decimal</code> 则可以得到精确的 $0.3$。</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">分数</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;"><strong>不可变对象</strong>：具有固定值的对象。不可变对象包括数字、字符串和元组。这样的对象不能被改变。</span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;">斐波那契数列即为从0和1开始的一个数列，每一项是前两项的和。</span><a href="#fnref:6" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【5.0】输入输出（IO）管理</title>
      <link href="/2023/03/13/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%905.0%E3%80%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88IO%EF%BC%89%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/13/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%905.0%E3%80%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88IO%EF%BC%89%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>NULL，懒得写了</p><h1 id="I-O管理概述"><a href="#I-O管理概述" class="headerlink" title="I&#x2F;O管理概述"></a>I&#x2F;O管理概述</h1><h2 id="I-O设备的概念和分类"><a href="#I-O设备的概念和分类" class="headerlink" title="I&#x2F;O设备的概念和分类"></a>I&#x2F;O设备的概念和分类</h2><p>“I／O”就是“输入／输出”（Input／Output）。I／O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p><p><strong>UNIX 系统将外部设备抽象为一种特殊的文件</strong>，用户可以使用与文件操作相同的方式对外部设备进行操作。 </p><h3 id="按使用特性分类"><a href="#按使用特性分类" class="headerlink" title="按使用特性分类"></a>按使用特性分类</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad8d2a701c.png" alt="image-20230311203028289" style="zoom:50%;" /><h3 id="按传输速率分类"><a href="#按传输速率分类" class="headerlink" title="按传输速率分类"></a>按传输速率分类</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad8d6d2cbb.png" alt="image-20230311203117825" style="zoom:50%;" /><h3 id="按信息交换单位分类"><a href="#按信息交换单位分类" class="headerlink" title="按信息交换单位分类"></a>按信息交换单位分类</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad8db8dc89.png" alt="image-20230311203148294" style="zoom:50%;" /><h2 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I&#x2F;O控制器"></a>I&#x2F;O控制器</h2><p>I&#x2F;O设备的<strong>机械部件</strong>主要用来执行具体 I&#x2F;O操作。如我们看得见摸得着的鼠标／键盘的按钮；显示器的LED屏；移动硬盘的磁臂、磁盘盘面。I／O设备的电子部件通常是一块插入主板扩充槽的印刷电路板。</p><p>I／O设备的<strong>电子部件</strong>通常是一块插入主板扩充槽的印刷电路板。</p><p>CPU无法直接控制I／O设备的机械部件，因此I／O设备还要有一个电子部件作为CPU和I／O设备机械部件之间的“中介”，用于实现CPU对设备的控制。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad8df78c58.png" alt="image-20230311203558826" style="zoom:67%;" /><h3 id="I-O控制器的组成"><a href="#I-O控制器的组成" class="headerlink" title="I&#x2F;O控制器的组成"></a>I&#x2F;O控制器的组成</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad8e3e62f7.png" alt="image-20230311203938774" style="zoom:67%;" /><p>注意：</p><ol><li>一个I／O控制器可能会对应多个设备；</li><li>数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制／状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为<strong>内存映像 I&#x2F;O</strong>；另一些计算机则采用 I&#x2F;O 专用地址，即<strong>寄存器独立编址</strong>。</li></ol><h3 id="内存映像和寄存器独立编址"><a href="#内存映像和寄存器独立编址" class="headerlink" title="内存映像和寄存器独立编址"></a>内存映像和寄存器独立编址</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad8e86cf4e.png" alt="image-20230311204435610" style="zoom:50%;" /><h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad8ec52606.png" alt="image-20230311204528062" style="zoom: 50%;" /><h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><p>【完成一次读／写操作的流程（Key word：<strong>轮询</strong>）】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad8f09d94c.png" alt="image-20230311204835150" style="zoom:80%;" /><p>【CPU干预的频率】</p><p>很频繁，I／O操作开始之前、完成之后需要CPU介入，并且在等待I／O完成的过程中CPU需要不断地轮询检查。</p><p>【数据传送的单位】</p><p>每次<strong>读／写一个字</strong></p><p>【数据的流向】</p><p>读操作（数据输入）：I／O设备→CPU→内存</p><p>写操作（数据输出）：内存→CPU→I／O</p><p><strong>设备每个字的读／写都需要CPU的帮助</strong>。</p><p>【主要缺点和主要优点】</p><p>优点：实现简单。在读／写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”）</p><p>缺点：<strong>CPU和I／O设备只能串行工作</strong>，<strong>CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低</strong>。</p><h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><p>引入中断机制。由于I／O设备速度很慢，因此在CPU发出读／写命令后，可将等待I／O的进程阻塞，先切换到别的进程执行。当I／O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从I／O控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，CPU恢复等待I／O的进程（或其他进程）的运行环境，然后继续执行。</p><img src="httpss://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20230312152125249.png" alt="image-20230312152125249" style="zoom:50%;" /><ol><li>CPU会在每个指令周期的末尾检查中断；</li><li>中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的频率太高，也会降低系统性能。</li></ol><p>【完成一次读／写操作的流程（Key word：<strong>中断</strong>）】</p><p>【CPU 干预的频率】</p><p>每次 $I&#x2F;O$ 操作开始之前、完成之后需要CPU介入。</p><p><strong>等待1&#x2F;O完成的过程中CPU可以切换到别的进程执行</strong>。</p><p>【数据传送的单位】</p><p>每次读／写一个<strong>字</strong>。</p><p>【数据的流向】</p><p>读操作（数据输入） ： 1&#x2F;O设备→CPU—内存</p><p>写操作（数据输出） ：内存→CPU—1&#x2F;O设备</p><p>【优缺点】</p><p>优点：与“程序直接控制方式”相比，在“中断驱动方式”中，I／O控制器会通过中断信号主动报告I／O已完成，CPU不再需要不停地轮询。CPU和I／O设备可并行工作，<strong>CPU利用率得到明显提升</strong>。</p><p>缺点：每个字在I／O设备与内存之间的传输，都需要经过CPU。而<strong>频繁的 中断处理会消耗较多的CPU时间</strong>。</p><h3 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h3><p>与“中断驱动方式”相比，<strong>DMA方式（Direct Memory Access，直接存储器存取</strong>。主要用于块设备的I／O控制）有这样几个改进：</p><ol><li><strong>数据的传送单位是“块”</strong>。不再是一个字、一个字的传送；</li><li>数据的流向是<strong>从设备直接放入内存，或者从内存直接到设备</strong>。不再需要CPU作为“快递小哥”。</li><li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</li></ol><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad8f97725d.png" alt="image-20230312155618365" style="zoom:67%;" /><h4 id="DMA-控制器"><a href="#DMA-控制器" class="headerlink" title="DMA 控制器"></a>DMA 控制器</h4><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad8ff8d5be.png" alt="image-20230312155845639" style="zoom:67%;" /><p>DR（Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。</p><p>MAR（Memory Address Register，内存地址寄存器）：在输入时，MAR表示数据应放到内存中的什么 位置；输出时MAR表示要输出的数据放在内存中的什么位置。</p><p>Data Counter，数据计数器）：表示剩余要读／写的字节数。</p><p>CR（Command Register，命令／状态寄存器）：用于存放CPU发来的I／O命令，或设备的状态信息。</p><p>【完成一次读／写操作的流程】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad903c9f26.png" alt="image-20230312155914789" style="zoom:50%;" /><p>【CPU干预的频率】</p><p>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</p><p>【数据传送的单位】</p><p>每次读／写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</p><p>【数据的流向】</p><p>读操作（数据输入） ： 1&#x2F;0设备→内存</p><p>写操作（数据输出） ：内存→1&#x2F;0设备</p><blockquote><p>不再需要经过CPU</p></blockquote><p>【主要缺点和主要优点】</p><p>优点：数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I／O设备的并行性得到提升。</p><p>缺点：<strong>CPU每发出一条I／O指令，只能读／写一个或多个连续的数据块</strong>。</p><h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><p>通道：<strong>一种硬件</strong>，可以理解为是“弱鸡版的CPU”。通道可以识别并执行一系列通道指令。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad908a632c.png" alt="image-20230312160450988" style="zoom:67%;" /><blockquote><p>与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存</p></blockquote><p>【完成一次读／写操作的流程】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad90db7d2d.png" alt="image-20230312160541408" style="zoom:50%;" /><p>【CPU干预的频率】</p><p>极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读／写后才需要发出中断信号，请求CPU干预。</p><p>【数据传送的单位】</p><p>每次读／写一组数据块</p><p>【数据的流向】</p><p>读操作（数据输入）：I／O设备→内存</p><p>写操作（数据输出）：内存→I／O设备</p><blockquote><p>在通道的控制下进行</p></blockquote><p>【优缺点】</p><p>缺点：实现复杂，需要专门的通道硬件支持</p><p>优点：<strong>CPU、通道、I／O设备可并行工作，资源利用率很高</strong>。</p><h2 id="I-O软件层次结构"><a href="#I-O软件层次结构" class="headerlink" title="I&#x2F;O软件层次结构"></a>I&#x2F;O软件层次结构</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad9149ea40.png" alt="image-20230312163115919" style="zoom:67%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad918b0a77.png" alt="image-20230312161137319" style="zoom:50%;" /><p>每一层会利用其下层提供的服务，实现某些功能，并屏蔽实现的具体细节，向高层提供服务（“封装思想”）</p><h3 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h3><p>用户层软件<strong>实现了与用户交互的接口</strong>，用户可直接使用该层提供的、与1／O操作相关的库函数对设备进行操作。</p><p>用户层软件将用户请求翻译成格式化的I／O请求，并<strong>通过“系统调用”请求操作系统内核的服务</strong>。</p><h3 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h3><p>设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p><ol><li>向上层提供统一的调用接闷（如 read／write 系统调用）</li><li>设备的保护</li><li>差错处理</li><li>设备的分配与回收</li><li>数据缓冲区管理：可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</li><li>建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序：用户或用户层软件发出I／O操作相关系统调用的系统调用时，需要指明此次要操作的I／O设备的逻辑设备名；<br><strong>设备独立性软件需要通过“逻辑设备表（LUT，Logical UnitTable）”来确定逻辑设备对应的物理设备</strong>，并找到该设备对应的设备驱动程序<br>操作系统系统可以采用两种方式管理逻辑设备表（LUT）：<ul><li><strong>整个系统只设置一张LUT</strong>，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。</li><li><strong>为每个用户设置一张LUT</strong>，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</li></ul></li></ol><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p><strong>主要负责对硬件设备的具体控制，将上层发出的一系列命令（如read&#x2F;write）转化成特定设备“能听得懂”的一系列操作</strong>。包括设置设备寄存器；检查设备状态等</p><p>不同的1&#x2F;0设备有不同的硬件特性，具体细节只有设备的厂家才知道。因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序。</p><blockquote><p>驱动程序一般会以一个独立进程的方式存在。</p></blockquote><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>当I／O任务完成时，I／O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad91e392a7.png" alt="image-20230312163011664" style="zoom:67%;" /><blockquote><p>中断处理程序也会和硬件直接打交道</p></blockquote><h2 id="输入输出程序接口"><a href="#输入输出程序接口" class="headerlink" title="输入输出程序接口"></a>输入输出程序接口</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad92255c5b.png" alt="image-20230312190128888" style="zoom:67%;" /><p>阻塞I／O：应用程序发出I／O系统调用，进程需转为阻塞态等待。</p><p>非阻塞I／O：应用程序发出I／O系统调用，系统调用可迅速返回，进程无需阻塞等待。</p><h2 id="设备驱动程序接口"><a href="#设备驱动程序接口" class="headerlink" title="设备驱动程序接口"></a>设备驱动程序接口</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad92681c9d.png" alt="image-20230312191740156" style="zoom: 50%;" /><p>不同的操作系统，对设备驱动程序接口的标准各不相同。</p><p>设备厂商必须根据操作系统的接口要求，开发相应的设备驱动程序，设备才能被使用</p><h1 id="设备独立性软件-1"><a href="#设备独立性软件-1" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h1><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad92a51a81.png" alt="image-20230312231205868" style="zoom:50%;" /><h2 id="I-O核心子系统"><a href="#I-O核心子系统" class="headerlink" title="I&#x2F;O核心子系统"></a>I&#x2F;O核心子系统</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad92e59b36.png" alt="image-20230312231448558" style="zoom:50%;" /><h3 id="I-O调度"><a href="#I-O调度" class="headerlink" title="I&#x2F;O调度"></a>I&#x2F;O调度</h3><p>I／O调度：用某种算法确定一个好的顺序来处理各个I／O请求。</p><p>如：磁盘调度（先来先服务算法、最短寻道优先算法、SCAN算法、C—SCAN算法、LOOK算法、C—LOOK算法）。当多个磁盘I／O请求到来时，用某种调度算法确定满足I／O请求的顺序。</p><p>同理，打印机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定I／0调度顺序。</p><h3 id="设备保护"><a href="#设备保护" class="headerlink" title="设备保护"></a>设备保护</h3><p>操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限（如：只读、读和写等）。</p><p>在UNIX系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。</p><h2 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h2><h3 id="什么是脱机技术"><a href="#什么是脱机技术" class="headerlink" title="什么是脱机技术"></a>什么是脱机技术</h3><p>手工操作阶段：主机直接从I／O设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备。</p><p>批处理阶段引入了脱机输入／输出技术（用磁带完成）：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad932b8133.png" alt="image-20230312231755541" style="zoom:50%;" /><blockquote><p>Tips：为什么称为“脱机”——脱离主机的控制进行的输入／输出操作。</p></blockquote><p>引入脱机技术后，<strong>缓解了CPU与慢速I／O设备的速度矛盾</strong>。</p><p>另一方面，即使CPU在忙碌，也可以提前将数据输入到磁带；即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。</p><h3 id="输入井和输出井"><a href="#输入井和输出井" class="headerlink" title="输入井和输出井"></a>输入井和输出井</h3><p><strong>“假脱机技术”，又称“SPOOLing技术”是用软件的方式模拟脱机技术</strong>。SPOOLing系统的组成如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad9368f71b.png" alt="image-20230312232527999" style="zoom:50%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad93a80dc1.png" alt="image-20230312233043717" style="zoom:50%;" /><p>要实现SPOOLing技术，<strong>必须要有多道程序技术的支持</strong>。系统会建立“输入进程”和“输出进程”。</p><h3 id="共享打印机原理"><a href="#共享打印机原理" class="headerlink" title="共享打印机原理"></a>共享打印机原理</h3><p>独占式设备——<strong>只允许各个进程串行使用的设备</strong>。一段时间内只能满足一个进程的请求。</p><p>共享设备——<strong>允许多个进程“同时”使用的设备</strong>（宏观上同时使用，微观上可能是交替使用）。可以同时满足多个进程的使用请求。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad93e71a4d.png" alt="image-20230312233527900" style="zoom:50%;" /><p>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：</p><ol><li>在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中；</li><li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。</li></ol><p>当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务。</p><p>虽然系统中只有一个台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p><p><strong>SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备、可将独占式设备改造成共享设备</strong>。</p><h2 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h2><h3 id="设备分配时应考虑的因素"><a href="#设备分配时应考虑的因素" class="headerlink" title="设备分配时应考虑的因素"></a>设备分配时应考虑的因素</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad9429fd52.png" alt="image-20230313181413982" style="zoom:50%;" /><h4 id="固有属性"><a href="#固有属性" class="headerlink" title="固有属性"></a>固有属性</h4><ul><li>独占设备：一个时段只能分配给一个进程（如打印机）</li><li>共享设备：可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用。</li><li>虚拟设备——采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLing技术实现的共享打印机）</li></ul><h4 id="设备分配算法"><a href="#设备分配算法" class="headerlink" title="设备分配算法"></a>设备分配算法</h4><p>先来先服务，优先级高者优先，短任务优先等等</p><h4 id="设备分配中的安全"><a href="#设备分配中的安全" class="headerlink" title="设备分配中的安全"></a>设备分配中的安全</h4><p><strong>安全分配方式</strong>：为进程分配一个设备后就将进程阻塞，本次I／O完成后才将进程唤醒。（eg：考虑进程请求打印机打印输出的例子）</p><p>一个时段内每个进程只能使用一个设备</p><ul><li>优点：破坏了“请求和保持”条件，不会死锁</li><li>缺点：对于一个进程来说，CPU和I／O设备只能串行工作</li></ul><p><strong>不安全分配方式</strong>：进程发出1&#x2F;0请求后，系统为其分配1&#x2F;0设备，进程可继续执行，之后还可以发出新的1&#x2F;0请求。只有某个1&#x2F;0请求得不到满足时才将进程阻塞。</p><p>一个进程可以同时使用多个设备</p><ul><li><p>优点：进程的计算任务和I／O任务可以并行处理，使进程迅速推进</p></li><li><p>缺点：有可能发生死锁（死锁避免、死锁的检测和解除）</p></li></ul><h3 id="静态分配和动态分配"><a href="#静态分配和动态分配" class="headerlink" title="静态分配和动态分配"></a>静态分配和动态分配</h3><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源</p><blockquote><p>破坏了“请求和保持”条件，不会发生死锁</p></blockquote><p>动态分配：进程运行过程中动态申请设备资源</p><h3 id="设备分配管理中的数据结构"><a href="#设备分配管理中的数据结构" class="headerlink" title="设备分配管理中的数据结构"></a>设备分配管理中的数据结构</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad9498afe9.png" alt="image-20230313182407855" style="zoom:50%;" /><p><strong>设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad94da1477.png" alt="image-20230313182527494" style="zoom:67%;" /><p><strong>控制器控制表（COCT）：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad9526fa61.png" alt="image-20230313182625421" style="zoom:67%;" /><p><strong>通道控制表（CHCT）：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad9573b7a2.png" alt="image-20230313182707200" style="zoom:67%;" /><p><strong>系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad95bb23b4.png" alt="image-20230313182734853" style="zoom:67%;" /><h3 id="设备分配的步骤"><a href="#设备分配的步骤" class="headerlink" title="设备分配的步骤"></a>设备分配的步骤</h3><ol><li>根据进程请求的物理设备名查找SDT（注：物理设备名是进程请求分配设备时提供的参数）</li><li>根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将<br>设备分配给进程。 </li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li></ol><blockquote><p>注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I／O设备进行数据传送</p></blockquote><p>缺点：</p><ol><li>用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</li><li>若换了一个物理设备，则程序无法运行</li><li>若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li></ol><p>改进方法：<strong>建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</strong>。</p><h4 id="设备分配步骤的改进"><a href="#设备分配步骤的改进" class="headerlink" title="设备分配步骤的改进"></a>设备分配步骤的改进</h4><ol><li>根据进程请求的逻辑设备名查找SDT（注：用户编程时提供的逻辑设备名其实就是“设备类型”）</li><li>查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li></ol><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad96101198.png" alt="image-20230313184050029" style="zoom:50%;" /><p>逻辑设备表（LUT）<strong>建立了逻辑设备名与物理设备名之间的映射关系</strong>。</p><p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。</p><p>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。</p><p>逻辑设备表的设置问题：</p><ul><li>整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户</li><li>操作系统每个用户一张LUT：<strong>不同用户的逻辑设备名可重复</strong>，适用于多用户操作系统</li></ul><h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><p><strong>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区</strong>。</p><p><strong>使用硬件作为缓冲区的成本较高，容量也较小</strong>，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</p><p>一般情况下，<strong>更多的是利用内存作为缓冲区</strong>，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区</p><h3 id="缓冲区的作用"><a href="#缓冲区的作用" class="headerlink" title="缓冲区的作用"></a>缓冲区的作用</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad96557a0b.png" alt="image-20230313184320866" style="zoom:50%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad969764c9.png" alt="image-20230313184404811" style="zoom:50%;" /><h3 id="缓冲区的管理"><a href="#缓冲区的管理" class="headerlink" title="缓冲区的管理"></a>缓冲区的管理</h3><h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><p>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>单缓冲</strong>的策略，<strong>操作系统会在主存中为其分配一个缓冲区</strong>（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</p><blockquote><p>注意：<strong>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出</strong>；当缓冲区为空时，可以往缓冲区冲入数据，但<strong>必须把缓冲区充满以后，才能从缓冲区把数据传出</strong>。</p></blockquote><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad96d3ee31.png" alt="image-20230313184801355" style="zoom:33%;" /><p><strong>在“单缓冲”题型中，可以假设初始状态为工作区满，缓冲区空。</strong></p><p>结论：<strong>采用单缓冲策略，处理一块数据平均耗时Max（C，T）＋M</strong></p><h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><p>假设某用户进程请求某种块设备读入若干块的数据。<strong>若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区</strong>（若题目中没有特别说明，一个缓冲区的大小就是一个块）</p><p>双缓冲题目中，<strong>假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空</strong>。</p><p>结论：<strong>采用双缓冲策略，处理一个数据块的平均耗时为Max（T，C＋M）</strong>。</p><h4 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h4><p><strong>将多个大小相等的缓冲区链接成一个循环队列</strong>。</p><p>注：以下图示中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad976362c7.png" alt="image-20230313190129221" style="zoom:50%;" /><h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><p>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</p><p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：用于收容输入数据的工作缓冲区（hin）、用于提取输入数据的工作缓冲区（sin）、用于收容输出数据的工作缓冲区（hout）、用于提取输出数据的工作缓冲区（sout）</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad97a270b1.png" alt="image-20230313190409291" style="zoom:50%;" /><h1 id="磁盘和固态硬盘"><a href="#磁盘和固态硬盘" class="headerlink" title="磁盘和固态硬盘"></a>磁盘和固态硬盘</h1><h2 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h2><h3 id="磁盘，磁道，扇区"><a href="#磁盘，磁道，扇区" class="headerlink" title="磁盘，磁道，扇区"></a>磁盘，磁道，扇区</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aad983c7315.png" alt="image-20230311200956483" style="zoom:50%;" /><p>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aad98802ce5.png" alt="image-20230311201623127" style="zoom:50%;" /><p>磁盘的盘面被划分成一个个磁道。这样的一个“圈”就是一个磁道。</p><p>一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”。各个扇区存放的数据量相同（如1KB）。</p><p><strong>最内侧磁道上的扇区面积最小，因此数据密度最大</strong>。</p><h3 id="如何在磁盘中读-写数据"><a href="#如何在磁盘中读-写数据" class="headerlink" title="如何在磁盘中读&#x2F;写数据"></a>如何在磁盘中读&#x2F;写数据</h3><p>需要把“磁头”移动到想要读／写的扇区所在的磁道。</p><p>磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读／写操作。</p><h3 id="盘面，柱面"><a href="#盘面，柱面" class="headerlink" title="盘面，柱面"></a>盘面，柱面</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aad98c920c9.png" alt="image-20230311202229677" style="zoom:50%;" /><p>可用<strong>（柱面号，盘面号，扇区号）</strong>来定位任意一个“磁盘块”。在“文件的物理结构”小节中，我们经常提到文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号）的地址形式。</p><p>可根据该地址读取一个“块”</p><ol><li>根据“柱面号”移动磁臂，让磁头指向指定柱面；</li><li>激活指定盘面对应的磁头；</li><li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读／写。</li></ol><h3 id="磁盘的分类"><a href="#磁盘的分类" class="headerlink" title="磁盘的分类"></a>磁盘的分类</h3><p>磁头可以移动的称为<strong>活动头磁盘</strong>。磁臂可以来回伸缩来带动磁头定位磁道。</p><p>磁头不可移动的称为<strong>固定头磁盘</strong>。这种磁盘中每个磁道有一个磁头。</p><p>盘片可以更换的称为<strong>可换盘磁盘</strong>。</p><p>盘片不可更换的称为<strong>固定盘磁盘</strong>。</p><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><h3 id="一次读写需要的时间"><a href="#一次读写需要的时间" class="headerlink" title="一次读写需要的时间"></a>一次读写需要的时间</h3><p><strong>寻找时间（寻道时间</strong>）Ts：在读／写数据前，将磁头移动到指定磁道所花的时间。</p><ol><li>启动磁头臂是需要时间的。假设耗时为s；</li><li>移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则：<br>寻道时间Ts＝s＋m＊n</li></ol><p><strong>延迟时间</strong>TR：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为（单位：转／秒，或转／分），则平均所需的延迟时间TR＝（1／2）＊（1／r）＝1／2r</p><blockquote><p>1／r 就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此再乘以1／2</p></blockquote><p><strong>传输时间</strong>T：从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读／写的字节数为b，每个磁道上的字节数为N。则：<br>传输时间Tt＝（1／r）＊（b／N）＝b／（rN）</p><blockquote><p>每个磁道要可存N字节的数据，因此b字节的数据需要b&#x2F;N 个磁道才能存储。而读&#x2F;写一个磁道所需的时间<br>刚好又是转一圈所需要的时间1&#x2F;r</p></blockquote><p>总的平均存取时间Ta＝Ts＋1／2r＋b／（rN）</p><p><strong>延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间</strong>。</p><h3 id="先来先服务算法（FCFS）"><a href="#先来先服务算法（FCFS）" class="headerlink" title="先来先服务算法（FCFS）"></a>先来先服务算法（FCFS）</h3><p>根据进程请求访问磁盘的先后顺序进行调度。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aad999b561d.png" alt="image-20230313191329635" style="zoom:67%;" /><p>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去。</p><p>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。</p><h3 id="最短时间寻址时间优先算法（SSTF）"><a href="#最短时间寻址时间优先算法（SSTF）" class="headerlink" title="最短时间寻址时间优先算法（SSTF）"></a>最短时间寻址时间优先算法（SSTF）</h3><p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优）</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aad99dec2b8.png" alt="image-20230313192056436" style="zoom: 67%;" /><p>优点：性能较好，平均寻道时间短</p><p>缺点：<strong>可能产生“饥饿”现象</strong>.</p><h3 id="扫描算法（SCAN）"><a href="#扫描算法（SCAN）" class="headerlink" title="扫描算法（SCAN）"></a>扫描算法（SCAN）</h3><p>SSTF算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，<strong>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</strong>。这就是扫描算法（SCAN）的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aad9a217a1d.png" alt="image-20230313192407997" style="zoom:67%;" /><p>优点：性能较好，平均寻道时间较短，<strong>不会产生饥饿现象</strong></p><p>缺点：</p><ol><li>只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。</li><li><strong>SCAN算法对于各个位置磁道的响应频率不平均</strong>（如：假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了）</li></ol><h3 id="LOOK调度算法"><a href="#LOOK调度算法" class="headerlink" title="LOOK调度算法"></a>LOOK调度算法</h3><p>扫描算法（SCAN）中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。LOOK调度算法就是为了解决这个问题，<strong>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</strong>。（边移动边观察，因此叫LOOK）</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aad9a730ff8.png" alt="image-20230313192634335" style="zoom:67%;" /><h3 id="循环扫描算法（C-SCAN）"><a href="#循环扫描算法（C-SCAN）" class="headerlink" title="循环扫描算法（C-SCAN）"></a>循环扫描算法（C-SCAN）</h3><p>SCAN算法对于各个位置磁道的响应频率不平均，而C—SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，<strong>而返回时直接快速移动至起始端而不处理任何请求</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aad9abd3b36.png" alt="image-20230313192802437" style="zoom:67%;" /><p>优点：比起SCAN来，对于各个位置磁道的响应频率很平均。</p><p>缺点：只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。</p><h3 id="C-LOOK调度算法"><a href="#C-LOOK调度算法" class="headerlink" title="C-LOOK调度算法"></a>C-LOOK调度算法</h3><p>C—SCAN算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C—LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aad9b69626d.png" alt="image-20230313192948714" style="zoom:67%;" /><h2 id="减少延迟时间的方法"><a href="#减少延迟时间的方法" class="headerlink" title="减少延迟时间的方法"></a>减少延迟时间的方法</h2><p>结论：磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”。</p><h3 id="交替编号"><a href="#交替编号" class="headerlink" title="交替编号"></a>交替编号</h3><p>若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aad9bae1815.png" alt="image-20230313193222017" style="zoom:43%;" /><h4 id="磁盘地址结构的设计"><a href="#磁盘地址结构的设计" class="headerlink" title="磁盘地址结构的设计"></a>磁盘地址结构的设计</h4><p>【思考：为什么？】<br>磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）</p><p>答：<strong>读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间</strong>。</p><h3 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h3><p>具体做法：让相邻盘面的扇区编号“错位”</p><p>原理：<strong>读取完一个扇区后需要一段时间处理才可以继续读入下一个扇区</strong>。“错位命名法”可降低延迟时间</p><h2 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h2><h3 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h3><ol><li><strong>进行低级格式化（物理格式化）</strong>，<strong>将磁盘的各个磁道划分为扇区</strong>。一个扇区通常可分为头、数据区域（如512B大小）、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误）</li><li>将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的C盘、D盘、E盘）</li><li><strong>进行逻辑格式化</strong>，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表）</li></ol><h3 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h3><p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。</p><p><strong>初始化程序可以放在ROM（只读存储器）中。ROM中的数据在出厂时就写入了，并且以后不能再修改</strong>。</p><p>【初始化程序程序（自举程序）放在ROM中存在什么问题？】</p><p>万一需要更新自举程序，将会很不方便，因为ROM中的数据无法更改。如何解决呢？</p><p>ROM中只存放很小的“自举装入程序，<strong>完整的自举程序放在磁盘的启动块（即引导块／启动分区）上，启动块位于磁盘的固定位置</strong>。</p><blockquote><p>拥有启动分区的磁盘称为启动磁盘或系统磁盘（C：盘）</p></blockquote><h3 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h3><p><strong>坏了、无法正常使用的扇区就是“坏块”。这属于硬件故障，操作系统是无法修复的</strong>。应该将坏块标记出来，以免错误地使用到它。</p><p>对于简单的磁盘，<strong>可以在逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如：在FAT表上标明</strong>。（在这种方式中，坏块对操作系统不透明）</p><p>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。</p><p><strong>在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化</strong>。</p><p><strong>会保留一些“备用扇区”，用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明</strong>。</p><h2 id="固态硬盘-SSD"><a href="#固态硬盘-SSD" class="headerlink" title="固态硬盘 SSD"></a>固态硬盘 SSD</h2><h3 id="固态硬盘的结构"><a href="#固态硬盘的结构" class="headerlink" title="固态硬盘的结构"></a>固态硬盘的结构</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aad9c23dffd.png" alt="image-20230313195557737" style="zoom:50%;" /><p>闪存翻译层：<strong>负责翻译逻辑块号</strong>，找到对应页（Page）</p><p>存储介质：多个闪存芯片（Flash Chip）—每个芯片包含多个块（block）—每个块包含多个页（page）</p><h3 id="读写特性"><a href="#读写特性" class="headerlink" title="读写特性"></a>读写特性</h3><p>以页（page）为单位读／写—相当于磁盘的“扇区”</p><p>以块（block）为单位“擦除”，擦干净的块，其中的每页都可以写一次，读无限次</p><p><strong>支持随机访问</strong>，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址</p><p><strong>读快、写慢</strong>。要写的页如果有数据，则不能写入，需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页。</p><p>【与机械硬盘相比】</p><ol><li>SSD读写速度快，随机访问性能高，用电路控制访问位置；机械硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟</li><li>SSD 安静无噪音、耐摔抗震、能耗低、造价更贵</li><li><strong>SSD的一个“块”被擦除次数过多（重复写同一个块）可能会坏掉</strong>，而机械硬盘的扇区不会因为写的次数太多而坏掉</li></ol><h3 id="磨损均衡技术"><a href="#磨损均衡技术" class="headerlink" title="磨损均衡技术"></a>磨损均衡技术</h3><p>思想：将“擦除”平均分布在各个块上，以提升使用寿命。</p><ul><li><strong>动态磨损均衡：写入数据时，优先选择累计擦除次数少的新闪存块</strong>。</li><li><strong>静态磨损均衡：SSD监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务</strong>。</li></ul><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>结（忙…..</p>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【4.0】文件管理</title>
      <link href="/2023/03/11/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%904.0%E3%80%91%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/11/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%904.0%E3%80%91%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分说明了文件整个系统的原理和底层大概逻辑。</p><h1 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h1><h2 id="初识文件管理"><a href="#初识文件管理" class="headerlink" title="初识文件管理"></a>初识文件管理</h2><p>文件——就是一组有意义的信息／数据集合。</p><h3 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h3><p><strong>文件名</strong>：由创建文件的用户决定文件名，主要是为了方便用户找到文件，<strong>同一目录下不允许有重名文件</strong>。</p><p><strong>标识符</strong>：<strong>一个系统内的各文件标识符唯一</strong>，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</p><p><strong>类型</strong>：指明文件的类型</p><p><strong>位置</strong>：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</p><p>大小：指明文件大小</p><p>创建时间、上次修改时间，文件所有者信息</p><p>保护信息：对文件进行保护的访问控制信息</p><h3 id="文件数据的组织"><a href="#文件数据的组织" class="headerlink" title="文件数据的组织"></a>文件数据的组织</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad78c9b41e.png" alt="image-20230310181607787" style="zoom: 67%;" /><p><strong>无结构文件（如文本文件）——由一些二进制或字符流组成，又称“流式文件</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad794c25dc.png" alt="image-20230310181618832" style="zoom:50%;" /><p><strong>有结构文件（如数据库表）——由一组相似的记录组成，又称“记录式文件</strong>。</p><p>用户可以自己创建一层一层的目录，各层目录中存放相应的文件。系统中的各个文件就通过一层一层的目录合理有序的组织起来了。目录其实也是一种特殊的有结构文件（由记录组成）。</p><h3 id="文件的外存存放"><a href="#文件的外存存放" class="headerlink" title="文件的外存存放"></a>文件的外存存放</h3><p>类似于内存分为一个个“内存块”，外存会分为一个个“块／磁盘块／物理块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址、（如本例中，一块包含210个地址，即1KB）。同样类似的是，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转换为外存的物理地址（物理块号，块内地址）的形式。块内地址的位数取决于磁盘块的大小</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad79913a18.png" alt="image-20230310182211732" style="zoom:33%;" /><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><ul><li>文件共享：使多个用户可以共享使用一个文件</li><li>文件保护：如何保证不同的用户对文件有不同的操作权限</li></ul><h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><p>所谓的“逻辑结构”，就是指<strong>在用户看来，文件内部的数据应该是如何组织起来的</strong>。而“物理结构”指的是<strong>在操作系统看来，文件的数据是如何存放在外存中的</strong>。</p><h3 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h3><p>文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。如：Windows操作系统中的.txt文件。</p><h3 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h3><p>有结构文件：由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如：数据库表文件。一般来说，每条记录有一个数据项可作为关键字（作为识别不同记录的ID）</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad79e69fe1.png" alt="image-20230310182536246" style="zoom:50%;" /><p>一般来说，每条记录有一个数据项可作为关键字。根据各条记录的长度（占用的存储空间）是否相等，<strong>又可分为定长记录和可变长记录两种</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7a30f7f7.png" alt="image-20230310182756085" style="zoom:50%;" /><h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p>顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。<strong>各个记录在物理上可以顺序存储或链式存储</strong>。</p><ul><li>顺序存储一—逻辑上相邻的记录物理上也相邻（类似于顺序表）</li><li>链式存储——逻辑上相邻的记录物理上不一定相邻（类似于链表）</li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7a79ae52.png" alt="image-20230310182856634" style="zoom:50%;" /><img src="httpss://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20230310183008254.png" alt="image-20230310183008254" style="zoom:67%;" /><p>顺序文件的缺点是增加&#x2F;删除一个记录比较困难（如果是串结构则相对简单）。</p><h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p>建立一张索引表以加快文件检索速度。每条记录对应一个索引项。文件中的这些记录在物理上可以离散地存放。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7ac07daf.png" alt="image-20230310190226314" style="zoom:50%;" /><p><strong>索引表本身是定长记录的顺序文件。因此可以快速找到第i个记录对应的索引项</strong>。</p><p>可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。</p><p>每当要增加／删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此<strong>主要用于对信息处理的及时性要求比较高的场合</strong>。</p><p>另外，可以用不同的数据项建立多个索引表。如：学生信息表中，可用关键字“学号”建立一张索引表。也可用“姓名”建立一张索引表。这样就可以根据“姓名”快速地检索文件了。（Eg：SQL就支持根据某个数据项建立索引的功能）</p><p>索引文件的缺点：每个记录对应一个索引表项，因此索引表可能会很大。比如：文件的每个记录平均只占8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。</p><h4 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h4><p>索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：<strong>并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7b0075af.png" alt="image-20230310190439543" style="zoom:50%;" /><h4 id="多级索引顺序文件"><a href="#多级索引顺序文件" class="headerlink" title="多级索引顺序文件"></a>多级索引顺序文件</h4><p>为了进一步提高检索效率，可以为顺序文件建立多级索引表。例如，对于一个含106个记录的文件，可先为该文件建立一张低级索引表，每100个记录为一组，故低级索引表中共有10000个表项（即10000个定长记录），再把这10000个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有100个表项。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7b40c9f8.png" alt="image-20230310190630639" style="zoom:50%;" /><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7b7ebe9b.png" alt="image-20230311122913729" style="zoom:50%;" /><h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><p>目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件。</p><p><strong>目录文件中的一条记录就是一个“文件控制块（FCB）”</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7bbcff5c.png" alt="image-20230311123143090" style="zoom:67%;" /><p>FCB的有序集合称为“文件目录”，一个FCB就是一个文件目录项。FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读／可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。</p><p><strong>最重要，最基本的还是文件名、文件存放的物理地址</strong>。</p><p>【❓需要对目录进行哪些操作？❓】</p><ul><li><strong>搜索</strong>：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</li><li>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</li><li>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</li><li>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</li><li>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）</li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h4 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h4><p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7c06f0a4.png" alt="image-20230311123507480" style="zoom:50%;" /><p>单级目录实现了“按名存取”，<strong>但是不允许文件重名</strong>。</p><p>在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。</p><p><strong>单级目录结构不适用于多用户操作系统</strong>。</p><h4 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h4><p>早期的多用户操作系统，采用两级目录结构。分为<strong>主文件目录（MFD，Master File Directory）和用户文件目录（UFD，User Flie Directory）</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7c482da4.png" alt="image-20230311123622392" style="zoom:50%;" /><p><strong>允许不同用户的文件重名</strong>。文件名虽然相同，但是对应的其实是不同的文件。</p><p>两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制（检查此时登录的用户名是否匹配）。但是两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类。</p><h4 id="多级目录结构"><a href="#多级目录结构" class="headerlink" title="多级目录结构"></a>多级目录结构</h4><p>又称：树形目录结构。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7c8afc0c.png" alt="image-20230311123840686" style="zoom:67%;" /><p>用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用“／”隔开。<strong>从根目录出发的路径称为绝对路径</strong>。</p><p>例如：自拍．jpg的绝对路径是“／照片／2015—08／自拍．jpg”</p><p>系统根据绝对路径一层一层地找到下一级目录。刚开始从外存读入根目录的目录表；找到“照片”目录的存放位置后，从外存读入对应的目录表；再找到“2015—08”目录的存放位置，再从外存读入对应目录表；最后才找到文件“自拍．jpg”的存放位置。整个过程需要3次读磁盘I／O操作。</p><p>很多时候，用户会连续访问同一目录内的多个文件（比如：接连查看“2015—08”目录内的多个照片文件），显然，每次都从根目录开始查找，是很低效的。<strong>因此可以设置一个“当前目录”</strong>。</p><p>例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想要访问某个文件时，<strong>可以使用从当前目录出发的“相对路径”</strong>。</p><p>树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，<strong>树形结构不便于实现文件的共享</strong>。为此，提出了“无环图目录结构”。</p><h4 id="无环图目录结构"><a href="#无环图目录结构" class="headerlink" title="无环图目录结构"></a>无环图目录结构</h4><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7cd71eef.png" alt="image-20230311124217771" style="zoom:67%;" /><p><strong>可以用不同的文件名指向同一个文件</strong>，甚至可以指向同一个目录（共享同一目录下的所有内容）。</p><p>需要为每个共享结点设置一个<strong>共享计数器</strong>，用于记录此时有多少个地方在共享该结点。<strong>用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点</strong>。</p><p><strong>只有共享计数器减为0时，才删除结点</strong>。</p><p>注意：共享文件不同于复制文件。<strong>在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化</strong>。</p><h3 id="索引结点（FCB的改进）"><a href="#索引结点（FCB的改进）" class="headerlink" title="索引结点（FCB的改进）"></a>索引结点（FCB的改进）</h3><p>其实在查找各级目录的过程中只需要用到“文件名”这个信息，<strong>只有文件名匹配时，才需要读出文件的其他信息</strong>。因此可以考虑让目录表“瘦身”来提升效率。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7d1a5f60.png" alt="image-20230311124417068" style="zoom:50%;" /><p>若使用索引结点机制，文件名占14B，索引结点指针站2B，则每个盘块可存放64个目录项，那么按文件名检索目录平均只需要读入320／64＝5个磁盘块。显然，这将大大提升文件检索速度。</p><p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</p><p><strong>存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”</strong>。<br>相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等。</p><h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7d60c97b.png" alt="image-20230311135534529" style="zoom:50%;" /><p>类似于内存分页，磁盘中的存储单元也会被分为一个个“块／磁盘块／物理块”。很多操作系统中，<strong>磁盘块的大小与内存块、页面的大小相同</strong>。</p><p>在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件“块”。于是文件的逻辑地址也可以表示为<strong>（逻辑块号，块内地址）</strong>的形式。</p><p>用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射。</p><h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p><strong>连续分配方式要求每个文件在磁盘上占有一组连续的块</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7da8edf5.png" alt="image-20230311135919473" style="zoom:50%;" /><img src="httpss://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20230311140004107.png" alt="image-20230311140004107" style="zoom:50%;" /><p>用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（FCB）…</p><p>$物理块号 ＝ 起始块号 ＋ 逻辑块号$</p><p>可以直接算出逻辑块号对应的物理块号，因此<strong>连续分配支持顺序访问和直接访问（即随机访问）</strong>。</p><p>读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。</p><p>结论：<strong>连续分配的文件在顺序读／写时速度最快</strong>。</p><p>结论：<strong>物理上采用连续分配的文件不方便拓展</strong>。</p><p>结论：<strong>物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片；可以用紧凑来处理碎片，但是需要耗费很大的时间代价</strong>。</p><p>优点：</p><ul><li>支持顺序访问和直接访问（即随机访问）；</li><li>连续分配的文件在顺序访问时速度最快</li></ul><p>缺点：</p><ul><li>不方便文件拓展；</li><li>存储空间利用率低，会产生磁盘碎片；</li></ul><h3 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h3><p>链接分配采取<strong>离散分配</strong>的方式，可以为文件分配离散的磁盘块。分为<strong>隐式链接和显式链接</strong>两种。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7dfe2076.png" alt="image-20230311145937211" style="zoom:50%;" /><h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h4><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项（FCB）…</p><p>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置．．．．．．．以此类推。</p><p>因此，读入i号逻辑块，总共需要 $i＋1$ 次磁盘 I&#x2F;O。</p><p>结论：<strong>采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低</strong>。另外，<strong>指向下一个盘块的指针也需要耗费少量的存储空间</strong>。</p><p>若此时要拓展文件，则可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的FCB。</p><p>结论：采用隐式链接的链接分配方式，<strong>很方便文件拓展</strong>。另外，所有的空闲磁盘块都可以被利用，<strong>不会有碎片问题，外存利用率高</strong>。</p><h4 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h4><p><strong>把用于链接文件各物理块的指针显式地存放在一张表中。即文件分配表</strong>（FAT，File Allocation Table）。</p><p>注意：<strong>一个磁盘仅设置一张FAT</strong>。开机时，<strong>将FAT读入内存，并常驻内存</strong>。</p><p><strong>FAT的各个表项在物理上连续存储，且每一个表项长度相同</strong>，因此“物理块号”字段可以是隐含的。</p><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项(FCB)…</p><p>从目录项中找到起始块号，若 $i＞0$，则查询内存中的文件分配表FAT，往后找到i号逻辑块对应的物理块号。<strong>逻辑块号转换成物理块号的过程不需要读磁盘操作</strong>。</p><p>结论：采用<strong>链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问</strong>（想访问i号逻辑块时，并不需要依次访问之前的 0 ～ $i - 1$ 号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</p><p>显然，<strong>显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展</strong>。</p><p>缺点：文件分配表的需要占用一定的存储空间。</p><h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><p><strong>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块</strong>（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系）。<strong>索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7e57f5f2.png" alt="image-20230311162019066" style="zoom:50%;" /><p>可以用固定的长度表示物理块号（如：假设磁盘总容量为1TB＝240B，磁盘块大小为1KB，则共有230个磁盘块，则可用4B表示磁盘块号），因此，索引表中的“逻辑块号”可以是隐含的。</p><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项（FCB）…</p><p>从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可只i号逻辑块在外存中的存放位置。</p><p>可见，<strong>索引分配方式可以支持随机访问</strong>。<strong>文件拓展也很容易实现</strong>（只需要给文件分配一个空闲块，并增加一个索引表项即可）但是<strong>索引表需要占用一定的存储空间</strong>。</p><p>【❓若每个磁盘块1KB，一个索引表项4B，则一个磁盘块只能存放256个索引项。如果一个文件的大小超过了256块，那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题？❓】</p><ul><li><strong>链接方案</strong>：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。缺点：<strong>若文件很大</strong>，索引表很长，就需要将很多个索引块链接起来。<strong>想要找到i号索引块，必须先依次读入0～i—1号索引块，这就导致磁盘I／O次数过多，查找效率低下</strong>。</li><li><strong>多层索引</strong>：建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K＋1次读磁盘操作。缺点：<strong>即使是小文件，访问一个数据块依然需要K＋1次读磁盘</strong>。</li><li><strong>混合索引</strong>：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）。优点：<strong>对于小文件来说，访问一个数据块所需的读磁盘次数更少</strong>。</li></ul><h4 id="链接方案"><a href="#链接方案" class="headerlink" title="链接方案"></a>链接方案</h4><p>如果索引表太大，一个索引块装不下，那么可以<strong>将多个索引块链接起来存放</strong>。</p><h4 id="多层索引"><a href="#多层索引" class="headerlink" title="多层索引"></a>多层索引</h4><p>多层索引：建立<strong>多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块</strong>。还可根据文件大小的要求再建立第三层、第四层索引块。</p><p>若某文件<strong>采用两层索引</strong>，则该文件的最大长度可以到 $256 \times 256 \times 1KB&#x3D;65,536 KB&#x3D;64MB$.</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7eab5c65.png" alt="image-20230311162714470" style="zoom:50%;" /><p><strong>采用 $K$ 层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要 $K＋1$ 次读磁盘操作</strong>。</p><h4 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a>混合索引</h4><p>混合索引：<strong>多种索引分配方式的结合</strong>。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7eec4a3e.png" alt="image-20230311163026840" style="zoom:50%;" /><p><strong>对于小文件，只需较少的读磁盘次数就可以访问目标数据块</strong>。（一般计算机中小文件更多）</p><h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7f2e34bc.png" alt="image-20230311163727585" style="zoom:50%;" /><p>安装Windows操作系统的时候，一个必经步骤是——为磁盘分区（C：盘、D：盘、E：盘等）</p><p>存储空间的划分：<strong>将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7f7491d9.png" alt="image-20230311163901602" style="zoom:50%;" /><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad7fc1bb1f.png" alt="image-20230311164032185" style="zoom:45%;" /><p>适用于“连续分配方式”。</p><p>如何分配磁盘块：与内存管理中的动态分区分配很类似，<strong>为一个文件分配连续的存储空间</strong>。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。</p><p>如何回收磁盘块：与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况</p><ol><li>回收区的前后都没有相邻空闲区；</li><li>回收区的前后都是空闲区；</li><li>回收区前面是空闲区；</li><li>回收区后面是空闲区。</li></ol><p>总之，<strong>回收时需要注意表项的合并问题</strong>。</p><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad800632ff.png" alt="image-20230311164411425" style="zoom:50%;" /><h4 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h4><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad80432941.png" alt="image-20230311164450220" style="zoom:40%;" /><p><strong>操作系统保存着链头、链尾指针</strong>。</p><p>如何分配：若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。</p><p>如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</p><p><strong>适用于离散分配的物理结构</strong>。为文件分配多个盘块时可能要重复多次操作</p><h4 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h4><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad80846134.png" alt="image-20230311164532144" style="zoom:40%;" /><p><strong>操作系统保存着链头、链尾指针</strong>。</p><p>如何分配：若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</p><p>如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</p><p><strong>离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高</strong>。</p><h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad80c87f14.png" alt="image-20230311170354209" style="zoom:30%;" /><p>位示图：每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配。位示图一般用连续的“字”来表示，如本例中一个字的字长是16位，字中的每一位对应一个盘块。因此<strong>可以用（字号，位号）对应一个盘块号</strong>。当然有的题目中也描述为（行号，列号）</p><p>如本例中盘块号、字号、位号从0开始，若n表示字长，则：</p><ul><li><p>（字号，位号）＝（i，j）的二进制位对应的盘块号$b＝ni＋j$</p></li><li><p>b号盘块对应的字号$i＝b／n$，位号$j＝b％n$</p></li></ul><p>如何分配：若文件需要K个块，</p><ol><li>顺序扫描位示图，找到K个相邻或不相邻的“0”；</li><li>根据字号、位号算出对应的盘块号，将相应盘块分配给文件；</li><li>将相应位设置为“1”。</li></ol><p>如何回收：</p><ol><li>根据回收的盘块号计算出对应的字号、位号；</li><li>将相应二进制位设为“0”</li></ol><p><strong>连续分配、离散分配都适用</strong>。</p><h3 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h3><p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了成组链接法对磁盘空闲块进行管理。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad810e7c32.png" alt="image-20230311171414890" style="zoom:50%;" /><p><strong>文件卷的目录区中专门用一个磁盘块作为“超级块”</strong>，<strong>当系统启动时需要将超级块读入内存</strong>。并且要保证内存与外存中的“超级块”数据一致。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad814aa5fe.png" alt="image-20230311171545364" style="zoom:50%;" /><p>如何分配？<br>Eg：需要100个空闲块</p><ol><li>检查第一个分组的块数是否足够。100＝100，是足够的。</li><li>分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中。</li></ol><p>如何回收？<br>Eg：假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块。</p><p>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。</p><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad81914c59.png" alt="image-20230311173558987" style="zoom:50%;" /><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>进行Create系统调用时，需要提供的几个主要参数：</p><ol><li>所需的外存空间大小（如：一个盘块，即1KB）</li><li>文件存放路径（“D：／Demo”）</li><li>文件名（这个地方默认为“新建文本文档.txt”）</li></ol><p>操作系统在处理Create系统调用时，主要做了两件事：</p><ol><li><strong>在外存中找到文件所需的空间</strong>（结合空闲链表法、位示图、成组链接法等管理策略，找到空闲空间）</li><li>根据文件存放路径的信息找到该目录对应的目录文件（此处就是D：／Demo目录），在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。</li></ol><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>进行 Delete 系统调用时，需要提供的几个主要参数：</p><ol><li>文件存放路径（“D：&#x2F;Demo” ）</li><li>文件名（“test.txt”）</li></ol><p>操作系统在处理Delete系统调用时，主要做了几件事：</p><ol><li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</li><li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。（回收磁盘块时，根据空闲表法、空闲链表法、立图法等管理策略的不同，需要做不同的处理）</li></ol><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件”，需要提供的几个主要参数：</p><ol><li>文件存放路径（“D：／Demo”）</li><li>文件名（“test．txt”）</li><li>要对文件的操作类型（如：r只读；rw读写等）</li></ol><p>操作系统在处理open系统调用时，主要做了几件事：</p><ol><li>根据文件存放路径找到相应的目录文件，<strong>从目录中找到文件名对应的的目录项</strong>，并检查该用户是否有指定的操作权限。</li><li><strong>将目录项复制到内存中的“打开文件表”中</strong>。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。</li></ol><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad81e0f13b.png" alt="image-20230311174003578" style="zoom:45%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad8226b0d7.png" alt="image-20230311174128425" style="zoom:50%;" /><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>进程使用完文件后，要“关闭文件”<br>操作系统在处理Close系统调用时，主要做了几件事：</p><ol><li>将进程的打开文件表相应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器 count减1，若count&#x3D;0， 则删除对应表项。</li></ol><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad828713b6.png" alt="image-20230311174911402" style="zoom:50%;" /><p>进程使用read系统调用完成写操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要读入多少数据（如：读入1KB）、指明读入的数据要放在内存中的什么位置。</p><p>操作系统在处理read系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad82ce411c.png" alt="image-20230311175255102" style="zoom:50%;" /><p>进程使用write系统调用完成写操作，需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要写出多少数据（如：写出1KB）、写回外存的数据放在内存中的什么位置。</p><p>操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad831433e4.png" alt="image-20230311175404085" style="zoom:50%;" /><blockquote><p>注意：多个用户共享同一个文件，意味着系统中只有“一份”文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。</p></blockquote><h3 id="基于索引结点的共享方式（硬链接）"><a href="#基于索引结点的共享方式（硬链接）" class="headerlink" title="基于索引结点的共享方式（硬链接）"></a>基于索引结点的共享方式（硬链接）</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad835b2d34.png" alt="image-20230311182444677" style="zoom:50%;" /><p>索引结点中设置一个链接计数变量count，用于表示链接到本索引结点上的用户目录项数。</p><p>若count＝2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1。</p><p>若count＞0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。count＝0 时系统负责删除文件。</p><h3 id="基于符号链的共享方式（软链接）"><a href="#基于符号链的共享方式（软链接）" class="headerlink" title="基于符号链的共享方式（软链接）"></a>基于符号链的共享方式（软链接）</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad839c0dbd.png" alt="image-20230311182545203" style="zoom:50%;" /><p>当User3访问“ccc”时，操作系统判断文件“ccc”属于Link类型文件，于是会根据其中记录的路径层层查找目录，最终找到User1的目录表中的“aaa”表项，于是就找到了文件1的索引结点。</p><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad83d9a706.png" alt="image-20230311183615902" style="zoom:50%;" /><h3 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h3><p>为文件设置一个“口令”（如：abc112233），用户请求访问该文件时必须提供“口令”。</p><p>口令一般存放在文件对应的FCB或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件</p><p>优点：<strong>保存口令的空间开销不多，验证口令的时间开销也很小</strong>。</p><p>缺点：<strong>正确的“口令”存放在系统内部，不够安全</strong>。</p><h3 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h3><p><strong>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad841c9e0b.png" alt="image-20230311184217461" style="zoom:50%;" /><p>优点：<strong>保密性强，不需要在系统中存储“密码”</strong>。</p><p>缺点：<strong>编码／译码，或者说加密／解密要花费一定时间</strong>。</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p><strong>在每个文件的FCB（或索引结点）中增加一个访问控制列表（Access—Control List，ACL），该表中记录了各个用户可以对该文件执行哪些操作</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad8468acdf.png" alt="image-20230311184359943" style="zoom:50%;" /><p>有的计算机可能会有很多个用户，因此访问控制列表可能会很大，可以用精简的访问列表解决这个问题。</p><p>精简的访问列表：以“组”为单位，标记各“组”用户可以对文件执行哪些操作。如：分为系统管理员、文件主、文件主的伙伴、其他用户几个分组。</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad84a966f2.png" alt="image-20230311185648017" style="zoom:80%;" /><p>假设某用户请求删除文件“D：／工作目录／学生信息．xlsx”的最后100条记录。</p><ol><li>用户需要通过操作系统提供的接口发出上述请求——<strong>用户接口</strong></li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项–<strong>文件目录系统</strong></li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——<strong>存取控制模块（存取控制验证层）</strong></li><li>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址——<strong>逻辑文件系统与文件信息缓冲区</strong></li><li>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址——物理文件系统6．要删除这条记录，必定要对磁盘设备发出请求——<strong>设备管理程序模块</strong></li><li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——<strong>辅助分配模块</strong></li></ol><h2 id="文件系统的全局结构"><a href="#文件系统的全局结构" class="headerlink" title="文件系统的全局结构"></a>文件系统的全局结构</h2><h3 id="原始磁盘"><a href="#原始磁盘" class="headerlink" title="原始磁盘"></a>原始磁盘</h3><h4 id="物理格式化"><a href="#物理格式化" class="headerlink" title="物理格式化"></a>物理格式化</h4><p>物理格式化，即低级格式化——划分扇区，检测坏扇区，并用备用扇区替换坏扇区。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad84fa5bb2.png" alt="image-20230311191904822" style="zoom:67%;" /><h4 id="逻辑格式化"><a href="#逻辑格式化" class="headerlink" title="逻辑格式化"></a>逻辑格式化</h4><p>逻辑格式化后，磁盘分区（分卷Volume），完成各分区的文件系统初始化注：逻辑格式化后，灰色部分就有实际数据了，白色部分还没有数据。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad853de97a.png" alt="image-20230311191928492" style="zoom: 80%;" /><h3 id="文件系统在内存中的结构"><a href="#文件系统在内存中的结构" class="headerlink" title="文件系统在内存中的结构"></a>文件系统在内存中的结构</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad8578933c.png" alt="image-20230311192424458" style="zoom:50%;" /><p>注：<strong>近期访问过的目录文件会缓存在内存中，不用每次都从磁盘读入，这样可以加快目录检索速度</strong>。</p><h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><h3 id="普通文件系统"><a href="#普通文件系统" class="headerlink" title="普通文件系统"></a>普通文件系统</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad85b7421c.png" alt="image-20230311192815954" style="zoom:50%;" /><h3 id="虚拟文件系统-1"><a href="#虚拟文件系统-1" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad85fa547d.png" alt="image-20230311193023469" style="zoom:50%;" /><p>虚拟文件系统的特点：</p><ol><li><p>向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异。</p></li><li><p>VFS要求下层的文件系统必须实现某些规定的函数功能，如：open／read／write。一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求。</p></li><li><p>每打开一个文件，VFS就在主存中新建一个<code>vnode</code>，用统一的数据结构表示文件，无论该文件存储在哪个文件系统。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad865c4c18.png" alt="image-20230311194128387" style="zoom:50%;" /></li></ol><blockquote><p>vnode只存在于主存中，而inode既会被调入主存，也会在外存中存储</p></blockquote><h3 id="文件系统的挂载"><a href="#文件系统的挂载" class="headerlink" title="文件系统的挂载"></a>文件系统的挂载</h3><p><strong>文件系统挂载（mounting），即文件系统安装／装载</strong>——如何将一个文件系统挂载到操作系统中？</p><p>文件系统挂载要做的事：</p><ol><li><strong>在VFS中注册新挂载的文件系统。内存中的挂载表（mount table）包含 每个文件系统的相关信息，包括文件系统类型、容量大小等</strong>。</li><li>新挂载的文件系统，要向 VFS 提供一个函数地址列表</li><li><strong>将新文件系统加到挂载点（mountpoint），也就是将新文件系统挂载在某个父目录下</strong>。</li></ol><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>快马加鞭！！！</p>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【3.0】内存管理</title>
      <link href="/2023/03/10/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%903.0%E3%80%91%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/10/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%903.0%E3%80%91%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>内存管理部分内容，解释说明了内存如何对进程进行管理调度，来使得软件可以正常的运行在操作系统之中。</p><h1 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h1><h2 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h2><p>内存可存放数据。<strong>程序执行前需要先放到内存中才能被CPU处理</strong>——缓和CPU与硬盘之间的速度矛盾。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5ba79f73.png" alt="image-20230308230114181" style="zoom:67%;" /><h3 id="从写程序到程序运行"><a href="#从写程序到程序运行" class="headerlink" title="从写程序到程序运行"></a>从写程序到程序运行</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5beadd92.png" alt="image-20230308233228838" style="zoom:67%;" /><p>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言）</p><p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块</p><p>装入（装载）：由装入程序将装入模块装入内存运行</p><h3 id="装入的三种方式"><a href="#装入的三种方式" class="headerlink" title="装入的三种方式"></a>装入的三种方式</h3><ul><li><p><strong>绝对装入</strong>：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。</p><blockquote><p>绝对装入只适用于单道程序环境</p></blockquote></li><li><p><strong>可重定位装入（静态重定位）</strong>：编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。<strong>装入时对地址进行“重定位”</strong>，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。</p><blockquote><p>静态重定位的特点是在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。</p><p><strong>作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间</strong>。</p></blockquote></li><li><p><strong>动态重定位</strong>：又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。</p><blockquote><p>采用动态重定位时允许程序在内存中发生移动。</p><p>并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p></blockquote></li></ul><h3 id="链接的三种方式"><a href="#链接的三种方式" class="headerlink" title="链接的三种方式"></a>链接的三种方式</h3><ul><li><strong>静态链接</strong>：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。</li><li><strong>装入时动态链接</strong>：将各目标模块装入内存时，边装入边链接的链接方式。</li><li><strong>运行时动态链接</strong>：在程序执行中需要该目标模块时，才对它进行链接。其优点是于修改和更新，便于实现对<br>目标模块的共享。</li></ul><h2 id="内存管理的概念-1"><a href="#内存管理的概念-1" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h2><ol><li><p>操作系统负责<strong>内存空间的分配与回收。</strong></p></li><li><p>操作系统需要提供<strong>某种技术从逻辑上对内存空间进行扩充。</strong></p></li><li><p>操作系统需要<strong>提供地址转换功能，负责程序的逻辑地址与物理地址的转换</strong>。</p></li><li><p>操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰。</p><p>内存保护可采取两种方法：</p><ul><li>在CPU中<strong>设置一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</li><li>采用<strong>重定位寄存器</strong>（又称基址寄存器）和<strong>界地址寄存器</strong>（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。<strong>界地址寄存器中存放的是进程的最大逻辑地址</strong>。</li></ul></li></ol><h3 id="覆盖和交换（内存扩充）"><a href="#覆盖和交换（内存扩充）" class="headerlink" title="覆盖和交换（内存扩充）"></a>覆盖和交换（内存扩充）</h3><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p><strong>覆盖技术，用来解决“程序大小超过物理内存总和”的问题</strong>。</p><p>覆盖技术的思想：<strong>将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存</strong>。</p><ul><li>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</li><li>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5c55995b.png" alt="image-20230308235429389" style="zoom: 67%;" /><p><strong>必须由程序员声明覆盖结构</strong>，操作系统完成自动覆盖。缺点：<strong>对用户不透明，增加了用户编程负担</strong>。</p><blockquote><p>覆盖技术只用于早期的操作系统中，现在已成为历史。</p></blockquote><h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p>交换（对换）技术的设计思想：内存空间紧张时，系统<strong>将内存中某些进程暂时换出外存</strong>，把外存中某些<strong>已具备运行条件的进程换入内存</strong>（进程在内存与磁盘间动态调度）</p><p>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</p><p>暂时换出外存等待的进程状态为挂起状态（挂起态，suspend），挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。</p><p>【应该在外存（磁盘）的什么位置保存被换出的进程？】</p><p>具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区和对换区</strong>两部分。文件区主要用于存放文件，<strong>主要追求存储空间的利用率</strong>，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此<strong>对换区空间的管理主要追求换入换出速度</strong>，因此<strong>通常对换区采用连续分配方式</strong>（学过文件管理章节后即可理解）。总之，<strong>对换区的<code>I／0</code>速度比文件区的更快</strong>。</p><p>【什么时候应该交换？】</p><p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</p><p>【应该换出哪些进程？】</p><p>可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…</p><blockquote><p><strong>注意：PCB会常驻内存，不会被换出外存</strong></p></blockquote><h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><p>连续分配：指为用户进程分配的必须是一个连续的内存空间。</p><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><p>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5cab2a4e.png" alt="image-20230309133614007" style="zoom:50%;" /><p><strong>内存中只能有一道用户程序</strong>，用户程序独占整个用户区空间。</p><p>优点：<strong>实现简单；无外部碎片</strong>；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的PC操作系统MS-DOS）。</p><p>缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。</p><blockquote><p>分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”</p></blockquote><h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是<strong>将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业</strong>，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5cf46d85.png" alt="image-20230309133843240" style="zoom:50%;" /><ul><li>分区大小相等：缺乏灵活性，但是<strong>很适合用于用一台计算机控制多个相同对象</strong>的场合（比如：钢铁厂有$n$个相同的炼钢炉，就可把内存分为$n$个大小相等的区域存放$n$个炼钢炉控制程序）</li><li>分区大小不等：<strong>增加了灵活性</strong>，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）</li></ul><p><strong>操作系统需要建立一个数据结构—一分区说明表，来实现各个分区的分配与回收</strong>。每个表项对应一个分区，通常按分区大小排列。<strong>每个表项包括对应分区的大小、起始地址、状态（是否已分配）</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5d3a9071.png" alt="image-20230309134016548" style="zoom:67%;" /><p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。</p><p>优点：实现简单，无外部碎片。</p><p>缺点：</p><ol><li>当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；</li><li><strong>会产生内部碎片，内存利用率低</strong>。</li></ol><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>动态分区分配又称为可变分区分配。<strong>这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区</strong>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</p><p>【❓系统要用什么样的数据结构记录内存的使用情况❓】</p><p>两种常用的数据结构：</p><ul><li><p><strong>空闲分区表</strong>：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5d98546d.png" alt="image-20230309134405299" style="zoom:50%;" /></li><li><p><strong>空闲分区链</strong>：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5dd852ec.png" alt="image-20230309134459855" style="zoom:50%;" /></li></ul><p>【❓当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配❓】</p><p>把一个新作业装入内存时，须按照一定的<strong>动态分区分配算法</strong>，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。</p><p><strong>动态分区分配没有内部碎片，但是有外部碎片</strong>。</p><ul><li><p>内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。</p></li><li><p>外部碎片，是指内存中的某些空闲分区由于太小而难以利用。</p></li></ul><p>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。<strong>可以通过紧凑（拼凑，Compaction）技术来解决外部碎片</strong>。</p><h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><p>动态分区分配算法：在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5e1e3ca3.png" alt="image-20230309140724522" style="zoom:80%;" /><h4 id="首次适应算法（First-Fit）"><a href="#首次适应算法（First-Fit）" class="headerlink" title="首次适应算法（First Fit）"></a>首次适应算法（First Fit）</h4><p>算法思想：<strong>每次都从低地址开始查找，找到第一个能满足大小的空闲分区</strong>。</p><p>如何实现：<strong>空闲分区以地址递增的次序排列</strong>。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><h4 id="最佳适应算法（Best-Fit）"><a href="#最佳适应算法（Best-Fit）" class="headerlink" title="最佳适应算法（Best Fit）"></a>最佳适应算法（Best Fit）</h4><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，<strong>优先使用更小的空闲区</strong>。</p><p>如何实现：<strong>空闲分区按容量递增次序链接</strong>。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p>缺点：<strong>每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块</strong>。因此这种方法会产生很多的外部碎片。</p><h4 id="最坏适应算法（Worst-Fit）"><a href="#最坏适应算法（Worst-Fit）" class="headerlink" title="最坏适应算法（Worst Fit）"></a>最坏适应算法（Worst Fit）</h4><p>又称 最大适应算法（Largest Fit）。</p><p>算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，<strong>可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用</strong>。</p><p>如何实现：<strong>空闲分区按容量递减次序链接</strong>。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p>缺点：<strong>每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完</strong>。如果之后有“大进程”到达，就没有内存分区可用了。</p><h4 id="邻近适应算法（Next-Fit）"><a href="#邻近适应算法（Next-Fit）" class="headerlink" title="邻近适应算法（Next Fit）"></a>邻近适应算法（Next Fit）</h4><p>算法思想：<strong>首次适应算法每次都从链头开始查找的</strong>。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。<strong>如果每次都从上次查找结束的位置开始检索，就能解决上述问题</strong>。</p><p>如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。<strong>每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</strong>。</p><h2 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5e7635ef.png" alt="image-20230309140917085" style="zoom:67%;" /><p>非连续分配：为用户进程分配的可以是一些分散的内存空间。</p><h3 id="分页存储"><a href="#分页存储" class="headerlink" title="分页存储"></a>分页存储</h3><p>将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“<strong>页框</strong>”（页框＝页帧＝内存块＝物理块＝物理页面）。每个页框有一个编号，即“<strong>页框号</strong>”（页框号＝页帧号＝内存块号＝物理块号＝物理页号），<strong>页框号从0开始</strong>。</p><p>将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面”。<strong>每个页面也有一个编号，即“页号”</strong>，页号也是从0开始。</p><p>操作系统<strong>以页框为单位为各个进程分配内存空间</strong>。进程的每个页面分别放入一个页框中。也就是说，<strong>进程的页面与内存的页框有一一对应的关系</strong>。</p><p>各个页面不必连续存放，可以放到不相邻的各个页框中。</p><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张<strong>页表</strong>。</p><blockquote><p>页表通常存在PCB（进程控制块）中</p></blockquote><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5eb6b9e2.png" alt="image-20230309141239068" style="zoom:50%;" /><ul><li>一个进程对应一张页表</li><li>进程的每个页面对应一个页表项</li><li><strong>每个页表项由“页号”和“块号”组成</strong></li><li>页表记录进程页面和实际存放的内存块之间的<strong>映射关系</strong></li></ul><blockquote><p>注意：页表记录的只是内存块号，而不是内存块的起始地址！<br>$J号内存块的起始地址＝J\times 内存块大小$</p></blockquote><p>【❓如何实现地址的转换❓】</p><p>特点：<strong>虽然进程的各个页面是离散存放的，但是页面内部是连续存放的</strong></p><p>如果要访问逻辑地址A，则</p><ol><li><p>确定逻辑地址A对应的“页号”P</p></li><li><p>找到P号页面在内存中的起始地址（需要查页表）</p></li><li><p>确定逻辑地址A的“页内偏移量”W</p><p>$逻辑地址A对应的物理地址＝P号页面在内存中的起始地址＋页内偏移量W$</p></li></ol><blockquote><p>结论：如果每个页面大小为 $2^K$ B，用二进制数表示逻辑地址，则<strong>末尾 $K$ 位即为页内偏移量，其余部分就是页号</strong>。</p></blockquote><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5f0288a9.png" alt="image-20230309164643756" style="zoom:80%;" /><h3 id="基本地址换化机构"><a href="#基本地址换化机构" class="headerlink" title="基本地址换化机构"></a>基本地址换化机构</h3><p>记忆基本地址变换机构（<strong>用于实现逻辑地址到物理地址转换的一组硬件机构</strong>）</p><p>通常会在系统中设置一个<strong>页表寄存器（PTR）</strong>，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，<strong>页式管理中地址是一维的</strong>。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p><blockquote><p>结论：理论上，页表项长度为3B即可表示内存块号的范围，但是，为了方便页表的查询，常常会让一个页表项占更多的字节，使得每个页面恰好可以装得下整数个页表项。</p></blockquote><h3 id="具有块表的地址变换机构"><a href="#具有块表的地址变换机构" class="headerlink" title="具有块表的地址变换机构"></a>具有块表的地址变换机构</h3><p><strong>快表，又称联想寄存器</strong>（TLB，translation lookaside buffer），是一种访问速度比内存快很多的 <strong>高速缓存（TLB不是内存！）</strong>，用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5f46d370.png" alt="image-20230309170537091" style="zoom:50%;" /><ol><li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，<strong>若快表命中，则访问某个逻辑地址仅需一次访存即可</strong>。</li><li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，<strong>若快表未命中，则访问某个逻辑地址需要两次访存</strong>（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但<strong>若快表已满，则必须按照一定的算法对旧的页表项进行替换</strong>）</li></ol><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5f830077.png" alt="image-20230309171929414" style="zoom:80%;" /><blockquote><p>TLB和普通Cache的区别——<strong>TLB中只有页表项的副本</strong>，而<strong>普通Cache中可能会有其他各种数据的副本</strong></p></blockquote><h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><p>【单极页表存在的问题】</p><ul><li><p>问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</p><p>可将长长的页表进行分组，使每个内存块刚好可以放入一个分组（比如上个例子中，页面大小4KB，每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再讲各组离散地放到各个内存块中）<br>另外，要为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶层页表</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad5fc65c37.png" alt="image-20230309194525097" style="zoom: 67%;" /></li><li><p>问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p><blockquote><p>可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</p></blockquote><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad600f33fa.png" alt="image-20230309194748694" style="zoom:67%;" /></li></ul><p>【注意】</p><ol><li>若采用多级页表机制，则<strong>各级页表的大小不能超过一个页面</strong>。</li><li>两级页表的访存次数分析（假设没有快表机构）<ul><li>第一次访存：访问内存中的页目录表</li><li>第二次访存：访问内存中的二级页表</li><li>第三次访存：访问目标内存单元</li></ul></li></ol><h2 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h2><p>与“分页”最大的区别就是——离散分配时所分配地址空间的基本单位不同。</p><p>进程的地址空间：<strong>按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名</strong>（在低级语言中，程序员使用段名来编程），每段从0开始编址。</p><p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad605a5f8d.png" alt="image-20230309225941778" style="zoom:67%;" /><p>分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成。如：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad60a9cfca.png" alt="image-20230309231150730" style="zoom:67%;" /><p><strong>段号的位数决定了每个进程最多可以分几个段，段内地址位数决定了每个段的最大长度是多少</strong>。</p><p>程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad60e7deec.png" alt="image-20230310132519657" style="zoom:67%;" /><ol><li>每个段对应一个段表项，其中记录了该段在内存中的<strong>起始位置（又称“基址”）和段的长度</strong>。</li><li>各个段表项的长度是相同的。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号16位，段内地址16位），因此用16位即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内存地址空间）。因此，可以让每个段表项占16＋32＝48位，即6B。由于段表项长度相同，<strong>因此段号可以是隐含的，不占存储空间</strong>。若段表存放的起始地址为M，则K号段对应的段表项存放的地址为 $M＋\times 6$</li></ol><h3 id="分段分页管理对比"><a href="#分段分页管理对比" class="headerlink" title="分段分页管理对比"></a>分段分页管理对比</h3><p><strong>页是信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</p><p><strong>段是信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</p><p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p><p><strong>分页的用户进程地址空间是一维的</strong>，程序员只需给出一个记忆符即可表示一个地址。<br><strong>分段的用户进程地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</p><p><strong>分段比分页更容易实现信息的共享和保护</strong>。</p><blockquote><p>不能被修改的代码称为<strong>纯代码或可重入代码</strong>（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）</p></blockquote><p>【❓访问一个逻辑地址需要几次访存？❓】</p><p>分页（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共两次访存</p><p>分段：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存</p><p>与分页系统类似，<strong>分段系统中也可以引入快表机构</strong>，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。</p><h2 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad6137e52f.png" alt="image-20230310145510422" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad61780053.png" alt="image-20230310152433641" style="zoom:80%;" /><p>段页式系统的逻辑地址结构由段号、页号、页内地址（页内偏移量）组成。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad61bf0614.png" alt="image-20230310160011582" style="zoom:80%;" /><ul><li><strong>段号的位数决定了每个进程最多可以分几个段</strong></li><li><strong>页号位数决定了每个段最大有多少页</strong></li><li><strong>页内偏移量决定了页面大小、内存块大小是多少</strong></li></ul><blockquote><p><strong>“分段”对用户是可见的</strong>，程序员编程时需要显式地给出段号、段内地址。而将<strong>各段“分页”对用户是不可见的</strong>。系统会根据段内地址自动划分页号和页内偏移量。因此<strong>段页式管理的地址结构是二维的</strong>。</p></blockquote><h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><h2 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad61fd7b30.png" alt="image-20230310160558185" style="zoom: 50%;" /><p>传统的存储管理方式存在如下问题：</p><p><strong>一次性：作业必须一次性全部装入内存后才能开始运行</strong>。这会造成两个问题：</p><ol><li>作业很大时，不能全部装入内存，<strong>导致大作业无法运行</strong>；</li><li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，<strong>导致多道程序并发度下降</strong>。</li></ol><p><strong>驻留性</strong>：一旦作业被装入内存，<strong>就会一直驻留在内存中，直至作业运行结束</strong>。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</p><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>时间局部性：<strong>如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行</strong>；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</p><p>空间局部性：<strong>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问</strong>。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p><p><strong>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存</strong>，就可以让程序开始执行。                                                 </p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</p><p>若内存空间不够，由操作系统负责将内存中暂时用不 到的信息换出到外存。</p><p><strong>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存</strong>。</p><p>虚拟内存有一下三个主要特征：</p><ul><li><strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li><li><strong>对换性</strong>：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li><strong>虚拟性</strong>：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li></ul><h3 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h3><p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在<strong>离散分配</strong>的内存管理方式基础上。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad62532539.png" alt="image-20230310161047145" style="zoom:50%;" /><h2 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h2><ul><li><p><strong>操作系统要提供请求调页功能，将缺失页面从外存调入内存</strong></p></li><li><p><strong>操作系统要提供页面置换的功能，将暂时用不到的页面换出外存</strong></p></li></ul><h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置。</p><p>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad62999a2f.png" alt="image-20230310161601914" style="zoom:67%;" /><h3 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h3><p>在请求分页系统中，每当<strong>要访问的页面不在内存时，便产生一个缺页中断</strong>，然后由操作系统的缺页中断处理程序处理中断。<br>此时<strong>缺页的进程阻塞，放入阻塞队列</strong>，调页完成后再将其唤醒，放回就绪队列。</p><ul><li><p>如果内存中<strong>有空闲块，则为进程分配一个空闲块</strong>，将所缺页面装入该块，并修改页表中相应的页表项。</p></li><li><p>如果内存中<strong>没有空闲块，则由页面置换算法选择一个页面淘汰</strong>，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</p></li></ul><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于<strong>内中断</strong>。</p><p>一条指令在执行期间，可能产生多次缺页中断。（如：<code>copy A to B</code>，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断）</p><h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><ol><li>请求调页（查到页表项时进行判断）</li><li>页面置换（需要调入页面，但没有空闲内存块时进行）</li><li>需要修改请求页表中新增的表项</li></ol><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad632bd062.png" alt="image-20230310162456960" style="zoom:50%;" /><h3 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h3><p>最佳置换算法（OPT，Optimal）：<strong>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。</p><blockquote><p>注意：缺页时未必发生页面置换。若还有可用的空闲内存块，就不用进行页面置换。</p></blockquote><p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。</p><h3 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h3><p>先进先出置换算法（FIFO）：<strong>每次选择淘汰的页面是最早进入内存的页面</strong>。<br>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p><p><strong>Belady异常——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象</strong>。</p><p>只有FIFO算法会产生Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差。</p><h3 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h3><p>最近最久未使用置换算法（LRU，least recently used）：<strong>每次淘汰的页面是最近最久未使用的页面</strong>。</p><p>实现方法：赋予每个页面对应的页表项中，<strong>用访问字段记录该页面自上次被访问以来所经历的时间</strong> <code>t</code> 。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p><blockquote><p>该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大</p></blockquote><h3 id="时钟置换算法（CLOCK）"><a href="#时钟置换算法（CLOCK）" class="headerlink" title="时钟置换算法（CLOCK）"></a>时钟置换算法（CLOCK）</h3><p>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。<br><strong>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法（NRU，NotRecently Used)</strong></p><p>简单的CLOCK算法实现方法：<strong>为每个页面设置一个访问位</strong>，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此<strong>简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描</strong>）</p><p>【改进型时钟置换算法】</p><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，<strong>如果被淘汰的页面没有被修改过，就不需要执行I／O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存</strong>。</p><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I／O操作。这就是改进型的时钟置换算法的思想。修改位＝0，表示页面没有被修改过；修改位＝1，表示页面被修改过。</p><p>算法规则：将所有可能被置换的页面排成一个循环队列<br>第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位<br>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0<br>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位<br>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。<br>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此<strong>改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描</strong>。</p><h2 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h2><h3 id="页面分配，置换策略"><a href="#页面分配，置换策略" class="headerlink" title="页面分配，置换策略"></a>页面分配，置换策略</h3><p><strong>驻留集：指请求分页存储管理中给进程分配的物理块的集合</strong>。</p><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</p><p>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</p><ul><li><p>固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，<strong>驻留集大小不变</strong></p></li><li><p>可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，<strong>驻留集大小可变</strong>。</p></li><li><p>局部置换：发生缺页时<strong>只能选进程自己的物理块进行置换</strong>。</p></li><li><p>全局置换：可以<strong>将操作系统保留的空闲物理块分配给缺页进程</strong>，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</p></li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad63da2bf0.png" alt="image-20230310165919326" style="zoom:67%;" /><p><strong>固定分配局部置换</strong>：系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）</p><p><strong>可变分配全局置换</strong>：刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。</p><p><strong>可变分配局部置换</strong>：刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</p><ul><li><strong>可变分配全局置换：只要缺页就给分配新物理块</strong></li><li><strong>可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块</strong></li></ul><h3 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h3><p><strong>预调页策略</strong>：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50％左右。<strong>故这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分</strong>。</p><p><strong>请求调页策略</strong>：<strong>进程在运行期间发现缺页时才将所缺页面调入内存</strong>。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I／O操作，因此I／O开销较大。</p><h3 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad6438a802.png" alt="image-20230310170450894" style="zoom:50%;" /><p>系统拥有足够的对换区空间：<strong>页面的调入、调出都是在内存与对换区之间进行</strong>，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</p><p>系统缺少足够的对换区空间：<strong>凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘</strong>，下次需要时再从文件区调入即可<strong>。对于可能被修改的部分，换出时需写回磁盘对换区</strong>，下次需要时再从对换区调入。</p><p>UNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</p><h3 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h3><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，<strong>这种频繁的页面调度行为称为抖动，或颠簸</strong>。<strong>产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）</strong>。</p><blockquote><p>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</p></blockquote><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>驻留集：指请求分页存储管理中给进程分配的内存块的集合。</p><p>工作集：指在某段时间间隔里，进程实际访问页面的集合。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad64923bd7.png" alt="image-20230310170810865" style="zoom:50%;" /><p><strong>工作集大小可能小于窗口尺寸</strong>，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。</p><blockquote><p>拓展：基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法——选择一个不在工作集中的页面进行淘汰。</p></blockquote><h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>内存映射文件——操作系统向上层程序员提供的功能（系统调用）</p><ul><li>方便程序员<strong>访问文件数据</strong><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad64e19839.png" alt="image-20230310173851956" style="zoom:67%;" /></li><li>方便<strong>多个进程共享同一个文件</strong>：多个进程可以映射同一个文件，<strong>实现共享</strong>。</li></ul><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>结🫡</p>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【2.0】进程和线程</title>
      <link href="/2023/03/08/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%902.0%E3%80%91%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/03/08/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%902.0%E3%80%91%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>NULL，基础部分，很长很多很麻烦</p><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><p><strong>程序</strong>：是<strong>静态</strong>的，程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。<br><strong>进程</strong>（Process）：是<strong>动态</strong>的，是程序的一次执行过程。</p><h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><p>系统使用 <strong>PCB（进程控制块）</strong>来描述进程的基本情况和运行状态，进而控制和管理进程。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad372ab6f7.png" alt="image-20230303191359280" style="zoom:80%;" /><p>相应的，<strong>程序段，数据段和 PCB 三个部分构成了进程实体</strong>。进程是动态的，进程实体是静态的。</p><p>进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配和调度</strong>的一个独立单位。</p><blockquote><p><strong>PCB 是进程存在的唯一标志</strong></p></blockquote><h2 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h2><ol><li>动态性：进程是动态产生，变化和消亡的</li><li>并发性：内存中有多个进程实体，各进程可以并发执行</li><li>独立性：独立运行，获得资源，进行调度的基本单位</li><li>异步性</li><li>结构性</li></ol><h2 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h2><ol><li>进程正在被创建时，其状态为“ <strong>创建态</strong> ”，这个阶段会分配资源，初始化 PCB</li><li>当进程创建完成后，便进入“<strong>就绪态</strong>”，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行</li><li>如果一个进程此时在CPU上运行，那么这个进程处于“<strong>运行态</strong>”。</li><li>在进程运行的过程中，可能会请求等待某个事件的发生。在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“<strong>阻塞态</strong>”</li><li>一个进程可以执行exit系统调用，请求操作系统终止该进程。此时该进程会进入“<strong>终止态</strong>”，操作系统会让该进程下CPU，并回收内存空间等资源，<strong>最后还要回收该进程的PCB</strong>。</li></ol><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad37850e34.png" alt="image-20230303194359726" style="zoom:80%;" /><p>$\color{red}{运行态} \to 阻塞态$ 是一种进程自身做出的<strong>主动行为</strong>。$\color{red}{阻塞态} \to 运行态$ 不能由进程自身控制，是一种<strong>被动行为</strong>。</p><blockquote><p>注意：不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态</p><p>另外，在单核 CPU 情况下，同一时刻只会有一个进程处于运行态</p></blockquote><p>补充：进程的挂起态和七状态模型</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad37d465f8.png" alt="image-20230304181741819" style="zoom:80%;" /><h2 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h2><h3 id="链式方式"><a href="#链式方式" class="headerlink" title="链式方式"></a>链式方式</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3820313d.png" alt="image-20230303194924225" style="zoom:80%;" /><h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3870eec4.png" alt="image-20230303201906700" style="zoom:80%;" /><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制的主要功能是<strong>对系统中的所有进程实施有效的管理</strong>，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><blockquote><p>进程状态的转换，需要通过原语转换，不可中断</p></blockquote><p><strong>原语</strong>的执行具有<strong>原子性</strong>，即执行过程只能一气呵成，<strong>期间不允许被中断</strong>。可以用<strong>“关中断指令”和“开中断指令”</strong>这两个<strong>特权指令</strong>实现原子性。</p><p>因为 CPU 在执行指令后需要检查是否有外部中断信号，这个时候关闭中断指令，即使收到中断信号，也不会中断，这样就实现了原子性，等到执行完成后，进行开中断。</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad38bf12c8.png" alt="image-20230303202908058" style="zoom:80%;" /><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad38ff01f9.png" alt="image-20230303203152548" style="zoom:80%;" /><h3 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3943d115.png" alt="image-20230303203341450" style="zoom:80%;" /><h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad39827e49.png" alt="image-20230303203433572" style="zoom:80%;" /><h2 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h2><p>进程间通信（Inter-Process Communication，IPC）是<strong>指两个进程 之间产生数据交互</strong>。</p><blockquote><p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p></blockquote><p>进程的通信可以分为三种：<strong>共享存储，消息传递和管道通信</strong></p><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>即开辟一段共享的内存空间，这样不同的进程可以在这个共享的内存空间中，读取或者写入数据来完成通信。</p><p><strong>为避免出错，各个进程对共享空间的访问应该是互斥的</strong>。</p><p>共享存储又可以分为：</p><ul><li><strong>基于存储区的共享</strong>：操作系统在内存中划出一块共享存储区，数据的形式、存放位置都<strong>由通信进程控制，而不是操作系统</strong>。这种共享方式速度很快，是一种高级通信方式。**</li><li><strong>基于数据结构的共享</strong>：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。</li></ul><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p><strong>进程间的数据交换以格式化的消息（Message）为单位</strong>。进程通过操作系统提供的“发送消息／接收消息”两个原语进行数据交换。</p><img src="httpss://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20230303210524715.png" alt="image-20230303210524715" style="zoom:50%;" /><p>消息传递又可以分为</p><ul><li><p><strong>直接通信方式</strong>：消息发送进程要指明接收进程的ID。</p></li><li><p><strong>间接通信方式</strong>：以“信箱”作为中间实体进行消息传递。</p><blockquote><p>可以多个进程往同一个信箱 send 消息，也可以多个进程，从同一个信箱中receive消息 </p></blockquote></li><li><p><strong>管道通信</strong>：“管道”是一个特殊的共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区</p><ol><li>管道<strong>只能采用半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</li><li>各进程要<strong>互斥地访问管道</strong>（由操作系统实现）</li><li><strong>当管道写满时，写进程将阻塞</strong>，直到读进程将管道中的数据取走，即可唤醒写进程。</li><li><strong>管道中的数据一旦被读出，就彻底消失</strong>。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：①<strong>一个管道允许多个写进程，一个读进程</strong>；②<strong>允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据</strong>（Linux的方案）。</li></ol></li></ul><h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，<strong>引入了“线程”，来增加并发度</strong>。</p><p><strong>线程是一个基本的CPU执行单元，也是程序执行流的最小单位</strong>。</p><p>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）。<br>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad39f8127f.png" alt="image-20230303220256817" style="zoom:80%;" /><h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3a371c2b.png" alt="image-20230303220437107" style="zoom:80%;" /><h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>早期的操作系统（如：早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3a7bc2ab.png" alt="image-20230303221645391" style="zoom: 43%;" /><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高<br><strong>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</strong>。</p><h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><p>大多数现代操作系统都实现了内核级线程，如Windows、Linux</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3ac20364.png" alt="image-20230303222328962" style="zoom:43%;" /><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。<br>缺点：<strong>一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</strong>。</p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><ul><li><strong>一对一模型</strong>：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</li><li><strong>多对一模型</strong>：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。<img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3b062ce1.png" alt="image-20230303222528761" style="zoom: 43%;" /></li><li><strong>多对多模型</strong>：n用户及线程映射到m个内核级线程（n＞＝m）。每个用户进程对应m个内核级线程。<img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3b498aae.png" alt="image-20230303222627366" style="zoom:43%;" /></li></ul><blockquote><p>操作系统只“看得见”内核级线程，因此<strong>只有内核级线程才是处理机分配的单位</strong>。</p></blockquote><h2 id="线程的状态与转换"><a href="#线程的状态与转换" class="headerlink" title="线程的状态与转换"></a>线程的状态与转换</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3b933f34.png" alt="image-20230303222839798" style="zoom:50%;" /><p>管理线程是通过 TCB（线程控制块）。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3be29246.png" alt="image-20230303223133291" style="zoom:67%;" /><p>多个线程 TCB 组成一张线程表，进行分类管理。</p><h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><h2 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h2><p>在多到程序系统中，由于资源优先，来使用调度来分配资源来实现并发执行。</p><h2 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h2><ol><li><p><strong>高级调度</strong>（作业调度）：按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。<strong>作业调入时会建立PCB，调出时才撤销PCB</strong>。</p><blockquote><p>即将外存中的程序&#x2F;作业，调入内存进行执行</p></blockquote></li><li><p><strong>低级调度</strong>（进程调度／处理机调度）：按照某种策略从就绪队列中<strong>选取一个进程</strong>，将处理机分配给它</p></li><li><p><strong>中级调度</strong>（内存调度）：按照某种策略决定将哪个处于挂起状态的进程重新调入内存。</p><blockquote><p>即将内存中挂起态的程序&#x2F;作业，调入外存中以腾出内存空间</p></blockquote></li></ol><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3c46e8bf.png" alt="image-20230304181844478" style="zoom:80%;" /><h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><p>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p><p><strong>需要进行进程调度</strong>的情况：</p><ol><li>当前运行的进程<strong>主动放弃处理机</strong></li><li>当前运行的进程<strong>被动放弃处理机</strong></li></ol><p><strong>不能进行进程调度</strong>的情况：</p><ol><li>在<strong>处理中断的过程</strong>中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li><li><strong>进程在操作系统内核程序临界区中</strong>。</li><li>在<strong>原子操作过程中（原语）</strong>。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li></ol><blockquote><p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</p><p>临界区：访问临界资源的那段代码。</p><p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p></blockquote><h2 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h2><p><strong>非剥夺调度方式</strong>，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p><p><strong>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</strong>。</p><p><strong>剥夺调度方式</strong>，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p><p>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统。</p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>调度程序进行调度的时机：</p><ol><li><strong>创建新进程</strong></li><li><strong>进程退出</strong></li><li>运行<strong>进程阻塞</strong></li><li><strong>I&#x2F;O中断</strong>发生</li></ol><blockquote><ul><li>非抢占式调度策略，只有运行进程阻塞或退出才触发调度程序工作</li><li>抢占式调度策略，每个时钟中断或k个时钟中断会触发调度程序工作</li></ul></blockquote><h2 id="闲逛进程"><a href="#闲逛进程" class="headerlink" title="闲逛进程"></a>闲逛进程</h2><p>调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程（idle）</p><p>闲逛进程的特性：</p><ul><li><strong>优先级最低</strong></li><li>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</li><li>能耗低</li></ul><h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><p><strong>CPU利用率：指CPU“忙碌”的时间占总时间的比例</strong>。</p><p>$\large 利用率 &#x3D; \frac{忙碌的时间}{总时间}$ </p><p><strong>系统吞吐量：单位时间内完成作业的数量</strong>。</p><p>$\large 系统吞吐量 &#x3D; \frac{中共完成了多少道作业}{总共花了多少时间}$ </p><p><strong>周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔</strong>。</p><p>$周转时间&#x3D;作业完成时间 - 作业提交时间$ </p><p>$\large 平均周转时间 &#x3D; \frac{各作业周转时间之和}{作业数}$ </p><p>$\large 带权周转时间 &#x3D; \frac{作业周转时间}{作业实际运行时间} &#x3D; \frac{作业完成时间 - 作业提交时间}{作业实际运行时间}$ </p><blockquote><p>带权周转时间必然是 $\geqslant 1$ </p><p>带权周转时间与周转时间是越小越好</p></blockquote><p>$\large 平均带权周转时间 &#x3D; \frac{各作业带权周转时间之和}{作业数}$ </p><p><strong>等待时间</strong>，指进程／作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p><p>对于<strong>进程</strong>来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I／O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p><p>对于<strong>作业</strong>来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p><p>响应时间，指从用户提交请求到首次产生响应所用的时间。</p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h3><table><thead><tr><th>类目</th><th>说明</th></tr></thead><tbody><tr><td>算法思想</td><td>主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）</td></tr><tr><td>算法规则</td><td>按照作业&#x2F;进程到达的先后顺序进行服务</td></tr><tr><td>用于作业&#x2F;进程调度</td><td>用于<strong>作业调度</strong>时，考虑的是哪个作业先到达<strong>后备队列</strong>（外存）；<br />用于<strong>进程调度</strong>时，考虑的是哪个进程先到达<strong>就绪队列</strong>（内存）；</td></tr><tr><td>是否可以抢占</td><td><strong>非抢占式算法</strong>（即阻塞或者结束进程）</td></tr><tr><td>优缺点</td><td>优点：公平、算法实现简单<br/>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，<strong>FCFS算法对长作业有利，对短作业不利</strong></td></tr><tr><td>是否会导致饥饿</td><td><strong>不会</strong></td></tr></tbody></table><h3 id="短作业优先（SJF）"><a href="#短作业优先（SJF）" class="headerlink" title="短作业优先（SJF）"></a>短作业优先（SJF）</h3><p>短作业／进程优先调度算法：每次调度时选择<strong>当前已到达且运行时间最短</strong>的作业／进程。</p><table><thead><tr><th>类目</th><th>说明</th></tr></thead><tbody><tr><td>算法思想</td><td>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</td></tr><tr><td>算法规则</td><td>最短的作业／进程优先得到服务（所谓“最短”，是指要求服务时间最短）</td></tr><tr><td>用于作业&#x2F;进程调度</td><td>即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先（<strong>SPF</strong>，Shortest Process First）算法”</td></tr><tr><td>是否可以抢占</td><td>SJF 和 SPF是<strong>非抢占式算法</strong>。但是<strong>也有抢占式的版本——最短剩余时间优先算法</strong>(SRTN,Shortes<br/>st Remaining Time Next)</td></tr><tr><td>优缺点</td><td>优点：“最短的”平均等待时间、平均周转时间<br/>缺点：不公平。<strong>对短作业有利，对长作业不利。可能产生饥饿现象</strong>。另外，作业／进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</td></tr><tr><td>是否会导致饥饿</td><td><strong>会</strong>。如果源源不断地有短作业／进程到来，可能使长作业／进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”</td></tr></tbody></table><p><strong>最短剩余时间优先算法</strong>（SPF）：每当有进程<strong>加入就绪队列改变时就需要调度</strong>，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度</p><blockquote><ol><li>如果题目中未特别说明，所提到的“短作业／进程优先算法<strong>”默认是非抢占式的</strong></li><li>很多书上都会说“SJF调度算法的平均等待时间、平均周转时间最少”（严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少<br>应该加上一个条件“在所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转时间最少”）</li><li>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间</li></ol></blockquote><h3 id="高响应比优先（HRRN）"><a href="#高响应比优先（HRRN）" class="headerlink" title="高响应比优先（HRRN）"></a>高响应比优先（HRRN）</h3><p>高响应比优先算法：非抢占式的调度算法，只有当前运行的进程主动放弃CPU时（正常&#x2F;异常完成，或主动阻塞），才需要进行调度，调度时<strong>计算所有就绪进程的响应比，选响应比最高的进程上处理机</strong>。</p><table><thead><tr><th>类目</th><th>说明</th></tr></thead><tbody><tr><td>算法思想</td><td>要综合考虑作业&#x2F;进程的等待时间和要求服务的时间</td></tr><tr><td>算法规则</td><td>在每次调度时先计算各个作业／进程的响应比，选择响应比最高的作业／进程为其服务<br /> $\large 响应比 &#x3D; \frac{等待时间 + 要求服务时间}{要求服务时间}$</td></tr><tr><td>用于作业&#x2F;进程调度</td><td>即可用于作业调度，也可用于进程调度</td></tr><tr><td>是否可以抢占</td><td><strong>非抢占式的算法</strong>。因此只有当前运行的作业／进程主动放弃处理机时，才需要调度，才需要计算响应比</td></tr><tr><td>优缺点</td><td>综合考虑了等待时间和运行时间（要求服务时间）<br/><strong>等待时间相同时，要求服务时间短的优先（SJF的优点）</strong><br /><strong>要求服务时间相同时，等待时间长的优先（FCFS的优点）</strong><br />对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</td></tr><tr><td>是否会导致饥饿</td><td><strong>不会</strong></td></tr></tbody></table><h3 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h3><table><thead><tr><th>类目</th><th>说明</th></tr></thead><tbody><tr><td>算法思想</td><td>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</td></tr><tr><td>算法规则</td><td>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</td></tr><tr><td>用于作业&#x2F;进程调度</td><td><strong>用于进程调度</strong>（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</td></tr><tr><td>是否可以抢占</td><td>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法<strong>属于抢占式的算法</strong>。由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到</td></tr><tr><td>优缺点</td><td>优点：公平；响应快，适用于分时操作系统；<br/>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</td></tr><tr><td>是否会导致饥饿</td><td><strong>不会</strong></td></tr></tbody></table><blockquote><p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此<strong>时间片不能太大</strong>。</p><p>另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见<strong>时间片也不能太小</strong>。</p></blockquote><h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><table><thead><tr><th>类目</th><th>说明</th></tr></thead><tbody><tr><td>算法思想</td><td>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</td></tr><tr><td>算法规则</td><td>每个作业／进程有各自的优先级，调度时选择优先级最高的作业／进程</td></tr><tr><td>用于作业&#x2F;进程调度</td><td>既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I／0调度中</td></tr><tr><td>是否可以抢占</td><td>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而<strong>抢占式还需在就绪队列变化时，检查是否会发生抢占</strong>。</td></tr><tr><td>优缺点</td><td>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业／进程的偏好程度。<br/>缺点：若源源不断地有高优先级进程到来，则<strong>可能导致饥饿</strong></td></tr><tr><td>是否会导致饥饿</td><td><strong>会</strong></td></tr></tbody></table><p>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级和动态优先级</strong>两种。</p><ul><li>静态优先级：创建进程时确定，之后一直不变。</li><li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li></ul><p>【如何合理地设置各类进程的优先级？】</p><ul><li>系统进程优先级 <strong>高于</strong> 用户进程</li><li>前台进程优先级 <strong>高于</strong> 后台进程</li><li>操作系统更<strong>偏好I／O型进程</strong>（或称I／0繁忙型进程）</li></ul><p>【如果采用的是动态优先级，什么时候应该调整？】</p><ul><li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li><li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li><li>如果发现一个进程频繁地进行1&#x2F;0操作，则可适当提升其优先级</li></ul><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p>FCFS算法的优点是公平，SJF 算法的优点是能尽快处理完短作业，平均等待／周转时间等参数很优秀，时间片轮转调度算法可以让各个进程得到及时的响应，优先级调度算法可以灵活地调整各种进程被服务的机会，能否对其他算法做个折中权衡？得到一个综合表现优秀平衡的算法呢？这就是<strong>多级反馈队列调度算法</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3d0355f0.png" alt="image-20230306210318660" style="zoom:67%;" /><p><strong>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</strong>。</p><p><strong>新进程</strong>到达时先进入<strong>第1级队列</strong>，按<strong>FCFS原则</strong>排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。<strong>如果此时已经在最下级的队列，则重新放回最下级队列队尾</strong>。</p><p>只有第 $k$ 级队列为空时，才会为 $k＋1$ 级队头的进程分配时间片。</p><p><strong>被抢占处理机的进程重新放回原队列队尾</strong>。</p><table><thead><tr><th>类目</th><th>说明</th></tr></thead><tbody><tr><td>算法思想</td><td>对其他调度算法的折中权衡</td></tr><tr><td>算法规则</td><td>1．设置多级就绪队列，各级队列优先级从高到低，时间片从小到大<br />2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾<br/>3．只有第 $k$ 级队列为空时，才会为 $k＋1$ 级队头的进程分配时间片</td></tr><tr><td>用于作业&#x2F;进程调度</td><td>用于进程调度</td></tr><tr><td>是否可以抢占</td><td><strong>抢占式的算法</strong>。在k级队列的进程运行过程中，若更上级的队列（1～k—1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</td></tr><tr><td>优缺点</td><td>对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I／O密集型进程<br />【拓展：可以将因I／O而阻塞的进程重新放回原队列，这样I／O型进程就可以保持较高优先级】</td></tr><tr><td>是否会导致饥饿</td><td><strong>会</strong></td></tr></tbody></table><blockquote><p>时间片轮转调度算法，优先级调度算法，多级反馈队列调度算法适合用于交互式系统。</p></blockquote><h3 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a>多级队列调度算法</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3d599db9.png" alt="image-20230306210932286" style="zoom:67%;" /><p><strong>队列之间</strong>可采取<strong>固定优先级，或时间片划分</strong>：</p><ul><li><p>固定优先级：高优先级空时低优先级进程才能被调度</p></li><li><p>时间片划分：如三个队列分配时间50％、40％、10％</p></li></ul><p><strong>各队列</strong>可采用不同的调度策略，如：</p><ul><li>系统进程队列采用优先级调度</li><li>交互式队列采用RR </li><li>批处理队列采用FCFS</li></ul><h1 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h1><h2 id="同步与互斥基本概念"><a href="#同步与互斥基本概念" class="headerlink" title="同步与互斥基本概念"></a>同步与互斥基本概念</h2><p>同步亦<strong>称直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要<strong>在某些位置上协调它们的工作次序而产生的制约关系</strong>。进程间的直接制约关系就是源于它们之间的相互合作。</p><p>我们把<strong>一个时间段内只允许一个进程使用的资源称为临界资源</strong>。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p><p>对临界资源的访问，必须互斥地进行。<strong>互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待</strong>。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p><p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    entry section;<span class="comment">//进入区,检查是否可以访问临界区</span></span><br><span class="line">    critical section;<span class="comment">//临界区，访问临界资源的diamond</span></span><br><span class="line">    <span class="built_in">exit</span> section;<span class="comment">//退出区，解除“正在访问临界资源的标志”（解除上锁）</span></span><br><span class="line">    remainder section;<span class="comment">//剩余区,其他处理</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><ol><li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li><li><strong>忙则等待</strong>。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li><li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol><h2 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h2><h3 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h3><p>算法思想：<strong>两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程</strong>。也就是说每个进程进入临界区的权限只能被另一个进程赋予。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3dc97838.png" alt="image-20230306220721552" style="zoom:67%;" /><p>该算法可以实现“<strong>同一时刻最多只允许一个进程访问临界区</strong>”</p><p>单标志法存在的主要问题是：<strong>违背“空闲让进”原则</strong>。</p><h3 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h3><p>算法思想：设置一个布尔型数组flagl］，<strong>数组中各个元素用来标记各进程想进入临界区的意愿</strong>，比如 <code>flag[0]＝ture</code> 意味着 0 号进程 $P_0$ 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 <code>flag[i]</code> 设为 <code>true</code>，之后开始访问临界区。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3e14bd61.png" alt="image-20230306221149962" style="zoom:67%;" /><p>双标志先检查法的主要问题是：<strong>违反“忙则等待”原则</strong>，在并发运行的时候，可能会出现多个进程同时访问的情况。</p><p>原因在于，<strong>进入区的“检查”和“上锁”两个处理不是一气呵成的</strong>。“检查”后，“上锁”前可能发生进程切换。</p><h3 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h3><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3e61ecb7.png" alt="image-20230306221637462" style="zoom:67%;" /><p>因此，<strong>双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象</strong>。</p><h3 id="Paterson-算法"><a href="#Paterson-算法" class="headerlink" title="Paterson 算法"></a>Paterson 算法</h3><p>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3ec9774e.png" alt="image-20230306223519981" style="zoom: 67%;" /><p>Peterson 算法用软件方法<strong>解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则</strong>，但是<strong>依然未遵循让权等待的原则</strong>。</p><h2 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h2><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><p><strong>利用“开／关中断指令”实现</strong>（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3f186d17.png" alt="image-20230306224414667" style="zoom:60%;" /><p>优点：简单、高效<br>缺点：<strong>不适用于多处理机</strong>；<strong>只适用于操作系统内核进程，不适用于用户进程</strong>（因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p><h3 id="TestAndSet-TS指令-TSL指令"><a href="#TestAndSet-TS指令-TSL指令" class="headerlink" title="TestAndSet (TS指令&#x2F;TSL指令)"></a>TestAndSet (TS指令&#x2F;TSL指令)</h3><p>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令</p><p><strong>TSL 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成</strong>。以下是用C语言描述的逻辑</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3f8056e0.png" alt="image-20230306224655818" style="zoom:67%;" /><p>若刚开始<code>lock</code>是<code>false</code>，则 TSL 返回的<code>old</code>值为<code>false</code>， <code>while</code>循环条件不满足，直接跳过循环，进入临界区。若刚开始<code>lock</code>是<code>true</code>，则执行TLS后<code>old</code>返回的值为<code>true</code>， <code>while</code>循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p><p>相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境。</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h3 id="Swap指令-XCHG指令"><a href="#Swap指令-XCHG指令" class="headerlink" title="Swap指令 (XCHG指令)"></a>Swap指令 (XCHG指令)</h3><p>有的地方也叫Exchange指令，或简称XCHG指令。</p><p>Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad3fd2217b.png" alt="image-20230306225543780" style="zoom:80%;" /><p>逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在<code>old</code>变量上），再将上锁标记<code>lock</code>设置为<code>true</code>，最后检查<code>old</code>，如果<code>old</code>为<code>false</code>则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>解决临界区最简单的工具就是互斥锁（mutex lock）。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数<code>acquire()</code>获得锁，而函数<code>release()</code>释放锁。</p><p>每个互斥锁有一个布尔变量<code>available</code>，表示锁是否可用。如果锁是可用的，调用<code>acqiure()</code>会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p><p><code>acquire()</code>或&#96;&#96;release()&#96;的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。</p><p><strong>互斥锁</strong>的主要缺点是<strong>忙等待</strong>，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用<code>acquire()</code>。当多个进程共享同一CPU时，就浪费了CPU周期。因此，<strong>互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行</strong>。</p><p>需要连续循环忙等的互斥锁，都可称为自旋锁（spin lock），如TSL指令、swap指令、单标志法。</p><p>特性：</p><ul><li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li><li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li><li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li><li>不太适用于单处理机系统，忙等的过程中不可能解锁</li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad402f1d72.png" alt="image-20230306233055402" style="zoom:67%;" /><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><ol><li>在双标志先检查法中，<strong>进入区的“检查”、“上锁”操作无法一气呵成</strong>，从而导致了两个进程有可能同时进入临界区的问题；</li><li>所有的解决方案都无法实现“让权等待”。</li></ol><p>1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法——信号量机制。</p><p>用户进程可以通过使用操作系统提供的<strong>一对原语来对信号量进行操作</strong>，从而很方便的实现了进程互斥、进程同步。</p><p>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以<strong>用一个信号量来表示系统中某种资源的数量</strong>，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p><p>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断／开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p><p>一对原语：<code>wait(S)</code>原语和<code>signal(S)</code>原语，可以把原语理解为我们自己写的函数，函数名分别为<code>wait</code>和 <code>signal</code>，括号里的信号量S其实就是函数调用时传入的一个参数。</p><p><code>wait</code>、<code>signal</code>原语常<strong>简称为P、V操作</strong>（来自荷兰语 proberen和verhogen）。因此，做题的时候常把 <code>wait(S)、signal(S)</code>两个操作分别写为P（S）、V（S）。</p><h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p>用一个<strong>整数</strong>型的变量作为信号量，用来<strong>表示系统中某种资源的数量</strong>。</p><blockquote><p>与普通整数变量的区别：对信号量的操作只有三种，即 <strong>初始化、P操作、V操作</strong></p></blockquote><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad4092a3da.png" alt="image-20230307181547864" style="zoom:67%;" /><h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad40d4fd3a.png" alt="image-20230307182220128" style="zoom:80%;" /><p><code>S.value</code>的初值表示系统中某种资源的数目。</p><p>对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此需要执行<code>S.value--</code>，表示资源数减1，当<code>S.value＜0</code>时表示该类资源已分配完毕，因此进程应调用<code>block </code>原语进行自我阻塞（当前运行的进程从运行态→阻塞态），主动放弃处理机，并插入该类资源的等待队列<code>S.L</code>中。可见，<strong>该机制遵循了“让权等待”原则，不会出现“忙等”现象</strong>。</p><p>对信号量S的一次V操作意味着进程释放一个单位的该类资源，因此需要执行<code>S.value＋＋</code>，表示资源数加1，若加1后仍是<code>S.value＜＝0</code>，表示依然有进程在等待该类资源，因此应调用<code>wakeup</code>原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态→就绪态）。</p><h3 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a>实现进程互斥</h3><ol><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li><li>设置互斥信号量<code>mutex</code>, 初值为1</li><li>在进入区<code>P(mutex)</code>——申请资源</li><li>在退出区<code>V(mutex)</code>——释放资源</li></ol><blockquote><p>注意：<strong>对不同的临界资源需要设置不同的互斥信号量</strong>。P、V操作必须成对出现。缺少<code>P(mutex)</code>就不能保证临界资源的互斥访问。缺少<code>V(mutex)</code>会导致资源永不被释放，等待进程永不被唤醒。</p></blockquote><h3 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h3><p>进程同步：要让各并发进程按要求有序地推进。</p><p>用信号量实现进程同步：</p><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</li><li><strong>设置同步信号量S，初始为0</strong>.</li><li>在“前操作”之后执行<code>V(S)</code>.</li><li>在“后操作”之前执行<code>P(S)</code>.</li></ol><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad412b89a9.png" alt="image-20230307185525671" style="zoom:80%;" /><h3 id="实现进程的前驱关系"><a href="#实现进程的前驱关系" class="headerlink" title="实现进程的前驱关系"></a>实现进程的前驱关系</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad41759e5c.png" alt="image-20230307185852766" style="zoom:40%;" /><p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）因此，</p><ol><li>要<strong>为每一对前驱关系各设置一个同步信号量</strong>。</li><li>在“前操作”之后对相应的同步信号量执行V操作。</li><li>在“后操作”之前对相应的同步信号量执行P操作。</li></ol><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>信号量机制存在的问题：编写程序困难、易出错，为了更加易用，出现了管程。</p><p>管程是一种特殊的软件模块，有这些部分组成：</p><ol><li>局部于管程的<strong>共享数据结构</strong>说明；</li><li>对该数据结构进行操作的<strong>一组过程</strong>；</li><li>对局部于管程的共享数据设置初始值的语句；</li><li>管程有一个名字。</li></ol><p>管程的基本特征：</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问；</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li><li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong>。</li></ol><p>【用管程解决生产者消费者问题】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad41c563f8.png" alt="image-20230307204053789" style="zoom:80%;" /><h1 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h1><h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）</p><ul><li>生产者、消费者共享一个初始为空、大小为 $n$ 的缓冲区。</li><li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li><li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li><li>缓冲区是临界资源，各进程必须互斥地访问。</li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad42189ff7.png" alt="image-20230307192202837" style="zoom:80%;" /><h2 id="多生产者多消费者问题"><a href="#多生产者多消费者问题" class="headerlink" title="多生产者多消费者问题"></a>多生产者多消费者问题</h2><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p><p>互斥关系：</p><ol><li>对缓冲区（盘子）的访问要互斥地进行</li></ol><p>同步关系（一前一后）：</p><ol><li>父亲将苹果放入盘子后，女儿才能取苹果。</li><li>母亲将橘子放入盘子后，儿子才能取橘子。</li><li><strong>只有盘子为空时，父亲或母亲才能放入水果</strong>。</li></ol><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad426c9b56.png" alt="image-20230307193942825" style="zoom:80%;" /><h2 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h2><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）</p><p>同步关系（从事件的角度来分析）：</p><ol><li>桌上有组合一→第一个抽烟者取走东西</li><li>桌上有组合二→第二个抽烟者取走东西</li><li>桌上有组合三→第三个抽烟者取走东西</li><li>发出完成信号→供应者将下一个组合放到桌上</li></ol><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad42c01e87.png" alt="image-20230307195157566" style="zoom:80%;" /><h2 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h2><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。</p><p>因此要求：</p><ol><li>允许多个读者可以同时对文件执行读操作； </li><li>只允许一个写者往文件中写信息；</li><li>任一写者在完成写操作之前不允许其他读者或写者工作； </li><li>写者执行写操作前，应让已有的读者和写者全部退出。</li></ol><p>互斥关系：写进程一写进程、写进程一读进程。读进程与读进程不存在互斥问题。</p><h2 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h2><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><p>在并发环境下<strong>，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象</strong>，就是“死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进。</p><p><strong>死锁</strong>：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p><p><strong>饥饿</strong>：<strong>由于长期得不到想要的资源，某进程无法问前推进的现象</strong>。比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p><p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那至少有两个或两个以上的进程同时发生死锁。另外，发生死锁的进程一定处于阻塞态。</li><li>可能只有一个进程发生饥饿。发生饥饿的进程既可能是阻塞态（如长期得不到需要的I／O设备），也可能是就绪态（长期得不到处理机）</li><li>可能只有一个进程发生死循环。死循环的进程可以上处理机运行（可以是运行态），只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。<strong>死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者的问题</strong>。</li></ul><h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ul><li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li><li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li><strong>请求和保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul><blockquote><p>注意！发生死锁时一定有循环等待，但是<strong>发生循环等待时未必死锁</strong>（循环等待是死锁的必要不充分条件）</p><p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p></blockquote><h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h3><ol><li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li><li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li></ol><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad431e9678.png" alt="image-20230307210257718" style="zoom:80%;" /><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。</p><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：SPOOLing技术。操作系统可以采用SPOOLing 技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备…</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad43737664.png" alt="image-20230307210459458" style="zoom: 50%;" /><p>该策略的缺点：<strong>并不是所有的资源都可以改造成可共享使用的资源</strong>。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</p><h3 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h3><p>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p><p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p><p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</p><p>该策略的缺点：</p><ol><li>实现起来比较复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li></ol><h3 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h3><p>请求和保持条件：<strong>进程已经保持了至少一个资源</strong>，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p><p>可以<strong>采用静态分配方法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p><p>该策略实现起来简单，但也有明显的缺点：</p><ol><li>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，<strong>资源利用率极低</strong>。另外，该策略也有可能导致某些进程饥饿。</li></ol><h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><p>循环等待条件：存在一种<strong>进程资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。</p><p>可采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定<strong>每个进程必须按编号递增的顺序请求资源</strong>，同类资源（即编号相同的资源）一次申请完。</p><p>原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。</p><p>该策略的缺点：</p><ol><li>不方便增加新的设备，因为可能需要重新分配所有的编号：</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；</li><li>必须按规定次序申请资源，用户编程麻烦。</li></ol><h2 id="避免死锁（银行家算法）"><a href="#避免死锁（银行家算法）" class="headerlink" title="避免死锁（银行家算法）"></a>避免死锁（银行家算法）</h2><p>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，<strong>安全序列可能有多个</strong>。</p><p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</p><p><strong>如果系统处于安全状态，就一定不会发生死锁</strong>。如果系统进入不安全状态，就<strong>可能发生死锁</strong>（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</p><p>因此可以<strong>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求</strong>。这也是“<strong>银行家算法</strong>”的核心思想。</p><p>银行家算法是荷兰学者Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于避免死锁。</p><p>核心思想：<strong>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待</strong>。</p><h2 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h2><p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：</p><ol><li><strong>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁</strong>。</li><li><strong>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来</strong>。</li></ol><h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><p>为了能对系统是否已发生了死锁进行检测，必须：</p><ol><li>用某种数据结构来保存资源的请求和分配信息；</li><li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</li></ol><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad43f70eef.png" alt="image-20230308223754219" style="zoom:80%;" /><p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。</p><p>相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…</p><p>如果按上述过程分析，<strong>最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁</strong>（相当于能找到一个安全序列）</p><p><strong>如果最终不能消除所有边，那么此时就是发生了死锁</strong>。最终还连着边的那些进程就是处于死锁状态的进程。</p><p><strong>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</strong>。</p><h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><p>一旦检测出死锁的发生，就应该立即解除死锁。</p><blockquote><p><strong>并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</strong></p></blockquote><p>解除死锁的主要方法有：</p><ol><li><strong>资源剥夺法</strong>。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li><strong>撤销进程法</strong>（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li><li><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li></ol><p>【如何绝对“对谁下手”？】</p><ol><li>进程优先级</li><li>已执行多长时间</li><li>还要多久能完成</li><li>进程已经使用了多少资源</li><li>进程是交互式的还是批处理式的</li></ol><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【1.0】操作系统概述</title>
      <link href="/2023/03/02/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%901.0%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/03/02/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%901.0%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统的基本概述，内容来源自《王道操作系统》并略有补充，此为本人笔记，仅供参考</p><h1 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h1><h2 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h2><p><em>操作系统</em>（英语：Operating System，缩写：OS）<em>是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序。根据运行的环境，操作系统可以分为桌面操作系统，手机操作系统，服务器操作系统，嵌入式操作系统等</em>。</p><blockquote><p>内容来源：百度百科</p></blockquote><h2 id="操作系统特点"><a href="#操作系统特点" class="headerlink" title="操作系统特点"></a>操作系统特点</h2><ul><li><p><strong>并发</strong>：指两个或者多个程序在<strong>同一个时间间隔</strong>内发生。</p><blockquote><p>注意：区分并行，<strong>并行指同一时刻发生</strong>。这就意味着，对于单核的CPU同一时刻只能执行一个程序，各个程序只能并发的执行，而对于多核CPU可以同时执行多个程序，多个程序可以并行的执行。</p></blockquote></li><li><p><strong>共享</strong>，指系统中的资源可以供内存中多个并发执行的进程共同使用。<br>共享可以分为两种类型：<strong>互斥共享方式</strong>和<strong>同时访问方式</strong>。</p><blockquote><p>如果失去并发性，也就没必要实现共享性，反之同理，两者互为存在条件。</p></blockquote></li><li><p><strong>虚拟</strong>，指把一个物理上的实体变为若干个逻辑上的对应物。<br>虚拟技术也可以分为两种类型：<strong>空分复用技术</strong>和<strong>时分复用技术</strong>。</p></li><li><p><strong>异步</strong>，由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。</p></li></ul><h1 id="操作系统的发展和分类"><a href="#操作系统的发展和分类" class="headerlink" title="操作系统的发展和分类"></a>操作系统的发展和分类</h1><h2 id="手工操作系统"><a href="#手工操作系统" class="headerlink" title="手工操作系统"></a>手工操作系统</h2><p>在这个阶段的操作系统并没有诞生，对于计算的工作都需要进行人工干预，例如：程序的装入，运行，输出结果等等。使用手工操作的方式，存在两个缺点：</p><ol><li>用户独占全机，资源利用率低</li><li>CPU等待手工操作，CPU的利用不充分</li></ol><p>其对应的解决办法是使用高速的机器代替较慢的手工操作。</p><h2 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h2><p>为了解决上述手工操作系统的人机矛盾和CPU以及I&#x2F;O设备速度不匹配的问题，出现了批处理系统。</p><h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><p>引入脱机输入&#x2F;输出技术，并由监督程序负责控制作业的输入&#x2F;输出。</p><p>优点：缓解了一定程度的人机矛盾</p><p>缺点：<strong>内存中仅能有一道程序运行</strong>，只有该程序结束运行后，才能调入下一道程序。<strong>CPU有大量的时间是处于等待I&#x2F;O完成</strong>，资源的利用率依然很低。</p><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><p>为了解决上述的问题，诞生了真正意义上的操作系统。其每次往内存中读入多道程序，使得其并发运行。</p><p>优点：多道程序并发执行，共享计算机的资源，资源利用率大大提升。</p><p>缺点：<strong>没有人机交互功能</strong>（用户提交作业之后只能等待计算机处理完成，不能中间控制自己的作业）</p><h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><p>计算机以<strong>时间片为单位</strong>轮流为各个用户／作业服务，各个用户可通过终端与计算机进行交互。</p><p>优点：用户的请求可以直接被响应，解决了人机交互的问题。</p><p>缺点：<strong>不能优先处理一些紧急任务</strong>。其对每个用户&#x2F;作业都是公平分配的。</p><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>优点：能够优先相应一些紧急任务，解决了分时操作系统的问题，</p><p>实时操作系统的主要特点是：<strong>及时性</strong>和<strong>可靠性</strong>。</p><p>实时操作系统又可以分为</p><ul><li>硬实时操作系统</li><li>软实时操作系统</li></ul><h2 id="其他操作系统"><a href="#其他操作系统" class="headerlink" title="其他操作系统"></a>其他操作系统</h2><p>还有一些其他的操作系统，包括但不限于<strong>网络操作系统</strong>，<strong>分布式操作系统</strong>，<strong>个人计算机操作系统</strong>等</p><h1 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h1><p><strong>内核程序</strong>：微软或者苹果有一帮人负责实现操作系统，其写的就是内核程序。由很多内核程序组成了“操作系统内核”，也是最接近硬件的部分。甚至可以说，一个操作系统只要有内核就可以了。</p><p><strong>应用程序</strong>：平时普通程序员所编写的。</p><p>特权指令：不允许用户直接使用的指令，包含一些危险指令。</p><p>非特权指令：允许用户直接使用的指令。</p><p>根据特权指令的是否使用，<strong>CPU使得有两种状态，即“内核态”和“用户态”</strong>。</p><blockquote><p>CPU中有一个寄存器叫 <strong>程序状态字寄存器（PSW）</strong>，其中包含一个二进制位，1 表示内核态，0 表示用户态</p><p>内核态也称为：<strong>管态</strong>，用户态也成为“<strong>目态</strong>”</p></blockquote><h2 id="内核态用户态的切换"><a href="#内核态用户态的切换" class="headerlink" title="内核态用户态的切换"></a>内核态用户态的切换</h2><p>由<strong>内核态切换到用户态</strong>，<strong>执行了一条特权指令——来修改 PSW 的标志位为“用户态”，</strong>这就意味着操作系统将主动让出 CPU 使用权。</p><p>由<strong>用户态切换到内核态</strong>，是由“<strong>中断</strong>”引发的，<strong>硬件自动完成变态过程</strong>，触发中断信号意味着操作系统将强行夺回 CPU 的使用权。</p><blockquote><p>只要需要操作系统介入的地方，就会触发中断信号。</p></blockquote><h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><p>CPU 上会运行两种程序，即操作系统的内核程序和应用程序。</p><p><strong>“中断”是让操作系统内核夺回 CPU 使用权的唯一途径</strong>。</p><h2 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h2><ul><li><p><strong>内中断</strong>：和当前执行的指令有关，<strong>中断信号来源于 CPU 内部</strong>。</p><p>例如：试图在用户态下执行特权指令，或者在执行除法指令时发现除数为 0 等。若当前执行的指令是非法的，则会引起一个中断信号。</p><p>例如：有时候应用程序想<strong>请求操作系统的内核服务</strong>，此时会执行一条<strong>特殊的指令——陷入指令</strong>，该指令会引发一个内部的中断信号。</p><blockquote><p>陷入指令是特殊指令但不是特权指令</p></blockquote></li><li><p><strong>外中断</strong>：与当前执行指令无关，<strong>中断信号来源于 CPU 外部</strong>。</p><p>例如：<strong>时钟中断</strong>，由时钟部件发来的中断信号。</p></li></ul><blockquote><p>狭义的中断指的是外中断，而内中断称为异常。</p></blockquote><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad10e4ab70.png" alt="image-20230302203421746" style="zoom:80%;" /><h2 id="中断的基本原理"><a href="#中断的基本原理" class="headerlink" title="中断的基本原理"></a>中断的基本原理</h2><p><strong>不同的中断信号，需要用不同的中断处理程序来处理</strong>。当 CPU 检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来查找相应的中断处理程序在内存中存放的位置。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad134c561a.png" alt="image-20230302203619865" style="zoom:50%;" /><blockquote><p>图片来源：王道操作系统</p></blockquote><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，<strong>程序接口由一组系统调用组成</strong>。<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong>。</p><h2 id="系统调用与库函数的区别"><a href="#系统调用与库函数的区别" class="headerlink" title="系统调用与库函数的区别"></a>系统调用与库函数的区别</h2><p>系统调用是比库函数更底层的库，可以理解为为了便于编程而做的封装，而我们也可以直接使用汇编语言来进行系统调用而不使用其库函数来实现。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad141ce6d8.png" alt="image-20230302203957207" style="zoom: 43%;" /><blockquote><p>当然，不是所有的库函数都是要使用系统调用，对于一些不需要特权指令的操作，库函数就并不需要使用系统调用</p></blockquote><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad14690cef.png" alt="image-20230302204435406" style="zoom:80%;" /><h2 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad1522d228.png" alt="image-20230302205941762" style="zoom:80%;" /><p>注意：</p><ol><li><strong>陷入指令</strong>是用户态下执行的，执行陷入指令之后立即引发一个内中断，<strong>使 CPU 进入核心态</strong>。</li><li><strong>发出系统调用请求是在用户态</strong>，而系统调用的相应处理是在<strong>核心态</strong>下进行。</li></ol><h1 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h1><h2 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad1572594f.png" alt="image-20230302210410788" style="zoom:80%;" /><p><strong>内核是操作系统最基本，最核心的部分</strong>。实现操作系统内核功能的那些程序就是内核程序。</p><p>操作系统有可以根据对于其内核功能的实现来分为如下两种：</p><ul><li><strong>大内核</strong>：包含全部的内核基本程序<ul><li>优点：高性能</li><li>缺点：内核代码庞大，结构混乱，难以维护</li></ul></li><li><strong>微内核</strong>：仅包含那些和硬件紧密结合的基本程序<ul><li>优点：内核功能最少，结构清晰，方便维护</li><li>缺点：需要频繁的在核心态和用户态之间切换，性能低</li></ul></li></ul><blockquote><p>微内核下的操作系统在工作下会一定程序影响效率</p></blockquote><h2 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h2><h3 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad15d73e37.png" alt="image-20230302215551314" style="zoom: 50%;" /><p>优点：</p><ol><li>便于调试和验证，自底向上逐层调试验证</li><li>易维护，各层之间调用接口清晰固定</li></ol><p>缺点：</p><ol><li>仅可调用相邻低层，难以合理定义各层的边界</li><li><strong>效率低，不可跨层调用，系统调用执行时间长</strong></li></ol><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad170c1ea7.png" alt="image-20230302215909296" style="zoom: 67%;" /><p>将内核划分为多个模块，各模块相互协作。</p><p>内核 &#x3D; 主模块 + 可加载内核模块</p><p>主模块：只负责核心功能，如进程调度，内存管理</p><p>可加载内核模块：可以动态加载新模块到内核，则无需重新编译整个内核；例如：驱动就是可加载内核模块。</p><p>优点：</p><ol><li>模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发</li><li>支持动态加载新的内核模块（如：安装设备驱动程序、安装新的文件系统模块到内核） ，增强OS适应性</li><li>任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高</li></ol><p>缺点：</p><ol><li>模块间的接口定义未必合理、实用</li><li>模块间相互依赖，更难调试和验证</li></ol><h3 id="宏内核（大内核）"><a href="#宏内核（大内核）" class="headerlink" title="宏内核（大内核）"></a>宏内核（大内核）</h3><p>所有的系统功能都放在内核里（大内核结构的OS通常也采用了“模块化”的设计思想）</p><h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>参考前面，此处略</p><h3 id="外核"><a href="#外核" class="headerlink" title="外核"></a>外核</h3><p><strong>内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全</strong>。</p><p>优点：</p><ol><li>外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源</li><li>减少了虚拟硬件资源的“映射层”，提升效率</li></ol><p>缺点：</p><ol><li>降低了系统的一致性</li><li>使系统变得更复杂</li></ol><h1 id="操作系统的引导"><a href="#操作系统的引导" class="headerlink" title="操作系统的引导"></a>操作系统的引导</h1><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad1786524d.png" alt="image-20230302221812022" style="zoom:80%;" /><ol><li>CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序（先进行硬件自检，再开机）</li><li>将磁盘的第一块——主引导记录读入内存，执行磁盘引导程序，扫描分区表</li><li>从活动分区（又称主分区，即安装了操作系统的分区）读入分区引导记录，执行其中的程序</li><li>从根目录下找到完整的操作系统初始化程序（即启动管理器）并执行，完成“开机”的一系列动作</li></ol><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>虚拟机：使用虚拟化技术，<strong>将一台物理机器虚拟化为多台虚拟机器</strong>（Virtual Machine，VM），每个虚拟机器都可以独立运行一个操作系统。</p><h2 id="VMM直接运行在硬件上"><a href="#VMM直接运行在硬件上" class="headerlink" title="VMM直接运行在硬件上"></a>VMM直接运行在硬件上</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad17dbee12.png" alt="image-20230302222124256" style="zoom:67%;" /><h2 id="VMM运行在宿主操作系统上"><a href="#VMM运行在宿主操作系统上" class="headerlink" title="VMM运行在宿主操作系统上"></a>VMM运行在宿主操作系统上</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/09/64aad183b2309.png" alt="image-20230302222346932" style="zoom:67%;" /><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>基本情况结束，希望复试顺利。</p>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>随记开发日志</title>
      <link href="/2023/01/23/%E5%BE%AE%E8%BD%AF%E5%A4%A9%E5%9D%91/WPF/%E9%9A%8F%E8%AE%B0%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
      <url>/2023/01/23/%E5%BE%AE%E8%BD%AF%E5%A4%A9%E5%9D%91/WPF/%E9%9A%8F%E8%AE%B0%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尝试开发第一个项目，详情可以查看<a href="https://helloseraphine.top:8090/s/about#toc-head-2">关于我的短期想法</a>，此文档是我的开发进度日志，希望我可以坚持到顺利开发更新。</p><h1 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h1><h2 id="想法第一版"><a href="#想法第一版" class="headerlink" title="想法第一版"></a>想法第一版</h2><p>采用侧边栏任务栏，将功能模块尽量缩小，让更多的内容专注于写作的右侧主模块。</p><p>右侧主模块默认主页是类似于气泡框的呈现形式，类似于小组件后续方便组件开发和排版。</p><p>配色采用经典白色，蓝色纯属是为了迎合背景图片，其他重要的功能压缩在设置中。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf63d2188b.png" alt="image-20230123233942176" style="zoom:80%;" /><h3 id="想法第二版"><a href="#想法第二版" class="headerlink" title="想法第二版"></a>想法第二版</h3><p>在尝试改进 UI 美化，参考了网上很多 UI 设计，做出来第二版的 UI 布局，相比于第一版的确美化程度上来说有质的飞跃，看起来更加的现代化，但是我个人感觉，这样的设计在增加美化的同时反而削弱了对写作记录本身的专注，使得使用者更加倾向于外观上的使用而不是写作内核的使用。</p><p>同样的右侧采用气泡框来展示每个内容，每个气泡框是一个小组件，用户可以自定义小组件的显示排序等，同样也可以根据我留下来的接口来开发其他小组件来完成首页的美化。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf643ee534.png" alt="image-20230123234218568" style="zoom:80%;" /><h2 id="想法第三版"><a href="#想法第三版" class="headerlink" title="想法第三版"></a>想法第三版</h2><p>思考了几天，这个软件的定位应该是“电子手账本”，软件设计的要灵活模块化，可以加载不同的 UI界面，不同的页面，以及插件。软件主体功能还是日记，日记事，计划，手账本以及记录一些自己的胡思乱想。</p><p>关于模块化的页面，我想到了“电子族谱”，用它来记录自己家庭成员或者好友的信息，照片，以及相关事件等，支持时间轴查看，例如和父母的生活日记，插入时间轴图片以及相关文字描述来专门记录自己和父母的时光，同样的也可以建立多个页面，例如和自己的好朋友以及对象的相关时间记录。</p><p>目前名字还在想新的名字，因为我一开始只是想做个现代化符合自己需求的日记本，但是目前考虑了一些，软件的定位变成了手账本，或者说“日记手账本”，其最基本的要求是单机数据归用户自己保存，开源支持拓展皮肤美化，插件拓展功能，免费跨平台，即使用<code>WebDav</code>协议可以实现跨平台软件。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf649524a5.png" alt="image-20230130180135535" style="zoom:50%;" /><h1 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h1><ul><li><p><input disabled="" type="checkbox"> 【2023&#x2F;6&#x2F;27】【15.00%】<br>如你所见，这个项目，目前砍掉了，在经过我毕设和毕业的忙活之后，就我要实现的功能和长期实用性来看，我认为继续用使用<code>WPF</code>技术来实现这个项目将会是一个错误且灾难性的。<br>目前来说，如果继续使用<code>C#</code>则需要掌握一定程度的<code>MAUI</code>并等待其开发稳定，或者我同样的使用<code>Electron</code>，即基于浏览器内核的开发。<br>产生如上想法，归根揭底还是源于我对于跨平台的执着，并且我认为这将是最优也是最终的解决方案。<br>在此时暂时封存项目，等到有机会的时候，再继续吧🫡</p><p>【2023&#x2F;2&#x2F;14】【15%】</p><ul><li><input checked="" disabled="" type="checkbox"> 使用了<code>LiteDB</code>作为软件的数据库，引用了<code>HandyControl</code>作为部分的控件实现，获取后期会作为一套UI样式供选择使用，使用了<code>LiveCharts2</code>作为图表统计的UI组件</li><li><input checked="" disabled="" type="checkbox"> 增加了日历模块的自定义控件</li><li><input checked="" disabled="" type="checkbox"> 修改了之前日记的UI和部分功能</li><li><input disabled="" type="checkbox"> 下一步解决日历的自定义控件的基本逻辑，然后就是数据库的事情，再然后就是串联起来实现基本的数据存储，读取和显示，再就是主页小组件模块的拓展，再然后就是设置的绑定，再然后就是 UI 样式和软件语言设置等配置文件的完善，再然后就是优化软件的逻辑，再然后就是更改日记的渲染模块（估计要在1.x版本才能实现了）</li></ul><p>【2023&#x2F;2&#x2F;13】【12%】</p><ul><li><input checked="" disabled="" type="checkbox"> 增加配置文件读写，准备绑定设置窗口</li><li><input checked="" disabled="" type="checkbox"> 增加日记文件目录读取</li><li><input checked="" disabled="" type="checkbox"> 合并<code>Beta</code>分支到<code>main</code>，准备下阶段的<code>Beta</code>功能性开发，目前仅仅实现了基本的<code>Markdown</code>写作和基本的UI，其他功能仍在开发中，任务较大，我在尝试尽量保持<code>MVVM</code>架构的条件下来支持开发</li></ul><p>【2023&#x2F;2&#x2F;12】【10%】</p><ul><li><input checked="" disabled="" type="checkbox"> 开发依赖升级<code>.NET4.8</code></li><li><input checked="" disabled="" type="checkbox"> 创建了<code>Beta</code>分支，此分支用于功能实验性开发测试，不保证支持更新</li><li><input checked="" disabled="" type="checkbox"> 使用了 <a href="httpss://github.com/cefsharp/CefSharp">CefSharp</a> 和 <a href="httpss://github.com/xoofx/markdig">markdig</a> 分别负责<code>markdown</code>文本转换和基础渲染工作，不过从<code>Beta</code>测试分支来看，仅仅处于能渲染的情况，对于美化的UI，我举得我需要我学习前端的内容（感觉要放弃这个项目）</li></ul><p>【2023&#x2F;2&#x2F;11】【5%】</p><ul><li><input checked="" disabled="" type="checkbox"> 修改了部分样式</li><li><input checked="" disabled="" type="checkbox"> 增加了相关空页面</li><li><input disabled="" type="checkbox"> 接下来的日历页面，我不得不重写一个自定义日历控件，这将耗费我不少的时间，因为涉及日历的算法比较麻烦</li><li><input disabled="" type="checkbox"> 第二大难点是利用<code>C#</code>来实现<code>Markdown</code>写作，我在想要么使用其他人的开源项目，我在我的软件嵌入<code>chrome</code>浏览器来实现写作解析，但是如果有很多自定义的功能就会很麻烦。第二个就是我自己推到重写写一个<code>C#</code>的<code>markdown</code>解析器，会很耗时间，但是我可以按照我自己的想法来更新</li></ul><p>【2023&#x2F;2&#x2F;3】【3%】</p><ul><li><input checked="" disabled="" type="checkbox"> 增加了设置页面</li><li><input checked="" disabled="" type="checkbox"> 美化并修改了页面内容，创建了相关样式</li></ul><p>【2023&#x2F;2&#x2F;2】【1%】</p><ul><li><input checked="" disabled="" type="checkbox"> 搭建了基本的 UI 框架</li><li><input checked="" disabled="" type="checkbox"> 自定义了两个基本的 UI 控件</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微软天坑 </category>
          
          <category> WPF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【2.0】XAML</title>
      <link href="/2023/01/05/%E5%BE%AE%E8%BD%AF%E5%A4%A9%E5%9D%91/WPF/%E3%80%902.0%E3%80%91XAML/"/>
      <url>/2023/01/05/%E5%BE%AE%E8%BD%AF%E5%A4%A9%E5%9D%91/WPF/%E3%80%902.0%E3%80%91XAML/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本来没打算写的，但是考虑到我的开源项目，我决定写一下当作复习了。</p><p>XAML（EXtensible Application Markup Language）是微软推出的对标 HTML 的标记语言，其本质就是<code>XML</code>的变体，微软在设计 WPF 的时候就学习了 HTML 的前后端分离的模式，这样就类比过来，WPF 技术，使用 XAML 作为前端，<code>C#</code>作为后端，分离了前后端，方便了团队合作和项目开发不必过于耦合。</p><h1 id="理解XAML"><a href="#理解XAML" class="headerlink" title="理解XAML"></a>理解XAML</h1><p>XAML编译</p><p>WPF 创建者知道，XAML 不仅要能仅仅设计协作的问题，它还需要快速运行。尽管 XML 格式可以很灵活的迁移到其他工具和平台，但是它们并不是最有效的选择。XML 的设计目标是逻辑性，易读性而且简单，且没有被压缩。</p><p>WPF 使用 BAML（Binary Application Markup Language，是一种二进制应用程序标记语言）来克服这个缺点。BAML 并不是新事物，它实际上就是 XAML 的二进制表示形式。在 Visual Studio 中编译 WPF 应用程序时，所有的 XAML 文件都被转换为 BAML，这些 BAML 然后作为资源嵌入到最终的 DLL 或者 EXE 程序集中。 BAML 是标记化的，这意味着较长的 XAML 被较短的标记代替。BAML 不仅明显小一些，还对其进行了优化，从而使得它更快的被解析。</p><p>大多数情况下，我们并不需要关心 XAML 相 BAML 的转换，因为编译器会在后台进行这些工作。但也可以使用未经编译的 XAML ，这对于需要即时提供一些用户界面的情况可能有意义的。</p><h1 id="XAML-基础"><a href="#XAML-基础" class="headerlink" title="XAML 基础"></a>XAML 基础</h1><p>XAML 的标准非常简单：</p><ul><li>XAML 文档中的每个元素都被映射为<code>.NET</code> 类的一个实例。元素名称也完全对应。例如元素<code>&lt;Button&gt;</code>对应 WPF的 <code>Button</code>对象</li><li>与所有的 XML 文档一样，可以在一个元素中嵌套另一个元素</li><li>可以通过特性（<em>attribute</em>）设置每个类的属性（<em>property</em>）</li></ul><p>在继续学习之前，现在来看一看下面的 XAML 文档基本框架：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Window</span> <span class="attr">x:Class</span>=<span class="string">&quot;WpfApp.MainWindow&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;https://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:x</span>=<span class="string">&quot;https://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">Title</span>=<span class="string">&quot;MainWindow&quot;</span> <span class="attr">Height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Grid</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Window</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该框架仅含有两个元素——顶级的<code>Window</code>元素以及一个<code>Grid</code>元素，<code>Window</code>元素代表整个窗口，在<code>Grid</code>元素中可以放置所有控件。尽管可以使用任何元素作为顶级元素，但是 WPF 应用程序只使用如下几个元素作为顶级元素：</p><ul><li><code>Window</code>元素</li><li><code>Page</code>元素（该元素定义应用程序与<code>Window</code>元素类型，但是它用于可导航的应用程序）</li><li><code>Application</code>元素（该元素定义应用程序资源和启动设置）</li></ul><p>与所有  XML 文档一样，<strong>在 XAML 文档中只能有一个顶级元素</strong>。在上述例子中，这意味着只要使用<code>&lt;/Window&gt;</code>标签关闭了<code>Window</code>元素，文档就结束了，在后面不能再有任何内容了。</p><p>查看<code>Windows</code>元素的开始标签，将会发现几个有趣的特性，包括一个类名和两个 XML 名称空间，还会发现三个属性，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Title=&quot;MainWindow&quot; Height=&quot;300&quot; Width=&quot;300&quot;</span><br></pre></td></tr></table></figure><p>这个特性对应<code>Window</code>类的一个单独的属性。其告诉 WPF 创建标题为 <code>MainWindow</code> 的窗口，窗口的大小为 $300 \times 300$ 个大小。</p><blockquote><p>注：$300 \times 300$并不是指的像素，而是 WPF 的屏幕计量单位</p></blockquote><h2 id="XAML-名称空间"><a href="#XAML-名称空间" class="headerlink" title="XAML 名称空间"></a>XAML 名称空间</h2><p>显然，只提供类名是不够的。XAML 解析器还需要知道类位于哪个 .NET 名称空间。例如，在许多名称空间中都有可能存在 <code>Window</code>类，或者说存在自定义的<code>Window</code>类等。为了区分实际上要使用哪个类，XAML 解析器还会检查应用于元素的 XML 名称空间。</p><p>下面是该机制的工作原理。上面的示例文档中存在如下两个名称空间：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlns=<span class="string">&quot;https://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="line">xmlns:x=<span class="string">&quot;https://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br></pre></td></tr></table></figure><p><strong><code>xmlns</code>特性是 XML 中的一个特殊特性，它专门用来声明名称空间</strong>。这段标记声明了两个名称空间，在创建的所有 WPF XAML 文档中都会有使用这两个名词空间。</p><ul><li><code>https://schemas.microsoft.com/winfx/2006/xaml/presentation</code>是 WPF 核心名词空间。<strong>它包含了所有 WPF 类，包括用来构建用户界面的控件</strong>。在该示例中，<strong>该名称空间的声明没有使用名称空间前缀，所以它成为整个文档的默认名称空间</strong>。换句话说，除非另行指明，每个元素默认自动位于这个名称空间。</li><li><code>https://schemas.microsoft.com/winfx/2006/xaml</code>是 XAML 名称空间。它包含各种 XAML实用特性，这些特性可影响文档的解释方式。该名称空间被映射为前缀<code>x</code>。这意味着可以通过元素名称之前放置名称空间前缀<code>x</code>来使用该名称空间，例如<code>x:ElementName</code>。</li></ul><p>正如前面看到的一样，XML 名称空间的名称和任何特定的 .NET 名称空间都不匹配。XAML的创建者选择这种设计有两个原因。按照约定，XML 名称空间通常是 URI。这种 URI 看起来像是指明 Web 上的位置，但是实际上不是。</p><p>另一个原因是 XAML 中使用 XML 名称空间和 .NET 名称空间不是一一对应的，如果一一对应的话，会明显增加 XAML 文档的复杂程度。所以，WPF 创建人员选择了这种方法，将所有的 .NET 名称空间组合到单个 XML 名称空间中。</p><h2 id="代码隐藏类"><a href="#代码隐藏类" class="headerlink" title="代码隐藏类"></a>代码隐藏类</h2><p>可以通过 XAML 构造用户界面，但为了使应用程序具有一定的功能，就需要用于链接包含应用程序代码的事件处理程序的方法。XAML 通过使用如下所示的 <code>Class</code>特性简化了这个问题：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x:Class=<span class="string">&quot;WpfApp.MainWindow&quot;</span></span><br></pre></td></tr></table></figure><p>在 XAML 名称空间的<code>Class</code>特性之前放置了名称空间前缀<code>x</code>，这意味着这是 XAML 语言中更通用的部分。实际上，<code>Class</code>特性告诉 XAML 解析器用指定的名称生成一个新类。</p><p><code>MainWindow</code>类是编译时自动生成的。我们也可以提供<code>MainWindow</code>的部分类，该部分类会自动和 XAML 的部分类结合在一起，这样这个部分类就完美的成为了事件处理程序代码的理想容器。</p><p><code>Visual Studio</code>会自动的帮助我们创建可以放置事件处理程序代码的部分类。例如:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WpfApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> MainWindow.xaml 的交互逻辑</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译应用程序的时候，定义用户界面的 XAML 被转换为 CLR 类型声明，这些类型声明与代码隐藏类文件（如<code>MainWindow.xaml.cs</code>）中的逻辑融合在一起，形成单一的单元。</p><h3 id="InitializeComponent-方法"><a href="#InitializeComponent-方法" class="headerlink" title="InitializeComponent()方法"></a>InitializeComponent()方法</h3><p>现在，<code>MainWindow</code>类尚不具有任何真正的功能。然而它确实包含一个重要的细节——默认构造函数，当创建类的一个实例的时候，该构造函数调用<code>InitializeComponent()</code>方法。</p><p><code>InitializeComponent()</code>方法在源代码中不可见，因为它是在编译程序的时候自动生成的。本质上，<code>InitializeComponent()</code>方法的所有工作就是调用<code>System.Windows.Application</code>类的<code>LoadComponent()</code>方法。<code>LoadComponent()</code>方法从程序集中提取 BAML ，并用它来构建用户界面。当解析 BAML 时，它会创建每个控件对象，设置其属性，并关联所有事件处理程序。</p><h3 id="命名元素"><a href="#命名元素" class="headerlink" title="命名元素"></a>命名元素</h3><p>还需要注意的一个细节，在代码隐藏类中，经常希望通过代码来操作控件。为了达到这个目的，控件必须包含 XAML <code>Name</code>特性。在上面的示例中，<code>Grid</code>控件没有包含<code>Name</code>特性，所以不能在代码隐藏类中对其进行操作。</p><p>下面的标记演示了如何为<code>Grid</code>控件关联名称：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Grid</span> <span class="attr">x:Name</span>=<span class="string">&quot;grid1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以直接在 XAML 文档中进行设置，也可以选择控件，在其属性面板中修改。</p><p>无论哪种方法，<code>Name</code>特性都会告诉 XAML 解析器将这样一个字段添加到 <code>MainWindow</code>类自动生成的部分。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> System.Windows.Controls.Grid grid1;</span><br></pre></td></tr></table></figure><p>现在就可以在<code>MainWindow</code>类的代码中，通过<code>grid1</code>名称和元素进行交互了。</p><h1 id="XAML中的属性和事件"><a href="#XAML中的属性和事件" class="headerlink" title="XAML中的属性和事件"></a>XAML中的属性和事件</h1><h2 id="简单属性与类型转换器"><a href="#简单属性与类型转换器" class="headerlink" title="简单属性与类型转换器"></a>简单属性与类型转换器</h2><p>现在如下一个文本示例，并为其设置了对齐方式，字体大小等属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">x:Name</span>=<span class="string">&quot;block1&quot;</span> <span class="attr">Text</span>=<span class="string">&quot;这是一行文本&quot;</span> <span class="attr">VerticalAlignment</span>=<span class="string">&quot;Center&quot;</span> <span class="attr">FontSize</span>=<span class="string">&quot;24&quot;</span> <span class="attr">HorizontalAlignment</span>=<span class="string">&quot;Center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">TextBlock</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了使得上面的属性设置起作用，对应的<code>TextBlock</code>类也必须有对应的属性，例如<code>FontSize</code>，<code>Text</code>等。</p><p>为了使这个系统顺利工作，XAML 解析器需要执行比表面看上去更多的工作。XML 特性中的值总是纯文本字符串。但是对应的属性可以是任何 .NET 类型。在上面的实例中，有字符串类型的<code>Text</code>，整型的<code>FontSize</code>等。</p><p>为了关联字符串的值和非字符串的属性，XAML 解析器需要进行转换。由类型转换器执行类型转换。在这个过程中，类型转换器起到了很重要的作用，它负责将特定的 .NET 类型转换为任意其他 .NET 类型，或者将任何其他 .NET 类型转换为特定的 .NET 类型。</p><blockquote><p>XAML 区分大小写，这意味着<code>&lt;Button&gt;</code>不等同于<code>&lt;button&gt;</code>，但是类型转换器并不区分大小写，这就意味着<code>Foreground=&quot;White&quot;</code>等同于<code>Foreground=&quot;white&quot;</code>。</p></blockquote><h2 id="复杂属性"><a href="#复杂属性" class="headerlink" title="复杂属性"></a>复杂属性</h2><p>虽然类型转换器便于使用，但是它并不能解决所有问题。例如：有些属性是完备的对象，这些对象具有自己的一组属性。尽管创建供类型转换器使用的字符串表示的形式是可能的，但是语法可能十分复杂，且容易出错。</p><p>幸运的是，XAML 提供了另一种选择：属性元素语法。<strong>使用属性元素语法，可以添加名称为<code>Parent.PropertyName</code>的子元素</strong>。例如：<code>Grid</code>控件有一个<code>Background</code>属性，该属性允许提供用于绘制背景的画刷。如果希望使用复杂的画刷——就需要添加名称为<code>Grid.Background</code>的子标签。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Grid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Grid.Background</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid.Background</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有一个细节就是，一旦识别出来要配置的复杂属性，该如何设置的问题。这里有一个技巧就是<strong>可以在嵌套元素内部添加其他标签来实例化特定的类</strong>。例如在上述示例中，为了定义需要的渐变颜色，需要创建<code>LinearGradientBrush</code>对象，代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Grid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Grid.Background</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearGradientBrush</span>&gt;</span><span class="tag">&lt;/<span class="name">LinearGradientBrush</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid.Background</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是，只创建一个<code>LinearGradientBrush</code>对象还不够，还需要指定其他的渐变色。需要通过<code>GradientStop</code>对象的集合填充属性<code>LinearGradientBrush.GradientStops</code>来完成这个工作。代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Grid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Grid.Background</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearGradientBrush</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinearGradientBrush.GradientStops</span>&gt;</span></span><br><span class="line">                </span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearGradientBrush.GradientStops</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearGradientBrush</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid.Background</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后可以使用一系列的<code>GradientStop</code>对象填充<code>GradientStops</code>集合。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Grid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Grid.Background</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearGradientBrush</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinearGradientBrush.GradientStops</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">GradientStop</span> <span class="attr">Offset</span>=<span class="string">&quot;0&quot;</span> <span class="attr">Color</span>=<span class="string">&quot;Red&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">GradientStop</span> <span class="attr">Offset</span>=<span class="string">&quot;0.5&quot;</span> <span class="attr">Color</span>=<span class="string">&quot;Black&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">GradientStop</span> <span class="attr">Offset</span>=<span class="string">&quot;1&quot;</span> <span class="attr">Color</span>=<span class="string">&quot;Yellow&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearGradientBrush.GradientStops</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearGradientBrush</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid.Background</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，任何的 XAML 标签都可以直接使用<code>C#</code>代码来直接实现，上述代码等价于下面的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LinearGradientBrush linearGradientBrush = <span class="keyword">new</span> LinearGradientBrush();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象GradientStop,并定义属性加入到集合中</span></span><br><span class="line">GradientStop gradientStop1 = <span class="keyword">new</span> GradientStop();</span><br><span class="line">gradientStop1.Offset = <span class="number">0</span>;</span><br><span class="line">gradientStop1.Color = Colors.Red;</span><br><span class="line">linearGradientBrush.GradientStops.Add(gradientStop1);</span><br><span class="line"></span><br><span class="line">GradientStop gradientStop2 = <span class="keyword">new</span> GradientStop();</span><br><span class="line">gradientStop2.Offset = <span class="number">0.5</span>;</span><br><span class="line">gradientStop2.Color = Colors.Black;</span><br><span class="line">linearGradientBrush.GradientStops.Add(gradientStop2);</span><br><span class="line"></span><br><span class="line">GradientStop gradientStop3 = <span class="keyword">new</span> GradientStop();</span><br><span class="line">gradientStop3.Offset = <span class="number">1</span>;</span><br><span class="line">gradientStop3.Color = Colors.Yellow;</span><br><span class="line">linearGradientBrush.GradientStops.Add(gradientStop3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置Grid元素的背景属性</span></span><br><span class="line">grid1.Background = linearGradientBrush;</span><br></pre></td></tr></table></figure><h2 id="标记扩展"><a href="#标记扩展" class="headerlink" title="标记扩展"></a>标记扩展</h2><p>对大多数属性而言，XAML 属性语法已经可以很好的工作了。但是有有些情况下，不能硬编码属性值。例如，可能希望将属性值设置为一个已经存在的对象，或者可能希望通过将一个属性绑定到另一个控件上来动态的控制属性值。这种情况都需要使用标记扩展——一种以非常规的方法设置属性的专门语法。</p><p>标记扩展可以用于嵌套标签或者 XML 特性中。当用在特性中是采用花括号包围起来。例如，下面的标记，它允许引用另一个类中的静态属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Foreground</span>=<span class="string">&quot;&#123;x:Static SystemColors.ActiveBorderBrush&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>标记扩展的语法：<code>&#123;标记扩展类 参数&#125;</code>。上述实例标记扩展时<code>StaticExtension</code>类，根据约定，在引用扩展类时可以省略最后一个单词<code>Extension</code>。</p><p>因为标记扩展映射为类，所以它们也可以作嵌套属性，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextBlock.Foreground</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">x:Static</span> <span class="attr">Member</span>=<span class="string">&quot;SystemColors.ActiveBorderBrush&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">x:Static</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TextBlock.Foreground</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和大多数标记扩展一样，<code>StaticExtension</code>需要在运行时赋值，因为只有在运行时才能缺点当前系统的颜色。</p><h2 id="附加属性"><a href="#附加属性" class="headerlink" title="附加属性"></a>附加属性</h2><p>除了普通属性外，XAML 还包括附加属性——<strong>附加属性是可以用于多个控件但是在另一个类中定义的属性</strong>。在 WPF 中，附加属性常用于控件布局。</p><blockquote><p>此处省略附加属性的详细说明，一般是<code>Grid</code>属性的排列位置需要附加指定，本质是调用<code>Grid</code>类的静态方法</p></blockquote><h2 id="嵌套元素"><a href="#嵌套元素" class="headerlink" title="嵌套元素"></a>嵌套元素</h2><p>XAML 通 HTML 整个就是一个嵌套的元素树，具体嵌套是根据元素所继承的不同接口或者方法来实现的，详细自行查询，此处也不做过多赘述。</p><h2 id="特殊字符与空白"><a href="#特殊字符与空白" class="headerlink" title="特殊字符与空白"></a>特殊字符与空白</h2><p>XAML 受制于 XML 规则的限制。例如：XML 关注一些特殊字符，例如 &amp;，&lt; 和 &gt; 。如果试图使用这些字符设置元素的内容，会遇到一定的麻烦，因为解析器可能会认为你在创建其他事情，例如嵌套元素。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button&gt; </span><br><span class="line">&lt;这是一行字&gt;</span><br><span class="line">&lt;/Button&gt;</span><br></pre></td></tr></table></figure><p>这个地方当你想要创建一个<code>Button</code>含有文字<code>&lt;这是一行字&gt;</code>解决问题的方法就是使用实体引用代替特殊字符，<strong>实体引用是 XAML 解析器能够正确解释特定字符的编码</strong>。如下：</p><table><thead><tr><th align="center">特殊字符</th><th align="center">字符实体</th></tr></thead><tbody><tr><td align="center">小于号（&lt;）</td><td align="center"><code>&amp;lt;</code></td></tr><tr><td align="center">大于号（&gt;）</td><td align="center"><code>&amp;gt;</code></td></tr><tr><td align="center">&amp;</td><td align="center"><code>&amp;amp;</code></td></tr><tr><td align="center">引号（”）</td><td align="center"><code>&amp;quot;</code></td></tr></tbody></table><p>下面是正确使用实体引用实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span>&gt;</span> <span class="symbol">&amp;lt;</span><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>特殊字符并非使用 XAML 的唯一障碍。另一个问题是空白的处理。<strong>默认情况下，XAML 折叠所有空白</strong>，这就意味着空格，Tab 键以及硬回车的长字符都会被转换为单个空格。而且，如果在元素内容之前或者之后添加空白，将会被完全忽略这个空格。</p><p>有时候这并不是我们所期望的。例如：我们可能希望文本内容含有一系列的空格。在这种情况下，就需要为元素使用<code>xml:space=&quot;preserve&quot;</code>。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button xml:space=<span class="string">&quot;preserve&quot;</span>&gt;这是       很多空格&lt;/Button&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，这个问题只会在 XAML 标记中存在。如果通过代码来设置文本则不会出现这种情况。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>到目前为止，介绍的所有特性都被映射为属性。然而，特性也可以用于关联事件处理程序，语法为：<code>事件名称=事件处理程序方法名</code>。</p><blockquote><p>注：关于事件详细不再赘述，如果你了解过微软的相关开发技术相信都了解一二</p></blockquote><h1 id="使用其他名称空间中的类型"><a href="#使用其他名称空间中的类型" class="headerlink" title="使用其他名称空间中的类型"></a>使用其他名称空间中的类型</h1><p>前面介绍了如何在 XAML 中使用 WPF 中的类来创建基本的用户界面。但是 <strong>XAML 是实例化 .NET 对象的通用方法</strong>，包括那些位于其他非 WPF 名称空间以及自己创建的名称空间的对象。</p><p>为使用未在 WPF 名称空间中定义的类，需要将 .NET 名称空间映射到 XML 名称空间，XAML 有一种特殊的语法可用于完成这一工作，语法示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:Prefix=&quot;clr-namespace:Namespace;assembly=AssemblyName&quot;</span><br></pre></td></tr></table></figure><p>通常，在 XAML 文档的根元素中，在紧随声明 WPF 和 XAML 名称空间的特性之后放置这个名称空间。还需要使用适当的信息填充这三个部分，其含义如下：</p><ul><li>**<code>Prefix</code>**：是希望在 XAML 标记中用于指示名称空间的 XML 前缀。例如：XAML 语言使用<code>x</code>作为前缀</li><li>**<code>Namespace</code>**：是完全限定的 .NET 名称空间的名称</li><li>**<code>AssemblyName</code>**：是声明类型的程序集，没有<code>.dll</code>扩展名。这个程序集必须在项目中引用。如果希望使用项目程序集，则可以忽略这一部分。</li></ul><p>例如，下面的标记演示了如何访问<code>System</code>名称空间中的基本类型，并将其映射到前缀<code>sys</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:sys=&quot;clr-namespace:System;assembly=mscorlib&quot;</span><br></pre></td></tr></table></figure><p>下面标记演示了如何访问当前项目在 <code>MyProkect</code> 名称空间中声明的类型，并将它们映射到<code>local</code>前缀中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:local=&quot;clr-namespace:MyObject&quot;</span><br></pre></td></tr></table></figure><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>介绍了 XAML 的基本语法和一些特性，还有一些深入的底层原理和内容需要自行研究。</p>]]></content>
      
      
      <categories>
          
          <category> 微软天坑 </category>
          
          <category> WPF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【基础 02】构建函数可视化图形</title>
      <link href="/2022/09/18/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/Catlike%20Coding/Basics/%E3%80%90%E5%9F%BA%E7%A1%80%2002%E3%80%91%E6%9E%84%E5%BB%BA%E5%87%BD%E6%95%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E5%BD%A2/"/>
      <url>/2022/09/18/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/Catlike%20Coding/Basics/%E3%80%90%E5%9F%BA%E7%A1%80%2002%E3%80%91%E6%9E%84%E5%BB%BA%E5%87%BD%E6%95%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>前排说明：关于本教程目录导航以及说明：<a href="httpss://www.helloseraphine.top/2022/09/11/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E7%8C%AB%E5%BC%8F%E6%95%99%E7%A8%8B/">猫式教程</a></strong></p></blockquote><p>在本篇文章中你将会学到：</p><ul><li><input checked="" disabled="" type="checkbox"> <strong>创建一个预制体（<em>prefab</em>）</strong></li><li><input checked="" disabled="" type="checkbox"> <strong>实例化（<em>Instantiate</em>）多个立方体</strong></li><li><input checked="" disabled="" type="checkbox"> <strong>图形化一个数学函数</strong></li><li><input checked="" disabled="" type="checkbox"> <strong>创建<em>surface shader and shader graph</em></strong></li><li><input checked="" disabled="" type="checkbox"> <strong>将图形赋予动画</strong></li></ul><p>这是有关学习和使用 Unity 基础知识系列教程的第二篇。这次我们将会使用基本的游戏对象（物体）来构建函数图形，我们可以通过图形来展示（图形化）数学函数。同时我们将会使用函数和时间进行关联创建对应的动画。</p><p>本篇教程使用<code>Unity 2020.3.38f1c1</code> 编写。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf84481c2a.png" alt="image-20220918103315837" style="zoom:80%;" /><h1 id="创建一排”点”"><a href="#创建一排”点”" class="headerlink" title="创建一排”点”"></a>创建一排”点”</h1><p>对数学的理解是编程所必不可少的。<strong>从表面上来说，数学是对表示数值的符号（即未知数）的操作</strong>。求解方程归结为一组符号（即方程）。数学规则（即函数定义）决定了这种结果。</p><p>例如，我们使用函数 $F(x) &#x3D; X +1$ ，现在我们使用数值 $3$ 来替代 $X$ 的位置，你就可以得到输出为 $F(x) &#x3D; 3 + 1 &#x3D; 4$ 。我们可以说通过函数  $F(x) &#x3D; X +1$  将数值 $3$ 映射到 数值 $4$ 上。当然，你可以通过如下的方式进行更短的缩写，例如：$(3,4)$ ；基于此我们可以写出更多的形式 $(X,F(x))$ 的映射，例如：$(5,6)$ 等。</p><p>对于函数 $F(x) &#x3D; X +1$ 相对容易理解，但是对于函数 F(X)&#x3D; $ (X-1)^ {4} $ + $ 5X^ {3} $ - $ 8X^ {2} $ +3X 理解起来会相对困难一些。当然我们也可以通过上述函数的方法，来写出其对应的映射对（即 $(X,F(X))$ 形式的映射结果），但是离散有限的映射对可能无法让我们很好的理解该函数。因此我们需要很多个点，来形成无数的映射对结果。相反的，我们也可以将这些映射转换成二维坐标 $[x,f(x)]$ 来展示。其中坐标的数值表示 $X$ 轴上的水平坐标，右边的数值表示 $Y$ 轴上的垂直坐标，<strong>我们可以通过大量的映射结果，来最终得到一条映射结果图</strong>，如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8512a10e.png" alt="image-20220918105143493" style="zoom: 67%;" /><blockquote><p>图形由 <a href="httpss://www.desmos.com/calculator/di84egsf7a?lang=zh-CN">Desmos</a> 绘制</p></blockquote><p>查看函数的图形可以让我们快速理解函数的行为结果。这是一个很方便的工具，现在来让我们在 Unity 中创建一个。现在我们将会从一个新项目开始创建。</p><h2 id="创建预制体-Prefabs"><a href="#创建预制体-Prefabs" class="headerlink" title="创建预制体(Prefabs)"></a>创建预制体(Prefabs)</h2><p>通过上面我们知道了可以在适当的坐标上来放置（生成）点来生成图形。所以我们需要一个可视化的“点”。为此，我们选择使用 Unity 中最基本的游戏对象（物体），即立方体。现在<strong>在场景中创建一个立方体并命名为 <code>Point</code> ，同时删除它的 <code>BoxColoder</code> 组件（<em>component</em>）</strong>，因为我们不会使用它的物理特性。</p><p>【<strong>立方体是可视化图形的最佳方式吗</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你也可以使用粒子系统或者线段，但是立方体是最容易使用的</span><br></pre></td></tr></table></figure><p>我们将使用一个自定义的组件（脚本）来创建这个立方体的许多实例并正确的定位它们的位置。为了做到这一点，我们需要通过<strong>将立方体<code>point</code>从层次结构窗口（<em>Hierarchy</em>）拖动到项目（<em>Project</em>）面板中</strong>将其<strong>转换成一个游戏对象（物体）的模板</strong>。这将会创建一个新的资源对象（<em>Assets</em>），其被称为<strong>预制体</strong>（<em>Prefab</em>）。它代表着已经预先制作好的游戏对象，属于这个项目中，而不单单是某个场景中。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf85589d0b.png" alt="image-20220918111102016" style="zoom:80%;" /><p>现在你会发现我们创建的预制体的游戏对象依旧存在于场景（<em>Scene</em>）中，但是它现在已经变成了一个预制体了。它<strong>在结构层次面板（<em>Hierarchy</em>）中变成了一个蓝色的图标</strong>，右侧存在一个箭头图标。其检查器面板（<em>Inspector</em>）标题栏部分也表明了该物体是一个预制体并且会多出一部分可选择按钮。位置（<em>Position</em>）和旋转（<em>Rotation</em>）现在也以粗体来显示，这表面实例对象（物体）的值覆盖了预制体的值。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf85a421a4.png" alt="image-20220918111640415" style="zoom:80%;" /><p>当你在项目资源面板（<em>Project</em>）中查看预制体的检查器面板（<em>Inspector</em>）将显示其根游戏对象和一个用于打开预制体（<em>Open Prefab</em>）的按钮。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf85ea4810.png" alt="image-20220918111843039" style="zoom:80%;" /><p>单击 <strong>【Open Prefab】</strong> 按钮会在场景（<em>Scene</em>）中显示一个只包含预制体（<em>Prefab</em>）的场景。你也可以通过点击层次结构面板（<em>Hierarchy</em>）预制体实例右侧的小箭头，或者双击项目资源面板（<em>Project</em>）中的预制体进入预制体（<em>Prefab</em>）场景。当我们制作复杂层次结构的预制体的时候，这会很有帮助，但是对于目前情况来说，并不需要。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf862e77a0.png" alt="image-20220918160846361" style="zoom:80%;" /><blockquote><p>你可以通过上图左侧的箭头退出预制体（<em>Prefab</em>）场景</p></blockquote><p>【<strong>为什么预制体场景的背景是统一的深蓝色</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果你是通过项目资源面板（Project）的预制体进入的预制体场景，则其默认是关闭天空盒（Skybox）的。</span><br><span class="line">如果你是通过层次结构面板（Hierarchy）进入的预制体场景，则默认是有天空盒（Skybox）的</span><br><span class="line">你也可以通过场景工具栏上，类似于堆栈上面有颗星星的图标进行设置</span><br></pre></td></tr></table></figure><p><strong>预制体（<em>Prefab</em>）是快速配置游戏对象的快捷方式</strong>。如果你修改了项目资源面板（<em>Project</em>）中的预制体，则场景中的所有实例都会以相同的方式进行修改。此外，你<strong>可以通过修改实例的值，来覆盖预制体（<em>Prefab</em>）的值</strong>。</p><blockquote><p>需要注意的是：在播放模式（<em>Play</em>）下，预制体和实例的影响关系会被暂时解除</p></blockquote><p>接下来，我们将使用脚本来创建我们设置好的预制体（<em>Prefab</em>）实例，这意味着我们现在并不需要使用场景中的这个预制体（<em>Prefab</em>）实例了，所以可以删除它了。</p><h2 id="创建图形组件-类"><a href="#创建图形组件-类" class="headerlink" title="创建图形组件(类)"></a>创建图形组件(类)</h2><p>现在我们需要创建一个<code>C#</code>脚本来使用我们创建的预制体来生成相关图形。创建脚本并命名为<code>Graph</code>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8673ef87.png" alt="image-20220918162140215" style="zoom:80%;" /><p>我们从最简单的类（<em>Class</em>）开始，<strong>其继承自 <a href="https://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html">MonoBehaviour</a> ，这样它就可以作为组件附加到游戏对象上</strong>。现在来创建一个可序列化字段来保存对实例化点的预制体的引用，名称为<code>pointPrefab</code>。因为我们需要访问 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Transform.html">Transform</a> 组件来控制物体的位置，所以字段的类型为 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Transform.html">Transform</a> 。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Graph</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    Transform pointPrefab;  <span class="comment">//序列化 Transform 类型的字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在在场景中添加一个空的游戏对象（<em>Empty</em>）并为其命名 <code>Graph</code>，确保它的位置（<em>Postiion</em>）和旋转（<em>Rotation</em>）为 0 ，且物体缩放（<em>Scale</em>）为 1 。现在将我们创建的脚本作为组件添加到这个对象上，然后将我们创建的预制体拖到 <em>point Prefab</em> 字段上，完成对预制体的引用。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf86ad8716.png" alt="image-20220918163300842" style="zoom:80%;" /><h2 id="实例化预制体"><a href="#实例化预制体" class="headerlink" title="实例化预制体"></a>实例化预制体</h2><p><strong>实例化（<em>Instantiate</em>）游戏对象是通过 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Object.html">Object</a>.<a href="https://docs.unity3d.com/Documentation/ScriptReference/Object.Instantiate.html">Instantiate</a> 来实现的</strong>。这是 Unity 为开发者提供的公开可用的方法，通过其基类为 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Object.html">Object</a> 以及类继承自 <a href="https://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html">MonoBehaviour</a> （这段的意思是物体的基类是<code>Object</code>类型可以实例化，但是要调用实例化代码需要将类继承自 <code>MonoBehaviour</code>来完成组件化）。<strong>该方法会创建一个预制体实例对象在场景中</strong>。现在我们在组件唤醒的时候执行该操作，代码示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Graph</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    Transform pointPrefab;  <span class="comment">//序列化 Transform 类型的字段</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Object.Instantiate(pointPrefab);<span class="comment">//实例化预制体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【<strong>关于<code>MonoBehaviour</code>的完整继承关系是什么？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MonoBehaviour 继承自 Behaviour，而 Behaviour 继承自 Component</span><br><span class="line">Component 继承自 Object</span><br></pre></td></tr></table></figure><p>如果我们现在进行播放模式（<em>Play</em>）则在开始的时候在世界原点生成一个预制体实例。它的名称和预制体的名称相同，你可以在层次结构面板（<em>Hierarchy</em>）中带有<code>(clone)</code>名称标识找到它。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf86f32741.png" alt="image-20220918164425639" style="zoom:80%;" /><p>要将该预制体实例移动到其他位置，我们需要调整实例的位置。<strong>而<code>Instantiate</code>方法为我们提供了其创建的内容的引用。因为我们给它传入的参数类型是<code>Transform</code>类型的引用，所以其方法的返回值也是创建实例的<code>Transform</code>类型</strong>。现在我们来使用一个变量来获取到创建的实例的值。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：我仅对修改代码的部分进行展示，未修改的代码和之前一样</p></blockquote><p>在第一篇教程中，我们使用了<code>localRotation</code>将四元数分配给时针轴来改变时钟臂的旋转。现在同样的，不过不太一样的是我们需要使用<code>localPosition</code>来向其分配一个三维向量来改变位置。</p><p>三维向量使用 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Vector3.html">Vector3</a> 类型创建。例如，现在我们将点的 X 坐标设置为 1，将其 Y 和 Z 设置为 0 。<a href="https://docs.unity3d.com/Documentation/ScriptReference/Vector3.html">Vector3</a> 类型有一个<code>right</code>属性给我们提供了这样的一个向量，现在我们来使用它设置点的位置。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">    point.localPosition = Vector3.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8737d1fc.png" alt="image-20220918170100345" style="zoom:80%;" /><p>现在进入播放模式后，我们依然会得到一个立方体，只是位置和之前有所不同。现在我们进行实例化第二个预制体对象。并将其向右移动两个单位。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">    point.localPosition = Vector3.right;</span><br><span class="line"></span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">    point.localPosition = Vector3.right*<span class="number">2f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现上述代码编译器会报错，这是因为我们尝试定义同一个变量两次，或者你可以理解为变量名称重复了。所以我们需要修改变量的名称来使用它，或者我们不使用该变量，继续使用之前定义的<code>point</code>变量。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">    point.localPosition = Vector3.right;</span><br><span class="line"></span><br><span class="line">    point = Instantiate(pointPrefab);</span><br><span class="line">    point.localPosition = Vector3.right*<span class="number">2f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8781aac2.png" alt="image-20220918170706876" style="zoom:80%;" /><h2 id="循环创建"><a href="#循环创建" class="headerlink" title="循环创建"></a>循环创建</h2><p>现在让我们创建更多的点一直到十个。我们可以通过重复上述代码 8 遍，但是这样是一种低效的编程，我们需要使用尽可能少的代码，让代码多次执行来完成。</p><p>现在使用<code>while</code>语句来使代码块重复执行。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        Transform point = Instantiate(pointPrefab);</span><br><span class="line">        point.localPosition = Vector3.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>while</code>关键词必须后面跟着圆括号内的表达式。只有圆括号内的表达式计算结果为真（<em>True</em>）时，才会执行后面代码块的内容。之后，程序会再次回到<code>while</code>语句，再次判断圆括号内的表达式结果，如果为真，则继续执行，如此重复。但是需要注意的是，要确保循环不会永远重复，即不会产生无限循环导致程序卡住，最安全的编译是使用关键词<code>false</code>，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">    point.localPosition = Vector3.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们可以通过追踪代码的执行次数来限制其重复的次数。我们来创建一个<code>int</code>类型的变量命名为<code>i</code>，其初始值为 0 ，为了能够在<code>while</code>语句中迭代使用，我们需要将其定义在<code>while</code>语句的上面。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">        Transform point = Instantiate(pointPrefab);</span><br><span class="line">        point.localPosition = Vector3.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们进入播放模式（<em>play</em>）会得到十个立方体，但是它们的位置是相同的。现在我们将其排成一排正方体，来将其<code>right</code>属性乘以变量<code>i</code>，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">point.localPosition = Vector3.right * i;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf87cf04df.png" alt="image-20220918172011291" style="zoom:80%;" /><p>需要注意的是，这样创建的立方体，第一个的位置在 1 ，而最后一个立方体的位置在 10 。现在让我们对其做修改，来让其从 0 开始。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">    point.localPosition = Vector3.right*i;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简化代码"><a href="#简化代码" class="headerlink" title="简化代码"></a>简化代码</h2><p>代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        Transform point = Instantiate(pointPrefab);</span><br><span class="line">        point.localPosition = Vector3.right*i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更改实例化范围"><a href="#更改实例化范围" class="headerlink" title="更改实例化范围"></a>更改实例化范围</h2><p>现在我们实例化 X 的坐标范围为 $0 \sim 9$ 。通常使用函数来说，我们一般使用 $0 \sim 1$ 的范围，或者说以零为中心的范围，即 $-1 \sim 1$ 。现在来让我们重新定位我们的点。</p><p>如果我们在不改变立方体的大小的情况下，将十个立方体放置在 $0 \sim 2$ 的位置范围中，会导致它们相互重叠。为了解决这种情况，我们将其大小缩小。默认情况下，立方体的维度大小为 1 。将其映射到 2 的范围中，则其大小比例应该为 $\frac{2}{10} &#x3D; \frac{1}{5}$ 。我们已通过将每个点的局部大小（通过属性<code>Vector3.one</code>）比例除以 5 来实现。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">    point.localPosition = Vector3.right*i;</span><br><span class="line">    point.localScale = Vector3.one / <span class="number">5f</span>;<span class="comment">//缩小5分之1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以通过切换场景（<em>Scene</em>）面板的正交透视模式来查看其相对位置。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf881402bd.png" alt="image-20220918173512783" style="zoom:80%;" /><p>要将立方体重新聚合在一起（指并排排一排），需要将其位置也除以 5 。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">    point.localPosition = Vector3.right*i / <span class="number">5f</span>;<span class="comment">//位置也除以5</span></span><br><span class="line">    point.localScale = Vector3.one / <span class="number">5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样使得其生成范围为 $0 \sim 2$ 。要使其范围为 $-1 \sim 1$ ，则将其位置再 $-1$。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">point.localPosition = Vector3.right* (i / <span class="number">5f</span> <span class="number">-1f</span>);</span><br></pre></td></tr></table></figure><p>现在第一个立方体的坐标为 -1 ，而最后一个立方体的坐标为 0.8 。这是因为立方体的大小为 0.2，即在其位置的左右各占 0.1 的宽度。所以只需要将其向右移动一般宽度距离即可，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">point.localPosition = Vector3.right* (i + <span class="number">0.5f</span> / <span class="number">5f</span> <span class="number">-1f</span>);</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf886972cf.png" alt="image-20220918174537522" style="zoom:80%;" /><h2 id="优化代码结构"><a href="#优化代码结构" class="headerlink" title="优化代码结构"></a>优化代码结构</h2><p>因为所有立方体最后是相同的大小比例，所以我们不需要每次都要计算新实例的大小。只需要计算一次即可，然后将其存储在变量<code>scale</code>中，循环使用它即可。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scale = Vector3.one / <span class="number">5f</span>;<span class="comment">//提到外面，仅计算一次即可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">    point.localPosition = Vector3.right* ((i + <span class="number">0.5f</span>) / <span class="number">5f</span> <span class="number">-1f</span>);</span><br><span class="line">    point.localScale = scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以在循环之前顶一个变量，当我们沿 X 轴创建一条线的时候，只需要调整点对应 X 的坐标即可。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vector3 position;   <span class="comment">//位置变量</span></span><br><span class="line"><span class="keyword">var</span> scale = Vector3.one / <span class="number">5f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">    position.x = ((i + <span class="number">0.5f</span>) / <span class="number">5f</span> - <span class="number">1f</span>);    <span class="comment">//计算点的 X 轴的位置</span></span><br><span class="line">    point.localPosition = position; <span class="comment">//将实例物体位置调整到计算好的位置</span></span><br><span class="line">    point.localScale = scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【<strong>我可以单独修改向量吗</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector3 类型结构有三个浮点类型字段：x，y和z。这些字段是公开的（Public），因此我们可以单独更改它们。</span><br></pre></td></tr></table></figure><p>如果你编译上述的代码，你会发现编译器给我们报错了，它告诉我们使用了未赋值的变量，这是因为我们只对变量<code>position</code>的 X 轴分量进行了赋值，而 Y 和 Z 轴的分量并未赋值，而编译器不知道应该给它们什么值。所以我们可以通过给变量<code>position</code>赋值零向量（即X,Y,Z全为0）来解决这个问题。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> position = Vector3.zero;   <span class="comment">//位置变量</span></span><br><span class="line"><span class="keyword">var</span> scale = Vector3.one / <span class="number">5f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">    position.x = ((i + <span class="number">0.5f</span>) / <span class="number">5f</span> - <span class="number">1f</span>);    <span class="comment">//计算点的 X 轴的位置</span></span><br><span class="line">    point.localPosition = position; <span class="comment">//将实例物体位置调整到计算好的位置</span></span><br><span class="line">    point.localScale = scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-X-映射-Y-的值"><a href="#使用-X-映射-Y-的值" class="headerlink" title="使用 X 映射 Y 的值"></a>使用 X 映射 Y 的值</h2><p>和我们在开头说的那样，Y 可以通过 X 表达式来建立相关的映射关系。现在来让 Y 轴的映射结果和 X 轴的值相同，这样就会产生一条线性的线，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> position = Vector3.zero;   <span class="comment">//位置变量</span></span><br><span class="line"><span class="keyword">var</span> scale = Vector3.one / <span class="number">5f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">    position.x = ((i + <span class="number">0.5f</span>) / <span class="number">5f</span> - <span class="number">1f</span>);    <span class="comment">//计算点的 X 轴的位置</span></span><br><span class="line"></span><br><span class="line">    position.y = position.x;    <span class="comment">//Y 轴的值由 X 的值映射</span></span><br><span class="line"></span><br><span class="line">    point.localPosition = position; <span class="comment">//将实例物体位置调整到计算好的位置</span></span><br><span class="line">    point.localScale = scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf88c0ac9e.png" alt="image-20220918184246912" style="zoom:80%;" /><p>现在来对代码做稍微改动，使其映射为 $F(X) &#x3D; X^2$ ，这个映射的表达式表示的是一条抛物线，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position.y = position.x*position.x;    <span class="comment">//Y 轴新的映射</span></span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8905aaaa.png" alt="image-20220918184529915" style="zoom:80%;" /><h1 id="创建更多的”点”"><a href="#创建更多的”点”" class="headerlink" title="创建更多的”点”"></a>创建更多的”点”</h1><p>尽管我们现在有了一个函数的图形化，但是它看起来相当简陋。这是因为我们只使用了十个立方体（“点”），所以其结果看起来十分离散。如果我们使用更多更小的立方体的话结果会更加好看。</p><h2 id="动态修改”点”数"><a href="#动态修改”点”数" class="headerlink" title="动态修改”点”数"></a>动态修改”点”数</h2><p>现在我们为立方体的数目做字段序列化，而不是之前固定数量的立方体。现在定义一个<code>int</code>类型变量<code>resolution</code>默认值为 10 ，也就是目前定义的 10 个立方体。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="built_in">int</span> resolution = <span class="number">10</span>;    <span class="comment">//立方体的数量</span></span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf89503c83.png" alt="image-20220918191843839" style="zoom:80%;" /><p>现在我们可以通过检查器面板（<em>Inspector</em>）来修改”点”数了，但是并非所有的值都是有效的点数。所以我们需要为检查器面板增加一个数值范围，可以通过其 <a href="https://docs.unity3d.com/Documentation/ScriptReference/RangeAttribute.html">Range</a> 属性附加来完成。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField,Range(10,100)</span>]</span><br><span class="line"><span class="built_in">int</span> resolution = <span class="number">10</span>;    <span class="comment">//立方体的数量</span></span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf898ac45f.png" alt="image-20220918192642939" style="zoom:80%;" /><p>【<strong>这能否保证<code>resolution</code>其值范围限制了 $10 \sim 100$ ？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Range属性仅仅检查我们在检查器面板（Inspector）的改动，它不会影响其以外的修改。</span><br><span class="line">也就是说，如果你在代码中修改了变量的值是不会被Range属性限制的，但是我们不会这样做</span><br></pre></td></tr></table></figure><h2 id="变量实例化"><a href="#变量实例化" class="headerlink" title="变量实例化"></a>变量实例化</h2><p>现在为了能够使用我们创建的变量<code>resolution</code>，即让生成预制体物体，即”点”的数量和我们的变量值是一致的，我们需要修改循环次数，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; resolution; i++) &#123;</span><br><span class="line">    <span class="comment">//省略中间代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为迭代生成的预制体数量不同了（即点数目不同），为了能让其映射范围始终在 $-1 \sim 1$，需要对代码做一点更改。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> position = Vector3.zero;   <span class="comment">//位置变量</span></span><br><span class="line"><span class="keyword">var</span> step = <span class="number">2f</span> / resolution; <span class="comment">//计算应该怎么分配位置</span></span><br><span class="line"><span class="keyword">var</span> scale = Vector3.one * step;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; resolution; i++)&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">    position.x = ((i + <span class="number">0.5f</span>) * step - <span class="number">1f</span>);    <span class="comment">//计算点的 X 轴的位置</span></span><br><span class="line"></span><br><span class="line">    position.y = position.x*position.x;    <span class="comment">//Y 轴的值由 X 的值映射</span></span><br><span class="line"></span><br><span class="line">    point.localPosition = position; <span class="comment">//将实例物体位置调整到计算好的位置</span></span><br><span class="line">    point.localScale = scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf89d61d7a.png" alt="image-20220918193640643" style="zoom:80%;" /><h2 id="设置父对象"><a href="#设置父对象" class="headerlink" title="设置父对象"></a>设置父对象</h2><p>当我们设置 50 数量点时，场景中会出现很多实例化的立方体，它们会出现在层次结构面板（<em>Hierarchy</em>）中。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8a12bb08.png" alt="image-20220918194319307" style="zoom:80%;" /><p>它们排列在层次结构面板中，我们需要为其设置一个父对象，这样能够在结构面板中展示的更加有序。我们可以通过调用 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Transform.html">Transform</a> 组件的 <code>SetParent</code>方法，将要设置的父对象传给它。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> step = <span class="number">2f</span> / resolution; <span class="comment">//计算应该怎么分配位置</span></span><br><span class="line"><span class="keyword">var</span> position = Vector3.zero;   <span class="comment">//位置变量</span></span><br><span class="line"><span class="keyword">var</span> scale = Vector3.one * step;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; resolution; i++)&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab);</span><br><span class="line">    position.x = (i + <span class="number">0.5f</span>) * step - <span class="number">1f</span>;    <span class="comment">//计算点的 X 轴的位置</span></span><br><span class="line">    position.y = position.x*position.x;    <span class="comment">//Y 轴的值由 X 的值映射</span></span><br><span class="line">    point.localPosition = position; <span class="comment">//将实例物体位置调整到计算好的位置</span></span><br><span class="line">    point.localScale = scale;</span><br><span class="line">    point.SetParent(transform);<span class="comment">//设置父对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8a55722e.png" alt="image-20220918194737687" style="zoom:80%;" /><p>当设置了新的父对象，Unity默认其子对象还时保持在原来设置的位置，旋转和缩放。在我们目前的情况下，我们不需要如此，我们需要让子物体跟随父对象而变换，这个时候可以将<code>SetParent</code>方法第二个参数设置为<code>false</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">point.SetParent(transform,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h1 id="为图形添加颜色"><a href="#为图形添加颜色" class="headerlink" title="为图形添加颜色"></a>为图形添加颜色</h1><p>白色的函数图形并不是很好看，虽然我们可以使用另外一种纯色，但是也不是很有趣。如果我们根据点的位置而设置不同的颜色，这会更加有趣。</p><p>调整每个立方体的颜色一种直接的方法是设置材质的颜色属性，我们可以通过循环中做到这一点。由于不同立方体都会有不同的颜色，这意味着我们会为每一个对象提供一个唯一的材质实例。这样做虽然有效，但是效率不高。如果我们可以使用一种直接使用位置作为颜色的单一材质就好了。很不幸，Unity 并没有这样的材质，我们需要自己去做。</p><h2 id="创建表面着色器（Surface-Shader）"><a href="#创建表面着色器（Surface-Shader）" class="headerlink" title="创建表面着色器（Surface Shader）"></a>创建表面着色器（Surface Shader）</h2><p>GPU 运行着色器（<em>Shader</em>）程序来渲染 3D 对象。Unity 材质资源确定使用哪个着色器，并允许配置其属性。我们需要通过 <em>Assets&#x2F;Create&#x2F;Shader&#x2F;Standard Surface Shader</em> 创建一个自定义着色器并命名为<code>Point Surface</code>来实现我们想要的功能。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8a9ad6a6.png" alt="image-20220918200138214" style="zoom:80%;" /><p>我们现在有了一个着色器（<em>Shader</em>）资源，你可以像脚本一样打开它。着色器文件包含定义表面着色器（<em>Surface Shader</em>）的代码，它使用的语法和<code>C#</code>不同。它默认包含一个表面着色器模板，但是我们将删除其所有内容并从头开始创建一个最小的着色器。</p><p>【<strong>表面着色器（<em>Surface Shader</em>）如何工作的？</strong>】</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Unity 提供了一个框架来快速生成执行默认光照计算的着色器，你可以通过修改它的某些值来影响它的结果。</span><br><span class="line">这种着色器成为表面着色器（Surface Shader）。</span><br><span class="line">不幸的是，它仅仅适用于默认渲染管道。后面我们将会介绍通用渲染管道。</span><br></pre></td></tr></table></figure><p>Unity 有着自己的着色器语法，总体上大致类似于<code>C#</code>，但是它是不同语言的混合。它以关键字<code>Shader</code>作为开头，后面跟着定义着色器在菜单栏显示的名称字符串。字符串写在双引号内。我们使用字符串 “<code>Graph/Point Surface</code>“，最后以花括号结束，花括号其中包含着色器内容代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Graph/Point Surface&quot;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>着色器可以拥有多个子着色器，每个子着色器使用关键字<code>SubShader</code>来定义，后面也是跟着一个代码块（花括号）。我们目前只需要一个。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Graph/Point Surface&quot;</span>&#123;</span><br><span class="line">SubShader &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子着色器下方，我们还需要为标准漫反射着色器（<em>Standard diffuse shader</em>）添加一个<code>FallBack</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Graph/Point Surface&quot;</span>&#123;</span><br><span class="line">SubShader &#123;&#125;</span><br><span class="line">FallBack <span class="string">&quot;DIFFUSE&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表面着色器的子着色器需要使用<code>CG</code>和<code>HLSL</code>这两种着色器语言混合编写代码部分。此代码部分必须使用关键字<code>CGPROGRAM</code>和<code>ENDCG</code>括起来，即代码编写的内容必须处于这两个关键词之间。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Graph/Point Surface&quot;</span>&#123;</span><br><span class="line">SubShader &#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line"></span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">FallBack <span class="string">&quot;DIFFUSE&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个语句是编译器指令，称为<code>pragma</code>。它的使用方法是<code>#pragma</code>后面跟着指令内容。我们需要使用<code>#pragma surface ConfigureSurface Standard fullforwardshadows</code>，它指示着色器编译器生成具有标准照明和完全支持阴影的表面着色器（<em>standard lighting and full support for shadows</em>）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Graph/Point Surface&quot;</span>&#123;</span><br><span class="line">SubShader &#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> surface ConfigureSurface Standard fullforwardshadows</span></span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">FallBack <span class="string">&quot;DIFFUSE&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【**<code>pragma</code>是什么意思？**】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pragma 这个词来自于希腊语，指的是一个动作，或者是需要做的事情</span><br><span class="line">它在许多编程语言中用于表示特殊的编译器指令</span><br></pre></td></tr></table></figure><p>接下来我们使用指令<code>#pragma target 3.0</code> 来为着色器的级别和质量（<em>the shader’s target level and quality</em>）设置最小值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Graph/Point Surface&quot;</span>&#123;</span><br><span class="line">SubShader &#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> surface ConfigureSurface Standard fullforwardshadows</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">FallBack <span class="string">&quot;DIFFUSE&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将根据物体的世界位置为我们的点着色。我们为着色器定义输入结构<code>struct Input</code>。其格式后面必须跟着一个代码块，然后是一个分号结束。在代码块中我们声明了一个结构字段<code>float3 worldPos</code>，它代表着被渲染物体的世界位置，其类型是着色器结构体的等价类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Graph/Point Surface&quot;</span>&#123;</span><br><span class="line">SubShader &#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> surface ConfigureSurface Standard fullforwardshadows</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Input &#123;</span><br><span class="line">float3 worldPos;</span><br><span class="line">&#125;;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">FallBack <span class="string">&quot;DIFFUSE&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【<strong>这是否意味着图形的移动会影响其颜色？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是的，使用这种方法，只要物体离开 Graph 物体的位置就会变化</span><br><span class="line"></span><br><span class="line">需要注意的是，这个位置是按着顶点来确定的。在我们这个例子中，是根据每个立方体的四个顶点。</span><br><span class="line">颜色会在立方体的面上进行插值计算。立方体的体积越大，这种颜色过度越明显。</span><br></pre></td></tr></table></figure><p>接下来我们定义<code>ConfigureSurface</code>方法，尽管在着色器的情况下它总是被称为函数，而不是方法。它是一个返回值为<code>void</code>类型且带有两个传入参数的函数。其第一个参数，它是我们刚刚定义的<code>Input</code>类型，第二个参数是表面配置数据（<em>surface configuration data</em>），其类型为<code>SurfaceOutputStandard</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Input &#123;</span><br><span class="line">float3 worldPos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureSurface</span>(<span class="params">Input input,SurfaceOutputStandard surface</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>第二个参数必须在其类型前面加上关键字<code>inout</code>，这表面它即传递给函数参数又作用于函数的结果。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureSurface</span>(<span class="params">Input input,inout SurfaceOutputStandard surface</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>现在我们有了一个正常工作的着色器，为它创建一个材质并命名为<code>Point Surface</code>，通过在材质的检查器面板（<em>Insepector</em>）标题栏的<em>Shader</em> 选项下拉选择我们创建的<code>Graph/Point Surface</code>。</p><blockquote><p>你也可以选中我们编辑好的表面着色器资源，然后右键创建材质即可直接创建对应材质</p></blockquote><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8afc7682.png" alt="image-20220925153259662" style="zoom:80%;" /><p>目前该材质是纯色哑光黑。我们可以通过在配置函数中设置<code>surface.Smoothness = 0.5</code> 来使其看起来更加相近于默认材质。</p><blockquote><p>注：在编写着色器代码的时候，不需要在 float 类型的值后面加 f</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureSurface</span>(<span class="params">Input input,inout SurfaceOutputStandard  surface</span>)</span>&#123;</span><br><span class="line">surface.Smoothness = <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在材质就不再是纯色的了，你可以在检查器面板（<em>inspector</em>）的材质预览中查看其预览效果。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8b3dc02d.png" alt="image-20220925154511542" style="zoom:80%;" /><p>我们还可以使材质的平滑度(<em>smoothness</em>)可配置，如同为其添加一个字段并在函数中使用它。默认格式是在其配置选项前加上下划线并讲第一个字符进行大写，我们使用<code>_Smoothness</code>，如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> _Smoothness;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureSurface</span>(<span class="params">Input input,inout SurfaceOutputStandard  surface</span>)</span>&#123;</span><br><span class="line">surface.Smoothness = _Smoothness;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够让我们在检查器面板（<em>Inspector</em>）中可以配置该变量，我们必须在着色器顶部，即子着色器上方添加一个新的“块”。将变量<code>_Smoothness</code>写在其中，并将<code>(&quot;Smoothness&quot;,Range(0,1)) = 0.5</code>写在其后。这语句意味着将<code>Smoothness</code>作为标签&#x2F;字段（<em>label</em>）显示在检查器面板（<em>Inspector</em>）中并将其滑块范围限定在 $0 \sim 1$ 中，其默认值为 0.5 。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Graph/Point Surface&quot;</span>&#123;</span><br><span class="line">Properties&#123;</span><br><span class="line">_Smoothness (<span class="string">&quot;Smoothness&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubShader &#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> surface ConfigureSurface Standard fullforwardshadows</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Input &#123;</span><br><span class="line">float3 worldPos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> _Smoothness;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureSurface</span>(<span class="params">Input input,inout SurfaceOutputStandard  surface</span>)</span>&#123;</span><br><span class="line">surface.Smoothness = _Smoothness;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">FallBack <span class="string">&quot;DIFFUSE&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8b83755b.png" alt="image-20220925155608099" style="zoom:80%;" /><p>现在来设置我们的“点”，即立方体的材质为我们设置好的材质而不是默认材质。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8bbc660c.png" alt="image-20220925155739921" style="zoom:80%;" /><h2 id="基于世界坐标开始着色"><a href="#基于世界坐标开始着色" class="headerlink" title="基于世界坐标开始着色"></a>基于世界坐标开始着色</h2><p>要修改“点”的颜色，我们必须修改其<code>surface.Albedo</code>参数。因为漫反射（<em>albedo</em>）和世界坐标都是三个参数的结构体类型，所以我们可以直接将世界坐标作为参数传递给漫反射（<em>albedo</em>）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureSurface</span>(<span class="params">Input input,inout SurfaceOutputStandard  surface</span>)</span>&#123;</span><br><span class="line">surface.Albedo = input.worldPos;</span><br><span class="line">surface.Smoothness = _Smoothness;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8bf42f77.png" alt="image-20220925160100193" style="zoom: 80%;" /><p>【<strong>漫反射（<em>Albedo</em>）是什么意思？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Albedo（漫反射）在拉丁语中是白色的意思。它是衡量有多少光被表面漫反射的度量。</span><br><span class="line">如果漫反射不是全白，那么部分的光能会被吸收而不是反射。</span><br></pre></td></tr></table></figure><p>现在<strong>世界坐标 X 轴位置控制点的红色分量，Y 位置控制绿色分量，Z 位置控制蓝色分量</strong>。由于我们的图形定义域（即 X 轴域）限定在了 $-1 \sim 1$ 中，负颜色分量是没有意义的。所以我们必须将位置减半，然后添加 $\frac{1}{2}$ 使颜色处于合适的域中。我们可以一次对所有三个维度执行此操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">surface.Albedo = input.worldPos* <span class="number">0.5</span> +<span class="number">0.5</span>;</span><br></pre></td></tr></table></figure><p>为了更好的确定颜色变化是否正确，现在对函数进行修改，使得其展示 $F(X) &#x3D; X ^3 $ 的图形。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8c31682f.png" alt="image-20220925160830921" style="zoom:80%;" /><p>结果发现其颜色整体偏蓝，这是因为立方体面的 Z 坐标都是 0 ，这是使得其蓝色分量为 0.5 。我们可以通过设置漫反射只包括红色和绿色通道来消除蓝色。这样就可以使得蓝色分量保持为 0 。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">surface.Albedo.rg = input.worldPos.xy* <span class="number">0.5</span> +<span class="number">0.5</span>;</span><br></pre></td></tr></table></figure><p>由于红色+绿色&#x3D; 黄色，这使得左下角开始接近于黑色，随着 Y 增加快于 X 轴的增加而变成绿色，随着 X 的追赶变为黄色，随着 X 增加更快变成橙色，最后接近明亮结束右上角的黄色。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8c636976.png" alt="image-20220925161530507" style="zoom:80%;" /><h2 id="通用渲染线管（Universal-Render-Pipeline）"><a href="#通用渲染线管（Universal-Render-Pipeline）" class="headerlink" title="通用渲染线管（Universal Render Pipeline）"></a>通用渲染线管（<em>Universal Render Pipeline</em>）</h2><p><strong>除了默认的渲染线管（<em>default render pipeline</em>），Unity 还包含了通用渲染线管（<em>Universal</em>）和高清渲染线管（<em>High-Definition</em>），简称 URP 和 HDRP</strong> 。两种渲染管线都有不同的功能和限制。当前默认渲染管线依然有效，但是其特性功能已经不被使用了（<em>its feature set is frozen</em>）。或许几年后，URP 会称为默认的渲染管线设置。因此，现在来让我们的图形也适用于 URP 。</p><p>如果你还没有使用 URP ，现在打开包管理器并安装最新的 URP，就我而言我使用的是版本 <em>10.4.0</em></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8ca6c7ec.png" alt="image-20220925162132964" style="zoom:80%;" /><blockquote><p>在查找 URP 的时候确保您的包过滤（<em>package filter</em>）设置为：Unity Registry 而不是 In Project</p></blockquote><p>在完成安装后这并不会使得 Unity 自动的使用 URP 。我们首先需要通过 <em>Assets &#x2F; Create &#x2F; Rendering &#x2F; Universal Render Pipeline &#x2F; Pipeline Asset (Forward Renderer)</em> 为其创建一个资源（<em>Asset</em>）,我给其命名为 <code>URP</code>。同时 Unity 也会自动给渲染器创建另一个资源（<em>Asset</em>），在本例中其被命名为<code>URP_Renderer</code>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8d15ae83.png" alt="image-20220925162800578" style="zoom:80%;" /><p>接下来，<strong>前往项目的设置中<code>Graphics</code>的部分，将 URP 资源（<em>Asset</em>）分配给 <em>Scriptable Renderer Pipeline Settings</em> 。</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8d53f03c.png" alt="image-20220925163002691" style="zoom:80%;" /><p>要是希望再切换回默认渲染管线，则只需在设置中将 <em>Scriptable Renderer Pipeline Settings</em> 改为 <em>none</em> 即可。当然这些操作只能在编辑器中完成，<strong>渲染管线不可以在构建的独立应用程序中更改。</strong></p><p>【<strong>HDRP 呢？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDRP 是一个更复杂的渲染管线，我并不会我的教程中介绍它。</span><br></pre></td></tr></table></figure><h2 id="创建着色器（Shader-Graph）"><a href="#创建着色器（Shader-Graph）" class="headerlink" title="创建着色器（Shader Graph）"></a>创建着色器（<em>Shader Graph</em>）</h2><p>我们<strong>前面制作的材质只适用于默认渲染管线，而不适用于 URP。</strong>因此当我们使用 URP 的时候，它会被 Unity 的错误材质取代，即纯洋红色。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8d996570.png" alt="image-20220925163402874" style="zoom:80%;" /><p>我们现在必须为 URP 创建一个单独的着色器，当然我们可以自己编写一个，但是目前来说非常困难，并且在升级到较新的 URP 版本的时候可能会失效（<em>Break</em>）。<strong>最好的办法是使用 Unity 提供的着色器图形包（<em>shader graph package</em>）来可视化的设置着色器</strong>。URP 依赖于这个包，因此它会和 URP 包安装的时候一起安装。</p><p>我们可以通过 <em>Assets &#x2F; Create &#x2F; Shader &#x2F; Universal Render Pipeline &#x2F; Lit Shader Graph</em> 创建一个新的着色器，并命名其为 <code>Point URP</code>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8dd6feed.png" alt="image-20220925163754152" style="zoom:80%;" /><p>可以通过在项目窗口双击其资源或者点击检查器面板中的<em>Open Shader Editor</em>按钮来打开一个图形化的着色器面板&#x2F;窗口。其中包含”黑板”（<em>Blackboard</em>），图形检查器面板（<em>Graph Insoector</em>）和主预览面板（<em>Main Preview</em>），你可以调整其大小或者通过工具来选择是否隐藏。另外在该图形化窗口中，<strong>还包含两个可以链接的节点：一个顶点（<em>Vertex</em>）节点和一个”面”（<em>Fragment</em>）节点。这两个节点用于配置着色器的输出</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8e117a96.png" alt="image-20220925164658793" style="zoom:80%;" /><p>URP 图形化着色器由表示数据或者操作的节点组成。现在”面”（<em>Fragment</em>）节点的<code>Smoothness</code>值为 0.5 。要使其成为可配置的着色器属性，需要<strong>在左边的 Ponit URP “黑板”（<em>Blackboard</em>）点击加号按钮，选择<code>Float</code>类型，并将其命名为<code>Smoothness</code>。</strong>（这个过程是添加变量）</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8e4bc890.png" alt="image-20220925165247066" style="zoom:80%;" /><p>引用（<em>Reference</em>）是表示和内部变量属性的链接。因此我们需要使用其内部属性名称<code>_Smoothness</code>（我们的表面着色器代码中属性的名称字段），然后设置其默认值（<em>Default</em>）为 0.5 。确保其 <em>Exposed</em> 选项已启动，因为其控制材质是否为能获取着色器的属性。最后，如果要使其显示为滑块，着将模式（<em>Mode</em>）修改为 滑块（<em>Slider</em>）。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8e88c249.png" alt="image-20220925165806430" style="zoom:80%;" /><p>接下来，拖动左侧”黑板”上的<code>Smoothness</code>圆形按钮到窗口的空白处。这将为图形窗口添加一个<code>Smoothness</code>节点，将其连接到<code>Smoothness</code>的输入。这样两者就建立了链接。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8ebf33c3.png" alt="image-20220925170202128" style="zoom:80%;" /><p>现在你可以点击图形化着色器面板工具栏左侧的保存资源（<em>Save Asset</em>）来保存修改后的图形化着色器，接着创建一个对应的材质来替代之前的表面着色器的材质，将新创建的材质命名为<code>Point URP</code>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8f001d72.png" alt="image-20220925170834422" style="zoom:80%;" /><h2 id="使用节点编程"><a href="#使用节点编程" class="headerlink" title="使用节点编程"></a>使用节点编程</h2><p>要为“点”着色，我们需要从位置节点开始。<strong>我们可以通过右键图形化着色器的空白处，再弹出的菜单中，选择创建节点（<em>Create Node</em>），然后在其中选择 <em>Input &#x2F; Geometry &#x2F; Position</em> 或者说直接搜索 <em>Position</em></strong> 。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8f424e1a.png" alt="image-20220925171319000" style="zoom:80%;" /><p>我们现在有一个位置节点，默认其设置为世界空间坐标。你可以通过单击将光标悬停在其上方时出现的上箭头来折叠其可视化预览。</p><p>现在来使用相同的方法创建一个乘法（<em>Multiply</em>）和加分（<em>Add</em>）节点，然后将其位置 XY 的分量缩放 0.5 ，然后加 0.5 ，同时将 Z 设置为 0 。最后，将结果链接到“面”（<em>Fragment</em>）的 <em>Base Color</em> 作为输入。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8f7ebeb4.png" alt="image-20220925172718931" style="zoom:80%;" /><p>你可以通过将鼠标悬停在节点上方，单击出现的箭头来隐藏其视觉大小。这样将较少一定程度上的视觉混乱，你也可以通过删除顶点（<em>Vertex</em>）和“面”（<em>Fragment</em>）节点的组件来减少视觉混乱。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8fb92651.png" alt="image-20220925173039442" style="zoom:80%;" /><p>保存图形化着色器的资源后，现在在播放模式（<em>Play</em>）下获得的渲染结果和默认渲染管道时是相同的结果颜色。除此之外，你还会发现<strong>在层次结构面板（<em>Hierarchy</em>）出现了 <em>DontDestroyOnLoad</em> 场景。这是为了调试 URP，可以忽略</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf8ff43b10.png" alt="image-20220925173355119" style="zoom:80%;" /><p>这个时候，你可以选择使用默认渲染线管或者 URP。切换到另一种渲染线管后，需要将指定的材质进行更替，否则其会显示成洋红色的错误材质。如果你对图形化着色器的代码感到好奇，你可以通过检查器面板（<em>Inspetor</em>）中的 <em>View Generated Shader</em> 按钮进行查看。</p><h1 id="为图形添加动画"><a href="#为图形添加动画" class="headerlink" title="为图形添加动画"></a>为图形添加动画</h1><p>显示静态图形很有用，但是显示动态图形会更加有趣。因此，我们将会为图形添加动画。这是通过将时间作为附件函数参数来完成的，其格式为 <code>F(X,t)</code>，<code>t</code> 表示时间。</p><h2 id="跟踪点"><a href="#跟踪点" class="headerlink" title="跟踪点"></a>跟踪点</h2><p>为了使图形动画化，我们必须跟随时间来调整其点的位置。我们可以通过删除所有点并在每次更新时创建新点来实现，但是这是一种比较低效的方法。最好是继续使用相同的点，每次更新调整它们的位置。为了实现，我们需要使用一个字段来保留对我们点的引用。为 <em>Graph</em> 类添加一个类型为 <code>Transform</code>的字段<code>points</code>。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField,Range(10,100)</span>]</span><br><span class="line"><span class="built_in">int</span> resolution = <span class="number">50</span>;    <span class="comment">//立方体的数量</span></span><br><span class="line"></span><br><span class="line">Transform points;   </span><br></pre></td></tr></table></figure><p>该字段允许我们引用单个点，但是我们需要访问所有这些点。我们可以通过在其类型后面加上空的方括号将该字段转换为数组。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transform[] points;</span><br></pre></td></tr></table></figure><p>该<code>points</code>字段现在是对数组的引用，其元素类型为 <code>Transform</code>。数组是对象，而不是简单的值。我们必须显式的创建一个这样的对象并让字段获取对其的引用。这是通过关键字<code>new</code>来实现的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span>&#123;</span><br><span class="line">points = <span class="keyword">new</span> Transform[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建数组的时候，我们必须指定其长度，这意味着它包含了多少个元素，并且在创建后无法进行更改。构造数组时，长度写在方括号内。我们使其等于图形的“点”数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">points = <span class="keyword">new</span> Transform[resolution];</span><br></pre></td></tr></table></figure><p>现在我们可以将实例化的物体和创建的数组元素进行引用链接。访问数组元素是通过数组引用后面方括号之间写下它的索引来完成的。第一个元素的数组索引是从零开始的，就像迭代的计数器一样。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">points = <span class="keyword">new</span> Transform[resolution]; <span class="comment">//创建数组对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; resolution; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Transform point = Instantiate(pointPrefab); <span class="comment">//获取实例化对象的引用</span></span><br><span class="line">    points[i] = point;  <span class="comment">//填充数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们多次引用&#x2F;赋值相同的东西，我们可以使用连等号来使其链接在一起，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">points = <span class="keyword">new</span> Transform[resolution]; <span class="comment">//创建数组对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; resolution; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Transform point = points[i] =  Instantiate(pointPrefab); <span class="comment">//获取实例化对象的引用并填充数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们正在循环我们的“点”数组。因为数组长度和“点”数相同，所以我们可以使用数组长度来约束我们的循环。每个数组都有一个<code>Lenth</code>属性，所以我们来使用它。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; points.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Transform point = points[i] =  Instantiate(pointPrefab); <span class="comment">//获取实例化对象的引用并填充数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新“点”"><a href="#更新“点”" class="headerlink" title="更新“点”"></a>更新“点”</h2><p>要调整每一帧的图形，我们需要在 <code>Update</code>方法中设置点的 Y 坐标。所以我们不需要在<code>Awake</code>中计算它们的值。但是我们任然可以在这里设置 X 的坐标，因为我们不会更改它们的值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这句不需要了</span></span><br><span class="line">position.y = position.x*position.x* position.x;    <span class="comment">//Y 轴的值由 X 的值映射</span></span><br></pre></td></tr></table></figure><p>像<code>Awake</code>一样在<code>Updat</code>添加一个带有<code>for</code>循环的代码，但是它的块中代码还暂时是空的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; points.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//这里啥也没有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将通过获取对当前数组元素的引用并将其存储在变量中开始循环迭代。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; points.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Transform point = points[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，我们将“点”的本地位置存储在一个变量中。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; points.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Transform point = points[i];</span><br><span class="line">    Vector3 position = point.localPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以根据 X 的位置，调整 Y 坐标，和之前做的那样。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Transform point = points[i];</span><br><span class="line">Vector3 position = point.localPosition;</span><br><span class="line">position.y = position.x * position.x * position.x;</span><br></pre></td></tr></table></figure><p>现在我们进行是对变量<code>position</code>做了计算处理，我们要将其结果作用于该“点”，我们需要再次设置其值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transform point = points[i];    <span class="comment">//获取实例对象</span></span><br><span class="line">Vector3 position = point.localPosition; <span class="comment">//获取对象的位置</span></span><br><span class="line">position.y = position.x * position.x * position.x;  <span class="comment">//计算新的位置</span></span><br><span class="line">point.localPosition = position; <span class="comment">//新位置赋值给对象</span></span><br></pre></td></tr></table></figure><h2 id="显示正弦图形"><a href="#显示正弦图形" class="headerlink" title="显示正弦图形"></a>显示正弦图形</h2><p>现在在播放模式下，我们的图形的“点”每帧都会进行计算定位。但是我们还没有注意到这一点，因为它们每次开始和结束的位置是相同的。我们必须将时间引用到函数中才能使其发生变化。但是，简单的添加时间会使其不断上升然后消失在我们视野之中。为了防止这种情况，我们必须使用一个能够改变但是保持在一定范围内的函数。正弦函数（<em>sine</em>）是理想的选择。所以我们可以通过<code>Mathf.Sin</code>来使其函数变为 $F(X) &#x3D; sin(X)$ 。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position.y = Mathf.Sin(position.x); </span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf9052214e.png" alt="image-20220925193641494" style="zoom:80%;" /><p>【**什么是<code>Mathf</code> ?**】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">它是 UnityEngine 命名空间中一个结构，包含了数学函数和常量的集合。</span><br><span class="line">因为它使用浮点数，所以它的类型名称给与了 f 的后缀。</span><br></pre></td></tr></table></figure><p>正弦波形在 $-1 \sim 1$ 之间震荡。它每 $2 \pi$ 个单位重复一次，这意味着它的周期约为 6.28 。我们的坐标介于 $-1 \sim 1$ 之间，也就是说看到的不足其图形的 $\frac{1}{3}$ 。为了能够查看到其整体的图形，我们需要将我们的左右边界乘以 $\pi$ ，这样使得我们的范围映射到了  $- \pi \sim \pi$ 之间，正好是其一个周期。我们可以使用<code>Mathf.PI</code>来表示  $\pi$ 的近似值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position.y = Mathf.Sin(Mathf.PI * position.x);  <span class="comment">//计算新的位置</span></span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf90959a23.png" alt="image-20220925195019920" style="zoom:80%;" /><p>要将函数图形设置动画，需要在计算函数之前将游戏时间添加到 X 坐标数值。即通过使用<code>Time.time</code>来获取时间。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position.y = Mathf.Sin(Mathf.PI * (position.x + Time.time));  <span class="comment">//计算新的位置</span></span><br></pre></td></tr></table></figure><p><video src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/WeepyAgreeableBoutu-mobile.webm" controls="" width="50%" autoplay="" playsinline="" preload="auto" ></video></p><p>因为<code>Time.time</code>循环每次迭代的值是相同的，所以我们可以将其调用到循环之外。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> time = Time.time; <span class="comment">//获取时间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; points.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Transform point = points[i];    <span class="comment">//获取实例对象</span></span><br><span class="line">    Vector3 position = point.localPosition; <span class="comment">//获取对象的位置</span></span><br><span class="line">    position.y = Mathf.Sin(Mathf.PI * (position.x + time));  <span class="comment">//计算新的位置</span></span><br><span class="line">    point.localPosition = position; <span class="comment">//新位置赋值给对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限制颜色范围"><a href="#限制颜色范围" class="headerlink" title="限制颜色范围"></a>限制颜色范围</h2><p>因为正弦的幅度是 $-1 \sim 1$ ，所以其最高点为 $1$ ，最低点是 $1$ 。但是因为我们的“点”是立方体，这就意味着它们的大小会导致其超出这个   $-1 \sim 1$  的范围。因此，我们会获得低于 -1 或者大于 1 的绿色分量颜色，虽然这个并不明显，但是我们需要来正确的限制颜色在 0 -1 的范围中。</p><p>我们可以通过将生成的颜色传递给 <code>Saturate</code>函数来为我们的着色器执行此操作。这是一项特殊功能，它可以将所有分量限制在 0-1 之间。这是着色器的常见操作，称为“饱和度”（<em>saturation</em>）。</p><blockquote><p>关于<a href="httpss://developer.download.nvidia.cn/cg/saturate.html">“饱和度”（<em>saturation</em>）的说明</a></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">surface.Albedo.rg = saturate(input.worldPos.xy * <span class="number">0.5</span> + <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><p>同样的，你也可以在图形化着色器中使用<code>Saturate</code>节点来实现。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf90f8dedd.png" alt="image-20220925200807685" style="zoom:80%;" /><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>下一个教程：<strong>数学曲面（* Mathematical Surfaces*）</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
          <category> Catlike Coding </category>
          
          <category> Basics </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>猫式教程</title>
      <link href="/2022/09/11/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/Catlike%20Coding/%E7%8C%AB%E5%BC%8F%E6%95%99%E7%A8%8B/"/>
      <url>/2022/09/11/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/Catlike%20Coding/%E7%8C%AB%E5%BC%8F%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分既是猫式教程的说明，也是猫式教程的索引开始文章页。</p><h1 id="关于猫式教程"><a href="#关于猫式教程" class="headerlink" title="关于猫式教程"></a>关于猫式教程</h1><p><strong>猫式教程（Catlike Coding）系列原作者： <a href="httpss://catlikecoding.com/unity/tutorials/">Catlike Coding</a>，作者名叫：Jasper Flick，是一位 software developer living in Amsterdam ，他创建并编写了 Unity 的 Catlike Coding 的博客教程</strong>。</p><blockquote><p>关于作者<a href="httpss://catlikecoding.com/jasper-flick/"><strong>Jasper Flick</strong></a></p></blockquote><p>我在前年的时候尝试翻译过他的博客，在翻译了 3 篇博文后由于一些事情遂放弃了，此次打算捡起来继续翻译，在翻译的时候也会对作者的过程进行复刻，一是提升我的 Unity 能力，二是为了能在翻译作者博文的时候校验可行性。</p><p>如果教程对你们有利的话，请对原作者进行打赏，最终知识版权归原作者所有。我本人仅做翻译和二次编写以及一些补充说明。因为很多小伙伴对于英语的编写查看以及复现起来很麻烦，所以我打算解决这个问题。</p><blockquote><p>翻译过程中可能会出现错误或者其他问题，如果发现了请谅解，我会尽量保证不会出错</p></blockquote><h1 id="猫式教程更新"><a href="#猫式教程更新" class="headerlink" title="猫式教程更新"></a>猫式教程更新</h1><p>我暂定于一周更新一篇博文的频率来尝试更新教程，我会在一些关键词和必要的部分进行英文和中午的双解释。</p><p>我会一次更新一章的目录+索引，所以如下的内容并不是猫式教程的全部内容。</p><p><strong>本博文完全遵循原作者的<a href="httpss://catlikecoding.com/unity/tutorials/license/">协议</a>，教程代码遵循 MIT-0 协议，教程遵循 CC BY-NC-SA 4.0 协议，如果你希望转载本博文，可以随意转载，但是请标明出处</strong>。</p><h2 id="基础（Basics）"><a href="#基础（Basics）" class="headerlink" title="基础（Basics）"></a>基础（Basics）</h2><p>这些教程解释了如何来使用 Unity。</p><p>如下的教程系列最后更新于 2021年 5 月 18 日，使用版本：  Unity 2020 。</p><table><thead><tr><th>名称</th><th>翻译</th><th>更新状态</th><th>索引</th></tr></thead><tbody><tr><td>Game Objects and Scripts</td><td>游戏物体和脚本</td><td>⏳ 更新中</td><td><a href="httpss://www.helloseraphine.top/2022/09/11/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E3%80%90%E5%9F%BA%E7%A1%80%E3%80%91%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93%E5%92%8C%E8%84%9A%E6%9C%AC/">点我访问</a></td></tr><tr><td>Building a Graph</td><td>创建图形</td><td>❎ 未更新</td><td>无</td></tr><tr><td>Mathematical Surfaces</td><td>数学曲面（表面）</td><td>❎ 未更新</td><td>无</td></tr><tr><td>Measuring Performance</td><td></td><td>❎ 未更新</td><td>无</td></tr><tr><td>Compute Shaders</td><td></td><td>❎ 未更新</td><td>无</td></tr><tr><td>Jobs</td><td></td><td>❎ 未更新</td><td>无</td></tr><tr><td>Organic Variety</td><td></td><td>❎ 未更新</td><td>无</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
          <category> Catlike Coding </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【基础 01】游戏物体和脚本</title>
      <link href="/2022/09/11/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/Catlike%20Coding/Basics/%E3%80%90%E5%9F%BA%E7%A1%80%2001%E3%80%91%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93%E5%92%8C%E8%84%9A%E6%9C%AC/"/>
      <url>/2022/09/11/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/Catlike%20Coding/Basics/%E3%80%90%E5%9F%BA%E7%A1%80%2001%E3%80%91%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93%E5%92%8C%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="游戏物体和脚本"><a href="#游戏物体和脚本" class="headerlink" title="游戏物体和脚本"></a>游戏物体和脚本</h1><blockquote><p><strong>前排说明：关于本教程目录导航以及说明：<a href="httpss://www.helloseraphine.top/2022/09/11/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E7%8C%AB%E5%BC%8F%E6%95%99%E7%A8%8B/">猫式教程</a></strong></p></blockquote><p>本篇任务：<strong>创建一个钟表</strong>，你将会学到：</p><ul><li>使用基本物体创建一个钟表</li><li>编写一个<code>C#</code>脚本</li><li>通过转动指针来显示时间</li><li>为指针做一个动画</li></ul><p>这是 Unity 教程的第一篇，在这篇学习中，我们将创建一个简单的时钟并编写一些组件使其显示当前时间。你不需要有任何 Unity 的经验，但是你需要有一定的 Windows 窗口使用能力。</p><p><strong>在文章最后我会放出本文原文的 PDF （注：英文原作者的），以及教程项目的仓库（代码仓库）</strong>。</p><p>本教程使用<code>Unity 2020.3.6f1</code>编写，我采用 <code>Unity 2020.3.38f1c1</code> 来翻译复刻编写。 </p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf742a37e5.png" alt="image-20220911093047113" style="zoom:80%;" /><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>开始使用 Unity 之前，你需要先创建一个项目。</p><h2 id="新项目"><a href="#新项目" class="headerlink" title="新项目"></a>新项目</h2><p>当你需要打开 Unity 的时候，需要通过 Unity Hub 启动器来完成 Unity 的版本安装和启动，你可以通过 Unity Hub 来创建或者打开，安装 Unity 等一系列操作。</p><p>【<strong>如何选择 Unity 版本？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Untiy 每年会发布多个新版本，并且有两个并行的发布时间表。分别是：最稳定和最安全的是 LTS 版本。</span><br><span class="line">LTS 代码会被官方长期支持并且每两年进行一次更新。此教程内容使用 LTS 版本。</span><br><span class="line">最高版本的 Unity 是开发分支的版本，它引入了新功能并可能删除了旧的功能；这些版本并不如 LTS 版本可靠，并且每个版本仅支持</span><br></pre></td></tr></table></figure><p>有时候该教程会包含一些疑问和回答，就如同上面所示的那样，在网页默认是不展开的，你可以通过单击来展开查看，<strong>需要注意的是：由于我的博客并没有原作者的展开栏一样的功能，所以我采用代码框来代替</strong>。</p><p>当你创建一个新项目的时候，你可以选择对应的 Unity 版本和项目模板。本例中，我们将采用标准的 3D模板。创建完成后，它会被添加到 Unity Hub 的项目列表中，并且会在对应版本的 Unity 编辑器中打开。</p><p>【<strong>我可以使用不同的渲染管道（Render Pipeline）创建项目吗？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以的，区别在于不同的项目默认场景中所拥有的东西不一样。</span><br></pre></td></tr></table></figure><h2 id="编辑器布局"><a href="#编辑器布局" class="headerlink" title="编辑器布局"></a>编辑器布局</h2><p>如果你是第一次使用 Unity 编辑器，那么你的编辑器布局（Editor Layout）可能是如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf74824496.png" alt="image-20220911095311839" style="zoom:80%;" /><p>默认的布局包含了我们所需要使用窗口，你也可以通过拖动来重新布局自定义窗口布局。你还可以打开或者关闭对应的窗口。每个窗口都可以通过其右上角的三个点来访问其窗口配置选项。</p><p>你也可以通过 Unity 编辑器的右上角 <code>Layout</code>（布局） 下拉菜单来切换已经配置好的布局，你也可以通过它来保存当前布局。</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>Unity 的功能是模块化的，除了核心功能之外，还有一些额外的包（Packages）会被下载并包含在你的项目中。默认的 3D模板项目会包含如下的几个包，你可以在你的 <code>Project</code>（项目）窗口下查看到 <code>Packages</code>（包）：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf74c90fba.png" alt="image-20220911100102092" style="zoom:80%;" /><p>你可以通过<code>Priject</code>（项目）窗口右上角的“眼睛”按钮来隐藏显示这些<code>Packages</code>（包），这只是为了减少编辑器的视觉混乱，并不会真的对项目的<code>Packages</code>（包）做任何处理，仅仅是隐藏了。在“眼睛”按钮旁边的数值表示了项目中含有多少个<code>Packages</code>（包）。</p><p>当然你也可以通过包管理器（Package Manager）来对项目中的包进行控制，包管理器（Package Manager）可以通过 Window &#x2F; Package Manager 来进入。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf751067e8.png" alt="image-20220911100643989" style="zoom:80%;" /><p>这些包为 Unity 提供了一些额外的功能，例如：Visual Studio 编辑器（Visual Studio Code Editor）添加了用于编写代码的 Visual Studio 编辑器（Visual Studio Code Editor）的集成。本实例并不需要使用其他包所提供的功能，仅保留 Visual Studio 编辑器的包，其他的我将其全部删除，这是因为我使用 Visual Studio 编辑器来编写代码。如果你使用不同的编辑器，则需要包含其他的集成包。</p><p>删除包最简单的办法就是使用包管理器（Package Manager），使用工具栏限制包列表为：在本项目中的（In Project），然后一次选择一个包，并使用右下角的删除（Remove）按钮。Unity 将会在每次删除后进行重编译，因此需要等待几秒钟才能完成该过程。</p><p>删除除了 Visual Studio 编辑器（Visual Studio Code Editor）之外的其他包后，我的项目窗口留下了三个可见包：Custom NUnit，Test FrameWork 和 Visual Studio Editor 。除了Visual Studio 编辑器（Visual Studio Code Editor）其他两个包存在是因为 Visual Studio 编辑器（Visual Studio Code Editor）依赖于这些包。</p><p>你可以通过项目设置（Project Settings）来让依赖项在包管理器（Package Manger）中可见，项目设置（Project Settings）在 <em>Edit&#x2F;Project Settings 然后选择 Package Manager 类型，在其中的 Advanced Settings 下启用，Show Dependencies</em>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf756a7fe7.png" alt="image-20220911102906069" style="zoom:80%;" /><h2 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a>色彩空间</h2><p>现在渲染通常使用线性色彩空间（Linear color space）来完成，但是 Unity 依旧默认配置为使用伽马色彩空间（Gamma color space）。为了获得最佳的视觉效果，<em>请在 Player 类别中，打开 Other Settings 面板，找到 Rendering 部分，确保 Color Space 被设定为 Linear</em> 。Unity 会弹出警告说这个操作可能会需要比较长的时间，点击确认即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf75bb2312.png" alt="image-20220911103552295" style="zoom:80%;" /><p>【<strong>现在还有必要使用伽马色彩空间（Gamma color space）吗？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">仅当你需要针对旧硬件或者旧图形 API 的时候使用。</span><br><span class="line">OpenGL ES2.0 和 WebGL 1.0 不支持线性空间，此外，在旧的一些移动设备上来说，伽马可能渲染会比线性空间要块一些。</span><br></pre></td></tr></table></figure><h2 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a>示例场景</h2><p>在刚刚创建的新项目中会包含一个名称为示例场景（<em>Sample Scene</em>）的场景，默认是打开的。你可以通过 <em>Assets&#x2F;Scenes</em> 路径来找到它。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7605cd20.png" alt="image-20220911104203043" style="zoom:80%;" /><p>默认情况下，项目窗口使用两列布局，你可以通过右上角三个点的配置菜单来切换到单列布局。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf76461442.png" alt="image-20220911104257858" style="zoom:80%;" /><p>示例场景（<em>Sample Scene</em>）包含一个主摄像机（<em>Main Camera</em>）和一个定向光源（<em>Directional Light</em>）。这些是游戏对象，它们陈列在场景下的层次结构窗口中。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7685cf3f.png" alt="image-20220911104609982" style="zoom:80%;" /><p>你可以通过层次结构窗口（<em>Hierarchy</em>）或者场景窗口来选择游戏对象，摄像机场景图标看起来像是老式胶片相机，而定向光源图标看起来像是太阳。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf76c5246a.png" alt="image-20220911104740048" style="zoom:80%;" /><p>【<strong>如何进行场景漫游（navigate the scene）</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你可以使用 alt 键或者鼠标右键结合鼠标移动来旋转视图</span><br><span class="line">你还可以使用方向键来移动视角位置，通过鼠标滚轮键进行缩放</span><br><span class="line">此外，你可以通过 F 键将视图聚焦到选定的游戏对象上</span><br></pre></td></tr></table></figure><p>当一个物体（<em>Object</em>）被选中时，它的详细信息会显示在检查器（<em>Inspector</em>）窗口中，我们会在需要的时候来使用它。我们不需要对摄像机和灯光进行参数修改，因此我们可以通过层次结构窗口（<em>Hierarchy</em>）中单击它们左侧的眼睛图标来讲它们在场景中隐藏，这个图标默认是不可见的，只有我们的鼠标悬停在其上面的时候才会出现。这样做纯粹是为了减少场景窗口中的视觉混乱。</p><p>【<strong>眼睛图标旁边的手型图标有用？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在眼睛图标旁边的列是一个手势形状的列。默认情况下，该图标也是不可见的，只有鼠标悬停在上面才会显示。</span><br><span class="line">当手势图标被激活的时候，你就无法在场景窗口中选中物体了，只有在层级面板（Hierarchy）来选择物体。</span><br></pre></td></tr></table></figure><h1 id="构建一个简单的时钟"><a href="#构建一个简单的时钟" class="headerlink" title="构建一个简单的时钟"></a>构建一个简单的时钟</h1><p>到目前为止，我们完成了项目设置，现在来正式开始创建我们的时钟了。</p><h2 id="创建游戏对象"><a href="#创建游戏对象" class="headerlink" title="创建游戏对象"></a>创建游戏对象</h2><p>我们需要一个游戏物体（game object）来表示时钟。我们讲会从最简单的游戏物体开始，你可以通过 <em>GameObject&#x2F;Create Empty</em> 来创建一个空物体。你也可以通过鼠标右键层次结构面板（<em>Hierarchy</em>）来打开该选项进行创建，或者使用层次结构面板（<em>Hierarchy</em>）左上角的加号来创建，这样就会讲游戏物体添加到了场景中。</p><p>你现在可以看到它已经存在并显示在了层次结构面板（<em>Hierarchy</em>）中，并且层次结构面板（<em>Hierarchy</em>）标有星号（*），它表示这该场景有着未保存的更改。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf771ba2c0.png" alt="image-20220911153907458" style="zoom:80%;" /><p>选中该物体，在 Inspector 面板中就会显示物体的详细信息，在它的顶部是一个带有物体名称和一些配置选项。默认情况下该物体是已启用的，非静态（Static），未标记并且位于默认图层上的，这些配置都很好，除了它的名字，现在来将它的名称改为 Clock 。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf775de10f.png" alt="image-20220911154733754" style="zoom:80%;" /><p>在它的名称下方是物体的组件（Component）列表。默认所以物体都会拥有一个 Transform 组件。它控制了游戏物体的位置（Position），旋转（Rotation）和缩放（Scale）。现在确保 Clock 物体的位置和旋转值为 0 ，其缩放应该统一为 1 （即不缩放，1 倍原始大小）。</p><p>【<strong>那么二维物体呢？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 2D 即二维编写程序的时候，你可以忽略其中一个维度。</span><br><span class="line">专门用于 2D 物体（如 UI 元素）通常有一个 RectTransform 来代替，它是一个专门的 Transform 组件</span><br></pre></td></tr></table></figure><p>因为游戏物体是一个空物体，所以它在场景中本身是不可见的。但是，在游戏物体的位置（世界中心位置）可以看到物体的操作工具。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf77a1f817.png" alt="image-20220911155524971" style="zoom:80%;" /><p>【<strong>为什么选中 Clock 物体后看不到操作工具？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作工具位于 Scene（场景）窗口中，而不是 Game（游戏）窗口中</span><br></pre></td></tr></table></figure><p>可以通过编辑器工具栏左上角的按钮控制不同操作工具处于活动状态。这些工具也可以通过快捷键<kbd>Q</kbd>，<kbd>W</kbd>，<kbd>E</kbd>，<kbd>R</kbd>，<kbd>T</kbd> 和 <kbd>Y</kbd> 来激活。该工具栏最右侧的按钮是用来启用我们自定义的编辑器工具。默认情况下移动工具处于活动状态（启用状态）。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf77ec97e7.png" alt="image-20220911155928408" style="zoom:80%;" /><p>工具栏右侧的另外三个按钮，分别影响物体对象的中心点，物体坐标系以及物体吸附。</p><blockquote><p>其动态使用效果可以查看<a href="httpss://blog.csdn.net/Liyager/article/details/120671179">Unity 工具栏功能介绍</a></p></blockquote><h2 id="创建时钟的表面"><a href="#创建时钟的表面" class="headerlink" title="创建时钟的表面"></a>创建时钟的表面</h2><p>虽然我们创建了一个时钟物体，但是我们并没有创建任何实际物体。我们必须向其添加 3D 模型，以便于渲染一些东西。Unity 中默认给我们提供了一些用来构建简单时钟的简单物体。现在来通过 <em>GameObject&#x2F; 3D Object &#x2F; Cylinder</em> 场景中添加一个圆柱体，添加完成后请确保其的 Transform 和我们的 Clock 物体有相同的值。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf782c7d95.png" alt="image-20220911160847342" style="zoom:80%;" /><p>新创建的物体比之前的空物体多了三个组件（Component）。首先，它拥有一个 Mesh Filter，其中包含对圆柱体网格的引用。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf78733bb5.png" alt="image-20220911161236700" style="zoom:80%;" /><p>第二个是 Mesh Renderer。该组件（Component）的目的是确保物体网格会倍渲染。同时它还确定了所使用的材质，即该物体所使用的默认材质。该材质也会被显示在组件列表的最下方。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf78b40e91.png" alt="image-20220911161422280" style="zoom:80%;" /><p>第三个组件是 Capsule Collider ，用于 3D 物理。该对象表示一个圆柱体，但是它缺拥有一个胶囊碰撞体，因为 Unity 没有原始圆柱体碰撞体。现在我们将这个组件删除即可，因为我们不需要它，如果你希望在 Clock 使用物理学，最好使用 Mesh Collider 组件。你可以通过组件右上角三个点来删除组件。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf78f304e9.png" alt="image-20220911161814332" style="zoom:80%;" /><p>现在我们将圆柱体变成钟表的底面。这是通过减少其 Y 轴缩放比例分量来实现的。将其降低到 0.2 ；现在来将其 X 和 Z 轴的缩放分量扩大到 10 来获得一个比较大的钟表底面。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf792afe0e.png" alt="image-20220911162105818" style="zoom:80%;" /><p>我们的时钟应该是竖直站立或者悬挂在墙上的，而目前是平放的。我们可以将圆柱体旋转 $\frac{1}{4}$ 圈来解决这个问题。在 Unity 中，X 轴指向右侧，Y轴指向上方，Z轴指向前方。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf79727805.png" alt="image-20220911162516873" style="zoom:80%;" /><p>现在来将圆柱体名称更改为 Face，它代表了 Clock（时钟）的表面，是其一部分。我们可以通过将其拖动到 Clock 层级下方来实现其父子关系。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf79c0dac6.png" alt="image-20220911162716377" style="zoom:80%;" /><p>子物体受制于父物体的变换，这意味着如果改变 Clock 物体的位置，Face 也会倍改变位置。旋转和缩放也是如此。你可以通过如此来制作复杂的对象层次结构。</p><h2 id="创建时钟时间标识"><a href="#创建时钟时间标识" class="headerlink" title="创建时钟时间标识"></a>创建时钟时间标识</h2><p>时钟外侧往往有时间标识用来指示时间，现在我们来使用 12 块来表示 12 小时制的时间。</p><p>通过添加一个立方体（Cube）物体到场景中，并命名其为 Hour Indicator 12 ，使其成为 Clock 物体的子对象，其层级顺序无关紧要。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf79fcdef7.png" alt="image-20220911163058758" style="zoom:80%;" /><p>然后将其进行为下图设置，使其成为一个扁平的物体。将其移动到 Face（钟表表面）上以指示 12 小时，同时移除它的 Box Collider 组件。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7a317024.png" alt="image-20220911163317496" style="zoom:80%;" /><p>由于时间标识器的颜色和表面颜色相近以至于很难看到。现在我们来对它创建一个单独的材质。通过 <em>Assets&#x2F; Create &#x2F; Material</em> 或者项目窗口（Project）右上角的加号来创建。这里我们创建了一个材质资源，并将其命名为 Hour Indicator 。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7a7dcc0f.png" alt="image-20220911163729567" style="zoom:80%;" /><p>现在来选中材质然后单击其颜色，这样会打开一个颜色弹出窗口，该窗口提供了不同颜色的选择方式，我选择了深灰色，对应 16 进制的 494949 。我们不使用 Alpha 通道，所以它的值不需要设置。然后保持材质的其他属性不变即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7abe0180.png" alt="image-20220911164032363" style="zoom:80%;" /><p>【<strong>什么是 Albedo（反射率&#x2F;漫反射率）？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Albedo 是一个拉丁词语，它的意思是 Whiteness (白色程度)</span><br><span class="line">它表示物体被白光照亮某物时的某物颜色。</span><br></pre></td></tr></table></figure><p>现在你可以通过将材质拖动到 场景（Scene）中或者层级窗口（Hierarchy）中的物体上来执行为物体赋予新的材质。你也可以在物体的 Mesh Renderer 组件的 Materials 属性改变其指向为你所指定的材质。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7afcb60e.png" alt="image-20220911164657105" style="zoom:80%;" /><h2 id="十二小时时间标识"><a href="#十二小时时间标识" class="headerlink" title="十二小时时间标识"></a>十二小时时间标识</h2><p>现在来复制 12 小时标识器，增加6，12，3，9小时标识，3，9小时标识其 X 位置应该为 4 和 -4。Y 轴的位置应该是 0 。另外它们的 Z 旋转设置为 90 ，这样它们就会旋转 $\frac{1}{4}$ 圈。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7b368d09.png" alt="image-20220911165741792" style="zoom:80%;" /><p>然后复制创建另外的标识物体，这次要设置的是 1 标识，要将其 Y 位置设置为 3.464，并选择其 Z 轴旋转为 -30 .然后复制创建 2 小时标识，交互其 X 和 Y 轴的数值，然后将 Z 轴旋转加倍到 -60 。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7b73e1e0.png" alt="image-20220911165931200" style="zoom:80%;" /><p>【<strong>这些数值都是从哪里来的？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每小时沿着 Z 轴顺时针旋转 30°。在这种情况下，我们可以通过三角函数，30°的正弦为 1/2，其余弦为 2分之根号3，我们按照其距离中心为 4来计算，最终得到 X 为 2，Y为 2根号3，即约等于3.364。</span><br><span class="line">对于旋转为 60°来说，只需要交互其正弦和余弦即可。</span><br></pre></td></tr></table></figure><p>现在来复制其他小时标识，来完成 12 小时时间标识。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7bb3d6d4.png" alt="image-20220911170344215" style="zoom:80%;" /><h2 id="创建指针"><a href="#创建指针" class="headerlink" title="创建指针"></a>创建指针</h2><p>接下来创建时钟指针，现在来从小时指针开始。再次复制 Hour Indicator 12 并命名为 Hours Arm 。然后创建一个 Clock Arm 的材质来赋给 Hours Arm 使用。在该材质，我创建其为纯黑色，即十六进制的 000000。然后将其 X 比例减小到 0.3，将其 Y 比例增加到 2.5 。然后将其 Y 位置改为 0.75，使其指向 12 小时标识，同时也让其位置超过中心位置向下一点，这样使得其在旋转的时候拥有一点配重的感觉。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7bf7a3b8.png" alt="image-20220911171610682" style="zoom:80%;" /><p>时针的旋转需要围绕时钟的中心，但是现在如果改变其 Z 旋转，只会使其围绕自己的中心旋转。</p><p><video src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/Rotating Clock Arm Itself.webm" controls="" width="50%" ></video></p><p>发生如上情况是因为旋转是相对于游戏物体的本地位置。要创建适当的旋转，我们必须引入一个轴并旋转该轴对象。所以创建一个新的空物体，并将其命名为 Hours Arm Pivot 并确保其位置和旋转为 0，且其缩放比例为 1 。然后使 Hours Arm 成为 Hours Arm Pivot 的子物体。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7c6c91bc.png" alt="image-20220911172437344" style="zoom:80%;" /><p>现在来尝试转动时针轴，如果你在场景（Scene）视图中进行此操作，<strong>请确保工具栏右侧第一个按钮的设置为 Pivot 而不是 Center</strong>。</p><p><video src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/Rotating Clock Arm Pivot.webm" controls="" width="50%" ></video></p><p>复制Hours Arm Pivot两次分别创建一个 Minutes Arm Pivot（分针）和一个 Seconds Arm Pivot（秒针）并相应的重命名它们，包括其包含的子物体。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7cc50fc1.png" alt="image-20220911185055710" style="zoom:80%;" /><p>然后分别调整 Minutes Arm（分针）的值为如下图所示，需要注意的是：这些值是针对分针来说的，而不是其轴点。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7d022d73.png" alt="image-20220911185204949" style="zoom:80%;" /><p>接下来是调整Seconds Arm（秒针）值如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7d3c8dab.png" alt="image-20220911185309837" style="zoom:80%;" /><p>最后为秒针创建一个特殊颜色的材质来区别其他指针，我采用深红色，即十六进制的 B30000。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7d732681.png" alt="image-20220911185645927" style="zoom:80%;" /><p>在完成时钟场景的构建后，就是保存场景的好时机，你可以通过<em>File &#x2F; Save</em>或者其指定的键盘快捷键来完成保存。</p><p>同时，时刻保持你的项目资源文件夹整洁是一个好习惯，所以我们会为材质创建一个<em>Materials</em>的文件夹用来存放我们为时钟创建的各种材质。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7dad033c.png" alt="image-20220911190029217" style="zoom:80%;" /><h1 id="时钟动画"><a href="#时钟动画" class="headerlink" title="时钟动画"></a>时钟动画</h1><p>现在我们创建的时钟仅仅是个物体，它并不会自己进行转动，需要我们对其进行动画处理，我们必须通过脚本来进行定义其行为，即为物体添加自定义组件（Component）。</p><h2 id="C-脚本"><a href="#C-脚本" class="headerlink" title="C# 脚本"></a>C# 脚本</h2><p>通过 <em>Assets &#x2F; Create &#x2F;C# Scripts</em> 并命名为 Clock。C# 是用于 Unity 脚本的编程语言，其发音为 C-Sharp。现在我们来创建一个 <em>Scripts</em> 文件夹来存放我们创建的脚本，来保持项目资源文件夹的整洁。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7de6d739.png" alt="image-20220911190400650" style="zoom:80%;" /><p>当我们选中脚本后，在检查器（Inspector）面板会显示其内容。但是要编辑其内容，我们必须通过代码编辑器来完成。你可以通过按键 Open 进行编辑，也可以在项目文件面板双击对应的脚本。Unity 会通过首选项配置的编辑器打开选中的脚本。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7e241077.png" alt="image-20220911190729550" style="zoom:80%;" /><h2 id="定义新组件类型"><a href="#定义新组件类型" class="headerlink" title="定义新组件类型"></a>定义新组件类型</h2><p>在你的代码编辑器加载脚本后，首先删除标准模板代码，因为我们将从头开始创建组件类型（Type）。</p><p>一个空的脚本文件没有定义任何东西。我们通过定义 Clock 类型，这样我们就可以在 Unity 中创建多个这样的组件。即使我们在本教程中仅仅使用这一个时钟。</p><p>在 C# 中，我们首先声明 Clock 是通过如下代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Clock</span></span><br></pre></td></tr></table></figure><p>【<strong>从技术角度上来说，什么是类（Class）？】</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你可以将类（Class）视为可以驻留在内存中的对象的蓝图，这些蓝图定义了这些对象应该包含的数据以及它们所有的功能。</span><br></pre></td></tr></table></figure><p>因为我们不想限制哪些代码可以访问我们的<code>Clock</code>类型，所以最好在它的前面加上<code>Public</code>访问修饰符。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span></span><br></pre></td></tr></table></figure><p>【<strong>类的默认访问修饰符是什么？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果没有设定访问修饰符，编译器默认我们使用的是 internal class Clock，这将限制对于来自同一程序集的代码的访问，所以为了确保它始终有效，请默认将类设置为公开，即使用 Public 关键词</span><br></pre></td></tr></table></figure><p>此时，我们的还并不是有效的 C# 语法，如果你保存脚本文件并且返回 Unity 编辑器中后，其编译的错误记录会显示在控制台（Console）窗口中。</p><p>我们在定义一个类型的时候，需要使用如下的一对大括号来完成对类型定义的结束表示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>现在来说，我们的代码是有效的。在保存文件并返回 Unity 编辑器后，Unity 检测到 Assets 的脚本文件发生变化，则会出发重新编译。完成后，选择我们的脚本，检查器（<em>Inspector</em>）面板会提示我们没有<code>MonoBehaviour</code>脚本。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7e6d224a.png" alt="image-20220911192411425" style="zoom:80%;" /><p>这意味着我们不能使用这个脚本在 Unity 中创建组件。至此，我们定义了<code>Clock</code>类的一个 C# 基本类型。但是我们自定义组件类型，必须使用 Unity 的<code>MonoBehaviour</code>类型，来继承它的数据和功能。</p><p>【**<code>Mono-Behaviour</code>是什么意思？**】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是我们可以编写我们自定义组件来为游戏物体添加自定义行为。这就是 Behaviour 部分所指示的信息。它碰巧使用了英式拼写。而Mono 是指将自定义代码添加到 Unity 的方式，它使用了 Mono 项目，这是个将 .NET 框架跨平台实现的项目。而 MonoBehaviour 是一个旧的名称，为了向后兼容，所以一直使用到现在。</span><br></pre></td></tr></table></figure><p>要使得<code>Clock</code>类型变成<code>MonoBehaviour</code>的子类型，我们必须更改我们对<code>Clock</code>类型的声明方式。我们可以在类型声明后面使用<code>:</code>来完成，如下代码所示，这样就使得<code>Clock</code>继承<code>MonoBehaviour</code>类型的所有内容。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span>:<span class="title">Monobehaviour</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>但是，这些写编译器会报错，表示无法找到<code>MonoBehaviour</code>类型，这是因为我们需要引用命名空间<code>UnityEngine</code>，因为<code>MonoBehaviour</code>类型就包含在其中，所以要访问它，我们需要使用其完整的引用名称，即<code>UnityEngine.MonBehaviour</code>。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span>:<span class="title">UnityEngine.MonoBehaviour</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>【<strong>什么是命名空间？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命名空间类似于网站域名，但是是用于代码部分，命名空间可以用来组织代码并防止代码中的名称冲突。</span><br><span class="line">UnityEngine代码程序集是 Unity 自带的，所以你不需要再单独获取它，如果你导入了适当的编辑器集成包，则编译器会自动识别并使用它</span><br></pre></td></tr></table></figure><p>在我们在访问 Unity 类型的时候，每次都带着<code>UnityEngine</code>是很不方便的，所以我们可以通过在文件头顶部分添加<code>using EnityEngine </code>来完成整体声明，并以分号表示结束，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span>:<span class="title">MonoBehaviour</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>现在我们可以将自定义的组件添加到我们的 Clock 游戏物体中了，你可以通过拖动脚本到物体来完成或者通过 <em>Add Component</em> （添加组件）来添加。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7eace376.png" alt="image-20220911194635356" style="zoom:80%;" /><p>需要注意的是：我的教程中大多数的代码类型都会链接到在线文档，例如<a href="httpss://docs.unity3d.com/ScriptReference/MonoBehaviour.html">MonoBehaviour</a> 是一个链接，可以通过它来访问 Unity 中该类型的脚本 API 页面。</p><h2 id="获取时针指针"><a href="#获取时针指针" class="headerlink" title="获取时针指针"></a>获取时针指针</h2><p>如果希望可以旋转指针，则我们所创建的<code>Clock</code>类型，需要先有指针的定义。现在我们从时针开始。和其他游戏物体一样，我们可以调整其 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Transform.html">Transform</a> 组件来旋转。所以我们必须将时针轴 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Transform.html">Transform</a> 组件添加到<code>Clock</code>类型中，这可以通过在代码中添加一个字段来完成。</p><p>我将使用<code>hours pivot</code>来命名该字段，一般习惯上我们会将字段第一个单词小写，然后其他单词的首字母大写，然后将它们合并在一起，即<code>hoursPivot</code>，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    hoursPivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还必须声明字段的类型为 UnityEngine.<a href="https://docs.unity3d.com/Documentation/ScriptReference/Transform.html">Transform</a>，在本例中，我们必须将其写在名称的前面。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform hoursPivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的类现在定义了一个可以保存对另一个对象的引用字段，该对象的类型必须是 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Transform.html">Transform</a> 类型，所以我们可以通过该字段来保存对时针的轴的 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Transform.html">Transform</a> 组件的引用。</p><p>默认情况下，字段是私有（private）的，这意味着你只属于<code>Clock</code>类型。但是该类不知道我们的 Unity 场景，所以没有办法直接将字段和正确的对象进行关联。我们可以通过将字段声明为可序列化（serializable）来改变这一点。这意味着当 Unity 保存场景的时候，它（该字段）应该包含在场景的数据中，它通过将所有数据按顺序排列并将其写入文件来实现。</p><p>将字段序列化（serializable）是通过将属性附加在它上面来完成的，使用 <a href="https://docs.unity3d.com/Documentation/ScriptReference/SerializeField.html">SerializeField</a> 并将其写在方括号之间并声明在字段的前面。一般来说是写在字段的上面一行，当然你也可以放在同一行上。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    Transform hoursPivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【<strong>我们不可以将其<code>Public</code>（公开）吗？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以，但是让类的字段（变量）可以被公开访问是一种不好的行为。</span><br><span class="line">经验上来说，仅仅需要被其他类型的 C# 代码访问的类型内容时才会公开类的内容，然后优先选择方法或者属性公开而不是字段。越难访问的东西就越容易维护，因为可以直接依赖它的代码更少。</span><br></pre></td></tr></table></figure><p>一旦该字段序列化（serializable）后，Unity 将检测到并将其显示在 Clock 游戏物体的检查器（<em>Inspector</em>）面板中。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7f05f3c3.png" alt="image-20220911200820460" style="zoom:80%;" /><p>要进行正确的链接（引用），我们可以将 Hours Arm Pivot 从结构层级（Hierarchy）面板拖动到对应的字段框，或者选择字段框右侧的圆形按钮进行选择。不论哪种方法，Unity 都会获取到 Hours Arm Pivot 物体的 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Transform.html">Transform</a> 组件并引用在字段上。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7f39bb2b.png" alt="image-20220911201116320" style="zoom:80%;" /><h2 id="获取所有指针"><a href="#获取所有指针" class="headerlink" title="获取所有指针"></a>获取所有指针</h2><p>现在我们来对另外的分针和秒针做同样操作，如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform minutesPivot;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform secondsPivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为声明的字段（变量）其类型是相同的，所以我们可以通过改变代码的编写方式来使得上述代码变得更加整洁：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[SerializeField]</span></span><br><span class="line"><span class="comment">//Transform minutesPivot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[SerializeField]</span></span><br><span class="line"><span class="comment">//Transform secondsPivot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【**&#x2F;&#x2F; 表示什么？**】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">双斜杠（//）在 C# 中表示注释的意思，编译器会忽略它们之后的所以文本直至最后。</span><br><span class="line">如果需要，可以通过使用它带添加文本来阐明代码。</span><br></pre></td></tr></table></figure><p>现在来将分针和秒针链接到字段（变量）上。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7f7784c2.png" alt="image-20220911201558164" style="zoom:80%;" /><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>现在我们获取所有的指针了，接下来就是旋转它们了。为此，我们需要让<code>Clock</code>类执行一些代码。这是通过向类中添加一个代码块来完成，称为：方法（Method）。该块必须以名称为前缀，安装约定大写，其命名为<code>Awake</code>，需要在组件唤醒的时候执行的代码可以写在里面。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line">    Awake&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法（Method）有点类似于数学函数，例如 $F(X) &#x3D; 2X +3$ ，函数接收一个数值，然后将其进行相关操作，输出结果。</p><p>如同数学函数一样，方法也可以产生结果，但是这不是必须的。我们必须声明结果的类型，就好像字段要声明其类型一样，或者你可以使用<code>void</code>来表示其不需要返回结果。在本例中，我们只想执行一些代码，不需要结果值，所以我们使用<code>void</code>，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> Awake&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们也不需要任何出入数据，但是我们必须将方法的参数定义在圆括号之间并用逗号分隔。在本例中，参数列表是一个空列表，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到现在为止，我们有了一个有效的方法，但是我们并没有做任何事情。如同 Unity 会检测我们定义的字段一样，它也会检测 <code>Awake</code>方法。当组件拥有<code>Awake</code>方法时，Unity会在组件唤醒的时候调用该方法。该方法发生在播放模式（Play）下被创建或者加载之后。我们目前处于编辑模式，所以并不会发生什么：</p><p>【**<code>Awake</code>方法必须要公共（Public）吗**】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Awake函数还有一些其他方法集合被认为是 Unity 的特殊事件方法，所以无论我们怎么声明它们，Unity 引擎都会找到它们并且在适当的时候执行调用它们。这将发生在托管 .NET 环境之外。</span><br></pre></td></tr></table></figure><p>请注意，<a href="https://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.Awake.html">Awake</a> 其他特殊的 Unity 事件方法在我的教程中同样有链接到他们的在线 Unity 脚本 API 页面。</p><h2 id="通过代码来旋转"><a href="#通过代码来旋转" class="headerlink" title="通过代码来旋转"></a>通过代码来旋转</h2><p>要旋转指针，我们可以通过改变物体的 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Transform.html">Transform</a> 组件的 <code>localRotation</code> 属性（property）来完成旋转。</p><p>【<strong>什么是属性（Property）？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">属性是一种伪装成字段的方法。它可能是只读或者只写的。</span><br><span class="line">C# 约定将属性大写，但是Unity的代码并不这样做。</span><br></pre></td></tr></table></figure><p>尽管在检查器（<em>Inspector</em>）面板中 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Transform.html">Transform</a> 组件的旋转是通过欧拉角（Euler angles，以度数为单位）来定义的，但是在代码中我们必须使用四元数（quaternion）来完成。</p><p>【<strong>什么是四元数（quaternion）？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">四元数是基于复数，用于表示 3D 旋转。</span><br><span class="line">虽然它相比于欧拉角的X,Y,Z轴组合更难以理解，但是它有一些独特的特性，例如：它不会出现万向节死锁的问题。</span><br></pre></td></tr></table></figure><blockquote><p>关于四元数的可以查看<a href="httpss://www.bilibili.com/video/BV1SW411y7W1">四元数的可视化</a></p></blockquote><p>我们可以通过调用 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Quaternion.html">Quaternion</a>.Euler 该方法创建基于欧拉角的四元数。为此，需要将其写入<code>Awake</code>方法在，最后以分号表示结束。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Quaternion.Euler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法具有描述所需旋转的参数，需要对其传入三个参数，分别表示 X,Y,Z轴的旋转数值，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Quaternion.Euler(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的执行结果是返回一个<code>Quaternion</code>类型的值（结构体，Strcut），其中包含绕 Z 轴顺时针旋转 30°，正好和时钟上的 1 小时匹配上。</p><p>要将其旋转结果应用在时针上，需要使用赋值语句将结果赋值给我们的时针，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        hoursPivot.localRotation = Quaternion.Euler(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【**<code>localRotation</code>和<code>rotation</code>有什么区别？**</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loaclRotation属性表示Transform组件单独描述的旋转，它是相对于其父级的旋转。</span><br><span class="line">相反而言，rotation属性表示世界空间中的旋转，这将会把整个层级结构考虑在内。</span><br><span class="line">即一个是本地为中心（父级）旋转，一个以世界中心旋转的。</span><br></pre></td></tr></table></figure><p>现在进入编辑器的播放模式（Play）。你可以通过 <em>Edit&#x2F; Play</em>来开始，或者使用快捷键，或者使用编辑器窗口顶部中心的播放按钮。进入播放模式（Play）后，Unity 会将焦点切换到游戏窗口（Game），该窗口会渲染 Main Camera 在 Scene（场景）面板中看到的内容。我们编写的 Clock 组件将会被唤醒，执行<code>Awake</code>方法的代码，将时钟设置为 1 点。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf7fdc17e9.png" alt="image-20220911210552600" style="zoom:80%;" /><p>如果你的摄像机并没有聚焦在时钟上，你可以调整它使得时钟在播放窗口中可见，但是请记住，退出播放模式时场景会重置（即恢复到播放前的状态），也就是所你在播放模式（Play）所做的任何操作都不会被保存。所以如果你需要对场景做更改，需要先退出播放模式。</p><h2 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h2><p>下一步是来计算我们当前的时间。我们可以使用 <a href="https://social.msdn.microsoft.com/search/en-us?query=DateTime">DateTime</a> 类型来获取我们当前设备的时间。<a href="https://social.msdn.microsoft.com/search/en-us?query=DateTime">DateTime</a> 类型并不是 Unity 的类型，而是 .NET 框架的功能之一，我们可以直接用来使用，其类型在<code>System</code>命名空间下。</p><p><a href="https://social.msdn.microsoft.com/search/en-us?query=DateTime">DateTime</a> 包含一个方法<code>Now</code>可以获取包含当前系统时间和日期的属性值。为了检测它是否正确，我们可以在<code>Awake</code>方法中使用<code>Debug.Log</code>来传递这个数值，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(DateTime.Now);</span><br><span class="line">        hoursPivot.localRotation = Quaternion.Euler(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们每次进入播放模式（Play）后就会记录一个时间戳，你可以通过控制台（Console）窗口或者编辑器底部的状态栏中看到它。</p><h2 id="旋转指针"><a href="#旋转指针" class="headerlink" title="旋转指针"></a>旋转指针</h2><p>现在我们来调用<code>DateTime.Now.Hour</code>，这样它会在时间戳的基础上给我们一个小时的值。</p><p>因此，为了让时针能够来显示当前小时时间，我们需要将 -30°旋转乘以 当前的小时。在代码中，我们使用<code>*</code>来表示乘法。我们现在也不需要再记录当前时间，可以直接删除<code>Debug.Log</code>语句了。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        hoursPivot.localRotation = Quaternion.Euler(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-30</span>*DateTime.Now.Hour);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf80226904.png" alt="image-20220911211634971" style="zoom:80%;" /><p>为了清晰表示我们正在从小时转换为旋转的度数，们可以定义一个名称为<code>hoursToDegrees</code>的字段，因为 <a href="https://docs.unity3d.com/Documentation/ScriptReference/Quaternion.html">Quaternion</a>.Euler 定义为浮点值，所以我们将会使用<code>float</code>类型。因为我们已经知道这个数值了，所以我们可以将其作为字段进行声明，然后使用的时候只需要用字段来表示该值即可。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> hoursToDegrees = <span class="number">-30f</span>;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        hoursPivot.localRotation = Quaternion.Euler(<span class="number">0</span>,<span class="number">0</span>, hoursToDegrees * DateTime.Now.Hour);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【<strong>什么是<code>float</code>(单精度浮点值)？</strong>】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算机并不能存储所有的数值，它必须最后被表示为 0 和 1 的二进制存储，这使得数值必须存储在有限的内存中，而不能做到存储无限的数值，这也就意味着在存储类似于 0.33333... 无限循环/不循环小数的时候，我们不得不丢弃一部分精度，即存储 0.3333 来表示 0.33333......</span><br><span class="line">而存储浮点数就是用float表示这是一个浮点数类型，它在内存一般使用 4个字节的长度来存储。</span><br></pre></td></tr></table></figure><p>如果我们直接声明一个没有后缀的数值，则会被默认为是一个整数（即整型数值），它不同于浮点类型数值，虽然编译器会自动转换它们的类型，但是我们一般会在<code>float</code>类型后通过添加<code>f</code>来表明我们的数值是<code>float</code>类型的。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> hoursToDegrees = <span class="number">-30f</span>;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        hoursPivot.localRotation = Quaternion.Euler(<span class="number">0f</span>,<span class="number">0f</span>, hoursToDegrees * DateTime.Now.Hour);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为每小时转动的度数都是相同的，我们可以通过将字段修饰为<code>const</code>来表示其是一个常量而不是字段（变量）。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">float</span> hoursToDegrees = <span class="number">-30f</span>;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        hoursPivot.localRotation = Quaternion.Euler(<span class="number">0f</span>,<span class="number">0f</span>, hoursToDegrees * DateTime.Now.Hour);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【**<code>const</code>类型有什么特殊之处？**】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const关键词表示该值永远不会改变，它的值会在编译期间计算并替换为常量来使用。</span><br></pre></td></tr></table></figure><p>现在，我们来使用对其他两个指针做类似的处理，一分钟和一秒钟都是以 -6° 来表示，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">float</span> hoursToDegrees = <span class="number">-30f</span>, minutesToDegrees = <span class="number">-6f</span>, secondsToDegrees = <span class="number">-6f</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * DateTime.Now.Hour);</span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * DateTime.Now.Minute);</span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * DateTime.Now.Second);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf80706569.png" alt="image-20220911212946178" style="zoom:80%;" /><p>我们在使用 <a href="https://social.msdn.microsoft.com/search/en-us?query=DateTime">DateTime</a>.Now 调用三次该方法，这样会导致，每次获取的数值会产生微小的差异。为了确保这种情况不再发生，我们应该只检索一次时间，我们可以通过声明一个变量并将时间分配给它来完成这点。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">float</span> hoursToDegrees = <span class="number">-30f</span>, minutesToDegrees = <span class="number">-6f</span>, secondsToDegrees = <span class="number">-6f</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">DateTime time = DateTime.Now;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * time.Hour);</span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * time.Minute);</span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * time.Second);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是变量，可以省略其类型声明，使用<code>var</code>关键字来替换它，这样可以缩短代码，但是只有当变量类型被分配值的时候才会推测其类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = DateTime.Now</span><br></pre></td></tr></table></figure><h2 id="让指针动起来"><a href="#让指针动起来" class="headerlink" title="让指针动起来"></a>让指针动起来</h2><p>现在我们进入播放模式，指针只会变化一次，即进入播放模式（Play）的时刻，我们现在需要将之前的<code>Awake</code>方法改为<code>Update</code>。这是另一个特殊的事件方法，该方法只要我们保持播放模式（Play），Unity 就会在每帧调用一次该方法，而不是类似于<code>Awake</code>方法只调用一次。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">float</span> hoursToDegrees = <span class="number">-30f</span>, minutesToDegrees = <span class="number">-6f</span>, secondsToDegrees = <span class="number">-6f</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">DateTime time = DateTime.Now;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * time.Hour);</span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * time.Minute);</span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * time.Second);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><video src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/Discrete Updating Clock - Create, .webm" controls="" width="50%" ></video></p><p>需要注意的是：我们创建的 Clock 组件（脚本）在检查器（<em>Inspector</em>）面板中出现了一个选择框，这意味我们可以通过禁用组件来禁用其中的<code>Update</code>方法。</p><h2 id="连续旋转"><a href="#连续旋转" class="headerlink" title="连续旋转"></a>连续旋转</h2><p>现在我们获得了一个离散的数字时针，但是通常来说，我们的时针具有缓慢旋转的指针，可以提供时间的模拟表示，现在来让我们对代码进行部分修改。</p><p><a href="https://social.msdn.microsoft.com/search/en-us?query=DateTime">DateTime</a> 类型并不包含小数数据，幸运的是，它确实有一个 <code>TimeOfDay</code>的属性。它返回一个<code>TimeSpan</code>类型的值，其中包含我们所需要的个数的数据，通过其<code>TotalHours，TotalMinutes,TotalSeconds</code>属性来设置我们的指针变化。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">float</span> hoursToDegrees = <span class="number">-30f</span>, minutesToDegrees = <span class="number">-6f</span>, secondsToDegrees = <span class="number">-6f</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">TimeSpan time = DateTime.Now.TimeOfDay;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * time.TotalHours);</span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * time.TotalMinutes);</span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * time.TotalSeconds);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这么写的话，编译器会给我们报错：无法从<code>double</code>转换为<code>float</code>类型，这是因为<code>TimeSpan</code>属性是双精度类型，即<code>double</code>类型。该类型提供了比<code>float</code>精度更高的类型。但是Unity 提供的方法仅仅接收一个单精度类型的数值。</p><p>所以我们可以通过显示转换类型来解决这个问题，此过程称为强制类型转换，通过在要转换的数值前面圆括号内写入要转换的类型即可。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">float</span> hoursToDegrees = <span class="number">-30f</span>, minutesToDegrees = <span class="number">-6f</span>, secondsToDegrees = <span class="number">-6f</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">TimeSpan time = DateTime.Now.TimeOfDay;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * (<span class="built_in">float</span>)time.TotalHours);</span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * (<span class="built_in">float</span>)time.TotalMinutes);</span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * (<span class="built_in">float</span>)time.TotalSeconds);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><video src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/Analog Updating Clock - Create, Discover and Share Awesome GIFs on Gfycat.webm" controls="" width="50%" ></video></p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>到目前为止，你已经了解了 Unity中创建对象（物体）和编写代码的相关基础了，下一个教程是：  <a href="httpss://www.helloseraphine.top/2022/09/18/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E3%80%90%E5%9F%BA%E7%A1%80%E3%80%91%E6%9E%84%E5%BB%BA%E5%87%BD%E6%95%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E5%BD%A2/">构建函数可视化图形</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
          <category> Catlike Coding </category>
          
          <category> Basics </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NAS入门</title>
      <link href="/2022/07/22/NAS%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8/NAS%E5%85%A5%E9%97%A8/"/>
      <url>/2022/07/22/NAS%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8/NAS%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在折腾<code>NAS</code>，关于<code>NAS</code>的想法我去年就有了，不过一直执行，其实那个时候我的硬盘空间已经不足了，因为我也算是个蓝光党，于是花费300余￥买了个 1t 的移动硬盘，到我现在购买并调试使用<code>NAS</code>，决定记录相关事宜。</p><blockquote><p>前排提醒：入门<code>NAS</code>需谨慎，这是一个烧钱的东西，第二如果你只希望存储完全不需要购买<code>NAS</code>，买个多硬盘的硬盘阵列盒即可。最重要的一点是<code>NAS</code>需要折腾。</p></blockquote><h1 id="NAS是什么"><a href="#NAS是什么" class="headerlink" title="NAS是什么"></a>NAS是什么</h1><p><em>NAS（Network Attached Storage：网络附属存储）按字面简单说就是连接在网络上，具备资料存储功能的装置，因此也称为“<a href="httpss://baike.baidu.com/item/网络存储器/9485387?fromModule=lemma_inlink">网络存储器</a>”。它是一种专用数据<a href="httpss://baike.baidu.com/item/存储服务器?fromModule=lemma_inlink">存储服务器</a>。它以数据为中心，将存储设备与服务器彻底分离，集中管理数据，从而释放带宽、提高性能、降低总拥有成本、保护投资。其成本远远低于使用服务器存储，而效率却远远高于后者。</em></p><blockquote><p>内容来源：百度百科</p></blockquote><p>用人话来说，你可以把 NAS 看作数据库，你可以将你需要保存的，备份的等只要是计算机数据都可以存储在上面。不过这样来理解 NAS 不是很正确，但是的确可以，相比于把电脑多加快硬盘，NAS 的优势就由凸显出来了。关于电脑多加块硬盘和 NAS 的区别，在看完这篇文章你或许就明白了，此处先不解释。</p><p>首先要说明的是：<strong>NAS 本质就是一台电脑</strong>，不过是专门用来数据存储而做了专门的系统。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf4585c75f.png" alt="image-20220831021154210" style="zoom: 50%;" /><p><strong>一般常见的 NAS 厂商有：群晖，海康威视，威联通等</strong>。需要注意的是每个NAS 厂商做的 NAS 产品的系统是各自家产品的系统，当然你也可以选择不去购买他们家的 NAS 而是淘洋垃圾来组装一台 NAS ，只需要装你想要的对应的 NAS 系统，当然这种组装的 NAS 被称为黑户。</p><p><strong>NAS 做的比较有名的是 群晖 NAS</strong>，很不幸，它虽然很好，但是一分钱一分货，它很贵，所以如果你有足够充足的预算的情况下，可以选择购买 群晖NAS，同样的因为每个厂商的使用人数不一样，自然用的人越多的 NAS 在出现问题的时候就会有更多人分享的解决方案。</p><blockquote><p>前排提醒：此篇<strong>文章是基于群晖NAS</strong>写的，且你已经装好了 NAS 系统</p></blockquote><h1 id="访问-NAS"><a href="#访问-NAS" class="headerlink" title="访问 NAS"></a>访问 NAS</h1><h2 id="内网访问"><a href="#内网访问" class="headerlink" title="内网访问"></a>内网访问</h2><p>首先，给你的 NAS 通电，开机，确保 NAS 已经和电脑在同一个局域网内。例如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf45c9d189.png" alt="image-20220831022103644" style="zoom: 80%;" /><p>这个图应该是一般家庭的网络构造，<strong>你需要确保你的电脑和你的NAS 通过网线连在同一个路由器上</strong>（虽然这么说不严谨），你通过在电脑的浏览器上输入对应NAS 的ip段进行访问，例如<code>192.168.1.5</code>。</p><p>群晖NAS 默认使用的访问网页端口号是5000，即上面说的ip+端口号访问，例如<code>192.168.1.5:5000</code>，不过NAS 会在你只输入ip 的情况下默认自动跳转到5000 端口对应的程序，所以即使你只输入ip地址也可以访问。</p><p>然后跟随群晖 NAS 系统的提示完成账户的注册，进入NAS桌面，例如：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf460d8abb.png" alt="image-20220831022612300" style="zoom:50%;" /><p>如果你是第一次访问NAS，则只会存在左上角的套件中心在桌面上，剩下的对于NAS 的操作可以当作 Windows 来操作即可。</p><p><strong>套件中心你可以理解为NAS 的应用商店</strong>，你需要下载安装相关的NAS 功能，服务等需要从这里下载安装。</p><p>这样就完成了在内网中对 NAS 的访问，内网也就是我前面路由器哪个图，必须在同一个局域网称为内网。</p><h2 id="外网访问"><a href="#外网访问" class="headerlink" title="外网访问"></a>外网访问</h2><p>外网访问这部分可以不着急配置，等你需要的时候再配置也可以。</p><p>外网访问和内网访问不同的是你不可以使用内网的ip地址进行访问，例如上面说的<code>192.168.1.5</code>。</p><p><strong>外网访问必须的前提是：你需要一个公网ip</strong>。这是一个大前提，关于公网ip又可以分为三种情况：</p><ul><li><strong>有公网ip：静态公网ip</strong></li><li><strong>有公网ip：动态公网ip</strong></li><li><strong>没有公网ip</strong></li></ul><h3 id="静态公网ip"><a href="#静态公网ip" class="headerlink" title="静态公网ip"></a>静态公网ip</h3><p><strong>静态公网ip：顾名思义，你的ip是固定不变的</strong>，类似于你家地址是永远不变的。</p><p>静态公网ip一般需要专门和运营商购买，价格相比于家庭宽带要贵不少。</p><p>我觉得一般家庭是没有，你可以致电你的宽带热线等询问你的宽带是否是公网ip，如果是静态公网ip，则什么都不需要做。</p><h3 id="动态公网ip"><a href="#动态公网ip" class="headerlink" title="动态公网ip"></a>动态公网ip</h3><p><strong>动态公网ip：顾名思义，就是你的ip是会改变的</strong>，具体怎么改变，什么时候改变，这个就不一定了，有的是在你的光猫每次拨号上网的时候变一次公网ip（实际上是光猫向服务商申请了一个临时公网ip），又或者每个几天会更高一下公网ip，这样的ip称为动态公网ip。</p><p>据我所知，移动似乎是动态公网ip不给的（我看很多人反映），我家是来联通的，默认就是动态公网ip，而电信的公网ip据说需要打电话给客服或者相关人员可以申请下来。</p><p><strong>因为公网ip是动态的，你总不能每次变的时候再去查看自己公网ip是啥，这样会很麻烦，而且公网ip的变动又是随机性的，这个时候你就需要做一下 DDNS</strong></p><h4 id="DDNS"><a href="#DDNS" class="headerlink" title="DDNS"></a>DDNS</h4><p><em>DDNS（Dynamic Domain Name Server，动态域名服务）是将用户的<a href="httpss://baike.baidu.com/item/动态IP地址?fromModule=lemma_inlink">动态IP地址</a>映射到一个固定的<a href="httpss://baike.baidu.com/item/域名解析/574285?fromModule=lemma_inlink">域名解析</a>服务上，用户每次连接网络的时候客户端程序就会通过信息传递把该<a href="httpss://baike.baidu.com/item/主机/455151?fromModule=lemma_inlink">主机</a>的<a href="httpss://baike.baidu.com/item/动态IP地址/10688515?fromModule=lemma_inlink">动态IP地址</a>传送给位于服务商主机上的<a href="httpss://baike.baidu.com/item/服务器?fromModule=lemma_inlink">服务器</a>程序，服务器程序负责提供DNS服务并实现<a href="httpss://baike.baidu.com/item/动态域名解析/98200?fromModule=lemma_inlink">动态域名解析</a>。</em></p><blockquote><p>来源：百度百科</p></blockquote><p>如果你解析过域名之类的事情你就会对它很熟悉，<strong>DDNS 就是通过一个程序每个一段时间来查看你家的公网ip有没有改变，有改变的话就更改DNS 服务商的域名解析地址</strong>，这样保证你通过域名访问每次都是正确的，你不需要关心公网ip是什么，有没有改变之类的问题。</p><blockquote><p>关于域名的相关问题查看<a href="httpss://www.helloseraphine.top/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%8A%EF%BC%89/">关于网站搭建那些事</a></p></blockquote><p>当然你也可以不用关心上面的解释，只需要明白弄完 DDNS 就可以正确的在外网访问你的 NAS 了。</p><ul><li><p><strong>要配置 DDNS 首先你需要一个域名，域名的注册和解析查看这部分 <a href="httpss://www.helloseraphine.top/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%8A%EF%BC%89/#%E3%80%903%E3%80%91%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E4%B8%8E%E8%A7%A3%E6%9E%90">域名的注册与解析</a></strong> ，此处不做过多说明。</p></li><li><p>在完成域名注册和解析的部分后，<strong>打开你的群晖【套件中心】</strong>，<strong>搜索【Docker】安装并启动套件</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf46661d06.png" alt="image-20220831024806686" style="zoom: 67%;" /></li><li><p><strong>启动套件后，在左侧选择【注册表】，在其中搜索【DDNS】，找到下图中红框的镜像，右键下载镜像</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf469f2ed3.png" alt="image-20220831025104404" style="zoom:80%;" /></li><li><p><strong>下载完成后，选择左侧【镜像】，找到你下载的【DDNS】，选中启动</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf46db902e.png" alt="image-20220831025622453" style="zoom:80%;" /></li><li><p>启动后，你大概会看到如下的界面，<strong>查看你的下图部分的【本地端口】</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf471c5a00.png" alt="image-20220831025810703" style="zoom:80%;" /></li><li><p>记住这串本地端口号，然后<strong>在你的浏览器上访问你的 NAS 内网ip+你刚刚查看的本地端口号</strong>，例如：<code>192.168.1.4:45678</code>.</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf47582b01.png" alt="image-20220831030237437" style="zoom:80%;" /><p>只需要填写IPV4 和DNS 服务商即上面截图出现的部分即可，然后保存。等待程序自动执行即可。</p></li><li><p>当然为了防止出现意外，你可以<strong>选择将 DDNS 选择开机启动</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf48305c1c.png" alt="image-20220831030443396" style="zoom: 67%;" /></li></ul><p>如何查看你的 DDNS 是否正确配置？去你的域名解析的地方，看看有没有自动修改对了，或者说看看域名解析的公网ip和DDNS 执行的结果是否相同。</p><p><strong>现在理论上你可以通过<code>DDNS填的你的域名:端口号</code>来远程（外网）访问你的 NAS</strong> 了，如果你尝试了会发现还是连不上，当然，<strong>这并不是DDNS 的问题，你还需要配置你家路由或者光猫的端口转发</strong>。</p><p>至于是修改你家路由器的端口转换设置还是光猫的这个要看具体情况，不过如果是修改路由器的应该不需要我这里的教程来修改了吧，<strong>如果你的光猫没有修改过桥接模式</strong>，就修改你的光猫的端口转发，反之则修改你的路由器，如果你有多个路由器，则寻找哪个路由器承担的是路由功能，而不是桥接模式。</p><p>如果你说上面说的桥接模式都没听说过，你直接修改你家光猫的端口转发即可，因为默认家庭宽带都是光猫负责路由。这个时候就需要进入你家光猫的后台，因为品牌不同，操作不同，此处以我家联通的光猫示例。</p><p>如果你问怎么进入光猫后台，查看你家光猫底面的字，会有一个网址，访问它就是。</p><p>因为联通的后台分为两个，一个是管理员后台，一个是普通用户的，所以你需要打电话问客服或者相关宽带人员，让它告诉你<strong>管理员后台的地址（一般管理员后台进了另一层网址）以及账户密码</strong></p><ul><li><p>登录到后台如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf4885f40e.png" alt="image-20220831031653475" style="zoom:80%;" /></li><li><p><strong>选择【高级配置】，选择【NAT配置】，选择【虚拟主机】</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf48e181bb.png" alt="image-20220831032000360" style="zoom:80%;" /></li><li><p>填写规则如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf492c75d6.png" alt="image-20220831032217040" style="zoom:80%;" /><ul><li>启用：选上</li><li>名称：随便起，让你自己直到这个端口转发规则是用来干啥的</li><li>协议：默认 TCP 即可</li><li>广域网主机起始和结束ip地址：这两项不填</li><li>广域网连接：默认不要动</li><li>广域网起始端口：这个就是你要设置的外网访问要用什么端口号，端口号的范围是：<strong>1到65535</strong>，但是一般建议避开$1 \sim 1023$  端口以及一些特殊端口，例如 8080等端口。</li><li>广域网结束端口：这个是和你的起始端口对应的，两者连起来表示端口范围，就是外网访问的端口号在这个范围内就转发到你指定的端口地址</li><li>启用 MAC 映射：看你自己，如果启用下面就需要填 MAC 地址而不是ip地址</li><li>虚拟主机ip地址：就是你 NAS 内网的ip</li><li>虚拟主机ip：这个需要看你要用你 NAS 的什么服务，这个端口是直接和 NAS 的端口对应的，例如你内网访问NAS 默认端口号是 5000，你需要在这里设置成 5000</li></ul></li><li><p>填写完成后，启用即可。这个时候你就可以通过<code>你设置的域名:你设置的外网访问端口</code>就可以远程（外网）访问你的NAS了。</p></li></ul><p>这里如果<strong>你在内网中访问这个你设置号的外网访问地址，会出现访问不到的原因，解决办法 NAT 回流</strong>，此处不再讨论访问。</p><p><strong>如果你想尝试外网连接测试一下，请使用手机数据连接访问尝试，或者手机用数据连接开热点，然后电脑连接热点来访问NAS</strong>。</p><h3 id="没有公网ip"><a href="#没有公网ip" class="headerlink" title="没有公网ip"></a>没有公网ip</h3><p><strong>做内网穿透，和端口转发类似，</strong>比较有名的内网穿透例如：花生壳等。具体内网穿透教程此处不做说明。</p><p>需要注意的是，关于内网穿透：</p><ul><li><strong>内网穿透一般需要付费</strong></li><li>内网穿透的网速有上限，也就是说，如果你外网访问内网NAS很大的数据，或许网速会比较</li><li>内网穿透是要付费的，所以加钱可以提高一定的外网访问网速</li><li>但是真要说外网访问，主要还是要看自家宽带的上行带宽，一般是你家宽带的 $\frac{1}{10}$，例如你家是300M的宽度，上行带宽可能就是30M（当然这种计算方式是基于动态公网ip和静态公网ip）</li></ul><p>如果你希望可靠免费网速还不错的，只能是用自己家的宽带，内网穿透本质还是借助端口转发给了你一个公网ip罢了。</p><p>到此为止，你就已经解决了 NAS 的内网和外网的访问问题了。</p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>NAS 在完成了硬件的购买&#x2F;组装，系统的安装，完成了内网&#x2F;外网的访问，最终要的就是存储了，NAS 存储就不得不提两种存储介质：</p><ul><li><strong>机械硬盘：相对便宜，但是速度相比慢</strong></li><li><strong>固态硬盘：相对昂贵，但是速度快</strong></li></ul><p>我这里只讨论机械硬盘，因为涉及到存储了，一般人应该没有钱烧到只买固态硬盘，而且固态硬盘的存储寿命不如机械硬盘。</p><p>关于机械硬盘的详细内容我不做过多说明，<strong>如果用于NAS 的硬盘选购前注意硬盘尺寸要和自己的NAS 相符，如果预算充足尽量购买紫盘或者红盘，红盘优先级更高。当然硬盘还根据其原理分为CMR 和 SMR，SMR就是我们常说的叠瓦盘，叠瓦盘优点是在相同的价格下，可以提高存储容量，人话就是存储容量高，但是它的写入读取速度等都相比于CMR差很多，一般建议购买 CMR</strong> ，当然，如果你确定你的数据不是那种经常读写的，也可以购买，这个根据自己的需求来。</p><h2 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h2><p>存储阵列是根据硬盘来对数据存储的处理，因为使用的NAS 所以这种算法是软件的，而不是那种硬盘柜的硬件实现的。存储阵列有很多种，但是常用的如下：</p><p><em>Raid 0：一块硬盘或者以上就可做</em><br><em>raid0优势：数据读取写入最快，最大优势提高硬盘容量，比如3快80G的硬盘做raid0 可用总容量为240G。速度是一样。</em><br><em>缺点：无冗余能力，一块硬盘损坏，数据全无。</em><br><em>建议：做raid0 可以提供更好的容量以及性能，推荐对数据安全性要求不高的使用。</em></p><p><em>Raid 1：至少2快硬盘可做</em><br><em>raid1优势：镜像，数据安全强，2快硬盘做raid一块正常运行，另外一块镜像备份数据，保障数据的安全。一块坏了，另外一块硬盘也有完整的数据，保障运行。</em><br><em>缺点：性能提示不明显，做<a href="httpss://www.zhihu.com/search?q=raid1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"112988111"}">raid1</a>之后硬盘使用率为50%.</em><br><em>建议：对数据安全性比较看着，性能没有太高要求的人使用。</em></p><p><em>Raid5：至少需要3块硬盘</em><br><em>raid5优势：以上优势，raid5兼顾。任意N-1快硬盘都有完整的数据。</em><br><em>缺点：只允许单盘故障，一盘出现故障得尽快处理。有盘坏情况下，raid5 IO&#x2F;CPU性能狂跌，此时性能烂到无以复加。</em><br><em>建议：盘不多，对数据安全性和性能提示都有要求，raid5是个不错选择，鉴于出问题的性能，盘多可考虑<a href="httpss://www.zhihu.com/search?q=riad10&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"112988111"}">riad10</a></em></p><p><em>Raid10:至少需要4快硬盘。<a href="httpss://www.zhihu.com/search?q=raid10&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"112988111"}">raid10</a>是2快硬盘组成raid1,2组raid1z组成raid0,所以必须需要4块硬盘。</em></p><p><em>优势：兼顾安全性和速度。基础4盘的情况下，raid10允许对柜盘2块故障，随着硬盘数量的提示，容错量也会相对应提升。这是raid5无法做到的。</em></p><p><em>缺点：对盘的数量要求稍高，磁盘使用率为一半。</em></p><p><em>建议：硬盘数量足够的情况，建议riad10.不过raid最重要的指标是可靠性：4盘的raid5,只允许单盘故障，raid10,允许对柜盘2块g故障，可靠性高于raid5,且raid10 可随盘上升提高容错，raid就不行，而且IO和CPU的额外开销还涂增，从可靠性和冗余角度，达到同样的可靠性,raid10写能力高于raid5.</em></p><p><em>特殊情况下：有坏盘，无热备radi5 CPU和IO性能狂跌。因为数据不完整，在某特殊软件下，实现即时重构数据进驻内存，保障业务运行，但此生raid5的性能已经烂到无以复加。raid10 是条带化+镜像，坏盘影响读性能，不影响写性能，而且无需重构。此时的raid10完爆raid5</em></p><blockquote><p>斜体内容来自<a href="httpss://zhuanlan.zhihu.com/p/112988111">知乎作者:Natasha</a></p></blockquote><p>当然，这些都是精简版的了，如果你想要详细的知道可以查看<a href="httpss://www.bilibili.com/video/BV1VJ411s7T5/">【硬件科普】磁盘阵列是什么东西？为什么需要磁盘阵列？</a> 或者其他网上或者书上等渠道的信息。</p><p>建立存储空间需要选择合适的磁盘阵列。</p><h1 id="NAS玩法"><a href="#NAS玩法" class="headerlink" title="NAS玩法"></a>NAS玩法</h1><ul><li><strong>NAS最基本也是最重要的就是：数据存储&#x2F;备份</strong></li><li>NAS还可以搭建视频影音库</li><li>NAS还可以搭建小说，漫画库</li><li>NAS最主要还可以完成数据同步，这个功能就可以实现跨平台了</li><li>NAS还可以利用<code>Docker</code>搭建各种服务器，例如：<code>RTMP</code>服务器实现自己的直播服务器，或者游戏开服务器，例如<code>我的世界</code>等等</li><li>NAS可以做下载站，文件中转站，网盘空间共享等</li></ul><p>NAS还可以做很多事情，你需要明白的是：<strong>NAS本质就是一台电脑，不过这个电脑的为了数据存储等专门设计，它可以保证全天 24小时运行，一年365天无需关机，正是这样NAS一般都是低功耗的，不需要花费大量的电费，保持自己有一台服务器一直在线。</strong></p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>这篇文章我拖了一个暑假了，说实话我一开始比较忙没来得及写，写了个开头就放一边了，后面是懒得写了，现在终于补完了。</p>]]></content>
      
      
      <categories>
          
          <category> NAS及服务器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【4.0】依赖项属性</title>
      <link href="/2022/06/21/%E5%BE%AE%E8%BD%AF%E5%A4%A9%E5%9D%91/WPF/%E3%80%904.0%E3%80%91%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%B1%9E%E6%80%A7/"/>
      <url>/2022/06/21/%E5%BE%AE%E8%BD%AF%E5%A4%A9%E5%9D%91/WPF/%E3%80%904.0%E3%80%91%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我尝试写一部分 WPF 元素绑定的相关内容的时候，写到开头发现我不得不先解释说明一下依赖项属性的相关内容，遂停止元素绑定内容的记录，补写依赖项属性的相关内容。</p><h1 id="理解依赖项属性"><a href="#理解依赖项属性" class="headerlink" title="理解依赖项属性"></a>理解依赖项属性</h1><p>属性和事件是<code>.NET</code>抽象模型的核心部分，如果你懂得 VB 或者 WinForm 相关开发的话会十分了解这点。但是对于 WPF 来说，它在传统的属性基础上做了一层封装，将它变成了更加高级的依赖项属性。同时也不会和传统的属性发生冲突。</p><p>这种更高级的依赖项属性使用了效率更高的保存机制，并支持附加功能，例如：更高通知以及属性值的继承。</p><p>依赖项属性是<code>.NET</code>属性的新实现，在 WPF 技术特性中，是及其依赖于依赖项属性的实现，虽然在使用过程中，感觉和普通的属性一致。</p><h1 id="定义依赖项属性"><a href="#定义依赖项属性" class="headerlink" title="定义依赖项属性"></a>定义依赖项属性</h1><p>绝大部分的微软提供的属性都是依赖项属性，但是在某些情况下，我们需要自定义我们自己的依赖项属性，比如我们自定义的控件。</p><h2 id="定义依赖项属性-1"><a href="#定义依赖项属性-1" class="headerlink" title="定义依赖项属性"></a>定义依赖项属性</h2><p>需要注意的是：**自定义的依赖项属性的类，必须继承于<code>DependencyObject</code>**，因为后续需要使用该类的方法来修改依赖项属性的值。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义了 Test 类，该类继承于 DependencyObject</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span> :<span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自定义依赖项属性 InfoProperty</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty InfoProperty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建依赖项属性的命名规则是最后加上<code>Property</code>来表示其为依赖项属性</p></blockquote><h1 id="注册依赖项属性"><a href="#注册依赖项属性" class="headerlink" title="注册依赖项属性"></a>注册依赖项属性</h1><p>定义好依赖项属性后需要注册依赖项属性来使用该依赖项，注册依赖项需要两个步骤，<strong>第一个步骤是创建<code>FrameworkPropertyMetadata</code>对象来决定依赖项的一些基础属性，然后创建<code>DependencyProperty</code>对象来实现依赖项属性的初始化。</strong></p><p>因为我们需要使用依赖项属性，所以依赖项属性的注册必须在使用代码之前注册，所以<strong>需要在静态构造函数中定义</strong>。又因为为了确保<code>DependencyProperty</code>，即依赖项属性不会在后续的代码中被人更改，所以使用的是<code>readonly</code>关键字。</p><p>同样的，<strong>WPF 确保<code>DependencyProperty</code>不会被直接实例化，所以必须通过静态的<code>DependencyProperty.Register</code>来生成实例对象</strong>；代码示例如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span> :<span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义依赖项属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty InfoProperty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化注册依赖项属性</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化依赖项属性的相关参数和功能</span></span><br><span class="line">        FrameworkPropertyMetadata metadata = <span class="keyword">new</span> FrameworkPropertyMetadata(<span class="string">&quot;这是默认值哦&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义依赖项属性对象</span></span><br><span class="line">        InfoProperty = DependencyProperty.Register(<span class="string">&quot;Anfo&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(Info),metadata);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FrameworkPropertyMetadata-对象"><a href="#FrameworkPropertyMetadata-对象" class="headerlink" title="FrameworkPropertyMetadata 对象"></a>FrameworkPropertyMetadata 对象</h2><p><strong>该对象规定了所注册依赖项的默认初始值，以及所支持的相关服务（布局影响，数据绑定等）</strong>，它的构造函数有多个重载，如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FrameworkPropertyMetadata</span>(<span class="params"><span class="built_in">object</span> defaultValue</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FrameworkPropertyMetadata</span>(<span class="params"><span class="built_in">object</span> defaultValue, FrameworkPropertyMetadataOptions flags, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>defaultValue</code>：该依赖项属性的默认初始值</strong>‘</p></li><li><p><strong><code>FrameworkPropertyMetadataOptions</code>：该依赖项属性的所支持的服务功能，</strong>参数如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     未指定任何选项；依赖属性使用 Windows Presentation Foundation (WPF) 属性系统的默认行为。</span></span><br><span class="line">None = <span class="number">0</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     更改此依赖属性的值会影响布局组合的测量过程。</span></span><br><span class="line">AffectsMeasure = <span class="number">1</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     更改此依赖属性的值会影响布局组合的排列过程。</span></span><br><span class="line">AffectsArrange = <span class="number">2</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     更改此依赖属性的值会影响父元素上的测量过程。</span></span><br><span class="line">AffectsParentMeasure = <span class="number">4</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     更改此依赖属性的值会影响父元素上的排列过程。</span></span><br><span class="line">AffectsParentArrange = <span class="number">8</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     更改此依赖属性的值会影响呈现或布局组合的某一方面（不是测量或排列过程）。</span></span><br><span class="line">AffectsRender = <span class="number">16</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     此依赖属性的值将由子元素继承。</span></span><br><span class="line">Inherits = <span class="number">32</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     此依赖属性的值跨越分隔的树以实现属性值继承。</span></span><br><span class="line">OverridesInheritanceBehavior = <span class="number">64</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     不允许将数据绑定到此依赖属性。</span></span><br><span class="line">NotDataBindable = <span class="number">128</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     此依赖属性上的数据绑定的 System.Windows.Data.BindingMode 默认为 System.Windows.Data.BindingMode.TwoWay。</span></span><br><span class="line">BindsTwoWayByDefault = <span class="number">256</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     此依赖属性的值应由日记记录进程或在由 Uniform resource identifiers (URIs) 导航时进行保存或存储。</span></span><br><span class="line">Journal = <span class="number">1024</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     此依赖属性值上的子属性不会影响呈现的任何方面。</span></span><br><span class="line">SubPropertiesDoNotAffectRender = <span class="number">2048</span></span><br></pre></td></tr></table></figure><blockquote><p>可以传入参数名称，也可以传入参数对应的数值</p></blockquote></li><li><p><strong><code>CoerceValueCallback</code>：该方法在<code>validateValueCallback</code>后执行，可以对依赖项属性进行验证</strong>，详细</p><p>可以查看下面的属性验证部分内容。</p><blockquote><p><code>validateValueCallback</code>是<code>DependencyProperty</code>类型的方法</p></blockquote></li><li><p><strong><code>propertyChangedCallback</code>：当属性值发生改变时会调用</strong></p></li></ul><h2 id="DependencyProperty-对象"><a href="#DependencyProperty-对象" class="headerlink" title="DependencyProperty 对象"></a>DependencyProperty 对象</h2><p><strong><code>DependencyProperty</code>对象的实例化需要通过静态方法<code>DependencyProperty.Register</code>来实现</strong>，该方法同样有多种重载，原型示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DependencyProperty <span class="title">Register</span>(<span class="params"><span class="built_in">string</span> name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata, ValidateValueCallback validateValueCallback</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>name</code>：你所定义的依赖项属性名称</strong>，该名称只会影响该对象的<code>Name</code>属性，不会对代码产生实际影响</li><li><strong><code>propertyType</code>：该依赖项属性的类型</strong>，即该依赖项属性的类型</li><li><strong><code>ownerType</code>：使用该依赖项属性的类型</strong>，即判断该类型对象是否支持该属性</li><li><strong><code>validateValueCallback</code>：</strong>详细查看下面的属性验证部分</li></ul><h1 id="添加属性包装器"><a href="#添加属性包装器" class="headerlink" title="添加属性包装器"></a>添加属性包装器</h1><p>在完成定义和注册依赖项属性后，<strong>需要将其包装成普通的属性</strong>，这样可以做到和普通属性一样的调用，即将其包装成传统的<code>.NET</code>属性，这样就完成依赖项属性的最后一步。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span> :<span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty InfoProperty;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        FrameworkPropertyMetadata metadata = <span class="keyword">new</span> FrameworkPropertyMetadata(<span class="string">&quot;这是默认值哦&quot;</span>);</span><br><span class="line"></span><br><span class="line">        InfoProperty = DependencyProperty.Register(<span class="string">&quot;Anfo&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(Info),metadata);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String Info</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; SetValue(InfoProperty, <span class="keyword">value</span>); &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> (String)GetValue(InfoProperty); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在就以及拥有了一个功能完备的依赖项属性了，可以像使用其他依赖项属性一样使用它。</p><p>另外，需要注意的是，依赖项属性值的确定是根据优先规则来确定的，即使你并没有直接设置它的值，它也可能通过数值绑定，样式等提供获取，也可能是元素树中继承而来。<strong>如果你希望删除本地值设置，像从来没有设置过一样，需要使用另一个继承自<code>DependencyProperty</code>的方法<code>ClearValue()</code>来实现</strong>。</p><h1 id="WPF-使用依赖项属性的方式"><a href="#WPF-使用依赖项属性的方式" class="headerlink" title="WPF 使用依赖项属性的方式"></a>WPF 使用依赖项属性的方式</h1><p>WPF 的许多行为功能都需要使用依赖项属性，所有的功能都是<strong>通过每个依赖项属性都支持的两个关键行为进行工作的——更改通知和动态值识别</strong>。</p><h2 id="更改通知"><a href="#更改通知" class="headerlink" title="更改通知"></a>更改通知</h2><p><strong>即当属性值发生变化时所进行的相关操作</strong>。</p><p><strong>当属性值发生变化时，依赖项属性会触发受保护的名为<code>OnPropertyChangedCallback()</code>的方法，该方法通过了数据绑定和触发器来传递信息，并调用<code>PropertyChangedCallback()</code>回调方法。</strong></p><p>换句话所，当属性发生变化时，如果希望进行响应，有两种选择：</p><ul><li><strong>使用属性值创建绑定</strong></li><li><strong>使用触发器</strong></li></ul><p>但是对于通用方法触发一些代码，WPF 处于性能考虑并没有给出，相反的可以将代码定义在回调函数<code>PropertyChangedCallback()</code>来替代实现。</p><h2 id="动态值识别"><a href="#动态值识别" class="headerlink" title="动态值识别"></a>动态值识别</h2><p><strong>即判定依赖项属性值的赋值问题。</strong></p><p>本质上依赖项属性，依赖于多个对象来获取属性值，每个提供者的优先级不同。WPF 会通过一系列检索，获取最终的属性值，相关检索因素如下（<strong>优先级从低到高</strong>）：</p><ol><li><strong>默认值（即注册依赖项属性的时候<code>FrameworkPropertyMetadata</code>对象定义的初始值）</strong></li><li><strong>继承了原来的值</strong></li><li><strong>来自主题样式的值</strong></li><li><strong>来自项目样式的值</strong></li><li><strong>本地值（通过 XAML 或者 CS代码直接设置的值）</strong></li></ol><p>如上所示，通过设置优先级高的依赖项提供者，来改变依赖项属性的值。</p><blockquote><p>这样做的好处是可以节省内存，；例如：对于一个窗口的多个<code>Button</code>控件，如果每个<code>Button</code>都可以使用主题或者其父级的样式，就可以少存储一份单独的样式值</p></blockquote><p>当然，在进行上述的值确定后，还需要考虑其他的可改变属性值的提供者，总结来说，WPF 确定属性值的步骤如下：</p><ol><li><p><strong>确定基本值（即上面的步骤）</strong></p></li><li><p><strong>如果属性使用的表达式设置，则对表达式进行求值。</strong></p><blockquote><p>WPF 支持两种表达式：<strong>数据绑定和资源</strong></p></blockquote></li><li><p><strong>如果属性是动画的目标，则应用动画</strong></p></li><li><p><strong>运行<code>CoerceValueCallBack</code>回调函数来修正属性值</strong></p></li></ol><h1 id="共享依赖项属性"><a href="#共享依赖项属性" class="headerlink" title="共享依赖项属性"></a>共享依赖项属性</h1><p>尽管一些类具有不同的继承层次，但是可以通过<code>DependencyProperty.AddOwner()</code>来共享同一个依赖项属性。</p><p>代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Apple</span> :<span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty SizeProperty;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Apple</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        FrameworkPropertyMetadata metadata = <span class="keyword">new</span> FrameworkPropertyMetadata(<span class="string">&quot;这是默认值哦&quot;</span>);</span><br><span class="line"></span><br><span class="line">        SizeProperty = DependencyProperty.Register(<span class="string">&quot;Size&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(Apple),metadata);</span><br><span class="line">        TextBlock textBlock = <span class="keyword">new</span> TextBlock();</span><br><span class="line">        Control control = <span class="keyword">new</span> Control();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String Info</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; SetValue(SizeProperty, <span class="keyword">value</span>); &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> (String)GetValue(SizeProperty); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">static</span> DependencyProperty SizeProperty;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Car</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//共享Apple的依赖项属性</span></span><br><span class="line">        SizeProperty = Apple.SizeProperty.AddOwner(<span class="keyword">typeof</span>(Car));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String Size</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; SetValue(SizeProperty, <span class="keyword">value</span>); &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> (String)GetValue(SizeProperty); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="附加的依赖项属性"><a href="#附加的依赖项属性" class="headerlink" title="附加的依赖项属性"></a>附加的依赖项属性</h1><p><strong>附加属性被应用到的类并非定义附加属性的类</strong>，例如，<code>Grid</code>类定义的<code>Row</code>和<code>Column</code>属性是在其嵌套的元素中应用的。</p><p><strong>定义附加属性，需要使用<code>RegisterAttached()</code>方法</strong>，而不是<code>Register()</code>方法。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Apple</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        FrameworkPropertyMetadata metadata = <span class="keyword">new</span> FrameworkPropertyMetadata(<span class="string">&quot;这是默认值哦&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册依赖项属性</span></span><br><span class="line">        SizeProperty = DependencyProperty.RegisterAttached(<span class="string">&quot;Size&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(Apple),metadata);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>与普通依赖属性一样，可以设置其回调函数。</p><p><strong>当创建附加属性时，不需要定义<code>.NET</code>属性封装器，这是因为附加属性可以被用于任何依赖对象</strong>。例如：<code>Grid.Row</code>属性可以被用在任何对象上。</p><p>不使用<code>.NET</code>属性封装器，反而附加属性因为需要满足被所有对象调用，所以<strong>需要两个静态方法来设置和获取属性值，这样来替代属性封装器。</strong>代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetValue</span>(<span class="params">Car car</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">string</span>)car.GetValue(Apple.SizeProperty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params">Car car,<span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    car.SetValue(Apple.SizeProperty,<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然<strong>你也可以通过直接使用<code>GetValue</code>和<code>SetValue</code>方法来绕过这两个静态方法直接获取和设置值</strong>，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">car2.SetValue(Apple.SizeProperty, <span class="string">&quot;这是car2的属性值&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上示例完整<code>CS</code>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Apple</span> :<span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明附加属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty SizeProperty;</span><br><span class="line"><span class="comment">//初始化对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Apple</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//设置附加属性的相关服务</span></span><br><span class="line">        FrameworkPropertyMetadata metadata = <span class="keyword">new</span> FrameworkPropertyMetadata(<span class="string">&quot;这是默认值哦&quot;</span>);</span><br><span class="line"><span class="comment">//注册附加属性</span></span><br><span class="line">        SizeProperty = DependencyProperty.RegisterAttached(<span class="string">&quot;Size&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(Apple),metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//附加属性获取方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetValue</span>(<span class="params">Car car</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">string</span>)car.GetValue(Apple.SizeProperty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//附加属性设置方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params">Car car,<span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        car.SetValue(Apple.SizeProperty,<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//空内容，只是单独表示一个要使用附加属性但自己没定义该附加属性的类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是调用验证附加属性的过程，我采用的是WPF的项目，写在了窗口初始化的事件里面</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Window_Initialized</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义两个Car对象</span></span><br><span class="line">    Car car1 = <span class="keyword">new</span> Car();</span><br><span class="line">    Car car2 = <span class="keyword">new</span> Car();</span><br><span class="line">    <span class="comment">//查看两个对象附加属性的初始值</span></span><br><span class="line">    Console.WriteLine(Apple.GetValue(car1)+ Apple.GetValue(car2));</span><br><span class="line">    <span class="comment">//通过定义的附加属性静态方法设置 car1 对象的附加属性值</span></span><br><span class="line">    Apple.SetValue(car1, <span class="string">&quot;这是car1的属性值&quot;</span>);</span><br><span class="line">    <span class="comment">//查看两个对象现在的附加属性初始值</span></span><br><span class="line">    Console.WriteLine(Apple.GetValue(car1)+ Apple.GetValue(car2));</span><br><span class="line">    <span class="comment">//采用SetValue直接绕过定义的静态方法修改附加属性的值</span></span><br><span class="line">    car2.SetValue(Apple.SizeProperty, <span class="string">&quot;这是car2的属性值&quot;</span>);</span><br><span class="line">    <span class="comment">//查看两个对象的附加属性初始值</span></span><br><span class="line">    Console.WriteLine(Apple.GetValue(car1) + Apple.GetValue(car2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf5fe20c4c.png" alt="image-20220621123310797"  /><h1 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h1><p><strong>在定义任何类型的属性的时候，都需要面对错误设置属性的可能性</strong>。对于传统的<code>.NET</code>可以直接在属性设置器中捕获验证这些问题。但是对于依赖项属性来说，它是通过静态方法<code>SetValue</code>来设置的，所以并不适用。</p><p>不过，<strong>WPF 对此提供了两种替代方法来阻止非法值</strong>：</p><ul><li><strong><code>ValidateValueCallback</code>：该回调函数可接受或拒绝新值。</strong>通常，该回调函数用于捕获违反属性约束的明显错误。作为<code>DependencyProperty.Register()</code>方法的一个参数。</li><li><strong><code>CoerceValueCallback</code>：该回调函数可将新值修改为更能被接受的值。</strong>该回调函数通常用于处理为相同对象设置的依赖项属性值相互冲突的问题。这些值本身可能是合法的，但是同时应用时它们时是相互冲突的。作为<code>FrameworkPropertyMetadata</code>对象的参数。</li></ul><p>当应用程序试图更改设置依赖项属性时，如下时这些内容的作用过程：</p><ol><li>首先，<code>CoerceValueCallback</code>方法有机会修改提供的值（通常使提供的值和其他属性值相容，即做一层映射），或者返回<code>DependencyProperty.UnsetValue</code>，来拒绝修改。【强制回调】</li><li>接下来激活<code>ValidateValueCallback</code>方法，该方法返回<code>true</code>接受一个值作为合法值，或者返回<code>false</code>来拒绝值。与上面方法不同的是，<strong>该方法不能访问设置属性的实际对象，这意味着不能检查其他属性</strong>。【验证回调】</li><li>最后，**如果上面两个阶段都成功，则触发<code>PropertyChangedCallback</code>**。</li></ol><p>通俗来所，对于需要映射来兼容其他方法参数或者需要对参数进行约束，例如：对于<code>ScrollBar</code>有最大值和最小值，则需要通过<code>CoerceValueCallback</code>方法来判断最大值是否小于最小值做一次冲突验证。而对于<code>Margin</code>属性来说，如果传入参数为<code>-1</code>，则可以通过<code>ValidateValueCallback</code>来验证传入参数是否合法。最后两个都通过了，则触发<code>PropertyChangedCallback</code>。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>如果你只是想使用依赖项属性，则只需要查看如何定义注册使用，比葫芦画瓢即可，如果你想要了解它的工作原理，则需要理解去了解。</p>]]></content>
      
      
      <categories>
          
          <category> 微软天坑 </category>
          
          <category> WPF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【1.0】初识Mainm</title>
      <link href="/2022/06/15/%E8%A7%86%E8%A7%89%E5%8A%A8%E7%94%BB/Manim/%E3%80%901.0%E3%80%91%E5%88%9D%E8%AF%86Mainm/"/>
      <url>/2022/06/15/%E8%A7%86%E8%A7%89%E5%8A%A8%E7%94%BB/Manim/%E3%80%901.0%E3%80%91%E5%88%9D%E8%AF%86Mainm/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我了解到<code>Manim</code>是在去年春夏的时候的事情了，当时沉迷于游戏开发，涉及到3D数学方面的知识，然后就找到了<a href="httpss://space.bilibili.com/88461692/">3blue1brown </a>的相关视频，然后就了解到了他所开发使用的数学动画引擎工具，即<code>Manim</code>。</p><p><strong>前排提醒：学习<code>Manim</code>需要一定的Python基础</strong>。</p><blockquote><p>关于<code>Manim</code>所能实现的数学动画效果可以查看<a href="httpss://space.bilibili.com/88461692/">3blue1brown </a>的相关视频。</p></blockquote><h1 id="Mainm简述"><a href="#Mainm简述" class="headerlink" title="Mainm简述"></a>Mainm简述</h1><p><em>Manim was originally created by Grant Sanderson as a personal project and for use in his YouTube channel, <a href="httpss://www.youtube.com/channel/UCYO_jab_esuFRV4b17AJtAw">3Blue1Brown</a>. As his channel gained popularity, many grew to like the style of his animations and wanted to use manim for their own projects. However, as manim was only intended for personal use, it was very difficult for other users to install and use it.</em></p><p><em>In late 2019, Grant started working on faster OpenGL rendering in a new branch, known as the shaders branch. In mid-2020, a group of developers forked it into what is now the community edition; this is the version documented on this website. In early 2021, Grant merged the shaders branch back into master, making it the default branch in his repository. The old version is still available as the branch <code>cairo-backend</code>.</em></p><blockquote><p>引用自 Mainm Community 的说明文档</p></blockquote><p>简单概括上面的来说，一开始<a href="httpss://space.bilibili.com/88461692/">3blue1brown </a>开发并自己使用该工具进行数学科普，随着被人们的了解，在2019年Grant 创建了新的分支来开发更快的 OpenGL 渲染；2020年由另一群开发人员开发了社区版；2021年，Grant 将新分支开发的 OpenGL 渲染分支合并到主分支上，将原来的旧分支仍作为分支<code>cairo-backend</code>。</p><h1 id="Manim版本"><a href="#Manim版本" class="headerlink" title="Manim版本"></a>Manim版本</h1><p>截至我所写本篇文章为止，主要存在三个版本的<code>Manim</code>：</p><ul><li><strong><code>ManimCE</code><strong>：</strong>manim的社区版本</strong>，在<code>pip</code>上被命名为manim</li><li><strong><code>ManimGL</code><strong>：</strong>是 3blue1brown 使用的当前版本的manim，它支持OpenGL的渲染和交互</strong>，并以<code>manimgl</code> pip命名。</li><li><strong><code>ManimCairo</code><strong>：是最初由 3blue1brown 使用的</strong>旧版本 manim</strong>，它在 pip 上不可用。</li></ul><p>某种程度下，更加推荐使用社区版，因为它的开发是为了更加稳定，便捷的方向而开发的；如果你希望使用完全OpenGL支持的可以使用<code>ManimGL</code>；对于老版本的 3blue1brown 的项目渲染使用 <code>ManimCairo</code>。</p><blockquote><p>需要注意的是：本篇是以<code>ManimGL</code>版本为运行版本，Win系统为前提，关于社区版的相关文档可以查看<a href="httpss://docs.manim.community/en/stable/index.html">Manim Community</a></p></blockquote><p>如果你希望判断，自己所使用的版本，可以尝试通过<strong>在引用文件的不同</strong>来判断：</p><table><thead><tr><th>版本</th><th>引用方式</th></tr></thead><tbody><tr><td>ManimCE（社区版）</td><td><code>from manim import *</code></td></tr><tr><td>ManimGL</td><td><code>from manimlib import *</code></td></tr><tr><td>ManimCairo</td><td><code>from manimlib.imports import *</code></td></tr></tbody></table><h1 id="ManimGL安装"><a href="#ManimGL安装" class="headerlink" title="ManimGL安装"></a>ManimGL安装</h1><p><strong>ManimGL 需要在 Python 3.7 或者更高版本上运行</strong>。关于其附属配置需求：</p><ul><li><p>安装<a href="httpss://ffmpeg.org/">FFmpeg</a>，并配置其环境变量到<code>PATH</code>中。</p></li><li><p>OpenGL（包含在python包<code>PyOpenGL</code>中）</p><blockquote><p>OpenGL的安装需要在python包中安装PyOpenGL即可</p></blockquote></li><li><p>安装<a href="httpss://www.latex-project.org/">LaTeX</a>，如果你的存储空间足够大推荐安装<a href="httpss://tug.org/texlive/">TexLive-full</a></p></li><li><p>安装<a href="httpss://git-scm.com/">Git</a></p></li></ul><blockquote><p>关于 LaTex 的相关说明，可以查看<a href="httpss://www.helloseraphine.top/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/LaTex%E5%9F%BA%E7%A1%80(%E4%B8%8A)/">LaTex基础(上)</a></p><p>关于 Git 的相关说明，可以查看 <a href="httpss://www.helloseraphine.top/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Git%E4%B8%8EGitHub(%E4%B8%8A)/">Git与GitHub(上)</a></p></blockquote><p>在完成上面的基础配置后，开始安装 <code>ManimGL</code>，在 Git 上运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone httpss://github.com/3b1b/manim.git</span><br><span class="line">cd manim</span><br><span class="line">pip install -e .</span><br><span class="line">manimgl example_scenes.py OpeningManimExample</span><br></pre></td></tr></table></figure><p>运行完成上述代码后，会在屏幕上显示如下图像并在几秒后自动关闭，则表示安装成功。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf525e8392.png" alt="image-20220613212012420" style="zoom:50%;" /><h1 id="Manim入门"><a href="#Manim入门" class="headerlink" title="Manim入门"></a>Manim入门</h1><h2 id="渲染图片"><a href="#渲染图片" class="headerlink" title="渲染图片"></a>渲染图片</h2><p>在完成上面的安装配置后，开始制作第一个入门场景。</p><p>首先<strong>在 Git 克隆的目录下创建新的 <code>.py</code> 文件</strong>，命名可以随意，例如：<code>start.py</code>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf52a8cb34.png" alt="image-20220615152502000" style="zoom: 67%;" /><p>然后在该文件下，粘贴如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 Manimlib 所有类</span></span><br><span class="line"><span class="keyword">from</span> manimlib <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Scene 的子类 SquareToCircle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareToCircle</span>(<span class="title class_ inherited__">Scene</span>):</span><br><span class="line">    <span class="comment"># 编写 construct 方法，这里面的内容将决定如何创建渲染画面</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个圆(Circle实例)</span></span><br><span class="line">        circle = Circle()</span><br><span class="line">        <span class="comment"># 将该圆填充为蓝色，透明度为50%</span></span><br><span class="line">        circle.set_fill(BLUE, opacity=<span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># 将该圆的线条设为深蓝色，线条宽度为4</span></span><br><span class="line">        circle.set_stroke(BLUE_E, width=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通过 Scene 的 add() 方法，将这个圆绘制到画面上</span></span><br><span class="line">        self.add(circle)</span><br></pre></td></tr></table></figure><p>然后在控制台中运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manimgl start.py SquareToCircle</span><br></pre></td></tr></table></figure><blockquote><p>注：控制台需要导航到刚刚所创建的 <code>.py</code> 文件目录下</p></blockquote><p>在运行如上命令后，会在屏幕的左上角弹出一个窗口，可以通过如下操作来进行相关操控：</p><ul><li>滚动鼠标中键（滚轮）实现<strong>上下移动画面</strong></li><li>按住键盘上<code>Z</code>键同时滚动鼠标中键来<strong>缩放画面</strong></li><li>按住键盘上<code>S</code>键同时移动鼠标来<strong>平移画面</strong></li><li>按住键盘上<code>D</code>键同时移动鼠标来<strong>改变三维视角</strong></li><li>按下键盘上<code>ESC</code>键来<strong>退出窗口</strong></li></ul><blockquote><p>注：如上操作需要在英文输入法下进行</p></blockquote><p>退出窗口后，再运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manimgl start.py SquareToCircle -os</span><br></pre></td></tr></table></figure><p>运行命令后，等待程序运行完成后，会自动打开渲染后得到的图片（默认位于同级目录的子目录 <code>images/</code> 中）：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf530248cd.png" alt="image-20220615153452204" style="zoom: 50%;" /><h2 id="渲染动画"><a href="#渲染动画" class="headerlink" title="渲染动画"></a>渲染动画</h2><p>现在，对上面的代码进行部分改动来实现渲染动画：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> manimlib <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareToCircle</span>(<span class="title class_ inherited__">Scene</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">self</span>):</span><br><span class="line">        circle = Circle()</span><br><span class="line">        circle.set_fill(BLUE, opacity=<span class="number">0.5</span>)</span><br><span class="line">        circle.set_stroke(BLUE_E, width=<span class="number">4</span>)</span><br><span class="line">        square = Square()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通过 Scene 的 play() 方法播放了一个动画，ShowCreation 是呈现创建给出物体的动画过程。 </span></span><br><span class="line">        <span class="comment"># self.play(ShowCreation(square)) 即播放创建 square 的动画。</span></span><br><span class="line">        self.play(ShowCreation(square))</span><br><span class="line">        <span class="comment"># 通过 Scene 的 wait() 方法来停顿（默认1s）</span></span><br><span class="line">        self.wait()</span><br><span class="line">        <span class="comment"># 播放将 square 变化为 circle 的动画。</span></span><br><span class="line">        self.play(ReplacementTransform(square, circle))</span><br><span class="line">        <span class="comment"># 通过 Scene 的 wait() 方法来停顿（默认1s）</span></span><br><span class="line">        self.wait()</span><br></pre></td></tr></table></figure><p>这次运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manimgl start.py SquareToCircle</span><br></pre></td></tr></table></figure><p>弹出的窗口会播放如下动画，如果想要保存这段动画，则运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manimgl start.py SquareToCircle -ow</span><br></pre></td></tr></table></figure><p>同样的，不会再弹出窗口，等待程序运行完成后会自动打开该视频文件（默认存放在与 <code>start.py</code> 同级的 <code>videos/</code> 文件夹中）：</p><p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/SquareToCircle.mp4" width="100%"></video></p><blockquote><p>如果你的渲染后的动画效果只有后半截变成圆形的动画，丢失了前半截的动画，则查看BUG说明部分</p></blockquote><h1 id="启用交互"><a href="#启用交互" class="headerlink" title="启用交互"></a>启用交互</h1><p>支持交互是新版本的新特性，可以在代码的末尾加上如下一行来启用交互：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.embed()</span><br></pre></td></tr></table></figure><p>这时再执行 <code>manimgl start.py SquareToCircle</code>。</p><p>在前面的动画执行后，将会在命令行打开 iPython 终端。**这时你将不能触碰动画窗口，而只能在终端中输入要运行的代码， 如果要和动画窗口进行互动，则要在终端中输入 <code>touch()</code> 或 <code>self.interact()</code>**。</p><p>如果你想要直接进入交互模式的话， 你可以直接运行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manimgl</span><br></pre></td></tr></table></figure><h1 id="BUG说明"><a href="#BUG说明" class="headerlink" title="BUG说明"></a>BUG说明</h1><p><strong>如果出现了渲染丢失的问题，请将 Python 程序的显卡调用设置为独显调用，集成显卡会出现不可预知的错误。</strong></p><blockquote><p>此处以 NVIDIA 为示例</p></blockquote><ul><li><p><strong>进入 NVIDIA 的程序【控制面板】，选择【程序设置】</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf536a13da.png" alt="image-20220615161459190" style="zoom: 60%;" /></li><li><p><strong>选择 Python 程序，为该程序首选独立显卡，最后应用即可</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf53aa61c3.png" alt="image-20220615161616293" style="zoom: 67%;" /></li></ul><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>到这里，就已经完成了 Manim的安装和基本处理过程的上手体验，后面将会开始正式的 Manim 的制作。</p>]]></content>
      
      
      <categories>
          
          <category> 视觉动画 </category>
          
          <category> Manim </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【CSharp实例】文件基本操作</title>
      <link href="/2022/06/12/%E8%AF%AD%E8%A8%80%E6%A0%91/CSharp/%E3%80%90CSharp%E5%AE%9E%E4%BE%8B%E3%80%91%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/06/12/%E8%AF%AD%E8%A8%80%E6%A0%91/CSharp/%E3%80%90CSharp%E5%AE%9E%E4%BE%8B%E3%80%91%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我记得我之前的博客是写过<code>C#</code>实例相关的文章，但是考虑到过于琐碎，我并没有那么多时间，所以指拿出来文件操作的部分来记录，因为对于程序来说，输入和输出的使用频率和重要性会更高一些。</p><blockquote><p>本篇内容参考自 互联网，哔哩哔哩相关视频，《C#开发实例》以及本人经验</p></blockquote><h1 id="获取文件基本信息"><a href="#获取文件基本信息" class="headerlink" title="获取文件基本信息"></a>获取文件基本信息</h1><h2 id="获取文件的大小"><a href="#获取文件的大小" class="headerlink" title="获取文件的大小"></a>获取文件的大小</h2><h3 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h3><p>获取文件大小，需要使用<code>File</code>类的<code>Open</code>方法开打开指定的文件，然后使用<code>FileStream</code>类的<code>Length</code>属性获取文件的长度。</p><ol><li><p><code>File</code>类的<code>Open</code>方法</p><p><code>File</code>类的<code>Open</code>根据传入的文件路径，获取其<code>FileStream</code>并返回，函数签名如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileStream <span class="title">Open</span>(<span class="params"><span class="built_in">string</span> path, FileMode mode, FileAccess access, FileShare share</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileStream <span class="title">Open</span>(<span class="params"><span class="built_in">string</span> path, FileMode mode, FileAccess access</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileStream <span class="title">Open</span>(<span class="params"><span class="built_in">string</span> path, FileMode mode</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>path</code>：文件路径</strong></p></li><li><p><strong><code>mode</code>：<code>FileMode</code>枚举值之一，用于指定在文件不存在时或者其他情况的相关操作。</strong></p><table><thead><tr><th>枚举值</th><th>说明</th></tr></thead><tbody><tr><td><code>CreateNew = 1</code></td><td>指定操作系统创建一个新的文件</td></tr><tr><td><code>Create = 2</code></td><td>同上，如果文件已经存在，则将其覆盖</td></tr><tr><td><code>Open = 3</code></td><td>指定操作系统打开现有文件</td></tr><tr><td><code>OpenOrCreate = 4</code></td><td>指定操作系统打开文件（如果文件存在），否则，创建新文件</td></tr><tr><td><code>Truncate = 5</code></td><td>指定操作系统应打开现有文件。 当打开文件时，被截断其大小为零字节。</td></tr><tr><td><code>Append = 6</code></td><td>打开现有文件并查找到文件尾，或者创建新文件并打开。</td></tr></tbody></table></li><li><p><strong>返回值：返回指定路径文件的<code>FileStream</code>，具有读&#x2F;写访问权限并且不共享</strong>。</p></li></ul></li><li><p><code>FileStream</code>类的<code>Length</code>属性</p><p>其返回值以字节为单位，函数签名如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">long</span> Length &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>和文件相关的操作，需要引入命名空间<code>System.IO</code></strong></p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OpenFileDialog openFileDialog = <span class="keyword">new</span> OpenFileDialog();</span><br><span class="line"><span class="keyword">if</span> (openFileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">&#123;</span><br><span class="line">    label1.Text = ((File.Open(openFileDialog.FileName, FileMode.Open).Length/<span class="number">1024.00</span>)/<span class="number">1024.00</span>).ToString() + <span class="string">&quot;MB&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb64273266.png" alt="image-20220627195222408" style="zoom:80%;" /><h2 id="获取文件拓展名"><a href="#获取文件拓展名" class="headerlink" title="获取文件拓展名"></a>获取文件拓展名</h2><h3 id="方法说明-1"><a href="#方法说明-1" class="headerlink" title="方法说明"></a>方法说明</h3><p>获取文件拓展名主要是在字符串上进行操作，截断最后的<code>.xxx</code>返回，需要使用如下函数签名：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Substring</span>(<span class="params"><span class="built_in">int</span> startIndex, <span class="built_in">int</span> length</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>startIndex</code>：子字符串的起始字符位置</strong></li><li><strong><code>length</code>：要截取的字符数</strong></li><li><strong>返回值：截取的字符串</strong></li></ul><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OpenFileDialog openFileDialog = <span class="keyword">new</span> OpenFileDialog();</span><br><span class="line"><span class="keyword">if</span> (openFileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">&#123;</span><br><span class="line">    label1.Text = openFileDialog.FileName.Substring(openFileDialog.FileName.LastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>, openFileDialog.FileName.Length - openFileDialog.FileName.LastIndexOf(<span class="string">&quot;.&quot;</span>)<span class="number">-1</span>).ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb6464c500.png" alt="image-20220627202108851" style="zoom:80%;" /><h2 id="获取文件创建时间"><a href="#获取文件创建时间" class="headerlink" title="获取文件创建时间"></a>获取文件创建时间</h2><h3 id="方法说明-2"><a href="#方法说明-2" class="headerlink" title="方法说明"></a>方法说明</h3><p>需要使用<code>FileInfo</code>类，该类型主要提供创建，复制，删除，移动和打开文件的实例方法。函数签名如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DateTime CreationTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OpenFileDialog openFileDialog = <span class="keyword">new</span> OpenFileDialog();</span><br><span class="line"><span class="keyword">if</span> (openFileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">&#123;</span><br><span class="line">    FileInfo fileInfo = <span class="keyword">new</span> FileInfo(openFileDialog.FileName);</span><br><span class="line">    label1.Text = fileInfo.CreationTime.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb64a6e12f.png" alt="image-20220627202907830" style="zoom:80%;" /><h2 id="获取文件最后一次修改时间"><a href="#获取文件最后一次修改时间" class="headerlink" title="获取文件最后一次修改时间"></a>获取文件最后一次修改时间</h2><h3 id="方法说明-3"><a href="#方法说明-3" class="headerlink" title="方法说明"></a>方法说明</h3><p>同样的需要使用到<code>FileInfo</code>类的<code>LastWriteTime</code>属性，函数签名如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DateTime LastWriteTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OpenFileDialog openFileDialog = <span class="keyword">new</span> OpenFileDialog();</span><br><span class="line"><span class="keyword">if</span> (openFileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">&#123;</span><br><span class="line">    FileInfo fileInfo = <span class="keyword">new</span> FileInfo(openFileDialog.FileName);</span><br><span class="line">    label1.Text = fileInfo.LastWriteTime.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb64e2076c.png" alt="image-20220627203515373" style="zoom:80%;" /><h2 id="获取文件名中禁止使用的字符"><a href="#获取文件名中禁止使用的字符" class="headerlink" title="获取文件名中禁止使用的字符"></a>获取文件名中禁止使用的字符</h2><p>在 Win 系统中创建文件时，存在部分非法字符，系统会提示错误，获取非法字符有哪些是本实例要做的。</p><h3 id="方法说明-4"><a href="#方法说明-4" class="headerlink" title="方法说明"></a>方法说明</h3><p>主要使用到了<code>Path</code>类的<code>GetInvalidFileNameChars</code>方法，其函数签名如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">char</span>[] <span class="title">GetInvalidFileNameChars</span>()</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>返回值：<code>char</code>类型的数组，包含所有非法字符</strong></li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="built_in">char</span> c <span class="keyword">in</span> Path.GetInvalidFileNameChars())</span><br><span class="line">&#123;</span><br><span class="line">    richTextBox1.Text += c+<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb651c7034.png" alt="image-20220627204517425" style="zoom:80%;" /><h1 id="文件的创建和删除"><a href="#文件的创建和删除" class="headerlink" title="文件的创建和删除"></a>文件的创建和删除</h1><h2 id="创建和删除文件"><a href="#创建和删除文件" class="headerlink" title="创建和删除文件"></a>创建和删除文件</h2><h3 id="方法说明-5"><a href="#方法说明-5" class="headerlink" title="方法说明"></a>方法说明</h3><p>使用到了<code>File</code>类的<code>Create</code>和<code>Delete</code>方法：</p><ul><li><p><code>File</code>类的<code>Create</code>方法，函数签名如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileStream <span class="title">Create</span>(<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>path</code>：文件路径和名称</strong></li><li><strong>返回值：<code>FileStream</code>类，可以对路径文件进行读写</strong></li></ul><blockquote><p>如果路径文件存在，该方法会覆盖文件创建新文件</p></blockquote></li><li><p><code>File</code>类的<code>Delete</code>方法，函数签名如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Delete</span>(<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>path</code>：指定路径文件</strong></li></ul></li></ul><h3 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> filename;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    SaveFileDialog saveFileDialog = <span class="keyword">new</span> SaveFileDialog();</span><br><span class="line">    <span class="keyword">if</span> (saveFileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        filename = saveFileDialog.FileName;</span><br><span class="line">        FileStream fileStream = File.Create(saveFileDialog.FileName);</span><br><span class="line">        MessageBox.Show(<span class="string">&quot;创建文件成功&quot;</span>);</span><br><span class="line">        fileStream.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button2_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    File.Delete(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb65630958.png" alt="image-20220627210709513" style="zoom:80%;" /><h2 id="生成随机文件名或者文件夹名"><a href="#生成随机文件名或者文件夹名" class="headerlink" title="生成随机文件名或者文件夹名"></a>生成随机文件名或者文件夹名</h2><h3 id="方法说明-6"><a href="#方法说明-6" class="headerlink" title="方法说明"></a>方法说明</h3><p>需要用到**<code>Guid</code>（全局唯一标识符）**类的<code>NewGuid</code>方法，其函数签名如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Guid <span class="title">NewGuid</span>()</span>;</span><br></pre></td></tr></table></figure><blockquote><p><em>全局唯一标识符（GUID，Globally Unique Identifier）是一种由算法生成的二进制长度为128位的数字标识符。GUID主要用于在拥有多个节点、多台计算机的网络或系统中。在理想情况下，任何计算机和计算机集群都不会生成两个相同的GUID。GUID 的总数达到了  2^128（3.4×10^38）个，所以随机生成两个相同GUID的可能性非常小，但并不为0。所以，用于生成GUID的算法通常都加入了非随机的参数（如时间），以保证这种重复的情况不会发生。</em></p></blockquote><h3 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FolderBrowserDialog folderBrowserDialog = <span class="keyword">new</span> FolderBrowserDialog();</span><br><span class="line">    <span class="keyword">if</span> (folderBrowserDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        File.Create(folderBrowserDialog.SelectedPath + Guid.NewGuid().ToString() + <span class="string">&quot;.txt&quot;</span>).Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button2_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FolderBrowserDialog folderBrowserDialog = <span class="keyword">new</span> FolderBrowserDialog();</span><br><span class="line">    <span class="keyword">if</span> (folderBrowserDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        Directory.CreateDirectory(folderBrowserDialog.SelectedPath + Guid.NewGuid().ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb65a2f1f2.png" alt="image-20220627213350466" style="zoom:80%;" /><h2 id="建立临时文件"><a href="#建立临时文件" class="headerlink" title="建立临时文件"></a>建立临时文件</h2><p>当用户在程序中新建一个文件时，但是尚未保存和命名时，所有建立的文件都是保存在内存中的，显然这样做是很危险的。如果突然死机或者其他原因造成了程序在未保存文件之前就关闭，那么将损失严重。如果在文件建立的同时在就磁盘中存储数据，将不会造成如上损失。这个时候就需要创建临时文件来保存数据。</p><h3 id="方法说明-7"><a href="#方法说明-7" class="headerlink" title="方法说明"></a>方法说明</h3><p>需要先使用<code>Path</code>类的<code>GetTempFileName</code>方法获得临时文件名称，然后使用<code>FileInfo</code>类的<code>AppendText</code>方法向临时文件写入数据。</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>待更新……’</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> CSharp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo入门（上）</title>
      <link href="/2022/06/04/NAS%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8/Hexo%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2022/06/04/NAS%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8/Hexo%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我第二次给网站装修的时候，曾经考虑过使用<code>Hexo</code>，不过那个时候看到人家好看的模板需要一定的网页基础，遂就放弃了，随着我今天发现我的网站似乎<code>CSS</code>的<code>CDN</code>服务停止了，遂打算用<code>Hexo+Github+COS</code>来完成网站的布置和搬迁，这样一来可以剩下一笔费用，而且因为<code>Hexo</code>是纯静态的，所以加载速度也会很快。</p><p>以此文章记录和帮助需要帮助的伙伴。</p><h1 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h1><p>Hexo是一个轻量级的博客框架，它是通过生成静态网页来实现网站的建设，因为是<code>HTML</code>形式，所以它的访问速度是很快的，关于<code>Hexo</code>网站可以通过点击访问<a href="httpss://hexo.io/zh-cn/">Hexo官网</a>。</p><h1 id="Hexo的搭建"><a href="#Hexo的搭建" class="headerlink" title="Hexo的搭建"></a>Hexo的搭建</h1><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p><strong>Hexo需要在电脑上安装<code>Node.JS</code>和<code>Git</code><strong>，如果你已经安装了这两个环境，则可以跳过这部分，直接到<code>Hexo</code>的部署。</strong>此处安装示例环境为<code>Windows</code>环境</strong>，其他系统请自行参考别的文章。</p><ul><li><a href="https://nodejs.org/">点我访问<code>Node.JS</code>官网</a>，进入官网下载符合自己平台的软件，<strong>版本建议使用<code>12.0</code>及以上的版本，可以无脑最新版</strong>。</li><li><a href="https://git-scm.com/">点我访问<code>Git</code>官网</a>，关于<code>Git</code>的安装和使用可以参考我这篇文章<a href="httpss://www.helloseraphine.top/index.php/archives/431.html">Git与GitHub(上)</a>，此处不过多赘述</li></ul><blockquote><p><strong>如果以上官网无法访问，可以尝试科学上网或者寻找其他镜像途径</strong></p></blockquote><p>在安装结束后，可以<strong>通过如下<code>CMD</code>命令来验证是否安装成功</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证Node.JS的版本</span></span><br><span class="line">node --version</span><br></pre></td></tr></table></figure><p>如果返回的是一串版本号，例如<code>18.1.0</code>，则证明安装成功。</p><p>在完成了上面的基础环境安装，使用如下代码安装<code>Hexo</code>，代码示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>在完成如上准备后，就可以正式开启Hexo博客之路。</p><h2 id="建站预览"><a href="#建站预览" class="headerlink" title="建站预览"></a>建站预览</h2><p>现在<strong>寻找一个文件位置来存放<code>Hexo</code>网站相关根文件</strong>，使用如下代码来完成初始化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><blockquote><p>注：执行上述代码前，<strong>需要确保当前目录为安装根文件目录</strong>；如果不是，则使用<code>cd</code>命令切换至对应目录</p></blockquote><p>完成<code>Hexo</code>的初始化后，可以看到在对应的目录下，会生成如下的相关文件：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf26249b27.png" alt="image-20220519104258168" style="zoom:80%;" /><p><strong>如果初始化失败，则删除对应目录下的文件，切换网络重新执行如上命令</strong>即可。</p><p>初始化完成后，<strong>使用如下代码来在本地开一个端口</strong>，查看建站效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><blockquote><p>如果命令执行报错，返回的错误是找不到命令之类的，需要在<code>Hexo</code>的根目录下使用该命令，或者你也可以将<code>安装目录\Hexo\node_modules\.bin</code>添加到环境变量中，关于如何设置环境变量，可以查看我的这篇文章<a href="httpss://www.helloseraphine.top/index.php/archives/476.html">环境变量那些事</a></p></blockquote><p>执行命令后，会<strong>显示一个访问地址，复制到浏览器上即可查看预览效果</strong>，如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf26705b36.png" alt="image-20220519104626862" style="zoom: 67%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf26a9c5af.png" alt="image-20220519104737970" style="zoom: 45%;" /><p>按下<code>Ctrl+C</code>即可停止本地端口占用，即关闭了网站的访问预览。</p><p><strong>如果预览网站报错了，则尝试如下解决办法：</strong></p><ul><li><strong>有进程占用了默认4000端口，可以使用命令<code>hexo s -p 5000</code></strong></li><li><strong>或者是因为你的电脑没有配置<code>IIS</code>，可以通过【打开控制面板】，选择【程序和功能】，选择【打开或关闭Windows功能】，找到【Internet information services】选中即可。</strong></li></ul><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>可以通过官方的主题页面选择自己喜欢的主题（如果你不想自己开发的话），<a href="httpss://hexo.io/themes/">Hexo主题(点击访问)</a>，或者从<code>GitHub</code>等途径自行寻找相关主题，然后根据主题的要求来安装和使用主题。</p><p>需要注意的是：<strong>安装主题需要在<code>Hexo</code>根目录下，即<code>themes</code>里创建相关主题的文件夹即可</strong>。</p><p>主题配置完成后，可以使用上面的命令<code>Hexo s</code>来启动预览网站。</p><h1 id="Hexo部署"><a href="#Hexo部署" class="headerlink" title="Hexo部署"></a>Hexo部署</h1><p><code>Hexo</code>因为是生成的静态页面，所以可以部署在很多地方，例如：<code>Github</code> ，<code>Gitee</code>，相关对象存储或者服务器上，<strong>此处仅示例如何部署在：GitHub和腾讯云的COS上</strong></p><h2 id="部署到GitHubPages"><a href="#部署到GitHubPages" class="headerlink" title="部署到GitHubPages"></a>部署到GitHubPages</h2><blockquote><p>关于Git和GitHub的基本使用，可以参考<a href="httpss://www.helloseraphine.top/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Git%E4%B8%8EGitHub(%E4%B8%8A)/">Git与GitHub(上)</a></p></blockquote><p>Hexo为 GitHub Pages 的部署提供了便利的部署方式，可以通过下面的命令来实现部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者简写为</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><strong>在使用该命令部署到GitHub页面之前，需要</strong>我们<strong>在Hexo的配置文件</strong>中，<strong>提供一些必要的参数</strong>。</p><h3 id="添加配置文件参数"><a href="#添加配置文件参数" class="headerlink" title="添加配置文件参数"></a>添加配置文件参数</h3><p>**Hexo 的配置文件在安装&#x2F;初始化目录下，名称为<code>_config.yml</code>**，打开文件找到如下部分：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf270687b5.png" alt="image-20220604152435494" style="zoom: 80%;" /><ul><li><strong><code>type</code>：在本方法下，填写<code>git</code></strong></li><li><strong><code>repo</code>：你所存放网页的Github仓库地址</strong></li><li><strong><code>branch</code>：分支名称，如果不懂的话填<code>main</code>即可</strong></li><li><strong><code>token</code>：访问GitHub账户的令牌，它可以验证是否有权限操作仓库</strong></li></ul><p>如上前三个参数，可以快速填写，我们需要填写第四个<code>token</code>参数，才能实现上传前的设置。</p><h3 id="token的获取"><a href="#token的获取" class="headerlink" title="token的获取"></a>token的获取</h3><ol><li><p>进入【个人账户的设置】中</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf2743bc59.png" alt="image-20220604153054210" style="zoom:50%;" /></li><li><p>在页面的<strong>最下面找到并【选择<code>Developer settings</code>(开发者选项)】</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf277e7db2.png" alt="image-20220604153219875" style="zoom: 67%;" /></li><li><p>在新的页面找到并<strong>【选择<code>Personal access tokens</code>(个人访问令牌)】，然后【选择<code>Generate new token</code>(生成新令牌)】</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf27b6b2f3.png" alt="image-20220604153458147" style="zoom:80%;" /></li><li><p>在创建<code>token</code>的页面中<strong>，<code>Note(名称)</code>可以随便填，<code>Expiration(令牌期限)</code>可以选择<code>no expiration（不限制期限） </code>，下面的<code>Select scopes（权限范围）</code>全选即可。</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf27ef366e.png" alt="image-20220604153920416" style="zoom: 67%;" /></li><li><p>最后<strong>【点击<code>Generate token</code>】就创建好<code>token</code>了，然后【复制给出的<code>token</code>值】，【填写到配置文件】中<code>token:</code>的部分</strong>就完成了部署前的配置。</p></li></ol><p>这个时候可以通过<strong>使用<code>hexo d</code>命令来测试</strong>上传部署到指定的GitHub仓库是否正常，<strong>如果最后反馈一行<code>INFO  Deploy done: git</code>，则表示上传部署成功</strong>。</p><h2 id="部署到腾讯云COS"><a href="#部署到腾讯云COS" class="headerlink" title="部署到腾讯云COS"></a>部署到腾讯云COS</h2><blockquote><p>感兴趣但是不了解的COS的可以查看这篇文章<a href="httpss://www.helloseraphine.top/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%8B%EF%BC%89/#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%EF%BC%9F">关于网站搭建那些事（下）</a></p></blockquote><p>官方并没有对腾讯云的COS（对象存储）做直接的配置，所以我们需要下载其他开发者的插件，此处**使用<code>hexo-deployer-cos</code>，项目地址<a href="httpss://github.com/sdlzhd/hexo-deployer-cos">hexo-deployer-cos**</a>，如果对你有帮助，可以给插件开发者点个<code>Star</code>。</p><p>在hexo安装的目录下，使用如下命令进行插件的安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-cos --save</span><br></pre></td></tr></table></figure><p>安装成功后，在hexo 的配置文件中，添加如下部分内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">cos</span></span><br><span class="line">  <span class="attr">secretId:</span> <span class="string">yourSecretId</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="string">yourSecretKey</span></span><br><span class="line">  <span class="attr">bucket:</span> <span class="string">yourBucket</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">yourRegion</span></span><br></pre></td></tr></table></figure><p>关于上述的<code>secretID</code>等参数可以在创建COS存储桶的时候获取到，COS的创建可以访问<a href="httpss://cloud.tencent.com/product/cos">对象存储COS</a>来创建，关于COS的更多说明和处理，参见<a href="httpss://www.helloseraphine.top/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%8B%EF%BC%89/#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%EF%BC%9F">关于网站搭建那些事（下）</a>。</p><blockquote><p>注：对象存储是需要对存储空间和访问流量进行收费的</p></blockquote><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>如上就完成了Hexo 的基本部署，以后如果你的博客更新都需要通过<code>hexo d</code>的命令来实现。</p><p>关于Hexo的文章更新，文章编写，插件，主题等配置可以参见<a href="">Hexo入门（下）</a></p>]]></content>
      
      
      <categories>
          
          <category> NAS及服务器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo入门（下）</title>
      <link href="/2022/06/04/NAS%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8/Hexo%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2022/06/04/NAS%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8/Hexo%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分将着手Hexo的一些基本的配置和使用方面，关于Hexo的部署部分可以参考我的上篇文章。</p><h1 id="Hexo文件目录"><a href="#Hexo文件目录" class="headerlink" title="Hexo文件目录"></a>Hexo文件目录</h1><p>Hexo的安装&#x2F;初始化目录如下图所示，可能部分文件存在不同，不需要担心，<strong>只需要关心我框出来的红色的文件部分</strong>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf2eae123b.png" alt="image-20220604161631343" style="zoom:80%;" /><table><thead><tr><th>文件&#x2F;文件夹名</th><th>说明</th></tr></thead><tbody><tr><td><code>public</code></td><td>我们最后生成的静态博客<code>.html</code>文件会在该目录下存在，如果你并为生成或者使用了<code>hexo clean</code>命令，则该文件夹不存在</td></tr><tr><td><code>scaffolds</code></td><td>模板文件夹，里面存在我们创建文章，分类等初始化的默认内容</td></tr><tr><td><code>source</code></td><td>文章以及一些主要内容的文件夹，该文件夹下的内容会被全部拷贝到生成的<code>public</code>文件夹里</td></tr><tr><td><code>themes</code></td><td>主题文件夹，我们下载使用的主题需要导入到该文件夹中，通过在该文件夹下创建命名为主题名称的文件夹即可</td></tr><tr><td><code>_config.yml</code></td><td>Hexo的配置文件</td></tr></tbody></table><blockquote><p>注：Hexo的配置文件和主题的配置文件不要混淆，如果你使用别人的主题则会存在一个对应的主题的配置文件</p></blockquote><h1 id="配置文件参数"><a href="#配置文件参数" class="headerlink" title="配置文件参数"></a>配置文件参数</h1><blockquote><p><strong>yaml文件的参数填写时一定要在<code>:</code>后加一个空格，再填写参数</strong></p></blockquote><p>在了解了Hexo 的文件目录后，我对一些常见的配置文件参数进行说明，以供参考。</p><h2 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h2><p>Site部分主要是网站一些基本说明参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site 【网站设置】</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">这是一个主标题</span> <span class="comment">#【网站主标题】就是网站最上面标签上的文字</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;这是一个子标题&#x27;</span> <span class="comment">#【子标题】跟在主标题后面</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;这是一句描述&#x27;</span> <span class="comment">#【网站描述】不同主题可能会呈现位置效果不同</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="comment">#【网站关键词】如果希望百度等搜索引擎收录网站，可以设置自己网站的关键词</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">我是作者名字</span> <span class="comment">#【作者名称】一般文章结束说明以及最后的版权归属会使用该名称</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment">#【网站语言】可以选择简体（zh-CN），繁体（zh-tw），英文（en）</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> <span class="comment">#【时区】网站时间，如果是中国，则使用左边的参数即可</span></span><br></pre></td></tr></table></figure><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>URL部分参数的设置，涉及到Hexo最后部署后的呈现成功与否，参数说明如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;httpss://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">httpss://www.baidu.com/</span> <span class="comment">#【访问网站的网址】</span></span><br><span class="line"><span class="attr">root:</span> <span class="comment">#【根目录位置】</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure><p><strong>如果你部署到GitHub上，则<code>url</code>的参数填写，GitHub提供的地址，<code>root</code>参数填写你的仓库名称，例如：<code>/仓库名称</code>；如果你使用了自定义的域名，则需要将这里<code>url</code>的参数改为你的自定义域名，<code>root</code>参数为空即可（前提是你的网站初始<code>index.html</code>文件就在仓库下，而不是被文件夹嵌套在里面）</strong>。</p><blockquote><p><strong>如果上述参数设置不正确，则会出现访问网站只有内容，而丢失样式</strong>，即排版不正常的情况出现</p></blockquote><h2 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h2><p><strong>Directory规定了相关文件生成&#x2F;获取的路径</strong>，我们可以通过修改其参数来指定相关文件生成的目录，而不是默认的hexo安装目录下，参数说明如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">D:\DATA\TyporaMd\z_hexo_source</span> <span class="comment">#【数据源文件夹】你可以理解为你写文章的目录，默认为Source，此处我将它自定义到如上参数路径下，则在编译生成网站静态文件的时候就会从我指定目录下获取数据编译</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br></pre></td></tr></table></figure><h2 id="theme"><a href="#theme" class="headerlink" title="theme"></a>theme</h2><p><strong>theme参数主要是指定网站的主题</strong>，传入主题名称即可，前提是网站主题已经导入到主题文件夹下，且和主题文件夹同名。参数说明：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: httpss://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: httpss://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span> <span class="comment">#【主题的名称】</span></span><br></pre></td></tr></table></figure><h1 id="插件和主题的配置"><a href="#插件和主题的配置" class="headerlink" title="插件和主题的配置"></a>插件和主题的配置</h1><p>插件和主题的配置，可以在后面熟悉上手之后进行配置，可以选择不配置使用默认主题。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>网站的美化可以使用别人已经开发的主题来快速实现，主题可以通过Hexo官网获取<a href="httpss://hexo.io/zh-cn/">Hexo官网</a>，或者从Github，百度等其他渠道获取使用。</p><p>主题的下载安装可以根据主题的说明文档来，<strong>需要注意的是，主题需要在Hexo指定的主题文件夹下存放，且每个主题都需要是一个文件夹</strong>。</p><p>关于主题配置的实例，可以参考本站，本站使用的是<code>buttfly</code>主题，<a href="httpss://butterfly.js.org/posts/21cfbf15/">主题地址</a>，希望大家可以给源作者一个Star支持一下。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>插件也同理，找到需要的插件，查看插件的文档，对插件进行相关配置。</p><p>插件的使用，本站使用了如下插件：</p><ol><li>本地搜索感谢 hexo-generator-search 提供支持</li><li>评论系统感谢 waline 提供支持</li><li>网站统计感谢  百度统计 提供支持</li><li>数学公式感谢 mathjax 提供支持</li><li>番剧列表感谢 hexo-bilibili-bangumi 提供支持</li><li>视频插件感谢 hexo-tag-mmedia 提供支持</li><li>文章自动分类感谢 hexo-auto-category 提供支持</li><li>游戏展示感谢 hexo-steam-games 提供支持</li><li>电影书籍音乐展示感谢 HEXO-DOUBAN-CARD 提供支持</li></ol><h1 id="文章编写和发布"><a href="#文章编写和发布" class="headerlink" title="文章编写和发布"></a>文章编写和发布</h1><p><em>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件</em></p><p>如上引用自Hexo官方说明，Hexo默认安装了<code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，所以<strong>默认支持使用<code>Markdown</code>进行写作</strong>，此处也使用<code>Markdown</code>写作来实例。</p><p>可以使用如下命令来创建一篇新文章：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法格式</span></span><br><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一篇名称为 测试 的文章</span></span><br><span class="line">hexo new post 测试</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为layout默认为post，所以上述命令可以简写为</span></span><br><span class="line">hexo new 测试</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一篇名称为 测试 的草稿</span></span><br><span class="line">hexo new draft 测试</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一页名称为 测试 的独立页面</span></span><br><span class="line">hexo new page 测试</span><br></pre></td></tr></table></figure><p>例如，<strong>使用命令<code>hexo new 测试</code>，可以发现在<code>source</code>文件夹下，里的<code>_post</code>文件夹里生成了一个名称为<code>测试</code>的<code>.md</code>文件，该<code>.md</code>文件就可以直接使用<code>Markdown</code>语法来书写文章</strong>。</p><blockquote><p>如果你自定义了<code>source</code>文件夹的位置，则生成在自定义的<code>source</code>文件夹下<code>_post</code>文件夹里</p></blockquote><p>当你打开生成 的<code>测试.md</code>文件后，会发现它默认文件中生成了一部分<code>yaml</code>内容，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">测试</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-06-04 18:02:30</span></span><br><span class="line"><span class="attr">updated:</span></span><br><span class="line"><span class="attr">top_img:</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">aplayer:</span></span><br><span class="line"><span class="attr">cover:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>当然，你生成的文件中的内容或许没这么多，一般会有<code>title</code>，<code>tags</code>等参数，其他的参数是我通过修改模板文件来实现，生成新文章的时候自动预先生成相关参数。<strong>这些参数是对本篇文章的参数，它可以设置本篇文章的标题，文章标签，文章分类，文章封面图片，文章描述等等的参数。当然你也可以选择不填写这些参数，可以为空（标题除外）</strong>。</p><blockquote><p>关于模板文件可以查看下面的部分，此处不做过多赘述</p></blockquote><p>然后在上面<code>yaml</code>参数的下面，开始使用<code>Markdown</code>语法写我们的文章，现在使用如下内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这是一个一级标题</span></span><br><span class="line"><span class="section">## 这是一个二级标题</span></span><br><span class="line"><span class="section">### 这是一个三级标题</span></span><br><span class="line"><span class="section">#### 这是一个四级标题</span></span><br><span class="line"><span class="bullet">*</span> 这是一个无序序号</span><br><span class="line"><span class="bullet">*</span> 这也是一个无序序号</span><br><span class="line"><span class="bullet">*</span> 这也是一个无序序号</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 这是一个引用说明</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**这是黑体**</span></span><br><span class="line"><span class="emphasis">*这是斜体*</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 这是有序序号</span><br><span class="line"><span class="bullet">1.</span> 这也是有序序号</span><br><span class="line"><span class="bullet">1.</span> 这还是有序序号</span><br><span class="line"></span><br><span class="line">这是一个代码块</span><br><span class="line"><span class="code">```c</span></span><br><span class="line"><span class="code">printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">这是一个行内代码`</span><br></pre></td></tr></table></figure><p>将上述内容保存后，就可以<strong>使用如下命令实现文章编译</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>如果你之前已经编译过了，生成新文章或者重新编译的时候，我们一般<strong>使用如下命令清除之前的编译文件</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令清除public文件夹，即删除所有已编译过的文件</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后让Hexo重新编译新的静态文件</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者你可以使用 &amp; 符号来链接两个命令</span></span><br><span class="line">hexo clean &amp;&amp; hexo g</span><br></pre></td></tr></table></figure><p>上述执行<code>hexo g</code>编译完成后，如果没有报错，则可以<strong>使用如下命令来本地查看编译效果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然你也可以简写为</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>在本地查看效果无误后，<strong>使用如下命令推送到远程的GitHub仓库，来实现文章的更新</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>完成以上操作，则完成了文章的编写和推送更新发布，<strong>简述来说通过<code>hexo new 文章名称</code>创建文章文件，编写文章文件内容的，保存后，使用<code>hexo g</code>将其编译为静态文件，如果之前已经编译过一遍，一般通过使用<code>hexo clean</code>将之前编译的文件删除，再执行<code>hexo g</code>编译一份新的静态文件，然后使用<code>hexo s</code>来本地查看效果，使用<code>hexo d</code>将新编译的静态文件推送到远程仓库，这样就实现文章的更新</strong>。</p><h1 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h1><p>在前面的Hexo文件目录中说明了模板文件的位置，在Hexo安装目录下的<code>scaffolds</code>文件夹下，里面会存在三个文件，如下说明，通过修改这三个文件的<code>yaml</code>内容部分，这样生成的相关类别的文章会默认包含该参数内容。</p><table><thead><tr><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td><code>draft.md</code></td><td>草稿文件的模板</td></tr><tr><td><code>page.md</code></td><td>独立页面的模板</td></tr><tr><td><code>psot.md</code></td><td>一般文章的模板</td></tr></tbody></table><h1 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h1><h2 id="文章标签和分类"><a href="#文章标签和分类" class="headerlink" title="文章标签和分类"></a>文章标签和分类</h2><p>前面说明了，文章创建的时候自带的<code>yaml</code>参数可以修改其文章的属性，其中有一个给文章分类的参数，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">测试</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">这是一个标签</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">这又是一个标签</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">这还是一个标签</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">这是一个分类</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">这是一个子分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-06-04 18:02:30</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># 如果你希望文章可以属于好几个类别，而不是主分类-子分类，则使用如下参数</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="string">这是一个分类</span>,<span class="string">这是一个子分类</span>]</span><br></pre></td></tr></table></figure><h2 id="GitHub使用自定义域名"><a href="#GitHub使用自定义域名" class="headerlink" title="GitHub使用自定义域名"></a>GitHub使用自定义域名</h2><p>如果你希望使用自定义域名来访问自己在GitHub上部署的网站，则可以在GitHub Page下，填写自己的自定义域名，然后解析到GitHub上，需要注意的是，<strong>在你添加自定义域名的时候，会在你的仓库下创建一个<code>CNAME</code>的文件，该文件只有一行内容，就是你的自定义域名</strong>。</p><p><strong>因为每次使用<code>hexo d</code>上传到仓库文件的时候，Hexo的解决办法是将本地<code>public</code>文件夹下的文件去覆盖GitHub仓库，那就意味着你的<code>CNAME</code>文件将会被覆盖消失，那么你配置的自定义域名就会失效。</strong></p><p><strong>你可以通过将<code>CNAME</code>文件创建在你本地的<code>source</code>文件夹下，则再每次使用<code>hexo g</code>编译的时候，<code>source</code>文件夹下的内容都会复制到<code>public</code>文件夹里，这样上传到GitHub上进行覆盖的时候就始终存在<code>CNAME</code>文件。</strong></p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>经过[[技术杂谈&#x2F;Hexo入门（上）|Hexo入门（上）]]和Hexo入门（下）后就可以完全自主的使用Hexo来编写和更新自己的文章了，关于本站的Hexo主题使用说明和插件说明，为了防止我自己忘记，我会写一篇备忘录来记录，内容来源是原主题&#x2F;插件开发者的说明文档。</p>]]></content>
      
      
      <categories>
          
          <category> NAS及服务器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【CSharp高级编程】default和typeof运算符</title>
      <link href="/2022/06/04/%E8%AF%AD%E8%A8%80%E6%A0%91/CSharp/%E3%80%90CSharp%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%91default%E5%92%8Ctypeof%E5%85%B3%E9%94%AE%E8%AF%8D/"/>
      <url>/2022/06/04/%E8%AF%AD%E8%A8%80%E6%A0%91/CSharp/%E3%80%90CSharp%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%91default%E5%92%8Ctypeof%E5%85%B3%E9%94%AE%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分本来应该和泛型一起讨论，考虑到分类问题，遂单独拿出来记录。</p><h1 id="default运算符"><a href="#default运算符" class="headerlink" title="default运算符"></a>default运算符</h1><p>早在<code>C# 1</code>时代，<code>typeof()</code>运算符就已经出现了，它接收一个类型名称作为唯一操作数。<code>C# 2</code>加入了<code>default()</code>运算符，并且略微拓展了<code>typeof()</code>的用途。</p><p><strong><code>default</code>运算符功能比较简单，它是一元运算符，其操作数是类型名或者类型形参，返回值是该类型的默认值。</strong>当声明一个字段，但是没有为该字段立刻赋值时，该字段的值就是默认值。如果是引用类型，默认值是一个<code>null</code>引用。如果是非可空值类型，将返回对应类型的”0值”（0，0.0，0.0m,false,UTF-16编码单元的0等）；如果是可空值类型则返回类型的<code>null</code>值。</p><p><code>default</code>运算符可以用于类型形参以及提供了类型实参的泛型类型，例如如下都是合法的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">default</span>(T)</span><br><span class="line"><span class="literal">default</span>(<span class="built_in">int</span>)</span><br><span class="line"><span class="literal">default</span>(<span class="built_in">string</span>)</span><br><span class="line"><span class="literal">default</span>(List&lt;T&gt;)</span><br></pre></td></tr></table></figure><p><code>default</code>运算符返回值的类型与操作数类型一致。**<code>default</code>常与泛型类型形参一起使用**，因为对于非泛型类型可以通过其他方式获取<code>default</code>值。但是对于泛型类型来说，我们不确定该泛型的初始值是什么类型的，这个时候就需要使用<code>default</code>运算符了，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">Last</span>&lt;<span class="title">T</span>&gt; (<span class="params">IEnumerable&lt;T&gt; source</span>)</span>&#123;</span><br><span class="line">    T ret = <span class="literal">default</span>(T);</span><br><span class="line">    <span class="keyword">foreach</span>(T item <span class="keyword">in</span> source)&#123;</span><br><span class="line">        ret = item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h1><p><code>typeof</code>运算符的使用相对复杂一些，考虑到如下几种常见的情形：</p><ul><li>不涉及泛型，例如：<code>typeof(string)</code></li><li>涉及泛型但是不涉及类型形参，例如：<code>typeof(List&lt;int&gt;)</code></li><li>仅涉及类型形参，例如：<code>typeof(T)</code></li><li><code>typeof</code>操作数中有泛型，而且泛型作为类型形参出现，例如：<code>typeof(List&lt;TItem&gt;)</code></li><li>涉及泛型，但是操作数中没有出现类型实参，例如：<code>typeof(List&lt;&gt;)</code></li></ul><p>其中第一个场景最简单，且其用法基本没有变过。对于其他的场景需要进行考虑。<code>typeof</code>运算符的返回值是<code>Type</code>类型的值，而且<code>Type</code>类在经过拓展之后可以支持泛型。</p><p>要理解<code>typeof</code>运算符，一个简单的例子是**<code>typeof(List&lt;int&gt;)</code>，其返回值是<code>List&lt;int&gt;</code>的<code>Type</code>值，结果与调用<code>new List&lt;int&gt;().GetType()</code>相同**。</p><p>现在来讨论<code>typeof(T)</code>，该表达式返回的是调用代码中<code>T</code>类型参数的<code>Type</code>。它的返回值永远是一个<strong>封闭的，已构造的类型</strong>，技术规范中将其描述为一个真正不包含任何类型形参的类型。</p><p>下面通过一个实例来展示<code>typeof(T)</code>和<code>typeof(List&lt;T&gt;)</code>，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序入口</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    PrintType&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">    PrintType&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintType</span>&lt;<span class="title">T</span>&gt;()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;typeof(T)= &#123;0&#125;&quot;</span>, <span class="keyword">typeof</span>(T));</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;typeof(T)= &#123;0&#125;&quot;</span>, <span class="keyword">typeof</span>(List&lt;T&gt;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb60a34397.png" alt="image-20220625234056672" style="zoom:80%;" /><p>结果一幕了然，其中还展示了使用反射时泛型类型的命名格式：<code>List &#39;1(注是斜上点，Markdown字符冲突)&#39;</code>，表示这是一个命名为<code>List</code>的泛型类型，其度为 1 ，后面的方括号表示类型实参。</p><p>最后再说明一下<code>typeof(List&lt;&gt;)</code>。该表达式看起来缺少类型实参。<strong>这种写法只有在<code>typeof</code>运算符中才有效</strong>，且指向了泛型类型定义。对于度为 1 的泛型，其书写格式为<code>TypeName&lt;&gt;</code>，**如果其度大于1，每增加一个度，就加一个逗号，例如要获取<code>D&lt;T1,T2&gt;</code>泛型类型定义，则表达式为： <code>Typeof(TypeName&lt;,&gt;)</code>**。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>说实话，这两种运算符，在实际应用过程并没有那么的应用，是一种数据获取手段，此处单独摘录说明，看看我接下来有没有时间写一下<code>C#</code>多线程的内容。</p><p>就这样，祝晚安。</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> CSharp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git与GitHub(中)</title>
      <link href="/2022/05/29/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Git%E4%B8%8EGitHub(%E4%B8%AD)/"/>
      <url>/2022/05/29/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Git%E4%B8%8EGitHub(%E4%B8%AD)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分将讲述Git相关的基本知识和操作方法。</p><p>各种Git命令操作，需要鼠标右键选择，<code>Git Bash here</code>来开始。</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul><li><p><strong><code>git init</code>——初始化仓库</strong></p><p><strong>要使用Git进行版本管理，必须先初始化仓库。</strong>Git是使用<code>git init</code>命令进行初始化的。命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf11e09744.png" alt="image-20220203172122036" style="zoom:80%;" /><p><strong>如果初始化成功，执行了<code>git init</code>命令的目录下就会生成<code>.git</code>目录。这个目录里存储着管理当前目录内容所需的仓库数据</strong>。</p><blockquote><p><code>.git</code>目录默认隐藏，需要开启查看隐藏文件才可以查看到</p></blockquote><p>在Git中，我们将这个目录的内容称为“附属于该仓库的工作树”。文件的编辑等操作在工作树中进行，然后记录到仓库中，以此管理文件的历史快照。如果想将文件恢复到原先的状态，可以从仓库中调取之前的快照，在工作树中打开。开发者可以通过这种方式来获取以往的文件，具体的操作指令后面会说明。</p></li><li><p><strong><code>git status</code>——查看仓库状态</strong></p><p><strong><code>git status</code>命令用于显示Git仓库的状态。</strong></p><p>工作树和仓库在被操作的过程中，状态会不断发生变化。在Git操作的过程中，要常看仓库状态。命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>结果显示我当前处于<code>master</code>分支下。关于分支我们会在后面讲到。接着还显示了没有可提交的内容。所谓提交(Commit)，是指“记录工作树中所有文件的当前状态”。</p><p>没有可提交内容，就是说明我们当前建立这个仓库中还没有记录任何文件的任何状态。这里，创建一共Readme文件作为示例，为第一次提交做前期准备。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1241d81d.png" alt="image-20220203184854865" style="zoom:80%;" /><p>可以看到在Untracked files中显示了Readme.md文件。类似地只要对Git的工作树或仓库进行操作，<code>git status</code>命令的显示结果就会发生变化。</p></li><li><p><strong><code>git add</code>——向暂存区中添加文件</strong></p><p>如果只是用Git仓库的工作树创建了文件，那么该文件并不会被计入Git仓库的版本管理对象当中。因此我们使用<code>git status</code>命令查看ReadMe.md文件时，它会显示在Untracked files里。</p><p><strong>要想让文件成为Git仓库的管理对象，就需要用<code>git add</code>命令将其加入暂存区（Stage或者Index）中</strong>。<strong>暂存区是提交之前的一个临时区域</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf12846f5c.png" alt="image-20220205105924838" style="zoom:80%;" /><p>将ReadMe.md文件加入暂存区后，<code>git status</code>命令的显示结果发生了变化。可以看到，ReadMe.md文件显示在Changes to be committed中了。</p></li><li><p><strong><code>git commit</code>——保存仓库的历史记录</strong></p><p><strong><code>git commit</code>命令可以将当前暂存区中的文件实际保存到仓库的历史记录中</strong>。通过这些记录，我们就可以在工作树中复原文件。</p><ol><li><p><strong>记录一行提交信息</strong></p><p>命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;这里是提交信息，是对提交的描述&quot;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf12ce1a69.png" alt="image-20220205110529770" style="zoom:80%;" /></li><li><p><strong>记录详细的提交信息</strong></p><p>上述命令示例，提交了一行简单的提交信息，如果希望更加详细的描述提交信息，就不需要加<code>-m</code>，直接执行<code>git commit</code>命令。如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不需要加-m了</span></span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>执行后编辑器会启动显示如下效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">with <span class="string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># On branch master</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Changes to be committed:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">new file:   ReadMe.md</span></span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure><p>在编辑器中记述提交信息的格式如下（可以不用遵守这个格式，此格式只是提高可读性）：</p><ul><li>第一行：用一行文字简要描述提交信息</li><li>第二行：空行</li><li>第三行以后：记录更改的原因和详细的内容</li></ul><p>只要按照上面的格式输入，今后便可以通过确认日志命令或者工具看到这些记录。命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这是一行注释</span><br><span class="line"></span><br><span class="line">这是详细的注释信息，可以一直写，都是文件更改注释描述</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">with <span class="string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># On branch master</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Changes to be committed:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">new file:   ReadMe.md</span></span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure><p>在以<code>#</code>标为注释的Changes to be committed（要提交的更改）栏中，可以查看本次提交中包含的文件。将要提交信息按格式记录完毕后，保存然后关闭编辑器，以<code>#</code>标注为注释的行不必删除，随后，刚才记录的提交信息就会被提交。</p></li><li><p><strong>中止提交</strong></p><p>如果在编辑器启动后想中止提交，直接将提交信息留空关闭编辑器即可。</p></li><li><p><strong>查看提交后的状态</strong></p><p>执行完毕<code>git commit</code>命令后再来查看当前状态：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf13293d3b.png" alt="image-20220205113345688" style="zoom:80%;" /></li></ol></li><li><p><strong><code>git log</code>——查看提交日志</strong></p><p><strong><code>git log</code>命令可以查看以往仓库中的提交日志。</strong>包括什么人在什么时候进行了提交和合并，以及操作前后的差别等。现在来查看之前<code>git commit</code>的命令是否被记录了：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf136a195c.png" alt="image-20220205113611232" style="zoom:80%;" /><p>可以看到已经记录了我们的提交记录。**<code>commit</code>后面显示的“4b68….”，是指向这个提交的哈希值。<code>Git</code>的其他命令中，在指向提交时也会用到这个哈希值。<code>Author</code>是提交人的用户名和邮箱地址。<code>Date</code>栏显示的提交时间，然后后面就是提交的信息。**</p><ol><li><p><strong>只显示提交信息的第一行</strong></p><p>如果只想让程序显示第一行简述信息，可以在<code>git log</code>命令后加上<code>--pretty=short</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=short</span><br></pre></td></tr></table></figure></li><li><p><strong>只显示指定目录，文件的日志</strong></p><p>只要在<code>git log</code>命令后面加上目录名或者文件名就可以显示于该目录或者文件相关的记录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令示例：</span></span><br><span class="line">git log ReadMe.md</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf13b1fbe4.png" alt="image-20220205114741582" style="zoom:80%;" /></li><li><p><strong>显示文件的改动</strong></p><p>如果想查看文件提交所带来的改动，可以加上<code>-p</code>参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure><p>如果只想查看某文件的提交日志以及前后差异可以使用如下格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令格式：</span></span><br><span class="line">git log -p 文件名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令示例：</span></span><br><span class="line">git log -p ReadMe.md</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong><code>git diff</code>——查看更改前后的差别</strong></p><p><code>git diff</code>命令可以查看工作树，暂存区，最新提交之间的差别。</p><p>现在我们在之前提交的ReadMe.md中写点东西：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是新写的东西</span><br></pre></td></tr></table></figure><ol><li><p><strong>查看工作树和暂存区的区别</strong></p><p>执行<code>git diff</code>命令，查看工作树与暂存区的差别。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf13f4c795.png" alt="image-20220205125519560" style="zoom:80%;" /><p>因为我们并没有使用<code>git add</code>命令将工作树的文件添加到暂存区，所以程序只显示工作树与最新提交状态之间的差别。</p><p><strong><code>+</code>号标出的是新添加的行，被删除的行用<code>-</code>标出</strong>，由此可以看出只添加了一行。</p><p>现在使用<code>git add</code>将修改后的文件添加到暂存区</p></li><li><p><strong>查看工作树和最新提交的差别</strong></p><p>如果我们现在执行<code>git diff</code>命令，由于工作树和暂存区的状态没有差别，结果是什么也不会显示。要查看与最新提交的差别，需要执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1437cb1a.png" alt="image-20220205125900504" style="zoom:80%;" /><p>然后我们就可以直接进行提交<code>git commit</code>了，提交完毕后使用<code>git log</code>命令检查一下提交是否被记录。</p></li></ol></li></ul><blockquote><p>如果进入<code>git log</code>日志最后发现了<code>&lt;End&gt;</code>，说明进入日志文件，这个时候按<code>q</code>就可以退出</p></blockquote><h1 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h1><p><strong>在进行多个并行作业时，我们会用到分支</strong>。在这类并行开发的过程中，往往同时存在多个最新代码状态。如下图所示，从<code>master</code>分支创建分支A和分支B后，每个分支中都拥有自己的最新代码。<code>master</code>分支是Git默认创建的分支，因此基本上所有开发都是以这个分支为中心进行的。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1485245c.png" alt="image-20220205131656707" style="zoom:80%;" /><p><strong>不同的分支中，可以同时进行完全不同的作业。等该分支的作业完成之后再与<code>master</code>分支合并</strong>。比如A分支的作业结束后再与<code>master</code>合并。如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf14c6bdf5.png" alt="image-20220205131939324" style="zoom: 67%;" /><ul><li><p><strong><code>git branch</code>——显示分支一览表</strong></p><p><code>git branch</code>命令可以将分支名列表显示，同时可以确认当前所在的分支。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf150ef945.png" alt="image-20220205132950335" style="zoom:80%;" /><p><strong>可以看到<code>master</code>分支左侧有<code>*</code>号，表示这是我们当前所在的分支</strong>。也就是说，我们正在<code>master</code>分支下进行开发。<strong>结果中没有显示其他分支名，表示本地仓库中只存在<code>master</code>一个分支</strong>。</p></li><li><p><strong><code>git checkout -b</code>——创建，切换分支</strong></p><p>如果想以当前的<code>master</code>分支为基础创建新的分支，需要用到<code>git checkout -b</code>命令。命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 需要创建的分支名称</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf154efca2.png" alt="image-20220205145339982" style="zoom: 67%;" /><p>实际上<code>git checkout -b</code>命令，是下面的命令合并效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建分支<span class="built_in">test</span></span></span><br><span class="line">git branch test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指针切换到分支<span class="built_in">test</span>，之前一直默认在主分支即master上</span></span><br><span class="line">git checkout test</span><br></pre></td></tr></table></figure><p><strong>如果在<code>test</code>分支的左边有<code>*</code>号，则表示目前指针指向该分支，如果这个时候正常开发修改代码，再提交的话，代码就会提交到<code>test</code>分支下</strong>。像这样不断对一个分支进行提交的操作，称为“培育分支”。</p><p><strong>如果我们想要快速切换回上一个分支，可以使用<code>-</code>代替分支名</strong>，命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1596a8ff.png" alt="image-20220205151438821" style="zoom:67%;" /></li><li><p><strong>特性分支</strong></p><p>Git与SVN等集中型版本管理系统不同，创建分支不需要连接中央仓库，所以能够轻松创建分支。因此，当今大部分工作流程中都用到了特性(Topic)分支。</p><p>特性分支顾名思义，是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常快开发中，往往会创建数个特性分支，同时在此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色同时由<code>master</code>分支担当。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf15e7764b.png" alt="image-20220205154334634" style="zoom:80%;" /><p>例如之前创建的分支A，这一分支主要实现A需求，除A需求之外不进行任何作业，即便在开发过程中发现了BUG，也需要创建新的分支，在新的分支中进行。</p><p>基于特定主题的作业在特性分支中进行，主题完成后再与<code>master</code>分支合并。只要保持这样一个开发流程，就能保证<code>master</code>分支可以随时供人查看。这样一来，其他开发者也可以放心大胆的从<code>master</code>分支创建新的特性分支。</p></li><li><p><strong>主干分支</strong></p><p>主干分支是特性分支的原点，同时也是合并的终点。一般来说是以<code>master</code>分支作为主干分支。</p></li><li><p><strong><code>git merge</code>合并分支</strong></p><p>现在假设我们前面创建的<code>test</code>分支以及实现完毕了，想要将它合并到主干分支<code>master</code>中，首先切换到<code>master</code>分支上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>然后合并<code>test</code>分支。为了在历史记录记录下来本次分支合并，需要创建合并提交。**因此，在合并时加上<code>--no-ff参数</code>**。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff test</span><br></pre></td></tr></table></figure><p>然后编辑器弹出，添加一定的描述，关闭编辑器后，就完成分支合并了。</p></li><li><p><strong><code>git log --graph</code>——以图表形式查看分支</strong></p><p>用<code>git log --graph</code>命令查看，能很清楚地看到很多信息。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1630433a.png" alt="image-20220205160840715" style="zoom: 67%;" /></li></ul><h1 id="更改提交的操作"><a href="#更改提交的操作" class="headerlink" title="更改提交的操作"></a>更改提交的操作</h1><h2 id="git-reset——回溯历史版本"><a href="#git-reset——回溯历史版本" class="headerlink" title="git reset——回溯历史版本"></a><strong><code>git reset</code>——回溯历史版本</strong></h2><p>在前面基础操作，以及可以在实现功能后进行提交，累积提交日志作为历史记录，借此不断培育一款软件。</p><p>Git的另一特性是可以灵活的操作历史版本，借助分散仓库的优势，可以在不影响其他仓库的前提下对历史版本进行操作。</p><p>现在进行版本回溯，然后再创建一个<code>B</code>特性分支，Git目前结构如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf167b8f28.png" alt="image-20220205165541460" style="zoom:67%;" /><p>我们需要先回溯到分支<code>A</code>的之前的分支节点，然后创建一个名为<code>B</code>的特性分支。要让仓库的HEAD，暂存区，当前工作树回溯到指定状态，需要使用<code>git reset --hard</code>命令。只要提高目标时间点的哈希值。就可以完全恢复到该时间点状态。命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要注意的是，每个哈希值不一样，操作的时候看自己的哈希值</span></span><br><span class="line">git reset --hard a369bfe343a6ce72d75b39db804da6f46769be2d</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf16b8b740.png" alt="image-20220205171050472" style="zoom:67%;" /><p>现在来创建新分支B，并且在新分支中，在ReadMe.md文件中添加一些文字，然后提交ReadMe.md文件。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf16f9d615.png" alt="image-20220205171518879" style="zoom:67%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1737689a.png" alt="image-20220205171548568" style="zoom:67%;" /><p>现在分支状态如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf17728454.png" alt="image-20220205171825806" style="zoom:67%;" /><p>现在需要恢复到分支<code>A</code>合并后的状态，使用<code>git log</code>只能查看当前状态为终点的历史记录。所以需要使用<code>git reflog</code>命令，查看当前仓库的操作日志。在日志中找出回溯历史之前的哈希值，然后通过<code>git reset --hard</code>命令回溯到历史之前的状态。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf17b3a074.png" alt="image-20220205172249850" style="zoom: 50%;" /><p>从日志里可以看到我们所有的操作，只要不进行Git的GC（Garbage Colloection，垃圾回收）就可以通过日志随意调取历史状态。可以了解到我们要恢复的时间点哈希值为：7092c19b410daac6937a906966b78565e6432771，其实我们只需要输入前面的7092c19即可执行恢复。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf17fdf7f6.png" alt="image-20220205172957748" style="zoom:67%;" /><p>恢复后的状态：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf183d192d.png" alt="image-20220205173422425" style="zoom:70%;" /><h2 id="消除冲突"><a href="#消除冲突" class="headerlink" title="消除冲突"></a><strong>消除冲突</strong></h2><p>现在只需要合并分支<code>B</code>就可以满足我们想要的状态：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1884f050.png" alt="image-20220205173630138" style="zoom: 67%;" /><p>执行合并后：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf18c586da.png" alt="image-20220205174155577" style="zoom:67%;" /><p>这是，系统告诉我们ReadMe.md合并过程中发生冲突(Conflict)。系统在合并ReadMe.md文件时，分支A更改的部分和分支B更改的部分发生了冲突。</p><p>所以需要解决冲突来完成合并。</p><ul><li><p><strong>查看冲突部分并将其解决</strong></p><p>使用编辑器打开ReadMe.md查看文件，会发现文件的内容变成如下示例类似样子：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf19039da0.png" alt="image-20220205174526571" style="zoom:60%;" /><p><code>==========</code>以上的部分是当前HEAD的内容，以下的内容是要合并的分支B中的内容，现在将其该成我们想要的样子</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf194472b0.png" alt="image-20220205174715520" style="zoom:60%;" /><p>现在内容被修改成了我们想要保存的样子，冲突解决</p></li><li><p><strong>提交最后的解决方案</strong></p><p>现在来执行<code>git add</code>命令和<code>git commit</code>命令来完成提交</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf19916886.png" alt="image-20220205174916848" style="zoom:67%;" /></li></ul><h2 id="git-commit-amend——修改提交信息"><a href="#git-commit-amend——修改提交信息" class="headerlink" title="git commit --amend——修改提交信息"></a><strong><code>git commit --amend</code>——修改提交信息</strong></h2><p>要修改上一条提交信息，可以使用<code>git commit --amend</code>命令，执行该命令后，会弹出编辑器，对内容进行修改后，关闭编辑器即可完成修改。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf19e87794.png" alt="image-20220205181447963" style="zoom:60%;" /><h2 id="git-rebase-i——压缩历史"><a href="#git-rebase-i——压缩历史" class="headerlink" title="git rebase -i——压缩历史"></a><strong><code>git rebase -i</code>——压缩历史</strong></h2><p>在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录。</p><p>现在我们新开一个分支<code>C</code>并且修改其中的内容来作为后面修正。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1a43a5c4.png" alt="image-20220205183834327" style="zoom:67%;" /><p>然后提交故意修改错误的内容，可以通过如下命令来一次执行到暂存区再到<code>commit</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1a8c44ea.png" alt="image-20220205184112266" style="zoom:67%;" /><ul><li><p><strong>修正拼写错误</strong></p><p>现在来修正刚刚的错误，修正完毕后查看修正前后的差别。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1ad1b576.png" alt="image-20220205184435866" style="zoom:67%;" /><p>然后进行提交</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1b10f60b.png" alt="image-20220205184620781" style="zoom:67%;" /><p>这种后来进行修正的错误，我们不希望在历史记录中看到这类提交，因为健全的历史记录不需要它们。如果在第一次合并中就发现并修正这些错误，也就不会出现这类提交了。</p></li><li><p><strong>更改历史</strong></p><p>因此，我们需要来更改历史。将修正的内容与之前的提交合并，在历史记录合并为一次完美的提交。因此，我们需要使用<code>git rebase</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure><p>用上述命令，可以选定当前分支包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1b5699a5.png" alt="image-20220205193525354" style="zoom:67%;" /><p>将6aca246的修正错误历史记录压缩到92d473d的ReadMe.md中，按照下述的方法，将6aca246左侧的<code>pick</code>部分删除，改为<code>fixup</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 92d473d ReadMe.md</span><br><span class="line">fixup 6aca246 修正了部分错误</span><br></pre></td></tr></table></figure><p>修改完成后，关闭编辑器，系统提示<code>Rebase</code>成功：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1b9976e1.png" alt="image-20220205193849481" style="zoom:57%;" /><p>也就是说将两个提交作为对象，合并到了第一次提交的时候成了一个新的提交。</p><p>现在再查看提交日志会发现最新的提交日志已经合并一个切之前写的描述信息也已经不见了，这证明提交已经被修改了。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1bd4a5b1.png" alt="image-20220205194109469" style="zoom:67%;" /></li><li><p><strong>合并到<code>master</code>分支</strong></p><p>现在将分支<code>C</code>可以合并到主分支<code>master</code>了。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1c11adde.png" alt="image-20220205194338635" style="zoom:57%;" /></li></ul><h1 id="推送至远程仓库"><a href="#推送至远程仓库" class="headerlink" title="推送至远程仓库"></a>推送至远程仓库</h1><p>Git是分散型版本管理系统，前面的操作都是针对单一本地仓库的操作。现在来尝试对远程仓库进行操作。现在首先在GitHub上创建一个仓库，不需要勾选<code>README</code>选项。仓库名称随意，此处演示远程仓库名称为TestGit。</p><h2 id="git-remote-add——添加远程仓库"><a href="#git-remote-add——添加远程仓库" class="headerlink" title="git remote add——添加远程仓库"></a><strong><code>git remote add</code>——添加远程仓库</strong></h2><p>**在GitHub上创建的仓库路径为”<a href="mailto:&#x67;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#109;">&#x67;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#109;</a>:用户名&#x2F;仓库名称.git”**。现在来使用<code>git remote add</code>命令将其设置成本地仓库的远程仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式：</span></span><br><span class="line">git remote add &lt;shortname&gt; &lt;url&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令示例：</span></span><br><span class="line">git remote add test git@github.com:L-Seraphine/TestGit.git</span><br></pre></td></tr></table></figure><p><strong>根据上述命令，将地址为：<a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#x63;&#111;&#x6d;">&#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#x63;&#111;&#x6d;</a>:L-Seraphine&#x2F;TestGit.git远程仓库的名称设置为：test（标识符）。可以通过标识符快速表示该地址的远程仓库</strong>。</p><h2 id="git-push——推送至远程仓库"><a href="#git-push——推送至远程仓库" class="headerlink" title="git push——推送至远程仓库"></a><strong><code>git push</code>——推送至远程仓库</strong></h2><ul><li><p><strong>推送至<code>master</code>分支</strong></p><p>如果想将当前分支下本地仓库中的内容推送给远程仓库，需要用到<code>git push</code>命令。现在假定我们在<code>master</code>分支下进行操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u test master</span><br></pre></td></tr></table></figure><p>执行如上命令，当前分支的内容会被推送给远程仓库TestGit的<code>mastet</code>分支。<code>-u</code>参数可以在推送时，将远程仓库的<code>master</code>分支设置为本地仓库当前分支的upstream(上游)。添加这个参数，将来运行<code>git pull</code>命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从远程仓库的<code>master</code>分支获取内容，省去了另外添加参数的麻烦。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1c650bfe.png" alt="image-20220205205105145" style="zoom:67%;" /><p>执行该操作后，当前本地仓库的<code>master</code>分支的内容就会被推送到GitHub的远程仓库中。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1cb6b59b.png" alt="image-20220205205151846" style="zoom:67%;" /></li><li><p><strong>推送至<code>master</code>以外的分支</strong></p><p>除了<code>master</code>分支之外，远程仓库也可以创建其他分支。现在我们在本地仓库创建分支<code>D</code>,并将它推送至远程的同名分支。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1cf897c8.png" alt="image-20220205205512167" style="zoom:67%;" /><p>现在，在远程仓库的GitHub页面就可以看到分支<code>D</code>了。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1d3481ad.png" alt="image-20220205205548606" style="zoom: 80%;" /></li></ul><h1 id="从远程仓库获取"><a href="#从远程仓库获取" class="headerlink" title="从远程仓库获取"></a>从远程仓库获取</h1><p>上部分我们将GitHub上的远程仓库<code>push</code>了分支D。现在，所有能够访问这个远程仓库的人都可以获取分支<code>D</code>并加以修改。</p><h2 id="git-clone——获取远程仓库"><a href="#git-clone——获取远程仓库" class="headerlink" title="git clone——获取远程仓库"></a><strong><code>git clone</code>——获取远程仓库</strong></h2><p><code>git clone</code>命令在很早之前就使用过，语法格式和操作方法不再说明。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1db22be3.png" alt="image-20220205210223590" style="zoom:67%;" /><p><strong>执行<code>git clone</code>命令后默认我们会处于<code>master</code>分支下，同时系统会自动将<code>origin</code>设置为该远程仓库的标识符</strong>。也就是说，当前本地仓库的<code>master</code>分支和远程仓库的<code>master</code>分支的内容是完全一致的。</p><p>我们使用<code>git branch -a</code>命令查看当前分支的相关信息。添加<code>-a</code>参数可以同时显示本地仓库和远程仓库的分支信息。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1df80657.png" alt="image-20220205210716346" style="zoom:67%;" /><h2 id="获取远程仓库的分支D"><a href="#获取远程仓库的分支D" class="headerlink" title="获取远程仓库的分支D"></a>获取远程仓库的分支D</h2><p>使用如下命令将指定获取远程仓库的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b D origin/D</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">D的意思是创建本地分支名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">origin是默认的远程仓库的标识符</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">origin/D是远程仓库的分支D的路径</span></span><br></pre></td></tr></table></figure><p>现在假定我们是另一个开发者，需要做一个新的提交。在ReadMe.md文件中添加一行文字，如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1e421d11.png" alt="image-20220205211918862" style="zoom: 67%;" /><p>然后提交即可：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1e83b258.png" alt="image-20220205212058588" style="zoom:67%;" /><p>然后远程推送即可：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf1ec467ca.png" alt="image-20220205212202257" style="zoom: 65%;" /><h2 id="git-pull——获取最新的远程仓库分支"><a href="#git-pull——获取最新的远程仓库分支" class="headerlink" title="git pull——获取最新的远程仓库分支"></a><strong><code>git pull</code>——获取最新的远程仓库分支</strong></h2><p>当远程仓库的内容更新了，需要拉取，则可以通过如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull 远程仓库标识符 分支名称</span><br></pre></td></tr></table></figure><p>来获取远程仓库，对本地仓库进行更新。</p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git与GitHub(上)</title>
      <link href="/2022/05/26/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Git%E4%B8%8EGitHub(%E4%B8%8A)/"/>
      <url>/2022/05/26/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Git%E4%B8%8EGitHub(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分写于寒假，之前学过<code>git</code>一些基本操作，属于学个开始就由于别的事情暂时耽搁了，现在是大三寒假，我决定把它补上。</p><p>此处推荐两个网站，一个是git官方的书籍教程，一个是GitHub上比较有名的可视化git教程</p><ul><li><a href="httpss://learngitbranching.js.org/?locale=zh_CN">玩游戏学习git网站</a></li><li><a href="httpss://git-scm.com/book/zh/v2">特别好的git书籍</a></li></ul><h1 id="Git与GitHub简要"><a href="#Git与GitHub简要" class="headerlink" title="Git与GitHub简要"></a>Git与GitHub简要</h1><h2 id="关于GitHub"><a href="#关于GitHub" class="headerlink" title="关于GitHub"></a>关于<a href="httpss://github.com/">GitHub</a></h2><p><a href="httpss://github.com/">GitHub</a>作为最大的同性交友网站(雾)，**<a href="httpss://github.com/">GitHub</a>为开发者提供<code>Git</code>仓库的托管服务，可以让开发者及其相关人员共享代码的场所**。可以暂时通俗理解为代码的仓库。</p><h2 id="关于Git"><a href="#关于Git" class="headerlink" title="关于Git"></a>关于Git</h2><p><strong>Git属于分散型版本管理系统，是为版本管理而设计的软件</strong>。</p><p>Linux的创始人Linus Torvalds在2005年开发了Git的原型程序，当时是为了更好的维护Linux系统。</p><p>关于这里有一个故事：一开始Linux之父是个人在开源做Linux，随着参与项目的人越来越多，Linux项目越来越复杂，Linux之父不得不在代码整理，纠错，审核，检查，发布的过程中耗费大量的时间，这样就严重影响了开发，于使Linux之父使用了当时的版本管理系统，虽然这样解决相关问题，当时由于技术宅的爱好，就把提供Linux之父版本控制厂商研发的版本管理系统给破解研究了，这样就违背了使用该软件的相关原则，于使Linux之父一生气，憋了一个月，开发出来了Git</p><h3 id="什么是版本管理"><a href="#什么是版本管理" class="headerlink" title="什么是版本管理"></a>什么是版本管理</h3><p>版本就是管理更新的历史记录。它为我们提供了一些在软件开发过程中必不可少的功能，例如记录一款软件添加或者更改源代码的过程，回滚到特定阶段，恢复误删除的文件等。</p><p>在Git出现以前，人们普遍采用Subversion(SVN)等集中型版本管理系统，而现在Git已经成为了主流。</p><h3 id="集中型与分散型"><a href="#集中型与分散型" class="headerlink" title="集中型与分散型"></a>集中型与分散型</h3><p>刚才说到的版本管理系统分为Subversion(SVN)这类集中型的与Git这类分散型的</p><ul><li><p><strong>集中型</strong></p><p>以Subversion为代表的集中型，会将如下图所示的仓库集中存放在服务器之中，所以只存在一个仓库，这就是为什么会被称为集中型。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf03608de0.png" alt="image-20220202165523166" style="zoom:80%;" /><p>集中型将所有数据集中存放在服务器当中，有便于管理的优点。但是一旦开发者所处的环境不能连接服务器，就无法获取最新的源代码，开发也就几乎无法进行。服务器宕机时也是同样的道理，而且万一服务器故障导致数据消失，恐怕开发者就再也见不到代码了。</p></li><li><p><strong>分散型</strong></p><p>如下图为GitHub分散型示意图。如图中所示，GitHub将仓库<code>Fork</code>给了每一个用户。<code>Fork</code>就是将GitHub的某个特定仓库复制到自己的账户下。<code>Fork</code>出的仓库与原仓库是两个不同的仓库，开发者可以随意编辑。</p><p>​<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf03a55d44.png" alt="image-20220202171024187" style="zoom:80%;" /></p><p>分散型拥有多个仓库，相对而言稍显复杂。不过，由于本地的开发环境中就有仓库，所以开发者不必远程连接仓库就可以进行开发。</p></li></ul><h3 id="集中型和分散型哪个更好？"><a href="#集中型和分散型哪个更好？" class="headerlink" title="集中型和分散型哪个更好？"></a>集中型和分散型哪个更好？</h3><p>各有优缺点，根据具体情况而定，不存在绝对的“好”。</p><h2 id="GitHub与Git的区别"><a href="#GitHub与Git的区别" class="headerlink" title="GitHub与Git的区别"></a>GitHub与Git的区别</h2><p><strong>GitHub与Git完全是两个东西。在Git中，开发者将源代码存放进“Git仓库”的资料库中并加以使用和操作。而GitHub则是网络上提供Git仓库的一项服务。</strong></p><p>也就是说，GitHub上公开的软件源代码全部都由Git进行管理，所以理解Git，是熟练运用GitHub的关键。</p><h1 id="开始Git与GitHub之旅"><a href="#开始Git与GitHub之旅" class="headerlink" title="开始Git与GitHub之旅"></a>开始Git与GitHub之旅</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><ul><li><p>Mac与Linux</p><p>无Mac系统，自行百度，Linux都以软件包(Package)的形式提供了，可以直接使用。</p></li><li><p>Windows</p><p>百度Git查找官网下载，或者点击这里<a href="httpss://git-scm.com/">Git官网</a>，然后选择Windows平台，或者直接在这里下载<a href="httpss://gitforwindows.org/">msysGit</a>，这两个是一个软件，选择一个合适的位数，下载，完成后双击运行，按照引导安装即可。</p><blockquote><p>说明：我使用的Git版本是<code>2.32.0.windows.2</code>，也是文章各种Git代码示例的演示版本</p></blockquote><ol><li><p>双击运行，选择下一步（Next）</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf03f2f731.png" alt="image-20220202213937370" style="zoom:80%;" /></li><li><p>选择安装位置，点击Next</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf042e9d1d.png" alt="image-20220202214123824" style="zoom:80%;" /></li><li><p>根据需要选择相应组件，或者直接默认即可，点击Next</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf046d0fdc.png" alt="image-20220202214851363" style="zoom:50%;" /></li><li><p>选择Win菜单中Git相关文件目录，无需求的可以选择默认，点击Next</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf04a95924.png" alt="image-20220202215753488" style="zoom:80%;" /><p>如果选择默认，则在开始菜单中可以找到git相关文件如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf04e38c54.png" alt="image-20220202215946572" style="zoom:80%;" /></li><li><p>选择Git默认编辑器，无特殊需求默认即可，有特殊需求的需要另行安装编辑器，并在安装时指定编辑器，并配置相关环境变量。默认则直接点击Next即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0518f36f.png" alt="image-20220202220139702" style="zoom:80%;" /></li><li><p>选择初始化仓库的主干名称，默认为第一项，即让Git选择，名称为<code>master</code>，未来可能会改名。第二项是我们可以自定义名称，下面附注的翻译为：<em>很多团队已经重命名他们的默认主干名，常见的选择为 main，trunk 以及 development，你可以修改你的主干名称为：</em></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf055854e4.png" alt="image-20220202220739690" style="zoom:80%;" /></li><li><p>选择修改Path环境变量，无特殊需求可以直接默认，点击Next即可</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf05955186.png" alt="image-20220202221014355" style="zoom:80%;" />翻译：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf06134142.png" alt="image-20220202221903449" style="zoom:70%;" /></li><li><p>选择HTTPS后端传输规则，同理无特殊需求默认即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf065d8c01.png" alt="image-20220202222429285" style="zoom:80%;" /><blockquote><p>关于两个选项的区别可以参考[<a href="httpss://stackoverflow.com/questions/62456484/whats-the-difference-between-openssl-and-the-native-windows-secure-channel-libr">What’s the difference between OpenSSL and the native windows Secure Channel library</a>]</p></blockquote></li><li><p>末尾换行符的处理，同理无特殊需求，默认即可</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf06bb050a.png" alt="image-20220202222547719" style="zoom:80%;" /><p>GitHub中公开的代码大部分都是以Mac或Linux中的LF(Line Feed)换行。然而，由于Windows中是以CRLF(Carriage Return + Line Feed)换行的，所以在非对应的编辑器中将不能正常显示。</p><p>Git可以通过设置自动转换这些换行符。对于使用Windows环境的用户来说，直接选择默认的”Checkout Windows-style,commit Unix-style line endings”选项。换行符在<code>checkout</code>时会自动转换为CRLF，在提交时则会自动转换为LF。</p><blockquote><p>相关说明：<a href="httpss://zhuanlan.zhihu.com/p/380574688">关于CRLF和LF的差异</a></p></blockquote></li><li><p>配置终端模拟器与Git Bash一起使用，同理无特殊需求默认即可，点击Next。<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf070dac33.png" alt="image-20220202225251266" style="zoom:80%;" /></p><p>翻译：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0754b005.png" alt="image-20220202230152589" style="zoom:70%;" /></li><li><p>选择默认的<code>git pull</code>行为，无特殊需求默认即可，点击Next。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf079ccd03.png" alt="image-20220202230311097" style="zoom:80%;" /></li><li><p>选择一个凭证帮助管理，无特殊需求无须配置，点击Next即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf07e46a69.png" alt="image-20220202230538736" style="zoom:80%;" /></li><li><p>其他配置，无特殊需求默认即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0828afcd.png" alt="image-20220202230710959" style="zoom:80%;" /><p>翻译：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf086b7be5.png" alt="image-20220202231151069" style="zoom:70%;" /></li><li><p>实验性功能选项，无特殊需求默认即可，然后选择<code>Install</code>等待安装即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf08ae3a41.png" alt="image-20220202231220516" style="zoom:80%;" /></li><li><p>安装成功后可以通过鼠标右键查看到如下快捷导航：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf08f8368e.png" alt="image-20220202231356420" style="zoom:67%;" /></li></ol></li></ul><h2 id="Git初始设置"><a href="#Git初始设置" class="headerlink" title="Git初始设置"></a>Git初始设置</h2><p>在随便一个位置，右键鼠标，选择<code>Git Bash Here</code>，在之后弹出的程序控制台中进行操作。</p><blockquote><ol><li><code>Git GUI Here</code>是Git提供的GUI图形化界面，但是用处不大，可以不用考虑</li><li>关于<a href="httpss://baike.baidu.com/item/Bash/6367661?fr=aladdin"><code>Bash</code>出处由来(点击查看)</a></li></ol></blockquote><ul><li><p><strong>设置姓名和邮箱地址</strong></p><p>使用如下代码来设置使用Git时的姓名和邮箱地址，名称使用英文输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置名称和邮箱地址</span></span><br><span class="line">git config --global user.name &quot;你自定义的名称&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱地址&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前名称和邮箱地址</span></span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf094a32b9.png" alt="image-20220202233416626" style="zoom:67%;" /><p><strong>这里设置的姓名和邮箱地址会用在Git的提交日志中。由于GitHub上公开仓库时，这里的姓名和邮箱也会随着提交日志一同被公开，所以注意不要使用隐私信息</strong>。</p></li><li><p><strong>提高命令输出的可读性</strong></p><p>可以通过将<code>color.ui</code>设置为<code>auto</code>来让命令的输出有更高的可读性。代码示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui auto</span><br></pre></td></tr></table></figure></li></ul><h2 id="GitHub的相关准备"><a href="#GitHub的相关准备" class="headerlink" title="GitHub的相关准备"></a>GitHub的相关准备</h2><p>访问GitHub网页，或者<a href="httpss://github.com/">单击这里</a>，进行GitHub的相关准备。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf09898fbf.png" alt="image-20220202234926203" style="zoom:80%;" /><ul><li><p><strong>创建账户</strong></p><p>进入如下类似界面创建账户，需要注意的是Username设置好后，个人公开页面URL即（httpss:&#x2F;&#x2F;github.com&#x2F;+username），其他项目根据提示完成填写并创建账户。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf09d0ab51.png" alt="image-20220202235255910" style="zoom:67%;" /></li><li><p><strong>设置头像</strong></p><p>在GitHub上随处可见的头像是通过<a href="https://cn.gravatar.org/">Gravatar</a>服务显示的。使用过<code>WordPress</code>的玩家可能会对它有所了解。</p><p>当然现在，可以直接点击我的头像，进入设置，上传自定义头像。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0a13a4cb.png" alt="image-20220203000017875" style="zoom:80%;" /></li><li><p><strong>设置SSH Key</strong></p><p><strong>GitHub上链接已有仓库时的认证，是通过SSH公开密钥认证方式进行的。现在需要来创建公开密钥认证所需要的SSH Key，并将其添加到GitHub上</strong>。运行下面的命令来创建SSH Key：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;这里添你的邮箱&quot; </span><br></pre></td></tr></table></figure><p>输入后会弹出一行提醒：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (/c/Users/电脑用户文件夹/.ssh/id_rsa):</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里是告诉你SSH key保存在哪个路径下，只需要按下回车确认就可以</span></span><br></pre></td></tr></table></figure><p>剩下的如下图所示，根据提示设置密码：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0a5ec68f.png" alt="image-20220203122043906" style="zoom:80%;" /><blockquote><p>需要注意的是，<strong>密码输入后会不显示在控制台上</strong>，所以不要误认为控制台失灵了</p></blockquote><p>设置成功会弹出如下提醒：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0aa1d876.png" alt="image-20220203124607435" style="zoom:80%;" /><p>同样的，你可以在它保存的路径下找到相关公钥和密钥文件：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0ada6619.png" alt="image-20220203123240917" style="zoom:80%;" /><blockquote><p>关于<a href="httpss://docs.github.com/en/authentication/connecting-to-github-with-ssh">SSH密钥的官方说明</a></p></blockquote></li><li><p>在GitHub上<strong>添加公开密钥</strong></p><p>在GitHub上添加公开密钥，今后就可以使用私有密钥进行认证了。</p><p>进入GitHub网站，登录你的账户，单击头像，选择<code>Settings</code>（设置）</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0b370944.png" alt="image-20220203123809744" style="zoom:90%;" /><p>进入设置页面，在左栏找到<code>SSH and GPG keys</code>，单击进入，在<code>SSH keys</code>栏选择<code>New SSH keys</code>（创建新的公钥）</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0b7e1167.png" alt="image-20220203124044881" style="zoom:80%;" /><p><strong><code>Title</code>部分可以自定义，<code>Key</code>需要填写公钥文件里的内容</strong>，可以通过找到路径文件，选择以记事本格式打开，或者通过下面的命令来查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0bc2dd01.png" alt="image-20220203124502974" style="zoom:80%;" /><p>点击添加，输入密码二次确认，添加成功后，可以在<code>SSH keys</code>栏看到刚刚添加的公钥，并且创建账户时所用的邮箱也会收到一封“公钥添加完成”的邮件提醒。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0c1f2373.png" alt="image-20220203124944367" style="zoom:80%;" /><p><strong>在添加完成后，现在可以尝试使用手中的私钥与GitHub进行认证和通信了</strong>。命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现如下提示，则表示连接成功。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0c67ff8b.png" alt="image-20220203125551594" style="zoom:80%;" /><blockquote><p>同理，这里输入密码，也是不可见的</p></blockquote></li><li><p><strong>使用社区功能</strong></p><p>你可以通过<code>Follow</code>来关注某人，这样一来，你关注的对象（用户）的活动就会在你的控制面板中显示出来，你可以看到该用户在GitHub上做了什么，可以通俗理解为微博关注了某人，某人的动态你就可以看到了。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0cb4540a.png" alt="image-20220203130013684" style="zoom:80%;" /></li></ul><h2 id="GitHub实操上手"><a href="#GitHub实操上手" class="headerlink" title="GitHub实操上手"></a>GitHub实操上手</h2><ul><li><p><strong>创建仓库</strong></p><p>在GitHub右上角，点击加号，选择<code>New repository</code>来创建新仓库。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0d09e7d2.png" alt="image-20220203132232745" style="zoom:80%;" /><ol><li><p><strong>Repository template(存储库模板)</strong></p><p>可以选择自定义存储卡模板，无特殊需求可以不用管。</p></li><li><p><strong>Repository name(仓库名称)</strong></p><p>为你创建的仓库自定义一个名称。</p></li><li><p><strong>Description(仓库描述)</strong></p><p>为你仓库添加一个描述，可以为空</p></li><li><p><strong>Public&#x2F;Private(仓库类型)</strong></p><p>仓库的类型，<strong>Public</strong>或者<strong>Private</strong>：</p><ul><li><strong>Public：公开&#x2F;公有，即别人可以看到你的代码</strong></li><li><strong>Private：私有，即别人看不到，只有自己或者授权的人才可以访问</strong></li></ul><p>私有仓库收费的，不过被微软爸爸收购后，可以免费提供最多3人协助私有仓库支持。</p><p>目前示例，创建公有即可</p></li><li><p><strong>Initializa this repository with(初始化命令&#x2F;文件)</strong></p><ul><li><p>**Add a README file(创建一个ReadMe文件)**：即仓库创建后，里面附带一个ReadMe文件。</p><p>ReadMe文件本质是一个记事本，不过其后缀为<code>.md</code>，如果熟悉<code>Markdown</code>的会了解这个文件，一般用来说明仓库包含软件的概要，使用流程，许可协议等信息，可以理解为仓库的说明文档，即使用手册和相关说明。</p><blockquote><p>关于<code>Markdown</code>语法格式及其相关教程可以点击这里<a href="httpss://helloseraphine.top/index.php/archives/57.html">浅谈MarkDown基础</a></p></blockquote></li><li><p>**Add .gitignore(创建.gitignore文件)**：即仓库创建后，附带.gitignore文件。</p><p>这个我没用过，以下内容出自作者: [<a href="httpss://book.douban.com/search/大塚弘记">日] 大塚弘记</a>的《GitHub入门与实践》</p><p><em>这个设定会帮我们把不需要在Git仓库中进行版本管理的文件记录在<code>.gitignore</code>文件中，省去了每次根据框架进行设置的麻烦，选择后下拉菜单包含主要的语言及框架，选择今后将要使用的即可。</em></p></li><li><p>**Add a license(创建许可协议文件)**：即仓库创建后，附带LICENSE协议文件。</p><p>选择后，可以根据下拉菜单来选择许可协议，仓库创建后会自动生成许可协议的LICENSE文件，用来表明仓库的许可协议。</p></li></ul></li><li><p>全部选择完成后，点击创建即可创建一个新的仓库。</p></li></ol><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0d6b1fa4.png" alt="image-20220203132947022" style="zoom:80%;" /></li><li><p><strong>仓库初始页面</strong></p><p>如下为创建的新仓库页面示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0db349db.png" alt="image-20220203140859991" style="zoom:100%;" /><p>我们可以通过示例连接来<code>Clone</code>仓库，或者其他方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpss://github.com/L-Seraphine/Test.git</span><br></pre></td></tr></table></figure><ul><li><p>ReadMe：可以看到我们在ReadMe中的内容会被直接显示在仓库的最下面，所以一般会在该文件中注明仓库包含的文件说明，使用说明，许可协议，支持等信息。可以使用普通文本，或者使用<code>Markdown</code>语法实现其他效果，来提高可读性。</p></li><li><p>**GitHub Flavored Markdown(GitHub 风格的 Markdown)**：在GitHub上进行交流时使用的Issue，评论，Wiki等都可以使用<code>Markdown</code>语法表述。准确的来说是GitHub Flavored Markdown（GFM）语法，该语法是在<code>Markdown</code>语法的基础上扩充来的，一般情况下，使用原本的<code>Markdown</code>语法即可。</p><blockquote><p>关于<a href="httpss://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax">GFM语法的官方文档说明</a></p></blockquote></li></ul></li><li><p><strong>使用Git对仓库的基本操作</strong></p><ul><li><p><strong><code>Clone</code>仓库</strong></p><p>选择一个要克隆的文件夹，对着空白处右键，选择<code>Git Bash here</code>，然后在控制台输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 这里是仓库的地址</span><br></pre></td></tr></table></figure><p>仓库地址可以在GitHub SSH选项下复制：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0dfe97bf.png" alt="image-20220203142932527" style="zoom:67%;" /><p>然后输入设置密钥时的密码即可<code>Clone</code>该仓库到指定的本地文件夹：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0e44193d.png" alt="image-20220203143317515" style="zoom:77%;" /></li><li><p><strong>编写代码</strong></p><p>现在在<code>Clone</code>的本地文件夹下，创建文件<code>1.txt</code>，随便写些内容。例如：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure><p>然后通过输入以下命令来查看文件状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0e8f18b3.png" alt="image-20220203151755689" style="zoom:80%;" /></li><li><p><strong>提交</strong></p><p>然后将<code>1.txt</code>提交到仓库，这样，这个文件就进入了版本管理系统的管理之下。今后的更改管理都交给Git进行。命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add 1.txt</span><br></pre></td></tr></table></figure><p><strong>通过<code>git add</code>命令将文件加入暂存区，再通过<code>git commit</code>命令提交。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;update 1.txt&quot;</span><br></pre></td></tr></table></figure><p><strong>添加成功后可以使用<code>git log</code>命令来查看提交日志。</strong></p></li><li><p><strong>进行<code>Push</code></strong></p><p>之后只需要执行<code>push</code>命令，就可以将GitHub上的仓库进行更新。命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0ed9bf35.png" alt="image-20220203152218078" style="zoom:80%;" /><p>这样一来，我们更新的操作就会在GitHub上面公开了。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf0f230f6b.png" alt="image-20220203152310838" style="zoom:80%;" /></li></ul></li></ul><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>这是基本的Git和GitHub的基础和交互基础，对于Git和GitHub连接提交等命令看不懂目前没问题，只需要跟着操作熟悉一下环境和命令即可，后面的部分会详细讲述git相关命令。</p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【CSharp高级编程】委托</title>
      <link href="/2022/05/26/%E8%AF%AD%E8%A8%80%E6%A0%91/CSharp/%E3%80%90CSharp%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%91%E5%A7%94%E6%89%98/"/>
      <url>/2022/05/26/%E8%AF%AD%E8%A8%80%E6%A0%91/CSharp/%E3%80%90CSharp%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%91%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于委托，我一开始同样也是没打算写的，但是考虑到我要写 lambda表达式的相关内容，于是不得不先说明委托的内容。对于初学者来说，第一次见到委托应该是在 Win 的事件模型中吧，反正我是这样的，这部分将对委托做详细说明。</p><h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p><strong>委托这一特性存在的目的是封装目标代码。</strong>封装好的代码可以在应用程序中进行传递，并根据需要执行（要保证参数和返回值的类型安全）。在<code>C# 1</code>时代，委托基本上用于事件处理和启动线程。即使在 2005 年后的<code>C# 2</code>推出之后，这一状况也没有太大变化。直到 2008 年 <code>LINQ</code> 问世，C# 开发人员才开始适应这种把函数传来传去的编程方式。</p><p><code>C# 2</code>提供了 3 种 创建委托实例的新方式，同时支持声明泛型委托，比如<code>EventHandler&lt;TEventArgs&gt;</code>和<code>Action&lt;T&gt;</code>。</p><h1 id="方法组转换"><a href="#方法组转换" class="headerlink" title="方法组转换"></a>方法组转换</h1><p>所谓<strong>方法组，就是一个或者多个同名方法</strong>。可以说，我们在每天不知不觉中使用方法组，因为每调用一次方法就是对方法组的一次使用，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;Hello,World&quot;</span>);</span><br></pre></td></tr></table></figure><p>表达式<code>Console.WriteLine</code>就是一个方法组。之后编译器会根据该方法的调用实参从方法组中选择合适的重载方法进行调用。除了方法调用，**<code>C# 1</code>还将方法组用于委托创建表达式，作为创建委托实例的唯一方法**。假设存在如下方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleButtonClick</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>可以创建<code>EventHandler</code>实例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventHandler eventHandler = <span class="keyword">new</span> EventHandler(HandleButtonClick);</span><br></pre></td></tr></table></figure><p><code>C# 2</code>通过方法组转换简化了委托实例的创建过程：<strong>只需要委托的签名与方法组中任何一个重载兼容，该方法组就可以隐式的转换为该委托类型</strong>。如下采用方法签名完全一致的委托举例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventHandler eventHandler = HandleButtonClick;</span><br></pre></td></tr></table></figure><p>事件的订阅和取消也可以采用同样的方式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.click += HandleButtonClick;</span><br></pre></td></tr></table></figure><p>简化版的代码和使用委托创建表达式代码最终会生成相同的中间代码，唯一区别是前者更加简洁。方法组转换简化了开发人员创建委托实例的工作，而对于匿名方法特性这方面表现更佳。</p><h1 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h1><p>这部分不会深入说明匿名方法，因为匿名方法的继承者<code>lambda</code>表达式才是主角。<code>lambda</code>表达式由 <code>C# 3</code>推出，如果<code>lambda</code>表达式先问世，则不会存在匿名函数。</p><p><strong>使用匿名方法，无须在创建委托实例前预先编写另一个实体方法，只需在委托中创建内联代码即可</strong>。大体过程是：使用<code>delegate</code>关键词，添加实参列表（可选），然后在大括号内编写需要的代码。</p><p>例如在事件触发时向控制台输出消息，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventHandler eventHandler = <span class="built_in">delegate</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，我们也可以传入相关参数，来打印<code>sender</code>和事件参数这些信息：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventHandler eventHandler = <span class="built_in">delegate</span>(<span class="built_in">object</span> sender,EventArgs args)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;sender = &#123;0&#125;,args=&#123;0&#125;&quot;</span>,sender.GetType(),args.GetType());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而匿名方法的正在威力，要等它用作<strong>闭包（closure）</strong>时才能发挥出来。<strong>闭包能够访问其声明作用域内的所有变量，即使当委托执行时这些变量已经不可访问</strong>。后面说明 <code>lambda</code>表达式的时候会对闭包做详细说明，此处只需要参考如下代码示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddClickLogger</span>(<span class="params">Control control,<span class="built_in">string</span> message</span>)</span>&#123;</span><br><span class="line">    control.click += <span class="built_in">delegate</span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Control Clicked:&#123;0&#125;&quot;</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>message</code>作为<code>AddClickLogger</code>方法的参数，是可以被匿名方法“捕获”的。<code>AddClickLogger</code>方法本身并不执行匿名方法，它只是将匿名方法添加到<code>Click</code>事件。当匿名方法真正开始执行时，<code>AddClickLogger</code>方法本身已经执行完成返回了。那么方法参数为何还可以访问呢？简而言之，是由编译器完成了枯燥的代码生成工作。</p><h1 id="委托的兼容性"><a href="#委托的兼容性" class="headerlink" title="委托的兼容性"></a>委托的兼容性</h1><p>在<code>C# 1</code>中创建委托实例时，创建实例的方法与委托的返回值类型和参数类型（包括<code>ref/out</code>修饰符）必须完全一致。假设有如下委托声明和方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Printer</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintAnything</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后创建一个<code>Printer</code>委托实例来把<code>PrintAnything</code>方法封装起来。看似没有声明问题，<code>Printer</code>传入的参数肯定是<code>string</code>引用，而<code>string</code>类型可以通过一致性转换变为<code>object</code>类型的引用，但是<code>C# 1</code>不允许这种方式，因为二者参数类型不匹配。到了<code>C# 2</code>，就可以在创建委托表达式和方法组中进行上述转换了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Printer p1 = <span class="keyword">new</span> Printer(PrintAnything);</span><br><span class="line">Printer p2 = PrintAnything;</span><br></pre></td></tr></table></figure><p>此外，还<strong>可以使用委托来创建另外一个委托，条件是两者前面要兼容</strong>。现在假设还有一个和<code>PrintAnything</code>兼容的委托，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">GeneralPrinter</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span>;</span><br></pre></td></tr></table></figure><p>之后可以使用<code>GeneralPrinter</code>实例来继续创建<code>Printer</code>委托的实例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GeneralPrinter generalPrinter = PrintAnything;</span><br><span class="line">Printer p1 = <span class="keyword">new</span> Printer(GeneralPrinter);</span><br></pre></td></tr></table></figure><p>编译器之所以允许以上写法，因为<code>Printer</code>的任何合法参数都可以安全的用作<code>GeneralPrinter</code>的实参，返回值也同理。</p><p>不过有时候上述规则并不能如我们所愿。<strong>参数或者返回值之间的兼容性必须满足一致性转换规则</strong>，这样才能保证执行期变量值不变，如下所示代码就不能通过编译：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Int32Printrt</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Int64Printrt</span>(<span class="params"><span class="built_in">long</span> x</span>)</span>;</span><br><span class="line"></span><br><span class="line">Int64Printrt int64Printrt = ....;<span class="comment">//完成方法委托</span></span><br><span class="line">Int32Printrt int32Printrt = <span class="keyword">new</span> Int32Printrt(int64Printrt);</span><br></pre></td></tr></table></figure><p>这是因为两个委托签名不兼容，尽管从<code>int</code>到<code>long</code>类型存在隐式类型转换，但是它没有满足一致性转换的要求。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>委托中封装的本质是创建了一个新的实例，而不是把已有委托看作不同类型的实例。</p><p>方法组转换如今广泛应用，兼容性特性已经融入日常编码；匿名方法的使用频率大幅度降低，因为<code>lambda</code>表达式几乎取代了匿名方法的所有功能。</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> CSharp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【CSharp高级编程】泛型</title>
      <link href="/2022/05/24/%E8%AF%AD%E8%A8%80%E6%A0%91/CSharp/%E3%80%90CSharp%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%91%E6%B3%9B%E5%9E%8B/"/>
      <url>/2022/05/24/%E8%AF%AD%E8%A8%80%E6%A0%91/CSharp/%E3%80%90CSharp%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%91%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我本来之前打算出一个<code>C#</code>入门到中级的相关文章教程的，但是考虑到太简单了我实在是懒得写了，可以参考很多网上的教程来学习，对于现在的我来说，我更加想记录一下<code>C#</code>的高级教程，因为对于<code>C#</code>的高级用法网上的教程并没有太多或者说太详细或者系统，也算是记录我自己的<code>C#</code>进阶路程。</p><p><strong>前排提醒：查看学习本文章，需要掌握一定的<code>C#</code>基础。</strong></p><blockquote><p>引用说明：部分内容学习自网络和《深入理解C#》</p></blockquote><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>在<code>C#</code>入门的时候，就大概说明过泛型的用法和功能，它可以在不需要事先知道要使用的类型，即可以在不同位置表示相同的类型。在<code>C# 2</code>之前（即<code>.NET 1</code>），泛型主要用于集合。如今，泛型以及广泛应用到各个部分，其中使用较多的如下几项：</p><ul><li><strong>集合</strong></li><li><strong>委托</strong>（尤其是<code>LINQ</code>中的应用）</li><li><strong>异步代码</strong>（<code>Task&lt;T&gt;</code>表示该方法将返回一个类型为<code>T</code>的值）</li><li><strong>可空值类型</strong></li></ul><p>如下实例将会从集合角度来展示泛型的优势。</p><h1 id="泛型诞生前的集合"><a href="#泛型诞生前的集合" class="headerlink" title="泛型诞生前的集合"></a>泛型诞生前的集合</h1><p>在<code>.NET 1</code>有如下三大类集合：</p><ul><li><p><strong>数组</strong>：语言和运行时直接支持数组。数组的大小在初始化的时候就确定了。</p></li><li><p><strong>普通对象集合</strong>：API中的值通过<code>System.Object</code>描述。尽管诸如索引器和和<code>foreach</code>语句这些语言特性可以应用在普通对象结合，但语言和运行时并未对其提供专门的支持。</p><p><code>ArrayList</code>和<code>Hashtable</code>是更常见的两种对象集合。</p></li><li><p><strong>专用类型集合</strong>：API中描述的值具有特定类型，集合只能用于该类型。例如：<code>StringCollection</code>是保存字符串的集合，虽然其 API 看起来和<code>ArrayList</code>类似，但是它只能接收<code>String</code>类型元素，而不能接收<code>Object</code>类型。</p></li></ul><p><strong>数组和专用类型集合都属于静态类型，因此 API 可以阻止讲错误类型的值添加到集合中。在集合中取值也无需手动转换类型</strong>。</p><p>现在假设有一个名为<code>GenerateName</code>，该方法用于创建一个<code>String</code>类型的集合，此外还有一个名为<code>PrintNames</code>的方法，它可以把该集合的所有元素显示出来。我们分别用上面所示的三种集合（数组，<code>ArrayList</code>以及<code>StringCollection</code>）来实现，然后对比三者的优劣。</p><h2 id="使用数组创建并打印"><a href="#使用数组创建并打印" class="headerlink" title="使用数组创建并打印"></a>使用数组创建并打印</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建数组</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">string</span>[] <span class="title">GenerateNames</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] names = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">4</span>];</span><br><span class="line">    names[<span class="number">0</span>] = <span class="string">&quot;Gamma&quot;</span>;</span><br><span class="line">    names[<span class="number">1</span>] = <span class="string">&quot;Vlissides&quot;</span>;</span><br><span class="line">    names[<span class="number">2</span>] = <span class="string">&quot;Johnson&quot;</span>;</span><br><span class="line">    names[<span class="number">3</span>] = <span class="string">&quot;Helm&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> names;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出数组</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNames</span>(<span class="params"><span class="built_in">string</span>[] names</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="built_in">string</span> name <span class="keyword">in</span> names)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中，<strong>并没有特意使用数组初始化器来创建数组，而是模拟了逐个获取<code>names</code>元素的场景</strong>，例如读取文件内容。另外，在创建数组的时候<strong>应当为其创建合适的大小</strong>。读文件这种情况就需要事先知道文件中有多少个名字，才能在创建数组的时候为他分配大小。或者采用更复杂的，先创建一个数组，如果初始数组被填满，则创建一个更大的数组，如此反复，直到所有元素添加完毕。当然最后如果数组依然有空间，可以再创建一个合适的数组来讲元素复制过去。</p><p><strong>诸如追踪当前集合大小，重新分配数组等重复性操作，都可以用一个类型封装起来，使用<code>ArrayList</code>即可实现</strong>。</p><h2 id="使用-ArrayList-创建并打印"><a href="#使用-ArrayList-创建并打印" class="headerlink" title="使用 ArrayList 创建并打印"></a>使用 ArrayList 创建并打印</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ArrayList对象</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ArrayList <span class="title">GenerateNames</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ArrayList names = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    names.Add(<span class="string">&quot;Gamma&quot;</span>);</span><br><span class="line">    names.Add(<span class="string">&quot;Vlissides&quot;</span>);</span><br><span class="line">    names.Add(<span class="string">&quot;Johnson&quot;</span>);</span><br><span class="line">    names.Add(<span class="string">&quot;Helm&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> names;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出对象内容</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNames</span>(<span class="params">ArrayList names</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="built_in">string</span> name <span class="keyword">in</span> names)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建<code>ArrayList</code>时，<strong>无须事先知道<code>names</code>的个数</strong>，因此<code>GenerateNames()</code>方法得以简化。不过，和数组一样存在一个相同的问题：<strong>使用<code>ArrayList</code>依旧无法确保非<code>String</code>类型的值被添加进来</strong>，<strong>因为<code>ArrayList.Add</code>方法的参数类型是<code>Object</code>。</strong></p><p>此外，<code>PrintNames</code>方法看似是类型安全的，但是如果该<code>ArrayList</code>中包含一个<code>WebReaquest</code>类型的值，由于<code>name</code>变量声明为<code>string</code>类型，因此<code>foreach</code>循环每次都会对集合中的元素做隐式类型转换，把<code>object</code>转换为<code>string</code>类型。最终，从<code>WebRequest</code>到<code>string</code>类型的转换抛出<code>InvalidCastException</code>。</p><p>虽然使用<code>ArrayList</code>解决了数组大小的问题，但是缺引出了类型安全的问题，有什么办法可以二者兼顾？</p><h2 id="使用-StringCollection-创建并打印"><a href="#使用-StringCollection-创建并打印" class="headerlink" title="使用 StringCollection 创建并打印"></a>使用 StringCollection 创建并打印</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ArrayList对象</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> StringCollection <span class="title">GenerateNames</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    StringCollection names = <span class="keyword">new</span> StringCollection();</span><br><span class="line">    names.Add(<span class="string">&quot;Gamma&quot;</span>);</span><br><span class="line">    names.Add(<span class="string">&quot;Vlissides&quot;</span>);</span><br><span class="line">    names.Add(<span class="string">&quot;Johnson&quot;</span>);</span><br><span class="line">    names.Add(<span class="string">&quot;Helm&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> names;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出对象内容</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNames</span>(<span class="params">StringCollection names</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> names)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：需要引用<code>using System.Collections.Specialized</code>命名空间</p></blockquote><p>除了把<code>ArrayList</code>都替换成了<code>StringCollection</code>之外，其他都和<code>ArrayList</code>的代码一致。但是使用了<code>StringCollection</code>这样与其他通用类型集合无区别，只是其只负责处理<code>String</code>类型的元素。**<code>StringCollection.Add</code>方法参数类型是<code>String</code>**，因此不能向其添加非<code>String</code>类型的元素，这样就保证了在显示<code>names</code>的时候不会出现非<code>String</code>类型的错误了。</p><p>如果只是在处理<code>String</code>类型的情况下，<code>StringCollection</code>确实是不二之选。<strong>但是如果使用的是其他的类型集合，要么就需要寄希望于<code>.NET Framework</code>已经提供了所需的集合类型，要么就需要自己写一个了</strong>。但是由于类型的需求非常普遍，<strong>因此就有了<code>System.Collections.CollectionBase</code>这个抽象类，用于减少上述工作量</strong>。</p><p>使用专用类型集合可以解决前面提到的两个问题（数组大小和类型安全），但是创建更多的额外类型，代价实在太高了。另外，编译实际，程序集大小，JIT 耗时，代码段内存都会产生额外的内存消耗，最关键的是维护这些集合需要额外的人力成本。</p><p>即使忽略上述成本，也没办法避免代码灵活性的降低：<strong>无法以静态方式编写适用于所有集合类型的通用方法，也无法把集合元素的类型用于参数或者返回值类型</strong>。假设需要创建一个方法，该方法把一个集合的前 N 项元素复制到另一个新的集合中，之后返回该集合。如果使用<code>ArrayList</code>，那就等同于舍弃了静态类型的优势。如果传入<code>StringCollection</code>，那么返回值类型也必须是<code>StringCollection</code>。<code>String</code>类型成了方法输入的要素，于是返回值也必须是<code>String</code>类型。**<code>C# 1</code>对这个问题束手无策，于是泛型登场了。**</p><h1 id="泛型诞生"><a href="#泛型诞生" class="headerlink" title="泛型诞生"></a>泛型诞生</h1><p>解决上述问题的办法就是<strong>泛型<code>List&lt;T&gt;</code><strong>。</strong><code>List&lt;T&gt;</code>是一个集合，其中 T 表示集合元素的类型</strong>，在如上的例子中，<code>string</code>就是这个 T ，因此<code>List&lt;string&gt;</code>就可以替换所有<code>StringCollection</code>。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ArrayList对象</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">GenerateNames</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; names = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    names.Add(<span class="string">&quot;Gamma&quot;</span>);</span><br><span class="line">    names.Add(<span class="string">&quot;Vlissides&quot;</span>);</span><br><span class="line">    names.Add(<span class="string">&quot;Johnson&quot;</span>);</span><br><span class="line">    names.Add(<span class="string">&quot;Helm&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> names;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出对象内容</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNames</span>(<span class="params">List&lt;<span class="built_in">string</span>&gt; names</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> names)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>List&lt;T&gt;</code>解决了前面说到的所有问题：</p><ul><li>与数组不同，**<code>List&lt;T&gt;</code>无须在创建前获取集合的大小**</li><li>与<code>ArrayList</code>不同，在对外提供的 API 之中，<strong>一切表示元素类型都可以用 T 来表示</strong>。这样我们就能知道<code>List&lt;string&gt;</code>的集合只能包含 <code>string</code>类型的引用。如果添加了错误的类型，则编译时会报错。</li><li>与<code>StringCollection</code>等类型不同，**<code>List&lt;T&gt;</code>兼容所有类型**，省去了诸多烦恼。</li></ul><h2 id="类型形参与类型实参"><a href="#类型形参与类型实参" class="headerlink" title="类型形参与类型实参"></a>类型形参与类型实参</h2><p><strong>形参（parameter）和实参（argument）</strong>的概念，比<code>C#</code>泛型概念出现的还要早。</p><p>声明函数时<strong>用于描述函数输入数据的参数</strong>称为形参，函数调用时<strong>实际传递给函数的参数</strong>称为实参。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb593f16dc.png" alt="image-20220622194416632" style="zoom:80%;" /><p>实参的值相当于方法形参的初始值，而泛型涉及两个参数概念：<strong>类型参数（type parameter）和类型实参（type argument）</strong>，相当于把普通形参和实参的思想用在了表示类型信息上。<strong>在声明泛型类或者泛型方法时，需要把类型形参写在类名或者方法名称之后，并用尖括号<code>&lt;&gt;</code>包围。</strong>之后在声明体中，就可以像普通类型一样使用该类型形参了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型形参</span></span><br><span class="line">List&lt;T&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//类型实参</span></span><br><span class="line">List&lt;<span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure><p>当使用如上<code>List&lt;string&gt;</code>时，如果使用其的<code>Add()</code>方法，其函数原型如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T item</span>)</span>;</span><br></pre></td></tr></table></figure><p>在 Visual Studio 中输入<code>List.Add()</code>方法，智能补全会提示我们应该是<code>string</code>类型，当传入不合法类型时，会引发编译错误。</p><p><strong>泛型也可以用于方法，在方法声明中给出类型形参，之后就可以在方法中使用这些类型参数了。</strong></p><p>如下解决了之前的一个问题，以静态类型的方式把一个集合的前 N 个元素复制到另一个新的集合中。</p><blockquote><p>静态类型如果传入错误的类型编译报错，且不需要进行类型转换</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CopyArray</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//复制并返回数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">CopyArrayNum</span>&lt;<span class="title">T</span>&gt;(<span class="params">List&lt;T&gt; list, <span class="built_in">int</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;T&gt; newList = <span class="keyword">new</span> List&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            newList.Add(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出数组值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintArrayNum</span>&lt;<span class="title">T</span>&gt;(<span class="params">List&lt;T&gt; list</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(T <span class="keyword">value</span> <span class="keyword">in</span> list)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//主程序口</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; list1 = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;() &#123; <span class="string">&quot;你好&quot;</span>, <span class="string">&quot;世界&quot;</span>, <span class="string">&quot;!!!&quot;</span> &#125;;</span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; list2 = CopyArray.CopyArrayNum(list1, <span class="number">2</span>);</span><br><span class="line">    CopyArray.PrintArrayNum&lt;<span class="built_in">string</span>&gt;(list2);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">    CopyArray.PrintArrayNum&lt;<span class="built_in">string</span>&gt;(list1);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb5995f2f1.png" alt="image-20220622203934611"  /><p>同样的，当声明有基类或者接口时，泛型形参也可以作为基类或者接口的泛型实参，比如下的泛型类和泛型接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Generics</span>&lt;<span class="title">T</span>&gt;:<span class="title">IEnumerable</span>&lt;<span class="title">T</span>&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实际上要实现泛型接口，需要实现其成员，不是如上面这么简化</p></blockquote><h2 id="泛型类型和泛型方法的度"><a href="#泛型类型和泛型方法的度" class="headerlink" title="泛型类型和泛型方法的度"></a>泛型类型和泛型方法的度</h2><p>泛型类型或者泛型方法<strong>可以声明多个类型形参</strong>，<strong>只需要在尖括号内用逗号把它们隔开</strong>即可，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型度（arity）是泛型声明中类型形参的数量</strong>。我们可以将非泛型的度理解为零。</p><p>泛型度是区分同名泛型声明的有效指标。比如前面提到的<code>C# 2</code>中的泛型接口<code>IEnumerable&lt;T&gt;</code>，它和<code>.NET 1.0</code>中非泛型接口<code>IEnumerable</code>就不属于同一类型。同样的，可以根据不同度来编写同名重载方法，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span>()</span> &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span>&lt;<span class="title">T</span>&gt;()</span> &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt;()</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>泛型方法重载的定义区分是根据泛型的度，而不是泛型的名称</strong>，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这么写编译器会报错的</span></span><br><span class="line"><span class="comment">//因为同一方法重载前提是两者的度不一样，和泛型类型形参的名称无关</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span>&lt;<span class="title">T1</span>&gt;()</span> &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span>&lt;<span class="title">T2</span>&gt;()</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>另外，泛型的形参也是不可以相同的，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个形参相同，编译器依旧会报错</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt;()</span> &#123; &#125;</span><br></pre></td></tr></table></figure><h1 id="泛型的适用范围"><a href="#泛型的适用范围" class="headerlink" title="泛型的适用范围"></a>泛型的适用范围</h1><p>并非所有类型或者类型成员适合用泛型。对于类型，很好区分，因为可供声明的类型比较有限；<strong>对于枚举类型不能声明泛型，而类，结构体，接口以及委托这些可以声明为泛型类型</strong>。</p><p><strong>判断一个声明是否是泛型声明的唯一标准，是看它是否引入了新的类型形参</strong>。</p><p>方法和类型可以是泛型，当时以下类型成员不能是泛型：</p><ul><li><strong>字段</strong></li><li><strong>属性</strong></li><li><strong>索引器</strong></li><li><strong>构造器</strong></li><li><strong>事件</strong></li><li><strong>终结器</strong></li></ul><p>下面举一个貌似是泛型但是实际不是的例如，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">TItem</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;TItem&gt; items = <span class="keyword">new</span> List&lt;TItem&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>items</code>是类型为<code>List&lt;TItem&gt;</code>的一个字段，它将<code>TItem</code>作为<code>List&lt;T&gt;</code>的类型实参。<code>TItem</code>是由<code>Test</code>类声明引入的类型形参，而不是由<code>items</code>声明本身引入的。</p><h1 id="方法类型实参的类型推断"><a href="#方法类型实参的类型推断" class="headerlink" title="方法类型实参的类型推断"></a>方法类型实参的类型推断</h1><p>对于如上类型形参和实参中的代码举例，摘出如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复制并返回数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">CopyArrayNum</span>&lt;<span class="title">T</span>&gt;(<span class="params">List&lt;T&gt; list, <span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;T&gt; newList = <span class="keyword">new</span> List&lt;T&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        newList.Add(list[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出数组值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintArrayNum</span>&lt;<span class="title">T</span>&gt;(<span class="params">List&lt;T&gt; list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span>(T <span class="keyword">value</span> <span class="keyword">in</span> list)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其泛型方法声明原型如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">CopyArrayNum</span>&lt;<span class="title">T</span>&gt;(<span class="params">List&lt;T&gt; list, <span class="built_in">int</span> num</span>)</span></span><br></pre></td></tr></table></figure><p>现在，我们在<code>main</code>方法中声明一个<code>List&lt;int&gt;</code>类型的变量<code>numbers</code>，并将该变量作为如上泛型方法<code>CopyArratNum()</code>的调用实参（参数）传入，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">CopyArray.CopyArrayNum&lt;<span class="built_in">int</span>&gt;(numbers, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>如上代码其实可以省略为如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">CopyArray.CopyArrayNum(numbers, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>从编译器之后生成的 IL 代码的角度来说，这两种写法是完全相同的。这里并不需要明确指出给定的泛型实参<code>int</code>，因为编译器可以根据传入的参数来判断泛型类型</strong>。</p><p><strong>编译器只能推断出传递给方法的类型实参，但是推断不出返回值的类型实参。</strong>对于返回值的类型实参，要么显式的表示出来，要么全部省略掉。</p><p>尽管类型判断只能用于方法，但是它可以简化泛型类型实例的创建，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Tuple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Tuple</span>&lt;<span class="title">T1</span>&gt; <span class="title">Create</span>&lt;<span class="title">T1</span>&gt;(<span class="params">T1 item1</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple&lt;T1&gt;(item1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Tuple</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt; <span class="title">Create</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt;(<span class="params">T1 item1,T2 item2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple&lt;T1,T2&gt;(item1,item2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上写法看似没有什么意义。前面说过，泛型类型推断并不适用于构造器，<strong>这么做旨在将对象构造的同时利用方法的类型推断</strong>。如果直接使用对象构造器实现会比较麻烦，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Tuple&lt;<span class="built_in">int</span>,<span class="built_in">string</span>,<span class="built_in">int</span>&gt;(<span class="number">10</span>,<span class="string">&quot;x&quot;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>但是如果使用上述静态方法配合类型推断，代码就会简单很多，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tuple.Create(<span class="number">10</span>,<span class="string">&quot;x&quot;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>使用这个技巧可以简化部分代码。</p><p>通常来说，使用泛型会遇到如下三种情况：</p><ul><li>类型推断成功，并且取得预期成果</li><li>类型推断成功，但是没有取得预期成果。此时，<strong>只需要显式指定类型实参或者对某些实参转换类型即可</strong>。例如上面的<code>Tuple.Create</code>方法，如果目标结果是<code>Tuple&lt;int,object,int&gt;</code>类型的元组，则显示的指定类型实参：<code>Tuple.Create&lt;int,object,int&gt;(10,&quot;x&quot;,20);</code>或者直接使用构造器<code>new Tuple&lt;int,object,int&gt;(...);</code>或者调用<code>Tuple.Create(10,(object)&quot;x&quot;,20);</code>。</li><li>类型推断在编译时出错。有时候只需要转换参数类型就能解决。例如调用<code>Tuple.Create(null,50)</code>就会出错，<strong>因为<code>null</code>本身不包含任何类型的信息</strong>，改写成<code>Tuple.Create((string)null,50)</code>即可。</li></ul><h1 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h1><p>前面提到的类型参数都是没有经过约束的，它们可以表示任意类型。有的时候我们需要对于某个类型参数需要它只限于特定的类型，这就引出了类型约束的概念。</p><p><strong>在泛型类型或者泛型方法中什么类型形参时，可以使用类型约束来限定哪些类型可以作为类型实参</strong>。</p><p>假设我们需要一个方法来实现某个功能，该方法存在于<code>IObject</code>接口里，我们传入参数使用，现在如果我们定义需要传入特定类型的参数如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutPut</span>(<span class="params">List&lt;Cube&gt; items</span>)</span>;</span><br></pre></td></tr></table></figure><p>这样如果有一个<code>Sphere</code>类型也继承自<code>IObject</code>接口，但是没有办法传入参数，编译器会报错，但是我们如果使用<code>List&lt;T&gt;</code>类型则没有办法约束传入的参数是否适合我们的这个方法，这个时候我们就需要使用类型约束就可以将传入的类型实参，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">staic <span class="keyword">void</span> <span class="title">OutPut</span>&lt;<span class="title">T</span>&gt;(<span class="params">List&lt;T&gt; items</span>) <span class="keyword">where</span> T : IObject</span></span><br></pre></td></tr></table></figure><p>这样就约束了需要传入的类型实参必须是实现继承了<code>IObject</code>接口的对象。</p><p>类型约束不仅仅适用于接口，还可以约束如下类型：</p><ul><li><p><strong>引用类型约束（<code>where T : class</code>）：类型实参必须是一个引用类型</strong>。</p><blockquote><p><code>class</code>关键词容易引起误解，它表示任何引用类型，包括接口和委托。</p></blockquote></li><li><p><strong>值类型约束（<code>where T : struct</code>）：类型实参必须是非可空值类型</strong>（结构体类型或者枚举类型）。</p></li><li><p><strong>构造器约束（<code>where T : new()</code>）：类型实参必须是公共的无参构造器。</strong>该约束保证了可以通过<code>new T()</code>来创建一个<code>T</code>类型的实例。</p></li><li><p><strong>转换约束（<code>where T : SomeType</code>）：这里的<code>SomeType</code>可以是类，接口或者其他类型形参</strong>，如上我所使用的<code>IObjecy</code></p></li></ul><p>类型约束可以组合使用，一般组合规则比较复杂，例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt;()</span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> T1 : IObejct,<span class="keyword">class</span></span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> T2 : <span class="keyword">new</span>(),<span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><h1 id="泛型类型初始化与状态"><a href="#泛型类型初始化与状态" class="headerlink" title="泛型类型初始化与状态"></a>泛型类型初始化与状态</h1><p>前面说到类型约束的时候，提到过：<em>这样如果有一个<code>Sphere</code>类型也继承自<code>IObject</code>接口，但是没有办法传入参数，编译器会报错</em>，因为每个不同泛型类型的对象都会被当作不同类型处理，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Tests</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Plus</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintNum</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数入口</span></span><br><span class="line">Tests&lt;<span class="built_in">int</span>&gt; tests1 = <span class="keyword">new</span> Tests&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">Tests&lt;<span class="built_in">string</span>&gt; tests2 = <span class="keyword">new</span> Tests&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">tests1.Plus();</span><br><span class="line">tests1.Plus();</span><br><span class="line">tests1.PrintNum();</span><br><span class="line">tests2.Plus();</span><br><span class="line">tests2.PrintNum();</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb5a17d351.png" alt="image-20220624234549579" style="zoom:80%;" /><p>你会发现对于这两个类，系统将其各自的静态字段<code>num</code>执行了不同次数的加法，说明<code>Tests&lt;int&gt;</code>和<code>Tests&lt;string&gt;</code>本质上是两个类型。</p><p>这个问题还可以进一步复杂化，将泛型进行嵌套，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">B</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于上述嵌套，如果使用<code>int</code>和<code>string</code>两个作为类型实参，如下的每种组合得到的都是一个独立的对象。</p><ul><li><code>A&lt;int&gt;.B&lt;int&gt;</code></li><li><code>A&lt;string&gt;.B&lt;int&gt;</code></li><li><code>A&lt;int&gt;.B&lt;string&gt;</code></li><li><code>A&lt;string&gt;.B&lt;string&gt;</code></li></ul><p>上述情况基本见不到，但是此处仅作说明表示这在编译器中都是独立的对象。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>如上就是泛型的全部内容了，我跳过了<code>default</code>和<code>typeof</code>关键词的说明，我打算把它们单独写一起会更加的条理化一些。**泛型的出现也引出了可空值类型，即<code>null</code>**，说实话我不太想去写关于<code>null</code>即可空值类型的相关部分的，对于这个来说，我更加像写一写关于<code>C#</code>多线程的说明。</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> CSharp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于我的Unity自述</title>
      <link href="/2022/05/23/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/MySelf/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Unity%E8%87%AA%E8%BF%B0/"/>
      <url>/2022/05/23/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/MySelf/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Unity%E8%87%AA%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>依次纪念我大学追求游戏开发的自己</strong>，我记得大概是20年10月份吧或者11月份，我正式开始了Unity的学习，我的游戏开发结束于21年暑假结束，在大三上，在我掌握并开发了一定的Unity游戏开发后，去学习了桌面软件开发，并且掌握了Winform和WPF开发技术，其中还有许多其他方面的东西。</p><h1 id="关于我如何自学的自述"><a href="#关于我如何自学的自述" class="headerlink" title="关于我如何自学的自述"></a>关于我如何自学的自述</h1><p>当然这一切都归功于Unity在学习游戏开发的过程中，我接触到了很多其他的东西，我看过很多教程，目前总结出来的自学流程：对于想要的学习的东西通过网络上查询了解概况，逞钱的伙伴可以直接买相关书籍，或者为了省钱的可以去学校图书馆借书，我很喜欢我们学校的图书馆，我曾经最多借书超过20本未还，当然借书多不代表能看得完，有些是需要长期来学习的，有些是短期来学习的，书籍是真的很好的东西，其次是教学视频，很多情况下我目前个人建议是不要过分依赖视频，视频教学可以让我们快速上手，但是对于教学内容来说全看视频制作者想讲什么或者视频制作者的见识，存在一定的局限性，综述来说：书籍 &gt; 网络上的教学视频，然后就是跟着做，在学的时候要记笔记，我从一开始使用微软的<code>OneNote</code>笔记到后来的<code>Markdown</code>语法笔记，例如：<code>Vnote</code>，<code>VsCode</code>再到现在的<code>Typora</code>。</p><p>如下是我笔记相关截图</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aafa707d602.png" alt="image-20220206153904331" style="zoom:67%;" /><p>在学习完成相关书籍和教程后，认为自己可以了，就做一个相关的作品出来，如果相关的作品可以做出来就说明基本入门了，可以继续深入了，证明了你已经学会了基本的操作。对我而言这种方法是很不错的，因人而异吧。</p><p>如下是我学习Unity的时候笔记截图</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aafa74c8277.png" alt="image-20220206154152195" style="zoom:67%;" /><p><strong>现在我个人的学习习惯就是：看书 +记笔记 + 教学视频 + 各种查询 和 问问题，最后做出一个相关的作品</strong>。</p><h1 id="关于我开发过的游戏"><a href="#关于我开发过的游戏" class="headerlink" title="关于我开发过的游戏"></a>关于我开发过的游戏</h1><p>我曾经尝试开发过许多东西，大多数开发一半就弃坑了，或者其他原因，还有一些小东西忘记了。</p><h2 id="第一个游戏Demo"><a href="#第一个游戏Demo" class="headerlink" title="第一个游戏Demo"></a>第一个游戏Demo</h2><p>我记得我第一个开发的游戏Demo是一个简单小球吃食物的Deno，相关文章后面会更新，可以自行查看，这个已经没有留存相关文件和视频了，暂时跳过了。</p><blockquote><p>此处，欠第一个开发的游戏Demo</p></blockquote><h2 id="合成大西瓜Demo"><a href="#合成大西瓜Demo" class="headerlink" title="合成大西瓜Demo"></a>合成大西瓜Demo</h2><p>后面是一个合成大西瓜的游戏，那个时候我记得刚刚流行这个游戏，我就用Unity复刻了一下，如下是我唯一一个留存的视频，当时是出现了一个BUG记录了下来：</p><p><video controls="controls" src="https://mos.helloseraphine.top:9100/blog/Video/关于我的Unity自述/合成大西瓜.mp4" controls="controls" width="100%"></video></p><h2 id="3D跑酷游戏Demo"><a href="#3D跑酷游戏Demo" class="headerlink" title="3D跑酷游戏Demo"></a>3D跑酷游戏Demo</h2><p>后面做了一个跑酷游戏Demo，相关留存视频如下：</p><p><video controls="controls" src="https://mos.helloseraphine.top:9100/blog/Video/关于我的Unity自述/跑酷游戏.mp4" width="100%"></video></p><h2 id="2D横版像素闯关游戏Demo"><a href="#2D横版像素闯关游戏Demo" class="headerlink" title="2D横版像素闯关游戏Demo"></a>2D横版像素闯关游戏Demo</h2><p>再后面是一个2D像素闯关的游戏Demo，类似于小时候4399那种游戏，当时的游戏背景很简单，公主被恶龙抓走了，勇者一路经过种种磨难，拯救公主的游戏闯关游戏，这个游戏我留存了部分源代码素材和相关的开发视频：</p><p>这一个视频是我开发刚刚实现UI界面和游戏人物相关控制的视频：</p><p><video controls="controls" src="https://mos.helloseraphine.top:9100/blog/Video/关于我的Unity自述/2D闯关_1.mp4" width="100%"></video></p><p>这个是新增了部分动画，游戏向导以及部分优化的视频：</p><p><video controls="controls" src="https://mos.helloseraphine.top:9100/blog/Video/关于我的Unity自述/2D闯关_2.mp4" width="100%"></video></p><p>这是加入了镜头跟随，界面UI，相关交过和关卡交互的基本雏形视频：</p><p><video controls="controls" src="https://mos.helloseraphine.top:9100/blog/Video/关于我的Unity自述/2D闯关_3.mp4" width="100%"></video></p><p>这是UI优化，不过这个没改动很多，我当时想的是做6个关卡：</p><p><video controls="controls" src="https://mos.helloseraphine.top:9100/blog/Video/关于我的Unity自述/2D闯关_4.mp4" width="100%"></video></p><p>这是新增角色攻击，拾取物品，跳跃，走路的动画：</p><p><video controls="controls" src="https://mos.helloseraphine.top:9100/blog/Video/关于我的Unity自述/2D闯关_5.mp4" width="100%"></video></p><p>这是新增地图，相关交互和部分优化的视频，也是这个视频我发现我没有办法做完了，就把关卡砍到了4关：</p><p><video controls="controls" src="https://mos.helloseraphine.top:9100/blog/Video/关于我的Unity自述/2D闯关_6.mp4" width="100%"></video></p><p>这是最后一个，增加了怪物，角色和怪物交互，到这个地方游戏的大概雏形了完成了后面就是拓展和优化了，一开始我是很想完成它的，然后投到4399上面去，后面我不记得怎么就弃坑了。</p><p><video controls="controls" src="https://mos.helloseraphine.top:9100/blog/Video/关于我的Unity自述/2D闯关_7.mp4" width="100%"></video></p><h1 id="关于我对游戏开发的感悟"><a href="#关于我对游戏开发的感悟" class="headerlink" title="关于我对游戏开发的感悟"></a>关于我对游戏开发的感悟</h1><p>随着我对游戏开发的学习，这是一些游戏开发的基本要素可以点击我之前写的这个：<a href="httpss://helloseraphine.top/index.php/archives/59.html">浅谈游戏开发</a></p><p>游戏和普通的软件不太一样，它对于美工的要求很高，游戏背后的逻辑需要程序来支撑，而游戏的直观好坏美工有很大一部分，游戏开发的难度和广度都很大，它不仅仅是UI界面交互，背后是程序和数学，表面是美工和渲染，游戏开发对数学的要求比较高，就单单《元神》的二次元渲染线管就是国内顶尖的TA了，美工也分为技术美工和普通美工，一般的美工是画图建模之类的，技术美工是要考虑如何将一个效果来通过数学和程序来呈现出来，举一个简单的例子，人物边缘高亮，怎么来实现？需要技术美工提供算法来实现，而人物需要程序来驱动，人物的外表需要一般的美工来建模，游戏引擎负责统筹和输出。</p><p>如果真的对游戏开发很感兴趣，想做程序的话，推荐一本书：<strong>《3D数学基础：图形与游戏开发》</strong>，书的封面是这个样子：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aafa7e136e8.png" alt="image-20220206162730036" style="zoom:80%;" /><h1 id="关于新人避坑"><a href="#关于新人避坑" class="headerlink" title="关于新人避坑"></a>关于新人避坑</h1><p>现在市面上的教程很多是坑人的，我的建议是书籍相对较好，当时也得看是什么人写的，说的难听一些，我曾经看到一本教程的书籍，就是把官方网站的教程，一模一样大致弄了下来，真的很没有意义，书籍传授的不仅仅是知识还有经验，他在写书的时候没有把自己的经验写进去怎么可能是一个认真的开发者？</p><h1 id="最后感谢一群小伙伴"><a href="#最后感谢一群小伙伴" class="headerlink" title="最后感谢一群小伙伴"></a>最后感谢一群小伙伴</h1><p>处于隐私问题，我只展示他们的相关网络昵称和头像</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aafa82caf7b.png" alt="image-20220206163233496" style="zoom:77%;" /><p>我们并创造什么，是我的个人能力过于有限没有办法来和他们一起去调动创造一个游戏，他们也是没有开发游戏基础，以某种情况聚集到了一起，起码我们聊过游戏，想过游戏，感谢他们每一个人。</p><blockquote><p>其中一位人员的个人博客<a href="https://papercut.top/">Papercut的博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
          <category> MySelf </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LaTex基础（上）</title>
      <link href="/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/LaTex%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/LaTex%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>从MS Office 到 Markdown 再到 LaTex，每个不同的编辑软件都对不同的文本排列提供了一种解决方案</strong>，可以根据自己的实际需求来合理使用，我尝试记录最基本且简单的语法来说明<code>LaTex</code>的使用语法。</p><p><strong>我使用的 <code>LaTex</code> 编辑器为 <code>TexStudio</code>，<code>Tex</code>的宏包直接安装的 <code>Tex Live</code>。</strong></p><blockquote><p><strong>本文内容是我个人学习自 《简单高效LaTex》以及百度和Bilibili相关网站的学习内容整理笔记</strong></p></blockquote><h1 id="认识LaTex"><a href="#认识LaTex" class="headerlink" title="认识LaTex"></a>认识<code>LaTex</code></h1><blockquote><p>前排提醒：<code>LaTex</code>对大小写敏感，即区分大小写</p></blockquote><h2 id="命令与环境"><a href="#命令与环境" class="headerlink" title="命令与环境"></a>命令与环境</h2><p><strong><code>LaTex</code>中的命令通常是由一个反斜杠加上命令名称，再加上花括号内的参数构成</strong>，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;ctexart&#125;</span><br></pre></td></tr></table></figure><p><strong>如果一些选项是有其他可以缺省的参数，一般在花括号前使用<code>[]</code>来指定</strong>，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8](ctexart)</span><br></pre></td></tr></table></figure><p><strong>关于<code>LaTex</code>的正文部分，写在一个称为环境的部分</strong>，其格式类似于<code>HTML</code>的<code>body</code>，<strong>需要将内容写在其间</strong>，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;environment&#125;</span><br><span class="line">这里是你的内容</span><br><span class="line"><span class="keyword">\end</span>&#123;environment&#125;</span><br></pre></td></tr></table></figure><h2 id="保留字符"><a href="#保留字符" class="headerlink" title="保留字符"></a>保留字符</h2><p><strong>在<code>LaTex</code>中，有一部分字符被用来作为命令字符，这些字符被称为<code>LaTex</code>的保留字符</strong>，例如下表</p><table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td><code>#</code></td><td>自定义命令时，用于标明参数序号</td></tr><tr><td><code>$</code></td><td>用于编写数学公式标识符</td></tr><tr><td><code>%</code></td><td>注释符，可以通过在行末添加该注释符，来注释掉后面的空白符</td></tr><tr><td><code>^</code></td><td>数学公式中的上标符</td></tr><tr><td><code>_</code></td><td>数学公司中的下标符</td></tr><tr><td><code>&amp;</code></td><td>表格中的跳列符</td></tr><tr><td><code>&#123;&#125;</code></td><td>在一些命令中填写参数的标识</td></tr><tr><td><code>\</code></td><td>标识<code>LaTex</code>命令的标识符</td></tr></tbody></table><p>上述字符，<strong>如果在文中需要使用上述保留字符的话（除<code>\</code>反斜杠）需要在前面加上<code>\</code>，即反斜杠来标识，这样就能够使用该字符</strong>，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%表示要使用 # 符号</span></span><br><span class="line"><span class="keyword">\#</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%表示要使用 &amp; 符号</span></span><br><span class="line"><span class="keyword">\&amp;</span></span><br></pre></td></tr></table></figure><p>如果想要使用 <code>\</code>（反斜杠）的话，需要使用如下示例命令：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%表示使用 \ 符号</span></span><br><span class="line"><span class="keyword">\texttt</span>&#123;<span class="keyword">\char</span>92&#125;</span><br></pre></td></tr></table></figure><p><code>\texttt</code>是使用 <code>tt</code> 字体环境，用于输出ASCII码对应的字符，<code>\char92</code>指定的是反斜杠字符，同样的可以使用：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\char</span>`<span class="keyword">\\</span></span><br></pre></td></tr></table></figure><p>来输出<code>\</code>反斜杠。</p><h2 id="导言区"><a href="#导言区" class="headerlink" title="导言区"></a>导言区</h2><p>对于任何一份<code>LaTex</code>文档都应该含有如下结构：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[options]&#123;doc-class&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;environment&#125;</span><br><span class="line">你的内容部分</span><br><span class="line"><span class="keyword">\end</span>&#123;environment&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong>在<code>\begin&#123;environment&#125;</code>之前的内容被称为导言区。导言区用来对文档进行一些设定，可以通俗理解为调控文档模板的地方</strong>。关于上述<code>options</code>和<code>doc-class</code>的参数如下表：</p><table><thead><tr><th>doc-class参数</th><th>说明</th></tr></thead><tbody><tr><td><code>article</code></td><td>科学期刊，演示文档，短报告，邀请函等</td></tr><tr><td><code>proc</code></td><td>基于<code>article</code>的会议论文集</td></tr><tr><td><code>report</code></td><td>多章节的长报告，博士论文，短篇书</td></tr><tr><td><code>book</code></td><td>书籍</td></tr><tr><td><code>slides</code>或<code>beamer</code></td><td>幻灯片</td></tr></tbody></table><p><strong>一般来说，对于纯英文的文档，推荐直接使用<code>article</code>，如果是含有中文的文档，则使用<code>ctexart</code>，并且要在前面的缺省参数标明指定的中文编码，例如<code>UTF-8</code>，</strong>命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br></pre></td></tr></table></figure><blockquote><p>文中所有命令都是在，<code>ctexart</code>格式下进行的，即上述命令示例</p></blockquote><table><thead><tr><th>options参数</th><th>说明</th></tr></thead><tbody><tr><td>默认<code>10pt</code>，可选则<code>11pt</code>和<code>12pt</code></td><td>字体大小</td></tr><tr><td>默认<code>portrait</code>（纵向），<code>landscape</code>（横向）</td><td>页面方向</td></tr><tr><td>默认<code>letterpaper</code>，可选<code>a4paper</code>，<code>b5paper</code>等</td><td>纸张大小</td></tr><tr><td>默认<code>onecolumn</code>（单栏），可选<code>twocolumn</code>（两栏）</td><td>分栏</td></tr><tr><td><code>article</code>和<code>report</code>默认单面，可选<code>oneside</code>和<code>twoside</code></td><td>双面打印</td></tr><tr><td>默认任意页，可选<code>openright</code>和<code>openany</code>，决定在奇数页或者任意页开启新页。<br />需要注意的是，<code>article</code>是没有<code>chapter</code>(章)命令的。</td><td>章节分页</td></tr><tr><td>默认居中，可选<code>fleqn</code>（左对齐）<br />默认编号居右，可选<code>leqno</code>（左对齐）</td><td>公式对齐</td></tr><tr><td>默认<code>final</code>，可选<code>draft</code>（使行溢出部分显示为黑块）</td><td>草稿选项</td></tr></tbody></table><p>**在导言区最常见的是宏包的加载工作，命令形如<code>\usepackage&#123;package&#125;</code>**。关于什么是宏包，通俗来说就是提前封装好的一些功能格式，对于一些非原生<code>LaTex</code>的功能格式，可以通过借用第三方宏包的方式来使用，提高效率。</p><blockquote><p>关于宏包文档的查看，可以通过打开Windows系统的<code>CMD</code>，然后输出<code>texdoc+宏包名称 </code>就可以查看对应宏包的说明文档，部分文档是汉化的，所以可以任意阅读</p></blockquote><h2 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h2><p><strong>一般情况下，推荐输出<code>pdf</code>格式</strong>，由<code>LaTex</code>直接生成的<code>dvi</code>格式并不推荐。</p><p>你或许会在<code>tex</code>文档的文件夹下看到如下格式类型的文件：</p><ul><li><code>.sty</code>：宏包文件</li><li><code>.cls</code>：文档类文件</li><li><code>.aux</code>：用于存储交叉引用信息的文件，因此，在更新交叉引用（公式编号，大纲级别）后，需要编译两次才能正常显示。</li><li><code>.log</code>：日志，记录上次的编译信息。</li><li><code>.toc</code>：目录文件。</li><li><code>.lof</code>：图形目录</li><li><code>.lot</code>：表格目录</li><li><code>.idx</code>：如果文档中包含索引，该文件用于存储索引信息</li><li><code>.ind</code>：索引记录文件</li><li><code>.ilg</code>：索引日志文件</li><li><code>.bib</code>：<code>BIBTEX</code>参考文献数据文件</li><li><code>.bbl</code>：生成的参考文献记录</li><li><code>.bst</code>：<code>BIBTEX</code>模板</li><li><code>.blg</code>：<code>BIBTEX</code>日志</li><li><code>.out</code>：<code>hyperref</code>宏包生成的<code>pdf</code>书签记录</li></ul><p>例如，我使用的示例<code>tex</code>文档下的文件内容：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf335082c7.png" alt="image-20220306204837996" style="zoom:67%;" /><p><strong>有时<code>LaTex</code>编译出现异常时，可以通过删除除了<code>tex</code>文件外的文件再编译</strong>。</p><blockquote><p>还需要注意的时，有时候其他程序占用了以上文件也会出现错误。</p></blockquote><h1 id="标点与强调"><a href="#标点与强调" class="headerlink" title="标点与强调"></a>标点与强调</h1><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p><strong>英文单引号并不是两个<code>&#39;</code>（单引号）符号的组合，而是由左单引号<code>ˋ</code>和右单引号<code>&#39;</code>来实现英文单引号</strong>，示例命令：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">这是两个单引号`&#x27;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染结果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf33fadd6c.png" alt="image-20220306211513687" style="zoom:80%;" /><p>如果我们直接使用英文两个<code>&#39;</code>单引号，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">这是两个单引号&#x27;&#x27;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染结果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf343a0fcc.png" alt="image-20220306212022453" style="zoom:80%;" /><p>同样的，<strong>使用英文双引号，也需要分开左双引号，即两个<code>ˋˋ</code>，然后两个右双引号<code>&#39;&#39;</code><strong>即可。</strong>中文符号的引号直接使用中文即可</strong>。</p><h2 id="短横，省略号与破折号"><a href="#短横，省略号与破折号" class="headerlink" title="短横，省略号与破折号"></a>短横，省略号与破折号</h2><p>英文的短横分为三种：</p><ul><li><strong>连字符：输入一个短横<code>-</code></strong></li><li><strong>数字起止符：输入两个短横<code>--</code></strong></li><li><strong>破折号：输入三个短横<code>---</code></strong></li></ul><p>【渲染效果】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf34991e9a.png" alt="image-20220306213543194" style="zoom:80%;" /></p><p>中文的字符都可以正常使用。<strong>需要注意的是，英文的省略号需要使用<code>\ldots</code>命令</strong>。</p><h2 id="强调：粗体与斜体"><a href="#强调：粗体与斜体" class="headerlink" title="强调：粗体与斜体"></a>强调：粗体与斜体</h2><p><code>LaTex</code>中有个命令<code>\emph&#123;text&#125;</code>，可以强调文本。对于一般的英文字体来说，这个命令的结果是斜体，而如果输入中文，则不会触发斜体，只是给中文应用了某个细字体，例如：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf34e3239e.png" alt="image-20220306214147619" style="zoom: 67%;" /><p><strong>对于英文来说，是采用斜体的方式进行强调，而不是中文惯用的粗体</strong>。</p><h2 id="下划线与删除线"><a href="#下划线与删除线" class="headerlink" title="下划线与删除线"></a>下划线与删除线</h2><p><code>LaTex</code>原生提供的下划线命令是<code>\underline</code>，不过原生提供的下划线风评不是很好，可以使用<code>ulem</code>宏包提供的下划线，如下是两个下划线的比较示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf351e3447.png" alt="image-20220306215057754" style="zoom:80%;" /><p>同样的<code>ulem</code>宏包还提供了一些其他的命令，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\uline</span>&#123;下划线&#125;</span><br><span class="line"><span class="keyword">\uuline</span>&#123;双下划线&#125;</span><br><span class="line"><span class="keyword">\uwave</span>&#123;下波浪线&#125;</span><br><span class="line"><span class="keyword">\sout</span>&#123;删除线&#125;</span><br><span class="line"><span class="keyword">\xout</span>&#123;删除封禁线&#125;</span><br><span class="line"><span class="keyword">\dashuline</span>&#123;下虚划线&#125;</span><br><span class="line"><span class="keyword">\dotuline</span>&#123;下点线&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf355e84b4.png" alt="image-20220307083136655" style="zoom:67%;" /><blockquote><p><strong>如果希望<code>LaTex</code>开头不自动缩进的话，可以在开头输入<code>\noindent</code>，来表示首行不缩进</strong></p></blockquote><p>需要注意的是<code>ulem</code>宏包对<code>\emph&#123;text&#125;</code>进行了重定义，之前使用<code>\emph</code>命令会产生斜体，<strong>使用<code>ulem</code>宏包后，它重定义的效果是产生下划线而不是斜体，如果希望取消这个重定义，则在引入宏包的导言区输入如下命令参数</strong>：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[normalem]&#123;ulem&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于数学公式，化学公式等，如果你使用过Markdown则会更熟悉，需要使用<code>$这里是你的公式内容$</code>来包裹你的公式来表示这里要渲染公式。例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 数学公式</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;x<span class="built_in">^</span>2-2&#125;&#123;x<span class="built_in">^</span>3&#125;+3=y<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 化学苯环</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\chemfig</span>&#123;*6(-=-=-=)&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf35a02144.png" alt="image-20220307084339540" style="zoom: 67%;" /><p>关于输出<code>Tex</code>家族标志，可以使用原生命令，例如<code>\LaTex</code>，<code>\Tex</code>等 </p><p>【渲染输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf35e18276.png" alt="image-20220307085001047" style="zoom:50%;" /><h1 id="格式控制"><a href="#格式控制" class="headerlink" title="格式控制"></a>格式控制</h1><p>关于<code>LaTex</code>的长度单位：</p><ul><li>**pt(point)**：磅</li><li>**pc(pica)**：1pc&#x3D;12pt，四号字</li><li>**in(inch)**：英寸，1 in&#x3D;72.27 pt</li><li>**bp(bigpoint)**：大点，1 bp &#x3D; $\frac{1}{72}$ in</li><li>**cm(centimeter)**：厘米，1 cm &#x3D; $\frac{1}{2.54}$ in</li><li>**mm(millimeter)**：毫米，1 mm &#x3D; $\frac{1}{10}$ cm</li><li>**sp(scaled point)**：<code>Tex</code>的基本长度单位，1 sp&#x3D;$\frac{1}{65536}$ pt</li><li><strong>em</strong>：当前字号下，大写字母 <code>M</code> 的宽度</li><li><strong>ex</strong>：当前字号下，小写字母 <code>x</code> 的高度</li></ul><p>如下是两个常用的长度宏，关于其他的长度宏后面的表格，分栏部分会做详细说明。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 页面上文字的总宽度，即页宽减去两侧边距</span></span><br><span class="line"><span class="keyword">\textwidth</span></span><br><span class="line"><span class="comment">% 当前行允许的行宽</span></span><br><span class="line"><span class="keyword">\linewidth</span></span><br></pre></td></tr></table></figure><h2 id="空格，换行与分段"><a href="#空格，换行与分段" class="headerlink" title="空格，换行与分段"></a>空格，换行与分段</h2><p>关于空格有多种表示方法，如下表格：</p><table><thead><tr><th>说明</th><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>两个<code>quad</code>宽度</td><td><code>\qquad</code></td><td>$a \qquad b$</td></tr><tr><td>一个<code>quad</code>宽度</td><td><code>\quad</code></td><td>$a \quad b$</td></tr><tr><td>大空格</td><td><code>\+空格</code></td><td>$a\ b$</td></tr><tr><td>中等空格</td><td><code>\;</code></td><td>$a;b$</td></tr><tr><td>小空格</td><td><code>\,</code></td><td>$a,b$</td></tr><tr><td>紧贴（即缩进距离）</td><td><code>\!</code></td><td>$a!b$</td></tr></tbody></table><p>换行的方法也非常简单，对于一般的长度来说，<code>LaTex</code>会自动换行，而<strong>如果希望手动换行，只需要在换行处输入两个回车即可完成分段</strong>。命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\noindent</span><span class="comment">%该命令表示开头无缩进</span></span><br><span class="line">测试测试测试测试测试测试测试</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</span><br><span class="line"><span class="keyword">\TeX</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf363c4def.png" alt="image-20220308211214804" style="zoom:80%;" /><p>如果希望<strong>在两个段之间插入一个空白行，即空白段，则需要先输入两个回车，然后使用命令<code>\mbox&#123;&#125;</code>，最后再输入两个回车即可</strong>。命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\noindent</span></span><br><span class="line">测试测试测试测试测试测试测试</span><br><span class="line"></span><br><span class="line"><span class="keyword">\mbox</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</span><br><span class="line"><span class="keyword">\TeX</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf36898359.png" alt="image-20220308211433101" style="zoom:80%;" /><p>同样的，<strong>也可以使用<code>\per</code>来生成一个带缩进的新段</strong>。</p><p><strong>关于强制换行的命令，即<code>\\</code>，这样会有一个缺点，即换行后的新段首行缩进会消失</strong>，这个命令一般不用在正文中换行。正常使用两个回车换行即可。</p><p>另外，宏包<code>lettrine</code>能够生成首字下沉的效果，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;lettrine&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\noindent</span></span><br><span class="line"><span class="keyword">\lettrine</span>&#123;测&#125; 试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</span><br><span class="line"><span class="keyword">\TeX</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf36c9200b.png" alt="image-20220308212304346" style="zoom:80%;" /><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p><strong>使用<code>\newpage</code>开始新的一页</strong>。</p><p>使用<code>\clearpage</code>命令清空浮动体队列，并开始新的一页。</p><blockquote><p>关于什么事浮动体队列，详情看后面</p></blockquote><p>使用<code>\cleardoublepage</code>情况浮动体队列，并在偶数页开始新的一页。</p><p>需要注意的是，上述命令是基于<code>vfill</code>的，<strong>所以如果需要连续新开两页，需要在中间加上一个空的箱子</strong>，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\newpage</span> <span class="keyword">\mbox</span>&#123;&#125; <span class="keyword">\newpage</span></span><br></pre></td></tr></table></figure><h2 id="缩进，对齐与行距"><a href="#缩进，对齐与行距" class="headerlink" title="缩进，对齐与行距"></a>缩进，对齐与行距</h2><p>关于首行缩进问题，在部分教程和书籍中表示<code>LaTex</code>对中文首行默认不缩进，需要借助宏包<code>indentfirst</code>来完成缩进，我测试过，在我的环境下，即 Win10，Tex Live 2022，Tex Studio 的情况下，已经支持中文默认缩进。<strong>关于取消首行缩进可以通过前面提到过的<code>\noindent</code>来实现</strong>。</p><p>关于其他更复杂的部分详细看后面。</p><h1 id="字体与颜色"><a href="#字体与颜色" class="headerlink" title="字体与颜色"></a>字体与颜色</h1><p>这部分只说明文中的字体使用，关于数学公式字体的使用详细看后面。</p><h2 id="字族，字系与字形"><a href="#字族，字系与字形" class="headerlink" title="字族，字系与字形"></a>字族，字系与字形</h2><p>宋体，黑体，楷体属于字族；对应到外文就是罗马体，等宽体等。加粗，加斜属于字系和字形，五号，小四号属于字号。这三者并称为字体。</p><h2 id="中西文“斜体”"><a href="#中西文“斜体”" class="headerlink" title="中西文“斜体”"></a>中西文“斜体”</h2><p>首先需要明确一点：<strong>汉字没有加斜体。平常看到的斜体汉字是通过几何变换得到的结果</strong>，对于排版来说，这种斜体是非常粗糙的，真正的字形是需要精细设计的。</p><p>西文中一般设有加斜，但与“斜体”并不是一回事。加斜是指某种字族的 <code>Italy</code> 字系；而斜体，是指<code>Slant</code>字族。</p><h2 id="原生字体命令"><a href="#原生字体命令" class="headerlink" title="原生字体命令"></a>原生字体命令</h2><p><code>LaTex</code>提供了基本的字体命令，如下表</p><table><thead><tr><th>字体</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>字族</td><td><code>\rmfamily</code></td><td>设置字体为<code>Roman</code>罗马字族</td></tr><tr><td></td><td><code>\sffamily</code></td><td>把字体设置为<code>Sans Serif</code>无衬线字族</td></tr><tr><td></td><td><code>\ttfamily</code></td><td>把字体设置为<code>Typewriter</code>等宽字族</td></tr><tr><td>字系</td><td><code>\bfseries</code></td><td>粗体<code>BoldSeries</code>字系属性</td></tr><tr><td></td><td><code>\mdseries</code></td><td>中粗体<code>MiddleSeries</code>字系属性</td></tr><tr><td>字形</td><td><code>\upshape</code></td><td>竖直<code>Upright</code>字形</td></tr><tr><td></td><td><code>\slshape</code></td><td>斜体<code>Slant</code>字形</td></tr><tr><td></td><td><code>\itshape</code></td><td>强调体<code>Italic</code>字形</td></tr><tr><td></td><td><code>\scshape</code></td><td>小号大写体<code>SCAP</code>字形</td></tr></tbody></table><p>然后就是<strong>关于字号的命令，<code>LaTex</code>给出了一系列“相对字号命令”</strong>，如下表所示，当然你也可以使用宏包<code>ctex</code>的相关字号命令来控制字号，详细文档说明可以使用控制台命令<code>texdoc ctex</code>即可查看。</p><table><thead><tr><th>符号</th><th>命令</th><th>符号</th><th>命令</th></tr></thead><tbody><tr><td>超超小</td><td><code>$\tiny$</code></td><td>其次小</td><td><code>$\scriptsize$</code></td></tr><tr><td>小一点</td><td><code>$\small$</code></td><td>默认大小</td><td><code>$\normalsize$</code></td></tr><tr><td>大一点</td><td><code>$\large$</code></td><td>大两点</td><td><code>$\Large$</code></td></tr><tr><td>大三点</td><td><code>$\LARGR$</code></td><td>巨大</td><td><code>$\huge$</code></td></tr><tr><td>巨巨大</td><td><code>$\Huge$</code></td><td></td><td></td></tr></tbody></table><h2 id="中文支持与CJK字体"><a href="#中文支持与CJK字体" class="headerlink" title="中文支持与CJK字体"></a>中文支持与CJK字体</h2><p>中文方面，<code>ctex</code>宏包直接定义了新的中文文档类<code>ctexart</code>，<code>ctexrep</code>与<code>ctexbook</code>，以及<code>ctexbeamer</code>幻灯文档类。</p><blockquote><p>关于中文支持方面的更多问题可以查看<code>ctex</code>文档说明</p></blockquote><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>使用<code>xcolor</code>宏包来方便的调用颜色，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\textcolor</span>&#123;red&#125;&#123;试测试测试测试&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf375b603e.png" alt="image-20220309162354001" style="zoom:80%;" /><blockquote><p>关于更多的颜色说明可以参考宏包<code>xcolor</code>说明文档</p></blockquote><h1 id="引用与注释"><a href="#引用与注释" class="headerlink" title="引用与注释"></a>引用与注释</h1><p>电子文档最大的优点在于可以使用超链接，跳转标签和目录。这些功能的实现都需要“引用”。</p><h2 id="标签和引用"><a href="#标签和引用" class="headerlink" title="标签和引用"></a>标签和引用</h2><p><strong>使用<code>\label</code>命令插入标签（在MS Word中称为“题注”），然后在其他地方使用<code>\ref</code>或者<code>\pageref</code>命令进行引用。</strong>命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建标签</span></span><br><span class="line"><span class="keyword">\label</span>&#123;123&#125;</span><br><span class="line"><span class="comment">% 引用标签</span></span><br><span class="line"><span class="keyword">\ref</span>&#123;123&#125;</span><br></pre></td></tr></table></figure><p>另外有个宏包<code>amsmath</code>提供了相关引用的命令，可以自行查看。</p><h2 id="脚注，边注与尾注"><a href="#脚注，边注与尾注" class="headerlink" title="脚注，边注与尾注"></a>脚注，边注与尾注</h2><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注是一种简单的标注，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一段测试文本<span class="keyword">\footnote</span>&#123;这是一段脚注&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf37a5566b.png" alt="image-20220309164253562" style="zoom:80%;" /><p><strong>在某些情况下（如表格），脚注无法正常使用，可以通过在需要插入脚注的位置插入命令<code>\footnotemark</code>，然后再在环境外使用<code>\footnotetext</code>来指明脚注内容</strong>，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">这是一段测试文本<span class="keyword">\footnotemark</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">\footnotetext</span>&#123;这是一段脚注内容&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>【渲染结果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf37e28392.png" alt="image-20220309165118369" style="zoom:80%;" /><blockquote><p>行文中切记过多使用脚注，会分散读者的注意力</p></blockquote><h3 id="边注"><a href="#边注" class="headerlink" title="边注"></a>边注</h3><p><code>LaTex</code>的边注命令<code>\marginpar</code>不会进行编号，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 命令格式</span></span><br><span class="line"><span class="keyword">\marginpar</span>&#123;右侧注释内容&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令示例</span></span><br><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">这是一段测试文本<span class="keyword">\marginpar</span>&#123;这是右侧边注&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf38237632.png" alt="image-20220309165633332" style="zoom:95%;" /><h3 id="尾注"><a href="#尾注" class="headerlink" title="尾注"></a>尾注</h3><p>尾注用于注释比较长，无法使用脚注的场合，需要使用宏包<code>endnotes</code>。</p><h2 id="援引环境"><a href="#援引环境" class="headerlink" title="援引环境"></a>援引环境</h2><p><strong>普通的援引环境有<code>quote</code>和<code>quotation</code>两种。前者首行不缩进，后者首行缩进，且支持多段文字</strong>。命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\noindent</span> 这是原文内容</span><br><span class="line"><span class="keyword">\begin</span>&#123;quote&#125;</span><br><span class="line">这是一段援引内容</span><br><span class="line"><span class="keyword">\end</span>&#123;quote&#125;</span><br><span class="line">这是后面的内容</span><br><span class="line"><span class="keyword">\begin</span>&#123;quotation&#125;</span><br><span class="line">这也是一段援引内容</span><br><span class="line"><span class="keyword">\end</span>&#123;quotation&#125;</span><br><span class="line">这也是后面的内容</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf385baa0e.png" alt="image-20220309170310170" style="zoom: 67%;" /><p>另外一个诗歌援引环境叫<code>verse</code>，是悬挂缩进的，一般很少用。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>部分文档类环境支持摘要，如果使用摘要，这需要在<code>\maketitle</code>命令之后才可以使用<code>abstract</code>环境来完成摘要。命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;这是文章标题&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\maketitle</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;abstract&#125;</span><br><span class="line">这部分是摘要。这部分是摘要。这部分是摘要。这部分是摘要。这部分是摘要。这部分是摘要。这部分是摘要。这部分是摘要。</span><br><span class="line"><span class="keyword">\end</span>&#123;abstract&#125;</span><br><span class="line"></span><br><span class="line">这是正文内容</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf38a1e761.png" alt="image-20220309172432967" style="zoom: 80%;" /><blockquote><p>需要注意的是命令要放在<code>document</code>环境内</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><strong>参考文献注意使用的命令是<code>\cite</code>。</strong></p><p>如果想要将参考文献章节正常编号，并加入到目录中，可以使用<code>tocbibind</code>宏包。</p><h1 id="正式排版：封面，大纲与目录"><a href="#正式排版：封面，大纲与目录" class="headerlink" title="正式排版：封面，大纲与目录"></a>正式排版：封面，大纲与目录</h1><h2 id="封面"><a href="#封面" class="headerlink" title="封面"></a>封面</h2><p>封面的内容在导言区进行定义，一般写在所有宏包，自定义命令之后，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;文章标题&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;作者名字&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;<span class="comment">%\today命令表示获取当前时间</span></span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf38f7ac8b.png" alt="image-20220309180826184" style="zoom:80%;" /><p><strong>然后在<code>document</code>环境内第一行写上<code>\maketitle</code><strong>，这样就形成了一个简易的封面。</strong>其中，<code>\title</code>和<code>author</code>是必须定义的</strong>。<code>\date</code>省略会自动编译当天的日期为准。**如果不想显示日期，这使用<code>\data&#123;&#125;</code>**即可。</p><p>标题页的脚注用<code>\thanks</code>命令完成。</p><h2 id="大纲与章节"><a href="#大纲与章节" class="headerlink" title="大纲与章节"></a>大纲与章节</h2><p><code>LaTex</code>中，文档分为若干大纲级别，分别包括如下内容：</p><ul><li><strong><code>\part</code>：部分，这个大纲不会打段<code>chapter</code>的编号</strong></li><li><strong><code>\chapter</code>：章，<code>article</code>的文档类不包含该大纲级别</strong></li><li><strong><code>\section</code>：节。</strong></li><li><strong><code>\subsection</code>：次节。</strong></li><li><strong><code>\subsubsection</code>：次节。</strong></li><li><strong><code>\paragraph</code>：段，很少使用</strong></li><li><strong><code>\subparagraph</code>：段，很少使用</strong></li></ul><p>book文档类还提供了以下命令：</p><ul><li><strong><code>\frontmatter</code>：前言。页码为小写罗马字母，其后章节不编号，但是生成页眉页脚和目录项</strong></li><li><strong><code>\mainmatter</code>：正文。页码为阿拉伯数字，其后章节编号，页眉页脚和目录项正常生成</strong></li><li><strong><code>\backmatter</code>：后记。页码格式不变，章节不编号，但生成页眉页脚和目录项</strong></li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><strong>目录在大纲的基础上生成，使用命令<code>\tableofcontents</code>既可插入目录。</strong></p><p>在加入宏包<code>hyperref</code>，目录可以实现点击跳转。关于更多高级目录自定义需要借助<code>titletoc</code>宏包。</p><h1 id="计数器与列表"><a href="#计数器与列表" class="headerlink" title="计数器与列表"></a>计数器与列表</h1><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p><code>LaTex</code>中的自动编号都借助内部的计数器来完成，计数器包括如下几种：</p><ul><li><strong>章节</strong>：part，chapter，section，subsection，subsubsection，paragraph，subparagraph</li><li><strong>编号列表</strong>：enumi，enumii，enumiii和enumiv</li><li><strong>公式和图表</strong>：equation，figure 与 table</li><li><strong>其他</strong>：page，footnote 与 mpfootnote</li></ul><p>可以通过<code>\the</code>接上计数器的名称来调用计数器，例如：<code>\thepart</code>。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>**<code>LaTex</code>支持的预定义列表有三种，分别是无须列表<code>itemize</code>，自动编号列表<code>enumerate</code>，以及描述列表<code>description</code>**。</p><p><strong>无须列表</strong>命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span> 第一项</span><br><span class="line"><span class="keyword">\item</span>[-] 第二项</span><br><span class="line"><span class="keyword">\item</span>[*] 第三项</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf395bb006.png" alt="image-20220309185733983" style="zoom:80%;" /><p><strong>有序列表</strong>命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\item</span> 第一项</span><br><span class="line"><span class="keyword">\item</span> 第二项</span><br><span class="line"><span class="keyword">\item</span> 第三项</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf3995448f.png" alt="image-20220309185946504" style="zoom: 80%;" /><p><strong>描述列表</strong>（自定义列表）命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;description&#125;</span><br><span class="line"><span class="keyword">\item</span>[LaTex] 第一项</span><br><span class="line"><span class="keyword">\item</span>[Tex] 第二项</span><br><span class="line"><span class="keyword">\item</span>[MarkDown] 第三项</span><br><span class="line"><span class="keyword">\end</span>&#123;description&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf39d3b139.png" alt="image-20220309190154869" style="zoom:80%;" /><h1 id="浮动体与图表"><a href="#浮动体与图表" class="headerlink" title="浮动体与图表"></a>浮动体与图表</h1><h2 id="浮动体"><a href="#浮动体" class="headerlink" title="浮动体"></a>浮动体</h2><p>浮动体将图或者表及其标题定义为整体，可以动态排版，以解决图，表在换页处造成的过长留白问题。</p><p><strong>图片的浮动体是<code>figure</code>环境，表格的浮动体是<code>table</code>环境。</strong></p><p>如果希望浮动体不要跨过<code>section</code>，可以使用如下命令：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[section]&#123;placeins&#125;</span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片的插入需要使用宏包<code>graphicx</code>和<code>\includegraphics</code>命令。命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">这是正文内容，我是长长的内容，我真的很长并且有很多内容，我企图扩展到第二行，甚至第三行。</span><br><span class="line"><span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\includegraphics</span>[width=0.8<span class="keyword">\linewidth</span>]&#123;1.jpg&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf3a52c085.png" alt="image-20220309192047201" style="zoom:80%;" /><p>其中，可选参数可以指定其宽高等，类似地，也可以使<code>height</code>（高），<code>scale</code>（图片缩放倍数），<code>angle</code>（图片逆时针旋转角度），<code>origin</code>（图片选中中心）等命令。</p><blockquote><p>前三个命令不建议同时使用，旋转的图片基线会变化，所以一般使用<code>totalheight</code>代替<code>height</code></p></blockquote><p>至于<code>&#123;&#125;</code>里的参数的写法，<code>LaTex</code>支持<code>pdf</code>,<code>eps</code>,<code>png</code>与<code>jpg</code>格式，所以可以选择带有图片拓展名的表示方式，也可以不带拓展名，如果不带拓展名，则会按照上述格式顺序搜索图片。</p><blockquote><p>默认图片需要在<code>.tex</code>文件放在同一个文件夹下</p></blockquote><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>懒得解释了，就看一个简单的命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|c|c|&#125;</span><br><span class="line"><span class="keyword">\hline</span> 2<span class="built_in">&amp;</span>9<span class="built_in">&amp;</span>4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span> 7<span class="built_in">&amp;</span>5<span class="built_in">&amp;</span>3<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span> 6<span class="built_in">&amp;</span>1<span class="built_in">&amp;</span>8<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf3a9bc785.png" alt="image-20220309194713871" style="zoom:80%;" /><h1 id="页面设置"><a href="#页面设置" class="headerlink" title="页面设置"></a>页面设置</h1><h2 id="纸张，方向和边距"><a href="#纸张，方向和边距" class="headerlink" title="纸张，方向和边距"></a>纸张，方向和边距</h2><p>详情参考宏包<code>geometry</code>。</p><h2 id="页眉和页脚"><a href="#页眉和页脚" class="headerlink" title="页眉和页脚"></a>页眉和页脚</h2><p>详情参考宏包<code>fancyhdr</code>。</p><h1 id="抄录与代码环境"><a href="#抄录与代码环境" class="headerlink" title="抄录与代码环境"></a>抄录与代码环境</h1><p>如果你希望直接输出相关内容而不经过<code>Tex</code>解释，可以使用<code>\verb</code>命令。命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;color&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\textcolor</span>&#123;red&#125;&#123;text&#125;</span><br><span class="line"><span class="keyword">\verb</span>*<span class="string">|\textcolor&#123;red&#125;&#123;text&#125;|</span></span><br><span class="line"><span class="string">\end&#123;document&#125;</span></span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf3aebcafe.png" alt="image-20220309195249437" style="zoom:80%;" /><h1 id="分栏"><a href="#分栏" class="headerlink" title="分栏"></a>分栏</h1><p>分栏需要使用<code>multicol</code>宏包，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;multicol&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;multicols&#125;&#123;2&#125;</span><br><span class="line">测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</span><br><span class="line"><span class="keyword">\end</span>&#123;multicols&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaf3b28326f.png" alt="image-20220309195831024" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown进阶用法</title>
      <link href="/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/MarkDown%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95/"/>
      <url>/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/MarkDown%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown进阶用法"><a href="#MarkDown进阶用法" class="headerlink" title="MarkDown进阶用法"></a>MarkDown进阶用法</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于常规的排版问题，MarkDown给出了简单的解决方案，但是如果我们希望能够做出顺序图&#x2F;时序图或者相关流程图，又或者数学相关工作者希望的相关数学公式显示问题又怎么解决呢？</p><p>学习此部分，需要掌握一定的<strong>MarkDown基础</strong></p><p><strong>本部分内容为个人经验总结</strong></p><p>本篇最后更新于 <strong>时间</strong> ，部分内容可能与现在不符，请自行判断</p><h4 id="start" align="center"><font color="blue">——生命的意义不在于躲避风雨，而是在雨中起舞♬</font></h4><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>如果在使用过程中，用户想要输入类似于 <code>*</code> 的等已经有相关意义的字符怎么办？这个时候就需要使用转义字符来表示你要单独使用该字符了，告诉编译器不要翻译成markdown格式了。<br><strong>MarkDown支持在下面的字符前插入反斜杠(<code>\</code>)来实现转义</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure><h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p>创建脚注格式类似这样 [^Markdown]。</p><p>[^Markdown]: MarkDown – Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。</p><blockquote><p>注：脚注可能在部分Markdown解析中不适用</p></blockquote><h1 id="LaTeX数学公式语言-Markdown支持的"><a href="#LaTeX数学公式语言-Markdown支持的" class="headerlink" title="LaTeX数学公式语言(Markdown支持的)"></a>LaTeX数学公式语言(Markdown支持的)</h1><p>常用的数学公式表示方法：</p><ul><li><p><strong>行中数学公式</strong><br>  <strong>在MarkDown中一般使用两个 <code>$这里写公式$</code> 来表示数学公式的区域</strong>，例如：</p>  <figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>2x+y=12<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>  显示的效果如下：$2x+y&#x3D;12$</p></li><li><p><strong>独立数学公式</strong><br>  <strong>如果采用两个 <code>$$这里写公式$$</code>，则是公式单独占用行</strong>，还是上面的例子，展示效果如下：$$2x+y&#x3D;12$$</p></li><li><p><strong>独立带编号的数学公式</strong><br>  代码如下:</p>  <figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;equation&#125;数学公式<span class="keyword">\end</span>&#123;equation&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>  $\begin{equation}数学公式\end{equation}$</p></li></ul><h2 id="常用的命令字符"><a href="#常用的命令字符" class="headerlink" title="常用的命令字符"></a>常用的命令字符</h2><ul><li><strong>字号转换</strong><br>  改变数学公式展示的字号大小，代码示例：  <figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Huge</span> 这是一号字体<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\huge</span> 这是二号字体<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\LARGE</span> 这是三号字体<span class="built_in">$</span></span><br></pre></td></tr></table></figure></li><li><strong>常用数学符号</strong><table><thead><tr><th align="center">符号</th><th align="center">实现</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">≤</td><td align="center">\leq</td><td align="center">小于等于</td></tr><tr><td align="center">≥</td><td align="center">\geq</td><td align="center">大于等于</td></tr><tr><td align="center">≪</td><td align="center">\ll</td><td align="center">远小于</td></tr><tr><td align="center">≫</td><td align="center">\gg</td><td align="center">远大于</td></tr><tr><td align="center">×</td><td align="center">\times</td><td align="center">乘号</td></tr><tr><td align="center">÷</td><td align="center">\div</td><td align="center">除号</td></tr><tr><td align="center">≠</td><td align="center">\neq</td><td align="center">不等于号</td></tr></tbody></table></li><li><strong>常用希腊字符</strong><table><thead><tr><th align="center">符号</th><th align="center">实现</th></tr></thead><tbody><tr><td align="center">α</td><td align="center">\alpha</td></tr><tr><td align="center">β</td><td align="center">\beta</td></tr><tr><td align="center">θ</td><td align="center">\theta</td></tr><tr><td align="center">π</td><td align="center">\pi</td></tr></tbody></table></li><li><strong>常用公式</strong><table><thead><tr><th align="center">公式</th><th align="center">实现</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">$log_xy$</td><td align="center">log_x y</td><td align="center"><code>_</code>表示下标，如果如左边写，默认第一个是下标内容</td></tr><tr><td align="center">$log_{x+1} 3y+1$</td><td align="center">log_{x+1} 3y+1</td><td align="center"><code>_&#123;&#125;</code>在花括号里写的公式会呈现在下标，花括号外面的则默认真数</td></tr><tr><td align="center">$x^n$</td><td align="center">x^n</td><td align="center">同样的可以使用<code>^&#123;&#125;</code>，在花括号里写的公式会默认在次方里显示</td></tr><tr><td align="center">$\sqrt {x + y}$</td><td align="center">\sqrt {x + y}</td><td align="center"><code>\sqrt&#123;&#125;</code>花括号里的公式会展示成开平方</td></tr><tr><td align="center">$\frac{x}{y}$</td><td align="center">\frac{x}{y}</td><td align="center"><code>\frac&#123;&#125;&#123;&#125;</code>第一个括号内的公式为分子，第二个括号的内容为分母</td></tr><tr><td align="center">$\sum\limits_{x &#x3D; 1}^{n} 7x$</td><td align="center">\sum\limits_{x &#x3D; 1}^{n} 7x</td><td align="center"><code>\sum\limits_&#123;&#125;^&#123;&#125;</code> 占位符，第一个花括号是下面的公式，第二个花括号是和，第三个占位符的位置是后缀的公式</td></tr><tr><td align="center">$\int_{0}^{\frac{\pi}{2}} \sin(x)$</td><td align="center">\int_{0}^{\frac{\pi}{2}} \sin(x)</td><td align="center">如左边公式所示</td></tr></tbody></table></li></ul><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><h2 id="横向流程图"><a href="#横向流程图" class="headerlink" title="横向流程图"></a>横向流程图</h2><p>代码示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">graph LR</span></span><br><span class="line"><span class="code">A[方形] --&gt;B(圆角)</span></span><br><span class="line"><span class="code">    B --&gt; C&#123;条件a&#125;</span></span><br><span class="line"><span class="code">    C --&gt;|a=1| D[结果1]</span></span><br><span class="line"><span class="code">    C --&gt;|a=2| E[结果2]</span></span><br><span class="line"><span class="code">    F[横向流程图]</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 注：代码前面存在一个制表位(`Tab`)来防止被转义为图形，下面同理</span><br><span class="line"></span><br><span class="line">展示效果：</span><br><span class="line">```mermaid</span><br><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure><h2 id="纵向流程图"><a href="#纵向流程图" class="headerlink" title="纵向流程图"></a>纵向流程图</h2><p>代码示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">graph TD</span></span><br><span class="line"><span class="code">A[方形] --&gt; B(圆角)</span></span><br><span class="line"><span class="code">    B --&gt; C&#123;条件a&#125;</span></span><br><span class="line"><span class="code">    C --&gt; |a=1| D[结果1]</span></span><br><span class="line"><span class="code">    C --&gt; |a=2| E[结果2]</span></span><br><span class="line"><span class="code">    F[竖向流程图]</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">展示效果：</span><br><span class="line">```mermaid</span><br><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a=1| D[结果1]</span><br><span class="line">    C --&gt; |a=2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure><h2 id="标准流程图（纵向）"><a href="#标准流程图（纵向）" class="headerlink" title="标准流程图（纵向）"></a>标准流程图（纵向）</h2><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">展示效果：</span><br><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><h2 id="标准流程图（横向）"><a href="#标准流程图（横向）" class="headerlink" title="标准流程图（横向）"></a>标准流程图（横向）</h2><p>代码示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```flow</span></span><br><span class="line"><span class="code">st=&gt;start: 开始框</span></span><br><span class="line"><span class="code">op=&gt;operation: 处理框</span></span><br><span class="line"><span class="code">cond=&gt;condition: 判断框(是或否?)</span></span><br><span class="line"><span class="code">sub1=&gt;subroutine: 子流程</span></span><br><span class="line"><span class="code">io=&gt;inputoutput: 输入输出框</span></span><br><span class="line"><span class="code">e=&gt;end: 结束框</span></span><br><span class="line"><span class="code">st(right)-&gt;op(right)-&gt;cond</span></span><br><span class="line"><span class="code">cond(yes)-&gt;io(bottom)-&gt;e</span></span><br><span class="line"><span class="code">cond(no)-&gt;sub1(right)-&gt;op</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">展示效果：</span><br><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><h1 id="其他图"><a href="#其他图" class="headerlink" title="其他图"></a>其他图</h1><p>其他图的设计例如：UML图，甘特图等，一般情况下专业的MarkDown才会支持，一般的MarkDown对于上面的流程图支持已是最大限度了。大多数情况下，使用MarkDown来直接绘制流程图远远不如使用相关软件工具绘制插入图片来的更加方便。</p><blockquote><p>如果真的必要且感兴趣，详情查询相关书籍或者其他教程</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何化身嘉然小姐来参加网课</title>
      <link href="/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%A6%82%E4%BD%95%E5%8C%96%E8%BA%AB%E5%98%89%E7%84%B6%E5%B0%8F%E5%A7%90%E6%9D%A5%E5%8F%82%E5%8A%A0%E7%BD%91%E8%AF%BE/"/>
      <url>/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%A6%82%E4%BD%95%E5%8C%96%E8%BA%AB%E5%98%89%E7%84%B6%E5%B0%8F%E5%A7%90%E6%9D%A5%E5%8F%82%E5%8A%A0%E7%BD%91%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们终于开始上网课了，看到网课的摄像头，啊很快啊，一个整活的想法油然而生啊。反手就是一个嘉然小姐，一个面补，我都打出去了，他都防住了，我说对不起我是瞎放的，他说我可不是瞎放的，视频后期，绿幕抠图，虚拟摄像头一看就是有备而来………</p><p>扯远了，关于最终的思想效果，如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee5028bc5.png" alt="image-20220321141443653" style="zoom: 50%;" /><blockquote><p>感谢林某爹提高的图片</p></blockquote><h1 id="软件准备和环境说明"><a href="#软件准备和环境说明" class="headerlink" title="软件准备和环境说明"></a>软件准备和环境说明</h1><p>【配置说明】</p><ol><li>Win10操作系统</li><li>vTube studio最新版</li><li>OBS Studio最新版</li><li>腾讯会议</li></ol><h1 id="VTube-studio"><a href="#VTube-studio" class="headerlink" title="VTube studio"></a>VTube studio</h1><h2 id="VTube-studio的安装"><a href="#VTube-studio的安装" class="headerlink" title="VTube studio的安装"></a>VTube studio的安装</h2><p>这个软件是Vtube即2D模型&#x2F;2.5D模型的运算场景，说人话就是虚拟人物和面部捕捉是在这个软件进行的，首先打开<code>Steam</code>，搜索<code>VTube studio</code>，如下图，选择安装即可</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee55bb8f5.png" alt="image-20220321143502768" style="zoom:60%;" /><blockquote><p>如果你的足够有能力的话，可以购买<code>DLC</code>来支持一下该软件</p></blockquote><p>安装完成后，运行<code>VTube studio</code>界面如下图，在进入软件的时候会弹出一堆相关说明，确认即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee5b9def8.png" alt="image-20220321144048742" style="zoom:67%;" /><h2 id="VTube-studio的使用"><a href="#VTube-studio的使用" class="headerlink" title="VTube studio的使用"></a><code>VTube studio</code>的使用</h2><h3 id="模型捕捉绑定"><a href="#模型捕捉绑定" class="headerlink" title="模型捕捉绑定"></a>模型捕捉绑定</h3><p>在安装完成后，进入软件的界面，首先需要记住的是可以<strong>使用双击来唤醒菜单</strong>，关于各个部分的功能如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee60840af.png" alt="image-20220321145008008" style="zoom:67%;" /><p>现在你所看到的人物模型是<code>VTube studio</code>自带的模型，你可以在<strong>【人物模型部分】</strong>进行选择其他默认自带的模型或者导入自己的2D模型。现在使用导入【嘉然模型】来做示例，关于模型文件会在文章最后末尾给出，自行下载，点击进入【人物模型部分】按钮后，选择导入模型，如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee64c7b70.png" alt="image-20220321145313856" style="zoom:60%;" /><p>在点击导入模型后，会弹出路径提醒，然后将你下载的模型导入到它所指定的文件夹中，如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee68db75a.png" alt="image-20220321145437300" style="zoom: 67%;" /><p>将【嘉然模型】文件导入<code>Live2DModels</code>文件夹，后即可在软件中查看导入的模型，如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee6c9602c.png" alt="image-20220321145621049" style="zoom:67%;" /><p>现在点击【设置】，进入设置页面。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee70b28cb.png" alt="image-20220321145900945" style="zoom:67%;" /><p>如果你需要导入自己的一些别的资源，例如背景，贴纸等，可以在【常规设置】中右侧【打开资源文件夹】中导入自己的资源，如果没有这个需求，可以不用管。</p><p>现在直接进入【摄像捕捉设置】中，在右侧栏选择【选择摄像头】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee748ecf6.png" alt="image-20220321150124713" style="zoom: 67%;" /><p>在弹出的设置提醒中，选择自己要使用哪个摄像头进行捕捉，如果你的摄像头列表中含有<code>VTubeSudioCam</code>则排除该摄像头，查找并选择其他摄像头，该摄像头是软件的虚拟摄像头。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee7819d24.png" alt="image-20220321150244658" style="zoom:67%;" /><p>剩下的设置，就是默认的第一个即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee7ba4b7d.png" alt="image-20220321150424082" style="zoom:67%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee7f6a915.png" alt="image-20220321150444592" style="zoom: 80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee839b2b7.png" alt="image-20220321150510882" style="zoom:80%;" /><p>设置完成后，可以选择【面部捕捉：开启】开启面部捕捉，如果你的模型支持且你希望进行手部捕捉，则在【捕捉类型】中选择面部捕捉和手部捕捉，在本示例【嘉然模型】中，不存在手部绑骨，即无法进行手部捕捉，默认即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee8735be1.png" alt="image-20220321150730936" style="zoom:80%;" /><p>面部捕捉开启后，你的摄像头会被调用打开，会出现面部捕捉的UI显示，如下图，你可以对着摄像头做面无表情来点击校准来校准表情，使用摄像头捕捉需要注意摄像头尽量正对自己且采光良好。</p><p>这个时候你就会发现你的表情和人物模型的表情和动作映射到一起了。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee8b1397d.png" alt="image-20220321150846987" style="zoom:70%;" /><h3 id="虚拟摄像头安装"><a href="#虚拟摄像头安装" class="headerlink" title="虚拟摄像头安装"></a>虚拟摄像头安装</h3><p>在完成人物模型动作表情映射绑定后，现在进行虚拟摄像头的安装，选择【摄像捕捉设置】，滑倒最下面，点击虚拟摄像头安装帮助，如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee902a41c.png" alt="image-20220321151332392" style="zoom:67%;" /><p>然后根据提示选择【打开文件夹】，在文件夹中寻找到<code>Install.bat</code>双击运行，等待安装完成后，关闭控制台即可，如果需要安装失败或者其他错误，可以尝试右键以管理员身份运行<code>Install.bat</code>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee959137f.png" alt="image-20220321151421727" style="zoom:70%;" /><p>安装完成后，就可以在【摄像捕捉设置】里【激活虚拟摄像头】，到这一步，所有的<code>VTube studio</code>基本设置已经完成，下面的微调可以跳过。</p><h3 id="其他调整"><a href="#其他调整" class="headerlink" title="其他调整"></a>其他调整</h3><p>对于带眼睛的伙伴来说，会发现模型眨眼的映射和人物模型的眨眼不是很对的上，这个时候就可以在【摄像捕捉设置】中，找到面部配置，将眨眼灵敏度设置到 30 左右即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee99e399d.png" alt="image-20220321151927907" style="zoom:67%;" /><h1 id="腾讯会议"><a href="#腾讯会议" class="headerlink" title="腾讯会议"></a>腾讯会议</h1><h2 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h2><p>腾讯会议安装，运行不再赘述，打开腾讯会议后，进入【设置】，选择【视频】，如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee9ed5f0c.png" alt="image-20220321152437211" style="zoom:67%;" /><p>然后点击【选择设备】，找到<code>VTubeStudioCam</code>，选择该摄像头，就会出现我们在<code>VTubeStudio</code>的模型环境，如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeea315579.png" alt="image-20220321152605977" style="zoom:80%;" /><p>在上图中，我框出了蓝色的部分，是需要将其关闭的，默认我记得是打开的，你可以选择将【眼神接触】和【暗场景增强】关闭，或者可以和我一样将其全部关闭。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeea76ccb3.png" alt="image-20220321152913107" style="zoom:67%;" /><p>如果你发现该虚拟摄像头的内容曝光过度或者色彩不正之类的问题，则需要选择左侧【虚拟背景和美颜】，将其中的【虚拟背景】【美颜】【滤镜】全部关闭即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeeabb7e25.png" alt="image-20220321165212823" style="zoom:80%;" /><p>这样你进入会议的时候开启摄像头就是使用的该虚拟摄像头，虚拟场景中人物映射你的动作和表情，到现在为止，基本的虚拟设置已经完成了，你已经实现了将嘉然带入到课堂中，可以停止阅读关闭本文即可。</p><p>如果你希望探索进阶玩法，请继续向下阅读操作。</p><h1 id="OBS-Studio"><a href="#OBS-Studio" class="headerlink" title="OBS Studio"></a><code>OBS Studio</code></h1><h2 id="前期配置"><a href="#前期配置" class="headerlink" title="前期配置"></a>前期配置</h2><p>在使用<code>OBS Studio</code>之前，需要在<code>VTube studio</code>中将背景替换为<code>Background_8</code>，即绿幕背景，如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeeb06d2fa.png" alt="image-20220321162517367" style="zoom: 67%;" /><p>因为我们后续的进阶操作需要将人物从绿幕中抠出来，然后配合<code>OBS Studio</code>来使用。</p><h2 id="OBS-Studio的使用"><a href="#OBS-Studio的使用" class="headerlink" title="OBS Studio的使用"></a><code>OBS Studio</code>的使用</h2><h3 id="环境基础配置"><a href="#环境基础配置" class="headerlink" title="环境基础配置"></a>环境基础配置</h3><p>关于OBS的下载和安装可以选择<a href="httpss://obsproject.com/">单击我</a>，进入官网，选择自己的对应的系统下载安装，或者在文本最后我会提供我所使用的版本的安装包，安装完成后，运行，它会弹出一个提醒，如下图，如果你是<code>VTube</code>主播且采用串流推送的方式进行直播，则选择默认第一个【优先优化串流，其次为录像】，如果你是上网课玩玩，则选择第三个【我只使用虚拟摄像机】，然后点击【下一步】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeeb4baa44.png" alt="image-20220321153523000" style="zoom: 80%;" /><p>然后，选择【应用设置】即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeeb8bd403.png" alt="image-20220321160604329" style="zoom: 80%;" /><p>然后进入了默认的软件设置界面：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeebd77e21.png" alt="image-20220321160904649" style="zoom: 60%;" /><p>现在在【来源框】中，点击【+】（加号），选择【视频采集设备】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeec25bba7.png" alt="image-20220321161318916" style="zoom:80%;" /><p>然后在弹出的选择框可以给该组件重命名或者直接点击【确定】即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeec650ddb.png" alt="image-20220321161420013" style="zoom:67%;" /><p>在弹出的组件设置中，选择【设备】找到【<code>VTubeStudioCam</code>】，选择即可，然后点击【确认】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeecad624e.png" alt="image-20220321161541927" style="zoom:80%;" /><p>然后这个时候就可以在<code>OBS Studio</code>中看到我们在<code>VTube Studio</code>中的虚拟场景，如下图，接下来扣除绿幕</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeecf1b2c7.png" alt="image-20220321162916135" style="zoom: 50%;" /><h3 id="绿幕扣除"><a href="#绿幕扣除" class="headerlink" title="绿幕扣除"></a>绿幕扣除</h3><p>选中我们导入的【视频采集设备】，然后点击【滤镜】，如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeed48d0cb.png" alt="image-20220321163301537" style="zoom:80%;" /><p>然后在弹出的弹窗中，选择【+】增加【色度键】，如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeed8c5945.png" alt="image-20220321163631717" style="zoom: 67%;" /><p>然后在弹出弹窗中给该色度键重命名或者直接使用默认确认即可，如下图，软件默认扣除绿色背景，如果需要设置则自行设置更改，目前为止，我们已经完成了绿幕抠图。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeedd3d071.png" alt="image-20220321163847606" style="zoom: 67%;" /><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p>现在我们来增加一张背景图片和文本来实现简单效果，此处添加不做过多赘述。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeee1398e8.png" alt="image-20220321164010737" style="zoom: 50%;" /><p>添加完成后的效果如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeee51e8ea.png" alt="image-20220321164246312" style="zoom: 50%;" /><p>如果你发现你添加图片或者内容挡住了一些你不想挡住的内容，如果你学过<code>PS``PR``AE</code>或者<code>PPT</code>的话应该对图层很熟悉，在来源框中，最前面的表示在图层的最上方，根据自己的需求来调整图层位置。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeee973195.png" alt="image-20220321164441105" style="zoom: 80%;" /><p>最后一步就是点击右下角的【启动虚拟摄像机】，完成<code>OBS</code>虚拟摄像机配置。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeeed447fe.png" alt="image-20220321164538058" style="zoom:80%;" /><h2 id="腾讯会议-1"><a href="#腾讯会议-1" class="headerlink" title="腾讯会议"></a>腾讯会议</h2><p>现在和前面<code>VTube Studio</code>类似，只需要将【设备】，切换成【<code>OBS Virtual Camera</code>】即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeef0f3320.png" alt="image-20220321164730520" style="zoom:80%;" /><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>我的电脑左侧屏幕放置运行环境，如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeef4d00c4.png" alt="image-20220321165403144" style="zoom: 45%;" /><p>右侧屏幕会议效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaeef918f00.png" alt="image-20220321165458686" style="zoom: 45%;" /><p>别人视角：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee5028bc5.png" alt="image-20220321141443653" style="zoom: 50%;" /><blockquote><p>再次感谢林某爹提高的图片</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>正则表达式是去年夏天我就想说明的东西了，不过一直鸽到现在，这部分将会记录正则表达式的基本语法以及一个C#应用实例。</p><p>关于正则表达式学习个人的相关推荐：</p><ul><li><a href="httpss://github.com/ziishaned/learn-regex">learn-regex</a></li><li><a href="httpss://www.runoob.com/regexp/regexp-tutorial.html">正则表达式 - 教程</a></li><li><a href="httpss://www.bilibili.com/video/BV1da4y1p7iZ">10分钟快速掌握正则表达式</a></li></ul><p>关于正则表达式测试的网站：</p><ul><li><a href="httpss://regexr.com/">RegExr</a></li><li><a href="httpss://regex101.com/">Regulex</a></li></ul><p>关于正则表达式在线生成工具（1&#x2F;2不表示排名）：</p><ul><li><a href="https://tools.jb51.net/regex/create_reg">正则表达式在线生成工具1</a></li><li><a href="httpss://tool.chinaz.com/tools/regexgenerate">正则表达式在线生成工具2</a></li></ul><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>关于正则表达式百度百科的定义如下</p><p><em><strong>正则表达式</strong>，又称规则表达式</em><em>。**（英语：Regular Expression，在代码中常简写为regex、regexp或RE），<a href="httpss://baike.baidu.com/item/计算机科学/9132">计算机科学</a>的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。</em></p><p>通俗来说，就是我们常用的Word搜索功能的加强版，它可以通过特定的语法格式来实现文本搜索（匹配），来满足我们期望找到的文本。</p><blockquote><p> Regular expression（正则表达式）这个词比较拗口，常使用缩写的术语“regex”或“regexp”</p></blockquote><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h2><p><strong>正则表达式的基本匹配是我们常规的搜索类型，即所见即所得</strong>，例如：输入<code>love</code>，则匹配到所有包含该字符的字符串。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef4ad0dfb.png" alt="image-20220227183506406" style="zoom: 80%;" /><p><strong>正则表达式是大小写敏感的</strong>，所以，如果输入<code>Love</code>，它不会匹配上图结果</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef4e493f1.png" alt="image-20220227183634232" style="zoom:80%;" /><blockquote><p>关于图中在输入表达式前面<code>/</code>符号的意义，后面会解释，默认我们输入正则表达式的格式为<code>/这里是我们输入的正则表达式/g</code>。</p></blockquote><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>正则表达式由元字符构成。元字符可以理解为正则表达式控制查找字符串规则的字符，它们具有一定的含义，类似于代码中<code>if</code>表示的是如果的意思。关于一些常规元字符的解释：</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td><code>.</code></td><td>句号匹配任意单个字符除了换行符。</td></tr><tr><td><code>[]</code></td><td>字符种类。匹配方括号内的任意字符。</td></tr><tr><td><code>[^]</code></td><td>否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr><td><code>*</code></td><td>匹配 $\geq 0$个重复的在<code>*</code>号之前的字符。</td></tr><tr><td><code>+</code></td><td>匹配 $\geq 1$个重复的<code>+</code>号前的字符。</td></tr><tr><td><code>?</code></td><td>标记<code>?</code>之前的字符为可选.</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>匹配 num个大括号之前的字符或字符集 ( $n \leq num \leq m$ ).</td></tr><tr><td><code>(xyz)</code></td><td>字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td>&#96;</td><td>&#96;</td></tr><tr><td><code>\</code></td><td>转义字符，用于匹配一些保留的字符 &#96;[ ] ( ) { } . * + ? ^ $ \</td></tr><tr><td><code>^</code></td><td>从开始行开始匹配.</td></tr><tr><td><code>$</code></td><td>从末端开始匹配.</td></tr></tbody></table><h3 id="点运算符"><a href="#点运算符" class="headerlink" title="点运算符."></a>点运算符<code>.</code></h3><p><strong><code>.</code>运算符是一个任意字符的占位符（除换行符）</strong>，例如：<code>.ve</code>表示匹配三个字符（<code>.</code>表示任意字符的占位符），以任意字符开头的且后面跟着<code>ve</code>字符的字符。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef5309d59.png" alt="image-20220227185302789" style="zoom:80%;" /><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>字符集表示的是字符的集合，它通过使用方括号(<code>[]</code>)来表示一个字符集。通过在<code>[]</code>中输入字符来表示匹配字符范围，需要注意的是：方括号中不关心其字符顺序，例如：<code>[a-z]</code>表示的意思是匹配字符集中小写字母<code>a</code>到<code>z</code>的所有字符。如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef562e794.png" alt="image-20220227185650629" style="zoom:80%;" /><p><code>-</code>表示两者的区间，同样的你也可以使用<code>[A-Z]</code>表示所有大写字母<code>A</code>到<code>z</code>的所有字符，或者<code>[0-9]</code>表示所有数值。再例如：<code>[Ll]ove</code>，表示的匹配<code>Love</code>或者<code>love</code>字符，因为<code>l</code>和<code>L</code>字符在字符集中，所以结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef59bafe6.png" alt="image-20220227185956260" style="zoom:80%;" /><h3 id="否定字符集"><a href="#否定字符集" class="headerlink" title="否定字符集"></a>否定字符集</h3><p>否定字符集的意思可以通过<code>^</code>来表示不包含字符集中某些字符，例如：<code>[^L]ove</code>表示的意思是不匹配以大写字符<code>L</code>开头且其后跟着字符<code>ove</code>的字符串。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef5cf3f4e.png" alt="image-20220227190249907" style="zoom:80%;" /><blockquote><p>需要注意的是字符<code>^</code>如果包含在字符集<code>[]</code>中，则其含义是不同的，例如：<code>[^L]</code>和<code>^L</code>的含义是不同的。</p></blockquote><h3 id="重复次数"><a href="#重复次数" class="headerlink" title="重复次数"></a>重复次数</h3><p>元字符<code>*</code>，<code>?</code>，<code>+</code>表示的是对字符出现次数的限制。</p><ul><li><p><strong>元字符<code>*</code></strong></p><p><strong><code>*</code>表示的是匹配在<code>*</code>号之前的字符的出现次数大于等于0次的字符</strong>。例如：<code>a*love</code>表示的意思匹配所有<code>a</code>字符开头且其出现次数大于等于0次，且后面跟着<code>love</code>的字符串。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef60cb2b7.png" alt="image-20220227191311560" style="zoom:80%;" /></li><li><p><strong>元字符<code>+</code></strong></p><p><strong><code>+</code>表示的是匹配在<code>+</code>号之前的字符出现次数大于或者等于1次的字符</strong>。例如：<code>a+love</code>表示的意思是匹配所有以<code>a</code>字符开头的且<code>a</code>字符的出现次数大于等于1次，且后面跟着<code>love</code>的字符串。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef64e2327.png" alt="image-20220227192149840" style="zoom:80%;" /></li><li><p><strong>元字符<code>?</code></strong></p><p><strong><code>?</code>表示的是匹配在<code>?</code>之前的字符出现的次数为 1 次或者 0 次的字符</strong>。例如：<code>a?love</code>表示的意思是匹配所有以字符<code>a</code>出现次数为 0 或者 1 次开头的，且其后面跟随<code>love</code>的字符串。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef6878450.png" alt="image-20220227192412963" style="zoom:80%;" /></li></ul><h3 id=""><a href="#" class="headerlink" title="{}"></a><code>&#123;&#125;</code></h3><p><strong><code>&#123;&#125;</code>表示的是匹配其前面字符指定的出现次数</strong>。例如：<code>a&#123;1,2&#125;love</code>表示的意思是匹配以<code>a</code>字符开始的且<code>a</code>字符的出现次数为 1 次或者 2次的，且其后面跟着<code>love</code>字符的字符串。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef6be9433.png" alt="image-20220227192708702" style="zoom:80%;" /><h3 id="特征标记群"><a href="#特征标记群" class="headerlink" title="(...)特征标记群"></a><code>(...)</code>特征标记群</h3><p><strong><code>()</code>表示的是在<code>()</code>里的字符是一个组合</strong>。这样描述不是很直观，如上述示例：<code>a&#123;1,2&#125;love</code>，表示的<code>a</code>字符的出现次数是 1 次或者 2次，但是如果我们希望<code>ab</code>字符出现的次数是 1 次或者 2次就会很棘手，或许有的伙伴认为可以这样：<code>a&#123;1,2&#125;b&#123;1,2&#125;love</code>，示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef6f62284.png" alt="image-20220227193247291" style="zoom:80%;" /><p>实际上，可以看到第三行的字符<code>abablove</code>也是我们想要匹配的字符，而不是第四行的<code>aabblove</code>字符。这个时候就需要使用特征标记群，例如：<code>(ab)&#123;1,2&#125;love</code>，表示的意思是以字符群<code>ab</code>开始的且其出现次数为 1 次或者 2 次，且其后面跟着字符<code>love</code>的字符串。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef727dbe5.png" alt="image-20220227193510915" style="zoom:80%;" /><h3 id="或运算符"><a href="#或运算符" class="headerlink" title="|或运算符"></a><code>|</code>或运算符</h3><p>同一般的计算机语言，**<code>|</code>表示或者**。例如：<code>(L|l)ove</code>表示匹配以<code>L</code>或者<code>l</code>开头的，且其后跟着<code>ove</code>的字符串。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef75ba10f.png" alt="image-20220227193812583" style="zoom:80%;" /><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>有的时候我们希望匹配的特殊字符是正则表达式的元字符之类的字符，例如我们希望匹配<code>.</code>字符，如果不使用转义字符，则默认被识别为正则表达式的<code>.</code>元字符来处理。所以<strong>我们需要使用<code>\</code>来表示转义字符，其后面跟的字符表示转义我们要使用的字符</strong>。例如：<code>\.love</code>表示匹配以<code>.</code>开始且后跟着<code>love</code>的字符串。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef78f0410.png" alt="image-20220227194152045" style="zoom:80%;" /><p>同理，其他字符也是，例如：<code>\[</code>表示匹配字符<code>[</code>，<code>\+</code>表示匹配字符<code>+</code>等等。</p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p><strong>如果我们希望专门匹配一段文字的开头和末尾的特定字符就离不开锚点</strong>。</p><ul><li><p><strong><code>^</code>开头锚点</strong></p><p><code>^</code>表示开头锚点。例如：<code>^(T|l)ove</code>表示匹配在一段文字的开头其字符为<code>Love</code>或者<code>love</code>的字符串。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef7cad5f2.png" alt="image-20220227194902124" style="zoom:80%;" /><p>需要注意的是<strong>锚点，在不改变匹配规则的情况下，默认只匹配一段文字的开头和末尾字符串</strong>。例如下图，即使第一个字符不匹配，也不会匹配到第二个字符</p><blockquote><p>关于什么是匹配规则，下面的部分会说明</p></blockquote><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef8049cac.png" alt="image-20220227195118609" style="zoom:80%;" /></li><li><p><strong><code>$</code>结尾锚点</strong></p><p>结尾锚点也同理，<strong>只匹配<code>$</code>前面字符与一段文字的最后一个字符串比较</strong>。例如：<code>love$</code>，表示匹配一段位置最后一个字符串是否包含<code>love</code>字符。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef83d5b55.png" alt="image-20220227195516194" style="zoom:80%;" /></li></ul><h3 id="简写字符集"><a href="#简写字符集" class="headerlink" title="简写字符集"></a>简写字符集</h3><p>对于一些常用的字符集，例如<code>[a-z]</code>，<code>[A-Z]</code>，<code>[0-9]</code>等字符集，官方做了整合，使用如下简单字符表达式来表示该公式：</p><table><thead><tr><th>简写</th><th>描述</th></tr></thead><tbody><tr><td><code>.</code></td><td>除换行符外的所有字符</td></tr><tr><td><code>\w</code></td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td><code>\W</code></td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr><td><code>\d</code></td><td>匹配数字： <code>[0-9]</code></td></tr><tr><td><code>\D</code></td><td>匹配非数字： <code>[^\d]</code></td></tr><tr><td><code>\s</code></td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr><td><code>\S</code></td><td>匹配所有非空格字符： <code>[^\s]</code></td></tr><tr><td><code>\f</code></td><td>匹配一个换页符</td></tr><tr><td><code>\n</code></td><td>匹配一个换行符</td></tr><tr><td><code>\r</code></td><td>匹配一个回车符</td></tr><tr><td><code>\t</code></td><td>匹配一个制表符</td></tr><tr><td><code>\v</code></td><td>匹配一个垂直制表符</td></tr><tr><td><code>\p</code></td><td>匹配 CRLF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table><h2 id="零宽度断言（前后预查）"><a href="#零宽度断言（前后预查）" class="headerlink" title="零宽度断言（前后预查）"></a>零宽度断言（前后预查）</h2><p>关于零宽断言的定义，如下斜体引用自百度百科：</p><p><em>零宽断言是<a href="httpss://baike.baidu.com/item/正则表达式/1700215">正则表达式</a>中的一种方法，正则表达式在计算机科学中，是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</em></p><p><strong>我个人理解为是一种筛选字符串的规则，当我们规则某个字符出现为真或者假时则执行的正则表达式取值，类似于将基本的真假判断分支不同处理结果，根据结果引入字符筛选的正则表达式</strong>。</p><p><strong>它是另一种形式的占位符，是一种条件零宽度占位符，所谓零宽度是指的是返回的结果中不包含该断言内容</strong>，例如：<code>(?&lt;=\$)[0-9\.]*</code>表示的意思是：判断字符的开头是否存在字符<code>$</code>，且其后面含有 0 到 9 的，且最后跟着字符<code>.</code>的字符串。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef88a5291.png" alt="image-20220227201637426" style="zoom:80%;" /><p>如上示例使用的是 正后发断言，关于零宽度断言的分类：</p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td><code>?=</code></td><td>正先行断言-存在</td></tr><tr><td><code>?!</code></td><td>负先行断言-排除</td></tr><tr><td><code>?&lt;=</code></td><td>正后发断言-存在</td></tr><tr><td><code>?&lt;!</code></td><td>负后发断言-排除</td></tr></tbody></table><h3 id="正先行断言"><a href="#正先行断言" class="headerlink" title="?=...正先行断言"></a><code>?=...</code>正先行断言</h3><p>**<code>?=</code>正先行断言，表示第一部分表达式之后必须跟着<code>?=</code>定义的表达式。返回结果只包含满足条件的第一部分表达式匹配的内容，定义正先行断言需要使用<code>()</code>**。例如：<code>love(?=\.)</code>表示满足字符<code>love</code>后面存在字符<code>.</code>匹配的字符串，其匹配字符串不包含正先行断言中的内容，即<code>.</code>。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef8c4044b.png" alt="image-20220227203020352" style="zoom:80%;" /><h3 id="负先行断言"><a href="#负先行断言" class="headerlink" title="?!...负先行断言"></a><code>?!...</code>负先行断言</h3><p><strong><code>?!</code>负先行断言，使用格式参考正先行断言，其作用是匹配不包含负先行断言的内容</strong>，理解为正先行断言的取反。例如：<code>love(?!\.)</code>，表示的意思是匹配不包含字符<code>.</code>的，且其前面的字符为<code>love</code>的字符串。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef8fa0a55.png" alt="image-20220227203520175" style="zoom:80%;" /><h3 id="-1"><a href="#-1" class="headerlink" title="?&lt;=...正后发断言"></a><code>?&lt;=...</code>正后发断言</h3><p><strong><code>?&lt;=</code>正后发断言，与正先行断言的区别是匹配的正则表达式要在断言的后面</strong>，例如：<code>(?&lt;=\.)love</code>表示的意思是匹配目标字符串前面存在字符<code>.</code>且包含<code>love</code>的字符串。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef93644a2.png" alt="image-20220227203942318" style="zoom:80%;" /><h3 id="-2"><a href="#-2" class="headerlink" title="?&lt;！...负后发断言"></a><code>?&lt;！...</code>负后发断言</h3><p><strong><code>?&lt;！</code>正后发断言，与负先行断言的区别是匹配的正则表达式要在断言的后面</strong>，例如：<code>(?&lt;!\.)love</code>表示的意思匹配目标字符串前面不存在字符<code>.</code>且包含字符<code>love</code>的字符。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef97496d2.png" alt="image-20220227204518557" style="zoom:80%;" /><blockquote><p>Lookarounds 是零宽度断言的英文</p></blockquote><h2 id="匹配规则（标志）"><a href="#匹配规则（标志）" class="headerlink" title="匹配规则（标志）"></a>匹配规则（标志）</h2><p><strong>匹配规则是一种匹配修正符，用来指控匹配的模式，它也是正则表达式的一部分</strong>。例如：</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td><code>i</code></td><td>忽略大小写。</td></tr><tr><td><code>g</code></td><td>全局搜索。</td></tr><tr><td><code>m</code></td><td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td></tr></tbody></table><p>实际完整的正则表达式的格式为：<code>/这里写正则表达式/匹配规则</code>，一般默认为<code>/我们在这里写正则表达式/g</code>。</p><p>当然实际上对于现在的正则表达式还有很多其他的匹配规则，例如下图，详细的请自行百度或者谷歌查询。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaef9b593e3.png" alt="image-20220227210030517" style="zoom:67%;" /><h3 id="忽略大小写"><a href="#忽略大小写" class="headerlink" title="忽略大小写"></a>忽略大小写</h3><p>可以通过在匹配规则中添加<code>i</code>来表示匹配字符串时忽略大小写。例如：<code>/love/gi</code>表示匹配不区分大小的包含<code>love</code>的字符。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaefa6a1c02.png" alt="image-20220227205116064" style="zoom:80%;" /><blockquote><p><code>i</code>是 insensitive（不区分大小写）的缩写</p></blockquote><h3 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h3><p><code>g</code>表示匹配的返回结果是全部的匹配结果，而不是仅返回第一个匹配的字符。例如：<code>/love/</code>表示仅返回匹配的第一个字符。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaefaa4a76c.png" alt="image-20220227205525750" style="zoom:80%;" /><p>但是如果使用<code>/love/g</code>，则示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaefae03a26.png" alt="image-20220227205603931" style="zoom:80%;" /><blockquote><p><code>g</code>是 global 的缩写</p></blockquote><h3 id="多行修饰符"><a href="#多行修饰符" class="headerlink" title="多行修饰符"></a>多行修饰符</h3><p><code>m</code>是表示执行多行匹配，这么说可能不直观，如图前面说明的锚点，对于开头或者结尾锚点，仅仅匹配一段文字的最后或者末尾一个字符串，但是如果使用了<code>m</code>，即多行修饰符，则会进行多行的开头和结尾匹配。例如：<code>/^love/gm</code>表示的意思是匹配每一行的开头包含<code>love</code>的字符串。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaefb1c6722.png" alt="image-20220227205915365" style="zoom:80%;" /><blockquote><p><code>m</code>是 muti line的缩写</p></blockquote><h2 id="贪婪匹配和惰性匹配（Greedy-vs-lazy-matching）"><a href="#贪婪匹配和惰性匹配（Greedy-vs-lazy-matching）" class="headerlink" title="贪婪匹配和惰性匹配（Greedy vs lazy matching）"></a>贪婪匹配和惰性匹配（Greedy vs lazy matching）</h2><p>正则表达式默认使用贪婪匹配，即尽可能的匹配更长的字符串，可以通过使用<code>?</code>将贪婪匹配模式转换为惰性匹配模式。例如：<code>.*in</code>表示的意思是：匹配空字符字符出现 0 次或者更多次的且后面包含字符<code>in</code>的字符串，这也是正则表达式默认我贪婪匹配模式。示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaefb5420e6.png" alt="image-20220227210739332" style="zoom:80%;" /><p>但是使用<code>.*?in</code>表示尽可能的匹配多段字符，示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaefb8adf4a.png" alt="image-20220227210841149" style="zoom:80%;" /><p>返回了两个字符段，而不是默认的一段长字符段。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaefbcde6eb.png" alt="image-20220227210900987" style="zoom:80%;" /><h1 id="正则表达式应用实例"><a href="#正则表达式应用实例" class="headerlink" title="正则表达式应用实例"></a>正则表达式应用实例</h1><p>本实例使用<code>C#</code>代码，基于 Winform 来实现。</p><p>实例内容：利用正则表达式来实现规定用户注册账户的时候，用户名仅限于英文字母和数字以及下划线的组合；而密码仅限于字母和数字的组合。</p><ol><li><p>使用 Winform 简单设计一个如下的注册窗口</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaefc08b4eb.png" alt="image-20220227211623290" style="zoom:80%;" /></li><li><p>然后在注册按钮的事件中，使用如下代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> pattern1 = <span class="string">@&quot;^\w+$&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> pattern2 = <span class="string">@&quot;^[A-Za-z0-9]+$&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (textBox1.Text == <span class="string">&quot;&quot;</span> || textBox2.Text == <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">&quot;请输入用户名或者密码&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Regex.IsMatch(textBox1.Text, pattern1) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(<span class="string">&quot;用户名格式不正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Regex.IsMatch(textBox2.Text, pattern2) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">&quot;密码格式不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">&quot;注册成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>当我们输入包含<code>?</code>字符的用户名时，则弹出错误提醒：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaefc59959d.png" alt="image-20220227214041819" style="zoom: 67%;" /></li><li><p>如果输入含有<code>?</code>字符的密码时，则弹出错误提醒：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaefc96813b.png" alt="image-20220227214144302" style="zoom:67%;" /></li><li><p>只有输入正确的用户名和密码格式，才会注册成功：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaefcda1b10.png" alt="image-20220227214245587" style="zoom:67%;" /></li></ol><h1 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h1><h2 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h2><ul><li>数字：**<code>^[0-9]\*$</code>**</li><li>n位的数字：**<code>^\d&#123;n&#125;$</code>**</li><li>至少n位的数字：**<code>^\d&#123;n,&#125;$</code>**</li><li>m-n位的数字：**<code>^\d&#123;m,n&#125;$</code>**</li><li>零和非零开头的数字：**<code>^(0|[1-9][0-9]\*)$</code>**</li><li>非零开头的最多带两位小数的数字：**<code>^([1-9][0-9]\*)+(\.[0-9]&#123;1,2&#125;)?$</code>**</li><li>带1-2位小数的正数或负数：**<code>^(\-)?\d+(\.\d&#123;1,2&#125;)$</code>**</li><li>正数、负数、和小数：**<code>^(\-|\+)?\d+(\.\d+)?$</code>**</li><li>有两位小数的正实数：**<code>^[0-9]+(\.[0-9]&#123;2&#125;)?$</code>**</li><li>有1~3位小数的正实数：**<code>^[0-9]+(\.[0-9]&#123;1,3&#125;)?$</code>**</li><li>非零的正整数：**<code>^[1-9]\d\*$</code> 或 <code>^([1-9][0-9]\*)&#123;1,3&#125;$</code> 或 <code>^\+?[1-9][0-9]\*$</code>**</li><li>非零的负整数：**<code>^\-[1-9][]0-9&quot;\*$</code> 或 <code>^-[1-9]\d\*$</code>**</li><li>非负整数：**<code>^\d+$</code> 或 <code>^[1-9]\d\*|0$</code>**</li><li>非正整数：**<code>^-[1-9]\d\*|0$</code> 或 <code>^((-\d+)|(0+))$</code>**</li><li>非负浮点数：**<code>^\d+(\.\d+)?$</code> 或 <code>^[1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*|0?\.0+|0$</code>**</li><li>非正浮点数：**<code>^((-\d+(\.\d+)?)|(0+(\.0+)?))$</code> 或 <code>^(-([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*))|0?\.0+|0$</code>**</li><li>正浮点数：**<code>^[1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*$</code> 或 <code>^(([0-9]+\.[0-9]\*[1-9][0-9]\*)|([0-9]\*[1-9][0-9]\*\.[0-9]+)|([0-9]\*[1-9][0-9]\*))$</code>**</li><li>负浮点数：**<code>^-([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*)$</code> 或 <code>^(-(([0-9]+\.[0-9]\*[1-9][0-9]\*)|([0-9]\*[1-9][0-9]\*\.[0-9]+)|([0-9]\*[1-9][0-9]\*)))$</code>**</li><li>浮点数：**<code>^(-?\d+)(\.\d+)?$</code> 或 <code>^-?([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*|0?\.0+|0)$</code>**</li></ul><h2 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h2><ul><li>汉字：**<code>^[\u4e00-\u9fa5]&#123;0,&#125;$</code>**</li><li>英文和数字：**<code>^[A-Za-z0-9]+$</code> 或 <code>^[A-Za-z0-9]&#123;4,40&#125;$</code>**</li><li>长度为3-20的所有字符：**<code>^.&#123;3,20&#125;$</code>**</li><li>由26个英文字母组成的字符串：**<code>^[A-Za-z]+$</code>**</li><li>由26个大写英文字母组成的字符串：**<code>^[A-Z]+$</code>**</li><li>由26个小写英文字母组成的字符串：**<code>^[a-z]+$</code>**</li><li>由数字和26个英文字母组成的字符串：**<code>^[A-Za-z0-9]+$</code>**</li><li>由数字、26个英文字母或者下划线组成的字符串：**<code>^\w+$</code> 或 <code>^\w&#123;3,20&#125;$</code>**</li><li>中文、英文、数字包括下划线：**<code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code>**</li><li>中文、英文、数字但不包括下划线等符号：**<code>^[\u4E00-\u9FA5A-Za-z0-9]+$</code> 或 <code>^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</code>**</li><li>可以输入含有^%&amp;’,;&#x3D;? $&quot;等字符：**<code>[^%&amp;&#39;,;=?$\x22]+</code>**</li><li>禁止输入含有<del>的字符：**&#96;[^</del>\x22]+&#96;**</li></ul><h2 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h2><ul><li>Email地址：**<code>^\w+([-+.]\w+)\*@\w+([-.]\w+)\*\.\w+([-.]\w+)\*$</code>**</li><li>域名：**<code>[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(\.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+\.?</code>**</li><li>InternetURL：**<code>[a-zA-z]+://[^\s]\*</code> 或 <code>^https://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]\*)?$</code>**</li><li>手机号码：**<code>^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</code>**</li><li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：**<code>^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</code>**</li><li>国内电话号码(0511-4405222、021-87888822)：**<code>\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</code>**</li><li>电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: <strong><code>((\d&#123;11&#125;)|^((\d&#123;7,8&#125;)|(\d&#123;4&#125;|\d&#123;3&#125;)-(\d&#123;7,8&#125;)|(\d&#123;4&#125;|\d&#123;3&#125;)-(\d&#123;7,8&#125;)-(\d&#123;4&#125;|\d&#123;3&#125;|\d&#123;2&#125;|\d&#123;1&#125;)|(\d&#123;7,8&#125;)-(\d&#123;4&#125;|\d&#123;3&#125;|\d&#123;2&#125;|\d&#123;1&#125;))$)</code></strong></li><li>身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：**<code>(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)</code>**</li><li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：**<code>^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</code>**</li><li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：**<code>^[a-zA-Z]\w&#123;5,17&#125;$</code>**</li><li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：**<code>^(?=.\*\d)(?=.\*[a-z])(?=.\*[A-Z])[a-zA-Z0-9]&#123;8,10&#125;$</code>**</li><li>强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：**<code>^(?=.\*\d)(?=.\*[a-z])(?=.\*[A-Z]).&#123;8,10&#125;$</code>**</li><li>日期格式：**<code>^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</code>**</li><li>一年的12个月(01～09和1～12)：**<code>^(0?[1-9]|1[0-2])$</code>**</li><li>一个月的31天(01～09和1～31)：**<code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code>**</li><li>钱的输入格式：<ol><li>有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：**<code>^[1-9][0-9]\*$</code>**</li><li>这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：**<code>^(0|[1-9][0-9]\*)$</code>**</li><li>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：**<code>^(0|-?[1-9][0-9]\*)$</code>**</li><li>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：**<code>^[0-9]+(.[0-9]+)?$</code>**</li><li>必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：**<code>^[0-9]+(.[0-9]&#123;2&#125;)?$</code>**</li><li>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：**<code>^[0-9]+(.[0-9]&#123;1,2&#125;)?$</code>**</li><li>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：**<code>^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)\*(.[0-9]&#123;1,2&#125;)?$</code>**</li><li>1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：**<code>^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)\*)(.[0-9]&#123;1,2&#125;)?$</code>**</li><li>备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</li></ol></li><li>xml文件：**<code>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</code>**</li><li>中文字符的正则表达式：**<code>[\u4e00-\u9fa5]</code>**</li><li>双字节字符：**<code>[^\x00-\xff]</code> (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))**</li><li>空白行的正则表达式：**<code>\n\s\*\r</code> (可以用来删除空白行)**</li><li>HTML标记的正则表达式：**<code>&lt;(\S\*?)[^&gt;]\*&gt;.\*?|&lt;.\*? /&gt;</code> ( 首尾空白字符的正则表达式：<code>^\s\*|\s\*$或(^\s\*)|(\s\*$</code>) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)**</li><li>腾讯QQ号：**<code>[1-9][0-9]&#123;4,&#125;</code> (腾讯QQ号从10000开始)**</li><li>中国邮政编码：**<code>[1-9]\d&#123;5&#125;(?!\d)</code> (中国邮政编码为6位数字)**</li><li>IPv4地址：**<code>((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125;</code>**</li></ul><blockquote><p>该常用正则表达式内容来源：<a href="httpss://c.runoob.com/front-end/854/">点击访问</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【NEW-4.0】R-基本图形</title>
      <link href="/2022/05/13/%E8%AF%AD%E8%A8%80%E6%A0%91/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-4.0%E3%80%91%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2/"/>
      <url>/2022/05/13/%E8%AF%AD%E8%A8%80%E6%A0%91/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-4.0%E3%80%91%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这不是基本图形的说明使用，例如常见的条形图，饼图，直方图等，此内容可以当作快速查阅手册。</p><h1 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h1><h2 id="简单条形图"><a href="#简单条形图" class="headerlink" title="简单条形图"></a>简单条形图</h2><p><strong>条形图通过函数<code>barplot()</code>来实现</strong>，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">barplot<span class="punctuation">(</span>height<span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> space <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">        names.arg <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> legend.text <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> beside <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">        horiz <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> density <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> angle <span class="operator">=</span> <span class="number">45</span><span class="punctuation">,</span></span><br><span class="line">        col <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> border <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;fg&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        main <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> sub <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ylab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">        xlim <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ylim <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> xpd <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="built_in">log</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        axes <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> axisnames <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">        cex.axis <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;cex.axis&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> cex.names <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;cex.axis&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        inside <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> plot <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> axis.lty <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> offset <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        add <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> ann <span class="operator">=</span> <span class="operator">!</span>add <span class="operator">&amp;&amp;</span> par<span class="punctuation">(</span><span class="string">&quot;ann&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> args.legend <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>height</code>：接收一个向量参数，根据向量参数内容绘制图形</strong></li><li>**<code>horiz = TRUE</code>**：设置为<code>TRUE</code>则图形会生成水平条形图</li><li><strong><code>main</code>：图形标题</strong></li><li><strong><code>xlab</code>：X 轴标签</strong></li><li><strong><code>ylab</code>：Y 轴标签</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">barplot<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">,</span>horiz <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>main <span class="operator">=</span> <span class="string">&#x27;这是标题&#x27;</span><span class="punctuation">,</span></span><br><span class="line">        xlab<span class="operator">=</span><span class="string">&#x27;这是X轴&#x27;</span><span class="punctuation">,</span>ylab<span class="operator">=</span><span class="string">&#x27;这是Y轴&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc08a0f761.png" alt="image-20220512200201549" style="zoom:50%;" /><p>如果<strong>希望标签距离图表更近一些</strong>，可以通过<strong>额外设置<code>mtext</code>来增加外边框的文本标签</strong>，例如：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">barplot<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">,</span>horiz <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>main <span class="operator">=</span> <span class="string">&#x27;这是标题&#x27;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">,</span>ylab<span class="operator">=</span><span class="string">&#x27;这是Y轴&#x27;</span><span class="punctuation">)</span></span><br><span class="line">mtext<span class="punctuation">(</span><span class="string">&#x27;这是X轴&#x27;</span><span class="punctuation">,</span>side<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span>line <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc08dd4407.png" alt="image-20220512202945242" style="zoom:50%;" /><blockquote><p>如果需要绘制的变量是一个因子或者有序型因子，可以直接使用<code>plot()</code>绘制垂直条形图</p></blockquote><h2 id="堆砌条形图和分组条形图"><a href="#堆砌条形图和分组条形图" class="headerlink" title="堆砌条形图和分组条形图"></a>堆砌条形图和分组条形图</h2><p><strong>如果传入的<code>Height</code>参数不是向量而是一个矩阵，则绘制的结果是堆砌条形图或者分组条形图</strong>。<strong>堆砌条形图和分组条形图取决于参数<code>beside=FALSE/TRUE</code><strong>，</strong>如果为<code>TRUE</code>，则矩阵中的每一列表示一个分组，各列的值将并列而不是堆砌；如果为<code>FALSE</code>，则矩阵中的每一列都生成图中的一个条形，其高度取决于其值。</strong></p><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">opar <span class="operator">=</span> par<span class="punctuation">(</span>no.readonly <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 将图形分割成一行两列</span></span><br><span class="line">par<span class="punctuation">(</span>mfrow<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 绘制堆砌条形图</span></span><br><span class="line">barplot<span class="punctuation">(</span>matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 绘制分组条形图</span></span><br><span class="line">barplot<span class="punctuation">(</span>matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span>beside <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>opar<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc091d8b24.png" alt="image-20220512204141414" style="zoom: 67%;" /><h2 id="均值条形图"><a href="#均值条形图" class="headerlink" title="均值条形图"></a>均值条形图</h2><p>可以将数据计算出各种平均值，中位值等结果生成相关条形图，代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">barplot<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>summary<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        names.arg <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;Min.&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;1st Qu.&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;Median&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;Mean&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;3rd Qu.&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;Max&#x27;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        las<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc0954cd19.png" alt="image-20220512212911555" style="zoom: 67%;" /><blockquote><p>关于文本显示不全问题，可以参考<a href="httpss://helloseraphine.top/index.php/archives/560.html">关于R以及Rstudio的相关问题</a>，或者查看下面内容</p></blockquote><h3 id="条形图微调"><a href="#条形图微调" class="headerlink" title="条形图微调"></a>条形图微调</h3><p>随着条数的增多，标签可能会重叠或者消失，可以通过如下参数来调整：</p><ul><li><strong><code>cex.names</code>：（数值型）小于 1 的数值表示缩小标签字体大小</strong></li><li><strong><code>names.arg</code>：（向量）允许自定义标签内容</strong></li><li><strong><code>las=2</code>：旋转字体朝向</strong></li></ul><h2 id="棘状图"><a href="#棘状图" class="headerlink" title="棘状图"></a>棘状图</h2><p>这是一种特殊的条形图，<strong>棘状图对堆砌图进行重缩放，使得每个条形的总值为 1 ，而每一段数据则以比例来呈现。棘状图可以通过<code>vcd</code>包中的<code>spine()</code>来绘制</strong>，代码示例：</p><blockquote><p>注意：<code>spine</code>传递的参数必须是双向表，即<code>table</code></p></blockquote><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 棘状图</span></span><br><span class="line">library<span class="punctuation">(</span>vcd<span class="punctuation">)</span></span><br><span class="line">a <span class="operator">&lt;-</span> table<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">,</span>trees<span class="operator">$</span>Height<span class="punctuation">)</span></span><br><span class="line">spine<span class="punctuation">(</span>a<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc099da05f.png" alt="image-20220512215113129" style="zoom:50%;" /><h1 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h1><p>饼图随处可见，可以<strong>通过函数<code>pie</code>来创建</strong>，其函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pie<span class="punctuation">(</span>x<span class="punctuation">,</span> labels <span class="operator">=</span> <span class="built_in">names</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">,</span> edges <span class="operator">=</span> <span class="number">200</span><span class="punctuation">,</span> radius <span class="operator">=</span> <span class="number">0.8</span><span class="punctuation">,</span></span><br><span class="line">    clockwise <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> init.angle <span class="operator">=</span> <span class="keyword">if</span><span class="punctuation">(</span>clockwise<span class="punctuation">)</span> <span class="number">90</span> <span class="keyword">else</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    density <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> angle <span class="operator">=</span> <span class="number">45</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> border <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">    lty <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> main <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>x</code>：（数值型）表示每个扇形所占的面积</strong></li><li><strong><code>labels</code>：（向量&#x2F;单体取决于X）表示每个扇形的标签</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 饼图</span></span><br><span class="line">a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">pie<span class="punctuation">(</span>a<span class="punctuation">,</span>labels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;苹果&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;西瓜&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;橘子&#x27;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc09e8bf53.png" alt="image-20220512215613638" style="zoom:80%;" /><p>如果希望<strong>实现<code>3D</code>饼图的效果，则可以使用<code>plotrix</code>包中的<code>pie3D()</code>函数来实现</strong>，代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3D饼图</span></span><br><span class="line">library<span class="punctuation">(</span>plotrix<span class="punctuation">)</span></span><br><span class="line">a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2.2</span><span class="punctuation">)</span></span><br><span class="line">name <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;苹果&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;西瓜&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;橘子&#x27;</span><span class="punctuation">)</span></span><br><span class="line">pie3D<span class="punctuation">(</span>a<span class="punctuation">,</span>labels<span class="operator">=</span>name<span class="punctuation">,</span>explode <span class="operator">=</span> <span class="number">0.1</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>explode</code>：表示饼的分离程度</strong></li></ul><p>运行效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc0a1d948c.png" alt="image-20220513184517721" style="zoom:50%;" /><p>如上图，在不标注标签数值的情况下，我们的肉眼获取无法区分”西瓜”和”橘子”的大小区别，这个时候可以使用<strong>扇形图</strong>。它是<strong>通过<code>plotrix</code>包中的<code>fan.plot()</code>函数来实现的</strong>。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3D饼图</span></span><br><span class="line">library<span class="punctuation">(</span>plotrix<span class="punctuation">)</span></span><br><span class="line">a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2.2</span><span class="punctuation">)</span></span><br><span class="line">name <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;苹果&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;西瓜&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;橘子&#x27;</span><span class="punctuation">)</span></span><br><span class="line">fan.plot<span class="punctuation">(</span>a<span class="punctuation">,</span>labels<span class="operator">=</span>name<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc0a4d8b42.png" alt="image-20220513190120549" style="zoom:50%;" /><h1 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h1><p><strong>直方图是一种类似于条形图的图</strong>，它通过将X轴的值连续起来，然后Y值显示其高度，<strong>通过函数<code>hist()</code>函数来创建</strong>，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hist<span class="punctuation">(</span>x<span class="punctuation">,</span> breaks <span class="operator">=</span> <span class="string">&quot;Sturges&quot;</span><span class="punctuation">,</span></span><br><span class="line">     freq <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> probability <span class="operator">=</span> <span class="operator">!</span>freq<span class="punctuation">,</span></span><br><span class="line">     include.lowest <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> right <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> fuzz <span class="operator">=</span> <span class="number">1e-7</span><span class="punctuation">,</span></span><br><span class="line">     density <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> angle <span class="operator">=</span> <span class="number">45</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;lightgray&quot;</span><span class="punctuation">,</span> border <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">     main <span class="operator">=</span> paste<span class="punctuation">(</span><span class="string">&quot;Histogram of&quot;</span> <span class="punctuation">,</span> xname<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">     xlim <span class="operator">=</span> <span class="built_in">range</span><span class="punctuation">(</span>breaks<span class="punctuation">)</span><span class="punctuation">,</span> ylim <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">     xlab <span class="operator">=</span> xname<span class="punctuation">,</span> ylab<span class="punctuation">,</span></span><br><span class="line">     axes <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> plot <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> labels <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">     nclass <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> warn.unused <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>x</code>：数据值</strong></li><li><strong><code>freq</code>：（布尔值）当值为<code>FLASE</code>表示根据概率密度而不是频数绘制图形</strong></li><li><strong><code>breaks</code>：用于控制组的数量</strong></li></ul><p>在定义直方图中的单元时，默认将生成等距切分。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直方图</span></span><br><span class="line">par<span class="punctuation">(</span>mfrow<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 普通直方图</span></span><br><span class="line">hist<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 概率密度直方图</span></span><br><span class="line">hist<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">,</span>freq <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 添加密度曲线</span></span><br><span class="line">hist<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">,</span>freq <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">lines<span class="punctuation">(</span>density<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc0a908317.png" alt="image-20220513192146545" style="zoom: 67%;" /><ul><li><strong><code>density(x)</code>：生成密度数据</strong></li></ul><h1 id="核密度图"><a href="#核密度图" class="headerlink" title="核密度图"></a>核密度图</h1><p>核密度图时用于估计随机变量密度概率的一种非参数方法，绘制核密度图的方法为：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>density<span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 核密度图</span></span><br><span class="line">opar <span class="operator">&lt;-</span> par<span class="punctuation">(</span>no.readonly <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>mfrow<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 基本和密度图</span></span><br><span class="line">plot<span class="punctuation">(</span>density<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span><span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;核密度图&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 颜色填充核密度图</span></span><br><span class="line">plot<span class="punctuation">(</span>density<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span><span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;核密度图&#x27;</span><span class="punctuation">)</span></span><br><span class="line">polygon<span class="punctuation">(</span>density<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span><span class="punctuation">,</span>col <span class="operator">=</span> <span class="string">&#x27;black&#x27;</span><span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>opar<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>polygon</code>：绘制指定值下的多边形区域</strong>，可以理解为填充指定区域</li></ul><p>运行效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc0ac73a2b.png" alt="image-20220513193651584" style="zoom: 67%;" /><p><strong>核密度可以通过分组来比较组间的差异，可以通过使用<code>sm</code>包中的<code>sm.density.compare()</code>来实现</strong>，具体方法和实现效果自行查询，此处不做说明。</p><h1 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a>箱线图</h1><p>箱线图又称为盒须图，<strong>通过绘制连续型变量的五数总括，即最小值，下四分位数（第25百分位数），中位数（第50百分位数），上四分位数（第75百分位数）以及最大值，描述了连续型变量的分布</strong>。</p><p><strong>通过函数<code>boxplot</code>来实现</strong>，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boxplot<span class="punctuation">(</span>formula<span class="punctuation">,</span> data <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ...<span class="punctuation">,</span> subset<span class="punctuation">,</span> na.action <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">        xlab <span class="operator">=</span> mklab<span class="punctuation">(</span>y_var <span class="operator">=</span> horizontal<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        ylab <span class="operator">=</span> mklab<span class="punctuation">(</span>y_var <span class="operator">=</span><span class="operator">!</span>horizontal<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        add <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> ann <span class="operator">=</span> <span class="operator">!</span>add<span class="punctuation">,</span> horizontal <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">        drop <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span> lex.order <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 箱线图</span></span><br><span class="line">boxplot<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc0afaf93e.png" alt="image-20220513195516930" style="zoom:50%;" /><p><strong>可以通过<code>boxplot.stats(x)</code>来输出用于构建图形的统计量</strong>。</p><h2 id="并列箱线图"><a href="#并列箱线图" class="headerlink" title="并列箱线图"></a>并列箱线图</h2><p>可以通过传入参数的时候传入如下格式的参数即可：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boxplot<span class="punctuation">(</span>并列数据<span class="number">1</span><span class="operator">~</span>并列数据<span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><blockquote><p>具体用法和实现效果自行查询，此处不做说明</p></blockquote><h2 id="小提琴图"><a href="#小提琴图" class="headerlink" title="小提琴图"></a>小提琴图</h2><p>有一种特殊的箱线图，<strong>它结合了核密度图</strong>，形成了新的图形即小提琴图。</p><p>可以通过<code>vioplot</code>包中的<code>vioplot()</code>函数来绘制，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vioplot<span class="punctuation">(</span>x<span class="punctuation">,</span> use.cols <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小提琴图</span></span><br><span class="line">library<span class="punctuation">(</span>vioplot<span class="punctuation">)</span></span><br><span class="line">vioplot<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc0b31fd53.png" alt="image-20220513200708708" style="zoom:50%;" /><blockquote><p>关于小提琴图的更多说明，请自行查询</p></blockquote><h1 id="点图"><a href="#点图" class="headerlink" title="点图"></a>点图</h1><p>点图顾名思义，在图中根据数据绘制大量的点，可以<strong>通过<code>dotchart()</code>函数来实现</strong>，其函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dotchart<span class="punctuation">(</span>x<span class="punctuation">,</span> labels <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> groups <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> gdata <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> offset <span class="operator">=</span> <span class="number">1</span><span class="operator">/</span><span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">         ann <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;ann&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> xaxt <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;xaxt&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> frame.plot <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="built_in">log</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">         cex <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;cex&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> pt.cex <span class="operator">=</span> cex<span class="punctuation">,</span></span><br><span class="line">         pch <span class="operator">=</span> <span class="number">21</span><span class="punctuation">,</span> gpch <span class="operator">=</span> <span class="number">21</span><span class="punctuation">,</span> bg <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;bg&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">         color <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;fg&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> gcolor <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;fg&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> lcolor <span class="operator">=</span> <span class="string">&quot;gray&quot;</span><span class="punctuation">,</span></span><br><span class="line">         xlim <span class="operator">=</span> <span class="built_in">range</span><span class="punctuation">(</span>x<span class="punctuation">[</span><span class="built_in">is.finite</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">         main <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ylab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>labels</code>：用来指点每个点的标签</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 点图</span></span><br><span class="line">dotchart<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc0b6b2b3e.png" alt="image-20220513201323377" style="zoom:50%;" /><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>关于 R 的基本图形如上所示，其更多的自定义参数可以查询官方文档，或者自行网络查询。</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于R以及Rstudio的相关问题</title>
      <link href="/2022/05/10/%E8%AF%AD%E8%A8%80%E6%A0%91/R%E8%AF%AD%E8%A8%80/%E5%85%B3%E4%BA%8ER%E4%BB%A5%E5%8F%8ARstudio%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/10/%E8%AF%AD%E8%A8%80%E6%A0%91/R%E8%AF%AD%E8%A8%80/%E5%85%B3%E4%BA%8ER%E4%BB%A5%E5%8F%8ARstudio%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分记录我所遇到的相关R及其Rstudio的问题，以及一些需要快速查阅和记忆的东西，由于问题过于琐碎，本来不愿意单独写出，如今记录成一篇文章，以此记录。</p><h1 id="快速查阅"><a href="#快速查阅" class="headerlink" title="快速查阅"></a>快速查阅</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td><code>Ctrl + L</code></td><td>清空控制台</td></tr><tr><td><code>Ctrl + 1</code></td><td>光标聚焦到代码编辑区</td></tr><tr><td><code>Ctrl + 2</code></td><td>光标聚焦到控制台区域</td></tr><tr><td><code>Ctrl + 3</code></td><td>焦点聚焦到帮助区域</td></tr><tr><td><code>Ctrl + 5</code></td><td>焦点到文件区域</td></tr><tr><td><code>Ctrl + 6</code></td><td>光标聚焦到图上</td></tr><tr><td><code>Ctrl + 7</code></td><td>焦点聚焦到包区域上</td></tr><tr><td><code>Ctrl + 8</code></td><td>光标聚焦到环境上</td></tr><tr><td><code>Ctrl + Enter</code></td><td>运行当前行</td></tr><tr><td><code>Ctrl + Shift + Enter</code></td><td>运行当前<code>R</code>文件</td></tr><tr><td><code>Alt + -</code></td><td>左赋值号</td></tr><tr><td><code>Alt + =</code></td><td>右赋值号</td></tr><tr><td><code>Ctrl + Shift + M</code></td><td><code>%&gt;%</code></td></tr><tr><td><code>Ctrl+Shift+C</code></td><td>注释&#x2F;取消注释行</td></tr><tr><td><code>Alt + Shift + K</code></td><td>快捷键帮助面板</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="常用查询命令"><a href="#常用查询命令" class="headerlink" title="常用查询命令"></a>常用查询命令</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>nrow(obj)</code></td><td>查看数据多少行</td></tr><tr><td><code>ncol(obj)</code></td><td>查看数据多少列</td></tr><tr><td><code>dim(obj)</code></td><td>查看多少行，多少列</td></tr><tr><td><code>head(obj)</code></td><td>查看前六行的数据</td></tr><tr><td><code>tail(obj)</code></td><td>查看最后六行数据</td></tr><tr><td><code>summary(obj)</code></td><td>数据汇总</td></tr><tr><td><code>str(obj)</code></td><td>查看数据的结构</td></tr><tr><td><code>names(obj)</code></td><td>查询行列名称</td></tr><tr><td><code>mode(obj)</code></td><td>查询对象的类型</td></tr><tr><td><code>ls()</code></td><td>查询当前所有对象</td></tr></tbody></table><h2 id="常用计算函数"><a href="#常用计算函数" class="headerlink" title="常用计算函数"></a>常用计算函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>mean(obj)</code></td><td>平均值</td></tr><tr><td><code>max(obj)</code></td><td>最大值</td></tr><tr><td><code>min(obj)</code></td><td>最小值</td></tr><tr><td><code>var(obj)</code></td><td>方差</td></tr><tr><td><code>sd(obj)</code></td><td>标准差</td></tr><tr><td><code>median(obj)</code></td><td>中位数</td></tr><tr><td><code>sort(obj)</code></td><td>从小到大排序</td></tr><tr><td><code>diff(obj)</code></td><td>连续相互差值</td></tr></tbody></table><h2 id="常用操作函数"><a href="#常用操作函数" class="headerlink" title="常用操作函数"></a>常用操作函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>cbind(obj,obj,..)</code></td><td>按列合并对象</td></tr><tr><td><code>rbind(obj,obj,..)</code></td><td>按行合并对象</td></tr><tr><td><code>rm(obj,obj,..)</code></td><td>删除一个或者更对象</td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><h2 id="使用宏包时提醒需要更高版本R的支持"><a href="#使用宏包时提醒需要更高版本R的支持" class="headerlink" title="使用宏包时提醒需要更高版本R的支持"></a>使用宏包时提醒需要更高版本R的支持</h2><p>【解决办法】</p><ol><li><strong>更新R的版本</strong>，保证R的版本大于等于宏包最低支持版本</li><li><strong>从<a href="httpss://cran.r-project.org/web/packages/available_packages_by_name.html">CRAN</a>上查找对应宏包的源码地址，选择旧版本手动安装宏包</strong></li></ol><h2 id="更新R版本后，Rstudio打开报错"><a href="#更新R版本后，Rstudio打开报错" class="headerlink" title="更新R版本后，Rstudio打开报错"></a>更新R版本后，Rstudio打开报错</h2><p>【解决办法】</p><ol><li><p>优先尝试，<strong>启动<code>Rstudio</code>的时候，按住<code>Ctrl</code>键不放，直到弹出，如下相关提醒</strong>，然后选择相关版本尝试启动。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc11a13212.png" alt="image-20220507153316333" style="zoom:80%;" /></li><li><p>第一种方法不管用的话，就<strong>卸载<code>Rstudio</code>，再重新安装即可</strong>。</p></li></ol><h2 id="使用Source函数运行脚本，显示空图"><a href="#使用Source函数运行脚本，显示空图" class="headerlink" title="使用Source函数运行脚本，显示空图"></a>使用Source函数运行脚本，显示空图</h2><p>【原因】</p><p>**由于<code>Rstudio</code>的BUG导致的，检测使用<code>Source()</code>运行的R脚本实际大小是否为<code>0KB</code>**，也可以尝试用记事本打开运行不出图的R脚本，如果内容为空，则看如下解决办法</p><p>【解决办法】</p><p>手动在文件中剪切全部内容，然后粘贴回去，保存。只要<strong>确保R文件拥有实际大小或者记事本打开后存在代码内容即可</strong>。</p><h2 id="生成图形的时候图形标签显示不全"><a href="#生成图形的时候图形标签显示不全" class="headerlink" title="生成图形的时候图形标签显示不全"></a>生成图形的时候图形标签显示不全</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc11e4a6de.png" alt="image-20220512213309607" style="zoom:50%;" /><p>【原因】</p><p><strong>标签文本太长，无法全部显示</strong>，于是显示个别标签。</p><p>【解决办法】</p><p><strong>可以尝试使用<code>las=2</code>，来让文字旋转竖排来解决</strong>。如果你对于竖排不满意，可以尝试去隐藏默认的坐标轴，然后手动绘制坐标轴来定义参数。</p><h2 id="通过par修改图形参数，怎么恢复默认设置"><a href="#通过par修改图形参数，怎么恢复默认设置" class="headerlink" title="通过par修改图形参数，怎么恢复默认设置"></a>通过<code>par</code>修改图形参数，怎么恢复默认设置</h2><p>【原因】</p><p><strong><code>par</code>函数修改的图形参数属于全局设置</strong>，即使已经删除了相关代码，如果运行过一次，该参数已被记录，除非设置回去默认的值</p><p>【解决办法】</p><ol><li><p><strong>直接关闭<code>R</code>或者<code>RStudio</code>，然后重新打开即可</strong>。</p></li><li><p>在<strong>使用<code>par</code>函数修改参数的时候，使用如下的方式修改</strong>：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opar <span class="operator">&lt;-</span> par<span class="punctuation">(</span>no.readonly <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 这里写你的图形代码</span></span><br><span class="line">par<span class="punctuation">(</span>opar<span class="punctuation">)</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【NEW-3.0】R-图形初阶</title>
      <link href="/2022/05/07/%E8%AF%AD%E8%A8%80%E6%A0%91/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-3.0%E3%80%91%E5%9B%BE%E5%BD%A2%E5%88%9D%E9%98%B6/"/>
      <url>/2022/05/07/%E8%AF%AD%E8%A8%80%E6%A0%91/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-3.0%E3%80%91%E5%9B%BE%E5%BD%A2%E5%88%9D%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>千呼万唤始出来，终于到了图形这部分，这部分主要说明如何创建和保存图形以及图形相关常用的参数使用。</p><h1 id="图形相关基础函数"><a href="#图形相关基础函数" class="headerlink" title="图形相关基础函数"></a>图形相关基础函数</h1><h2 id="使用图形"><a href="#使用图形" class="headerlink" title="使用图形"></a>使用图形</h2><p>首先，先在你的R上运行如下代码：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 1.jpg 的文件</span></span><br><span class="line">jpeg<span class="punctuation">(</span><span class="string">&#x27;1.jpg&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 绑定trees数据</span></span><br><span class="line">attach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 根据Height和Volume绘制点图形</span></span><br><span class="line">plot<span class="punctuation">(</span>Height<span class="punctuation">,</span>Volume<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 自定义图形标题</span></span><br><span class="line">title<span class="punctuation">(</span><span class="string">&quot;这是一个标题&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 解除绑定trees数据</span></span><br><span class="line">detach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 返回输出结果</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行后会在当前工作目录下产生一个名称为<code>1.jpg</code>的图片，如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc02ec86b1.png" alt="image-20220507194124730" style="zoom: 50%;" /><p>这就是所生成的图形，利用的是<code>trees</code>数据所生成的图形。</p><h2 id="图形输出"><a href="#图形输出" class="headerlink" title="图形输出"></a>图形输出</h2><p>用于图形输出的函数如下所示：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>pdf(&#39;filename.pdf&#39;)</code></td><td>输出<code>PDF</code>文件</td></tr><tr><td><code>png(&#39;filename.png&#39;)</code></td><td>输出<code>PNG</code>文件</td></tr><tr><td><code>jpeg(&#39;filename.jpg/jpeg&#39;)</code></td><td>输出<code>JPG</code>文件</td></tr><tr><td><code>bmp(&#39;filename.bmp&#39;)</code></td><td>输出<code>BMP</code>文件</td></tr></tbody></table><p>需要注意的是<strong>使用上述函数输出图片后要使用<code>dev.off()</code>函数来完成文件输出</strong>。</p><blockquote><p>关于<code>JPG</code>和<code>JPEG</code>的区别可以参考我这篇文章<a href="httpss://www.helloseraphine.top/static/%E7%90%90%E7%A2%8E%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html">琐碎问题记录</a>。</p></blockquote><h1 id="图形参数"><a href="#图形参数" class="headerlink" title="图形参数"></a>图形参数</h1><p>我们可以通过修改图形的相关参数来实现我们想要的图形效果，例如图形颜色，图形样式等。</p><p><strong>修改图形参数的方式有两种，第一种是使用<code>par()</code>函数来修改全局参数，第二种是在定义图形的时候定义相关参数</strong>。关于<code>par()</code>函数的使用后续说明。</p><p>在前面的代码中，以及试验过了<code>plot()</code>函数的输出结果，即图形样式。函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">,</span> y <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;p&quot;</span><span class="punctuation">,</span>  xlim <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ylim <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">     <span class="built_in">log</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> main <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> sub <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ylab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">     ann <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;ann&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> axes <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> frame.plot <span class="operator">=</span> axes<span class="punctuation">,</span></span><br><span class="line">     panel.first <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> panel.last <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> asp <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">     xgap.axis <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> ygap.axis <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">     ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>**<code>x</code>**：即<code>x</code>轴数据</li><li>**<code>y</code>**：即<code>y</code>轴数据</li></ul><h2 id="符号和线条"><a href="#符号和线条" class="headerlink" title="符号和线条"></a>符号和线条</h2><p>可以通过设置以下参数来修改图形的符号和线条类型：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>pch</code></td><td>指定绘制点时使用的符号</td></tr><tr><td><code>cex</code></td><td>指定符号的大小。<code>cex</code>是数值型，默认大小为1，2表示放大2倍</td></tr><tr><td><code>lty</code></td><td>指定线条类型</td></tr><tr><td><code>lwd</code></td><td>指定线条宽度。默认值为1，同<code>cex</code></td></tr></tbody></table><p>关于**<code>pch</code>值对应的点符号样式**如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc036b9f36.png" alt="image-20220507202152075" style="zoom: 200%;" /><p>关于<code>lty</code>参数对应线条的类型样式如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc0337d9c8.png" alt="image-20220507202632041" style="zoom: 50%;" /><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>用于颜色指定的相关参数如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>col</code></td><td>设置绘图颜色。某些函数可以接受颜色值向量并自动循环使用。例如：<code>col=c(&#39;red&#39;,&#39;green)</code>则绘制的图线先红色后绿色，周而复始.</td></tr><tr><td><code>col.axis</code></td><td>坐标轴刻度文字的颜色</td></tr><tr><td><code>col.lab</code></td><td>坐标轴标签的颜色</td></tr><tr><td><code>col.main</code></td><td>标题颜色</td></tr><tr><td><code>col.sub</code></td><td>副标题颜色</td></tr><tr><td><code>fg</code></td><td>前景色（即图表框的颜色）</td></tr><tr><td><code>bg</code></td><td>背景色</td></tr></tbody></table><p>颜色的指定可以通过颜色索引，颜色名称，十六进制颜色值，RGB值或者HSV值来指定颜色。例如：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">col<span class="operator">=</span><span class="number">1</span></span><br><span class="line">col<span class="operator">=</span><span class="string">&#x27;white&#x27;</span></span><br><span class="line">col<span class="operator">=</span><span class="string">&#x27;#FFFFFF&#x27;</span></span><br><span class="line">col<span class="operator">=</span>rgb<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">col<span class="operator">=</span>hsv<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><p>图形参数同样可以用来指定字号，字体和字样等，参数如下所示：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>cex</code></td><td>表示绘图大小，默认为1</td></tr><tr><td><code>cex.axis</code></td><td>坐标轴刻度字体的大小，大小设置同上</td></tr><tr><td><code>cex.lab</code></td><td>坐标轴标签的大小，大小设置同上</td></tr><tr><td><code>cex.main</code></td><td>标题的大小，大小设置同上</td></tr><tr><td><code>cex.sub</code></td><td>副标题的大小，大小设置同上</td></tr><tr><td>————-</td><td>————————————–</td></tr><tr><td><code>font</code></td><td>接收整型参数，用于指定绘图字体样式。（1&#x3D;常规，2&#x3D;粗体，3&#x3D;斜体，4&#x3D;粗斜体，5&#x3D;符号字体）</td></tr><tr><td><code>font.axis</code></td><td>坐标轴刻度字体样式，同上</td></tr><tr><td><code>font.lab</code></td><td>坐标轴标签字体样式，同上</td></tr><tr><td><code>font.main</code></td><td>标题字体样式，同上</td></tr><tr><td><code>font.sub</code></td><td>副标题字体样式，同上</td></tr><tr><td><code>ps</code></td><td>字体磅值（1磅 $\approx$ $\frac{1}{72}$ 英寸），文本最终大小&#x3D;$ps \times cex$</td></tr><tr><td><code>family</code></td><td>绘制文本时使用的字体族。</td></tr></tbody></table><h1 id="添加文本，自定义坐标轴和图例"><a href="#添加文本，自定义坐标轴和图例" class="headerlink" title="添加文本，自定义坐标轴和图例"></a>添加文本，自定义坐标轴和图例</h1><h2 id="图形尺寸于边界尺寸"><a href="#图形尺寸于边界尺寸" class="headerlink" title="图形尺寸于边界尺寸"></a>图形尺寸于边界尺寸</h2><p>同样的可以通过参数来控制生成图形的尺寸，如下所示：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>pin</code></td><td>以英寸表示图形的尺寸（宽和高）</td></tr><tr><td><code>mai</code></td><td>以数值向量表示边界的大小，顺序是下，左，上，右，单位为英寸</td></tr><tr><td><code>mar</code></td><td>以数值向量表示边界大小，顺序同上，单位是英分</td></tr></tbody></table><blockquote><p>1英寸&#x3D;2.54厘米，1英分&#x3D; $\frac{1}{12}$ 英寸</p></blockquote><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>需要高级绘图函数（例如<code>plot</code>，<code>hist</code>，<code>boxplot</code>）允许设定更多的自定义内容，例如标题，图例等。</p><blockquote><p>某些高级绘图函数默认包含了标题和标签，可以<strong>通过设置<code>ann=FLASE</code>来移除它们</strong></p></blockquote><p>可以使用<code>title()</code>函数为图形添加标题和坐标轴标签，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title<span class="punctuation">(</span>main <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> sub <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ylab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">      line <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> outer <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><blockquote><p>NA是Not Available的缩写，是一种占位符，可以理解为值&#x3D;NA，但是不存在</p></blockquote><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title<span class="punctuation">(</span>main <span class="operator">=</span> <span class="string">&#x27;这是主标题&#x27;</span><span class="punctuation">,</span>sub <span class="operator">=</span> <span class="string">&#x27;这是副标题&#x27;</span><span class="punctuation">,</span>xlab <span class="operator">=</span> <span class="string">&#x27;这是横坐标标签&#x27;</span><span class="punctuation">,</span>ylab <span class="operator">=</span> <span class="string">&#x27;这是纵坐标标签&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h2 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h2><p>可以<strong>使用函数<code>axis()</code>来创建自定义坐标轴</strong>。函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axis<span class="punctuation">(</span>side<span class="punctuation">,</span> at <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> labels <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> tick <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> line <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">     pos <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> outer <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> font <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> lty <span class="operator">=</span> <span class="string">&quot;solid&quot;</span><span class="punctuation">,</span></span><br><span class="line">     lwd <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> lwd.ticks <span class="operator">=</span> lwd<span class="punctuation">,</span> col <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> col.ticks <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">     hadj <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> padj <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> gap.axis <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>参数说明如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>side</code></td><td>整型，表示在图形哪边绘制坐标轴（1&#x3D;下，2&#x3D;左，3&#x3D;上，4&#x3D;右）</td></tr><tr><td><code>at</code></td><td>数值型向量，表示需要绘制刻度线的位置</td></tr><tr><td><code>labels</code></td><td>字符型向量，表示置于刻度线旁边的文字标签（如果为<code>NULL</code>则直接使用<code>at</code>中的值）</td></tr><tr><td><code>pos</code></td><td>坐标轴线绘制位置的坐标（即与另一条坐标轴相交的位置）</td></tr><tr><td><code>lty</code></td><td>线条类型</td></tr><tr><td><code>col</code></td><td>线条和刻度线的颜色</td></tr><tr><td><code>las</code></td><td>标签是否平行(&#x3D;0)或者垂直于(&#x3D;2)坐标轴</td></tr><tr><td><code>tck</code></td><td>刻度线的长度，以相对于绘图区域大小的分数表示（负值表示在图形外侧，正值表示在图形内侧，0表示禁用刻度，1表示绘制网格线）；默认值为 $-0.01$</td></tr></tbody></table><p>创建自定义坐标轴时，应该禁用高级绘图函数自动生成的坐标轴。</p><ul><li><strong>参数<code>axes=FLASE</code>将禁用全部坐标轴（包括坐标轴框架线）</strong></li><li><strong>参数<code>xaxt=&#39;n&#39;</code>和<code>yaxt=&#39;n&#39;</code>将分别禁用 X 轴或者 Y 轴（会留下框架线，只是去除了刻度）</strong></li></ul><p>现在运行如下代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">x <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">y <span class="operator">&lt;-</span> x</span><br><span class="line">z <span class="operator">&lt;-</span> 10<span class="operator">/</span>x</span><br><span class="line"></span><br><span class="line">opar <span class="operator">&lt;-</span> par<span class="punctuation">(</span>no.readonly <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定图形边界</span></span><br><span class="line">par<span class="punctuation">(</span>mar<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">)</span><span class="operator">+</span><span class="number">0.1</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制红色直线</span></span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">,</span>y<span class="punctuation">,</span>type <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span><span class="punctuation">,</span>pch<span class="operator">=</span><span class="number">21</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="string">&#x27;red&#x27;</span><span class="punctuation">,</span>yaxt<span class="operator">=</span><span class="string">&#x27;n&#x27;</span><span class="punctuation">,</span>lty<span class="operator">=</span><span class="number">3</span><span class="punctuation">,</span>ann<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制蓝色曲线</span></span><br><span class="line">lines<span class="punctuation">(</span>x<span class="punctuation">,</span>z<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&#x27;b&#x27;</span><span class="punctuation">,</span>pch<span class="operator">=</span><span class="number">22</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="string">&#x27;blue&#x27;</span><span class="punctuation">,</span>lty<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制左侧Y轴刻度线</span></span><br><span class="line">axis<span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span>at<span class="operator">=</span>x<span class="punctuation">,</span>labels <span class="operator">=</span> x<span class="punctuation">,</span>col.axis<span class="operator">=</span><span class="string">&#x27;red&#x27;</span><span class="punctuation">,</span>las<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制右侧Y轴刻度线</span></span><br><span class="line">axis<span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span>at<span class="operator">=</span>z<span class="punctuation">,</span>labels <span class="operator">=</span> <span class="built_in">round</span><span class="punctuation">(</span>z<span class="punctuation">,</span>digits <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span>col.axis<span class="operator">=</span><span class="string">&#x27;blue&#x27;</span><span class="punctuation">,</span>las<span class="operator">=</span><span class="number">2</span></span><br><span class="line">     <span class="punctuation">,</span>cex.axis<span class="operator">=</span><span class="number">0.7</span><span class="punctuation">,</span>tck<span class="operator">=</span><span class="operator">-</span><span class="number">.01</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加右侧标题</span></span><br><span class="line">mtext<span class="punctuation">(</span><span class="string">&#x27;y=1/x&#x27;</span><span class="punctuation">,</span>side<span class="operator">=</span><span class="number">4</span><span class="punctuation">,</span>line<span class="operator">=</span><span class="number">3</span><span class="punctuation">,</span>cex.lab<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span>las<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="string">&#x27;blue&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加横纵坐标标题</span></span><br><span class="line">title<span class="punctuation">(</span><span class="string">&#x27;这是一个样图&#x27;</span><span class="punctuation">,</span>xlab <span class="operator">=</span> <span class="string">&#x27;这是横坐标&#x27;</span><span class="punctuation">,</span>ylab <span class="operator">=</span> <span class="string">&#x27;这是纵坐标&#x27;</span><span class="punctuation">,</span>line <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">par<span class="punctuation">(</span>opar<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行结果生成的图形如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc0405f108.png" alt="image-20220508105802075" style="zoom: 50%;" /><p>关于上述语法解释，**<code>line()</code>函数是绘制图线**，其函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> iter <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>其中参数<code>type</code>的值以及功能如下：</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td><code>type=&#39;p&#39;</code></td><td>表示绘制点</td></tr><tr><td><code>type=&#39;l&#39;</code></td><td>表示绘制线</td></tr><tr><td><code>type=&#39;b&#39;</code></td><td>表示绘制点和线</td></tr><tr><td><code>type=&#39;c&#39;</code></td><td>表示曲线连接的空点</td></tr><tr><td><code>type=&#39;s&#39;</code>或者<code>type=&#39;S&#39;</code></td><td>表示阶梯状线</td></tr><tr><td><code>type=&#39;h&#39;</code></td><td>表示直方图状垂直线</td></tr><tr><td><code>type=&#39;n&#39;</code></td><td>表示不产生任何点或者线</td></tr></tbody></table><p><strong><code>round()</code>函数是进行四舍五入的函数</strong>，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">round</span><span class="punctuation">(</span>x<span class="punctuation">,</span> digits <span class="operator">=</span> <span class="number">0</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>x</code>：需要处理的数据</strong></li><li><strong><code>digits</code>：要使用的小数位数或者有效数字的数目</strong></li></ul><p><strong><code>mtext</code>函数是将文本写在图形区域的是个边距的周围</strong>。函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mtext<span class="punctuation">(</span>text<span class="punctuation">,</span> side <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> line <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> outer <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> at <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">      adj <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> padj <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> cex <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> font <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>相关参数说明如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>text</code></td><td>标题内容</td></tr><tr><td><code>side</code></td><td>文本在坐标轴边框的位置（1&#x3D;下，2&#x3D;左，3&#x3D;上，4&#x3D;右）</td></tr><tr><td><code>line</code></td><td>距离坐标轴边框的距离，值越大越远</td></tr><tr><td><code>las</code></td><td>文字是否平行(&#x3D;0)或者垂直于(&#x3D;2)坐标轴</td></tr></tbody></table><h2 id="次要刻度线"><a href="#次要刻度线" class="headerlink" title="次要刻度线"></a>次要刻度线</h2><p>如上创建的图形都只拥有主刻度线，没有次刻度线。想要<strong>创建次刻度线，需要使用<code>Hmisc</code>宏包的<code>minor.tick()</code>函数。</strong><code>minor.tick()</code>函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minor.tick<span class="punctuation">(</span>nx<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span> ny<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span> tick.ratio<span class="operator">=</span><span class="number">0.5</span><span class="punctuation">,</span> x.args <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span> y.args <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>nx</code>：指在X轴分割的区域，2即次刻度线将每个区间分为两个区域</strong></li><li><strong><code>ny</code>：指在Y轴分割的区域，同上</strong></li><li><strong><code>tick.ratio</code>：表示次刻度相对于主刻度线的大小比例</strong></li></ul><h2 id="参考线"><a href="#参考线" class="headerlink" title="参考线"></a>参考线</h2><p><strong>函数<code>abline()</code>可以用来为图形添加参考线</strong>，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abline<span class="punctuation">(</span>a <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> b <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> h <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> v <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> reg <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">       coef <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> untf <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>h</code>：Y 轴的参考线</strong></li><li><strong><code>v</code>：X 轴的参考线</strong></li></ul><p>代码实例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在垂直 3 坐标和水平 2 坐标，用虚线话画出红色的参考线</span></span><br><span class="line">abline<span class="punctuation">(</span>h<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>v<span class="operator">=</span><span class="number">3</span><span class="punctuation">,</span>lty<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="string">&#x27;red&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h2 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h2><p>当图形中存在多个数据的时候，使用图例可以帮助读者快速区分数据曲线。</p><p>可以<strong>使用函数<code>legend()</code>来添加图例。</strong>函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">legend<span class="punctuation">(</span>x<span class="punctuation">,</span> y <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> legend<span class="punctuation">,</span> fill <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> col <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;col&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       border <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span> lty<span class="punctuation">,</span> lwd<span class="punctuation">,</span> pch<span class="punctuation">,</span></span><br><span class="line">       angle <span class="operator">=</span> <span class="number">45</span><span class="punctuation">,</span> density <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> bty <span class="operator">=</span> <span class="string">&quot;o&quot;</span><span class="punctuation">,</span> bg <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;bg&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       box.lwd <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;lwd&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> box.lty <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;lty&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> box.col <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;fg&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       pt.bg <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> cex <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> pt.cex <span class="operator">=</span> cex<span class="punctuation">,</span> pt.lwd <span class="operator">=</span> lwd<span class="punctuation">,</span></span><br><span class="line">       xjust <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> yjust <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> x.intersp <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> y.intersp <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">       adj <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">)</span><span class="punctuation">,</span> text.width <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> text.col <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;col&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       text.font <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> merge <span class="operator">=</span> do.lines <span class="operator">&amp;&amp;</span> has.pch<span class="punctuation">,</span> trace <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">       plot <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> horiz <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> title <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">       inset <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> xpd<span class="punctuation">,</span> title.col <span class="operator">=</span> text.col<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> title.adj <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">       title.cex <span class="operator">=</span> cex<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> title.font <span class="operator">=</span> text.font<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">       seg.len <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>参数说明如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>location</code></td><td>有两种定位图例位置的方法，第一种是通过指定 X，Y 的值来指定图例的位置（以图例左上角为顶点），第二种方式是通过指定关键字，<code>&quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; and &quot;center&quot;</code>，如果使用关键字指定位置，可以通过<code>inset</code>参数来调整其距离边框的位置。</td></tr><tr><td><code>title</code></td><td>图例的标题</td></tr></tbody></table><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">legend<span class="punctuation">(</span><span class="string">&quot;topleft&quot;</span><span class="punctuation">,</span>title <span class="operator">=</span> <span class="string">&#x27;图例标题&#x27;</span><span class="punctuation">,</span>inset <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;A&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;B&#x27;</span><span class="punctuation">)</span><span class="punctuation">,</span>pch<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc045a94b8.png" alt="image-20220508191935662" style="zoom:50%;" /><h2 id="文本标注"><a href="#文本标注" class="headerlink" title="文本标注"></a>文本标注</h2><p>可以<strong>通过函数<code>text()</code>和<code>mtext()</code>将文本添加到图形，<code>text()</code>可以向绘图区域内添加文字，而<code>mtext()</code>是向绘图区域四周添加文字</strong>。函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mtext</span></span><br><span class="line">mtext<span class="punctuation">(</span>text<span class="punctuation">,</span> side <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> line <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> outer <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> at <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">      adj <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> padj <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> cex <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> font <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># text</span></span><br><span class="line">text<span class="punctuation">(</span>x<span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><code>mtext</code>函数已经在坐标轴部分说明了，<code>text</code>的相关参数说明如下;</p><ul><li><strong><code>x</code>：指定 X 轴的位置</strong></li><li><strong><code>y</code>：指定 Y 轴的位置</strong></li><li><strong><code>label</code>：标注内容</strong></li><li><strong><code>pos</code>：标准内容和点的偏移量</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line">a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">b <span class="operator">&lt;-</span> 1<span class="operator">/</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图形</span></span><br><span class="line">plot<span class="punctuation">(</span>a<span class="punctuation">,</span>b<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加坐标的文字</span></span><br><span class="line">text<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="string">&#x27;这是第一个数据&#x27;</span><span class="punctuation">,</span>pos<span class="operator">=</span><span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">text<span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="operator">/</span><span class="number">2</span><span class="punctuation">,</span><span class="string">&#x27;这是第二个数据&#x27;</span><span class="punctuation">,</span>pos<span class="operator">=</span><span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">text<span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="operator">/</span><span class="number">3</span><span class="punctuation">,</span><span class="string">&#x27;这是第三个数据&#x27;</span><span class="punctuation">,</span>pos<span class="operator">=</span><span class="number">4</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc0499bd8a.png" alt="image-20220508193453179" style="zoom:50%;" /><h3 id="数学标注"><a href="#数学标注" class="headerlink" title="数学标注"></a>数学标注</h3><p>同样的，你也可以<strong>使用类似于<code>Tex</code>中的写法为图形添加数学符号和公式</strong>。<strong>可以利用<code>plotmath()</code>函数来实现</strong>，如果你希望看到即时效果，可以尝试运行<code>demo(plotmath)</code>来查看。</p><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 expression() 来呈现数学公式</span></span><br><span class="line">text<span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="operator">/</span><span class="number">2</span><span class="punctuation">,</span>labels<span class="operator">=</span><span class="built_in">expression</span><span class="punctuation">(</span>frac<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span>pos<span class="operator">=</span><span class="number">4</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><blockquote><p>关于<code>Tex</code>&#x2F;<code>LaTex</code>用法说明，可以看我这篇文章<a href="httpss://www.helloseraphine.top/index.php/archives/514.html">LaTex基础（上）</a></p></blockquote><h1 id="图形的组合"><a href="#图形的组合" class="headerlink" title="图形的组合"></a>图形的组合</h1><p><strong>在R中使用函数<code>par()</code>或者<code>layout()</code>可以组合多幅图形为一幅总括图</strong>。</p><p>可以通过<strong>在<code>par()</code>函数中使用图形参数<code>mfrow=c(nrows,ncols)</code>来创建按行填充的图形矩阵</strong>，或者可以使用**<code>nfcol=c(nrows,ncols)</code>来按列填充矩阵**。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绑定数据源</span></span><br><span class="line">attach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 获取初始图形参数</span></span><br><span class="line">opar <span class="operator">&lt;-</span> par<span class="punctuation">(</span>no.readonly <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 设置两行两列</span></span><br><span class="line">par<span class="punctuation">(</span>mfrow<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 绘制图形</span></span><br><span class="line">plot<span class="punctuation">(</span>Height<span class="punctuation">,</span>Volume<span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;第一个图&#x27;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>Height<span class="punctuation">,</span>Girth<span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;第二个图&#x27;</span><span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>Height<span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;第三个图&#x27;</span><span class="punctuation">)</span></span><br><span class="line">boxplot<span class="punctuation">(</span>Height<span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;第四个图&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 设置图形参数</span></span><br><span class="line">par<span class="punctuation">(</span>opar<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 解绑数据源</span></span><br><span class="line">detach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc04e377cc.png" alt="image-20220509101320519" style="zoom:50%;" /><p>接下来尝试<strong>使用<code>layout（）</code>函数绘制组合图形</strong>，其函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout<span class="punctuation">(</span>mat<span class="punctuation">,</span> widths <span class="operator">=</span> rep.int<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> ncol<span class="punctuation">(</span>mat<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       heights <span class="operator">=</span> rep.int<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> nrow<span class="punctuation">(</span>mat<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> respect <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>mat</code>：矩阵类型参数，四个参数表示四个位置</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">attach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br><span class="line">layout<span class="punctuation">(</span>matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span>byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>Height<span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>Volume<span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>Girth<span class="punctuation">)</span></span><br><span class="line">detach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc051d855c.png" alt="image-20220509102709140" style="zoom:50%;" /><p>为了<strong>更精细的控制每幅图的大小</strong>，可以有选择性的在<code>layout()</code>函数中<strong>使用<code>heights</code>和<code>widths</code>两个参数</strong>。</p><ul><li><strong><code>widths</code>和<code>heights</code>：两个函数都接收一个向量参数</strong>，是一种比例</li></ul><p><strong>相对高度可以通过数值来指定，绝对高度通过函数<code>lcm()</code>来指定</strong>。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">attach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br><span class="line">layout<span class="punctuation">(</span>matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span>byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">       <span class="punctuation">,</span>widths <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span>heights <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>Height<span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>Volume<span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>Girth<span class="punctuation">)</span></span><br><span class="line">detach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc05568f35.png" alt="image-20220509103823858" style="zoom:50%;" /><h2 id="图形的精细化控制"><a href="#图形的精细化控制" class="headerlink" title="图形的精细化控制"></a>图形的精细化控制</h2><p>在某些情况下，你可能希望通过多个图形叠加来形成其他图形，这个时候就需要<strong>使用<code>fig</code>参数来实现</strong>。代码示例如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">attach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>fig<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0.8</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0.8</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>Height<span class="punctuation">,</span>Volume<span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>fig<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0.8</span><span class="punctuation">,</span><span class="number">0.5</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span>new<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">boxplot<span class="punctuation">(</span>Height<span class="punctuation">,</span>horizontal <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>axes<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>fig<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.65</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0.8</span><span class="punctuation">)</span><span class="punctuation">,</span>new<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">boxplot<span class="punctuation">(</span>Volume<span class="punctuation">,</span>axes<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">detach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>new=TRUE</code>：意思是绘制图形的时候不清楚原图像，而是继续叠加绘图</strong></li></ul><p>运行效果如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abc058dfe04.png" alt="image-20220509105257431" style="zoom:50%;" /><p>**<code>fig</code>参数接收一个四参数的向量，它表示的是相对位置，其参数类型为<code>fig=c(x1,x2,y1,y2)</code>**，代码<code>par(fig=c(0,0.8,0,0.8))</code>的意思是规定图形的绘制范围为：横向从 0 到 0.8 这个比例范围内，纵向 0 到 0.8 这个比例范围内。</p><blockquote><p>如果你在绘图过程中报错<code>figure margins too large</code>，则说明绘图已经超出绘图设备区域，适当缩小绘图区域即可。</p></blockquote><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>这部分初步理解和利用图形相关参数来实现一些基本的自定义图形。</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>全方位榨干大疆MINISE</title>
      <link href="/2022/04/25/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%A8%E6%96%B9%E4%BD%8D%E6%A6%A8%E5%B9%B2%E5%A4%A7%E7%96%86MINISE/"/>
      <url>/2022/04/25/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%A8%E6%96%B9%E4%BD%8D%E6%A6%A8%E5%B9%B2%E5%A4%A7%E7%96%86MINISE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我的无人机到手了，但是购买的是大疆MINI-SE，有些功能想用但是没有办法实现怎么办？我开启了榨干MINI之路。</p><p>基本榨干功能：<strong>全景模式，视觉跟踪，正射影像，倾斜摄影建模，航线规划，环绕摄影</strong>。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>如下是准备的基本工作，无人机型号同我或者以之上皆可，软件设备等同理。</p><ul><li><strong>无人机型号：大疆MINI-SE</strong></li><li><strong>手机设备：华为P30（HarmonyOS 2.0）</strong></li><li><strong>航点规划软件：Rainbow无人机控制飞行软件（V3.6）</strong></li><li><strong>电脑：Win10（20H2）</strong></li><li><strong>后期软件：Pix4Dmapper（V4.4.12），PS（CC 2018），AE（CC 2018）</strong></li></ul><h1 id="全景模式"><a href="#全景模式" class="headerlink" title="全景模式"></a>全景模式</h1><p>对于<strong>全景模式大疆支持是MINI2及以上才支持一键全景，而MINI-SE是不支持全景的</strong>，但是我们又很想要全景的效果，这个时候就需要手动全景合成了，两种方法：</p><blockquote><p>注：此处全景模式特指的是<strong>球形全景</strong></p></blockquote><h2 id="手动全景合成"><a href="#手动全景合成" class="headerlink" title="手动全景合成"></a>手动全景合成</h2><p>关于手动全景合成可以看这个视频，<a href="httpss://www.bilibili.com/video/BV1TE411N7SG">【教程】Mini也能做全景图？</a>，此处不做过多说明。</p><p>就我个人认为手动全景可以，但是工作量相对较大，而且不是很精准，<strong>我个人更推荐下面的软件合成+人工后期处理</strong>。</p><h2 id="使用软件来合成"><a href="#使用软件来合成" class="headerlink" title="使用软件来合成"></a>使用软件来合成</h2><p><strong>打开【Rainbow无人机控制飞行软件】，选择全景</strong>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed28efc6a.png" alt="image-20220416105915979" style="zoom: 50%;" /><p><strong>然后选择【全景设置】，在全景设置中，选择【球形】，在下面的参数中，将【全景清晰度】设置为【高】</strong>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed2d1f6bd.png" alt="image-20220416110203581" style="zoom: 50%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed31babb5.png" alt="image-20220416110452010" style="zoom:50%;" /><p>然后，点<strong>击左侧【开始】，等待无人机拍摄，结束完成后，点击【下载】，选择要合成的全景图，等待合成</strong>，一般要3-5分钟，因手机和图片质量以及合成参数而异。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed361e131.png" alt="image-20220416110723305" style="zoom:50%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed3a75003.png" alt="image-20220416110757610" style="zoom:50%;" /><p>下载完成后，可以在软件中浏览全景图片，如下为在软件中预览效果：</p><p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/SVID_20220416_110842_1.mp4" width="100%"></video></p><p>你会发现部分地方有些模糊，头顶更是黑了一片，<strong>关于模糊的部分是因为镜头拍摄的时候曝光问题</strong>，需要在拍摄的时候注意曝光，而<strong>头顶黑了一片是因为MINI-SE没办法拍摄头顶图片，这个时候就需要手动“补天”</strong>。如下图为软件初步合成的全景图片：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed42f218f.png" alt="image-20220416111648908" style="zoom:80%;" /><p>将图片使用PS来手动补天，<strong>补天后的图片输出如下</strong>，可以通过<a href="httpss://720yun.com/t/9fvkb7pmd1h?scene_id=92363395">点我来预览</a>，所有归属归山东农业大学所有，此处仅做演示说明，<strong>未经授权不可它用</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed475ac72.png" alt="image-20220416111833860" style="zoom:80%;" /><p>这样就基本实现了一张球形的全景图片，<strong>如果你想要纯手动制作一张全景图片或者希望分享给别人自己拍的全景图片，可以使用<a href="httpss://720yun.com/">720云</a>网站来制作和分享</strong>。</p><h1 id="正射影像"><a href="#正射影像" class="headerlink" title="正射影像"></a>正射影像</h1><h2 id="什么是正射影像"><a href="#什么是正射影像" class="headerlink" title="什么是正射影像"></a>什么是正射影像</h2><p>正射影像顾名思义：<strong>即通过将无人机的云台成 -90° 方向（镜头正下方）来进行连续拍摄，保证一定的航向重叠率情况下，完成航线拍摄，然后通过后期软件来处理成一张航拍的地区正射影像</strong>。可以想象成地图的样子就是呈现结果。</p><h2 id="开始航拍工作"><a href="#开始航拍工作" class="headerlink" title="开始航拍工作"></a>开始航拍工作</h2><p>首先找一个地方，<strong>选择一片需要正射影像</strong>的地方，此处<strong>示例以山东农业大学南校区正南门一片区域</strong>为正射影像为例，<strong>因为正射影像涉及航测方面的问题，所以示例会做模糊和水印处理</strong>。</p><p>我在早上大概7点20左右拍摄的正射影像，拍摄地区如下卫星图（高德地图）：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed4be48ca.png" alt="image-20220416103259680" style="zoom:80%;" /><p>飞行航线如下图，<strong>具体飞行航线和航拍点是根据飞行高度，即航拍高度决定的</strong>。因为我的MINI-SE只有1200万的像素，所以<strong>我通过降低航拍飞行高度来让我的正射影像结果更清晰一些</strong>，同样的，<strong>随着航拍高度的降低航线和航点，拍摄的正射图片也会增加，也就是说正射完成的耗时更长</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed4f95191.png" alt="image-20220416103403378" style="zoom: 50%;" /><p>我一共拍摄了130张正射影像，然后<strong>将图像导入到Pix4Dmapper软件中</strong>，进行处理，<strong>如果没有特殊需求，一路默认下去，然后在如下选择中选择第一个【3D Maps】，点击下一步即可，然后等待漫长解析</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed5300229.png" alt="image-20220416112830021" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed56caf80.png" alt="image-20220416113020209" style="zoom:80%;" /><p>解析完成后，<strong>会在相关的项目文件夹中生成相关文件以及质量报告</strong>，项目文件如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed5b63b7f.png" alt="image-20220416113134308" style="zoom:80%;" /><ul><li><strong>1_initial：包含质量报告和相关图像基本信息</strong></li><li><strong>2_densification：包含3D点云以及相关3D模型</strong></li><li><strong>3_dsm_ortho：包含正射影像文件和DSM文件等</strong></li><li><strong>temp：临时文件（不需要管）</strong></li><li><strong>Test.log：项目日志（不需要管）</strong></li></ul><p>在如下路径可以找到<strong>项目生成的质量报告</strong>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed5f5813a.png" alt="image-20220416113953015" style="zoom:80%;" /><p>在如下路径可以找到<strong>正射影像文件和DSM文件</strong>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed6344c64.png" alt="image-20220416114128730" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed674289a.png" alt="image-20220416114051155" style="zoom:80%;" /><p>在如下路径可以找到生成的<strong>模型文件</strong>：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed6b3e4d9.png" alt="image-20220416114217754" style="zoom:80%;" /><p>如下为我拍摄最后生成的正射影像和DSM图像，最终归属为山东农业大学，未经允许不可它用。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed6f37f3f.png" alt="image-20220416114919521" style="zoom:80%;" /><h1 id="倾斜摄影"><a href="#倾斜摄影" class="headerlink" title="倾斜摄影"></a>倾斜摄影</h1><p>倾斜摄影和正射影像同理，也需要<strong>使用Pix4Dmapper</strong>，将相关倾斜摄影图片导入项目中，在遇到下列选项中<strong>选择【3D Models】</strong>，然后等待解析生成质量报告。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed737d9c2.png" alt="image-20220416164918800" style="zoom:80%;" /><p>如下是我倾斜摄影的航线，我选择了很小的一块地方，所以相对图片和时间上少很多。可以看到，<strong>倾斜摄影会飞5条航线，分别是上下左右（东南西北）的倾斜摄影和一条中间的正射影像</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed7793a0b.png" alt="image-20220416165051015" style="zoom: 67%;" /><p>等待质量报告出来，解析完成后，<strong>在文件夹【1_initial】中可以找到质量报告，在文件夹【2_densification】中可以找到相关的3D模型</strong>。如下是相关模型的GIF：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaedee03626.gif" alt="image-20220416165051015" style="zoom: 80%;" /><p>因为大疆MINI-SE的像素只有1200万，所以可以尝试将飞行高度降低，来增加航点来提升最终模型质量。</p><h1 id="视觉跟踪"><a href="#视觉跟踪" class="headerlink" title="视觉跟踪"></a>视觉跟踪</h1><p>因为大疆MINI-SE没有内置硬件图形加速相关，所以<strong>此处的视觉跟踪是基于软件的图像识别，使用<code>Rainbow无人机控制软件</code>，选择【视觉跟踪】</strong>，然后框选需要跟踪的对象，剩下的交给图像识别。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed80a45b8.png" alt="image-20220416174154442" style="zoom:50%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed8463412.png" alt="image-20220416174214906" style="zoom:50%;" /><p>需要注意的是，<strong>因为是基于图像识别的，所以它对于控制的手机有一定的性能要求</strong>，当然你也可以在其设置中选择低精度识别，不过同理识别精度会差很多。另外还需要注意的是，这个功能更加建议在空旷的场景或者有人看着的情况下使用，<strong>因为大疆MINI-SE没有视觉避障，所以存在炸机的风险</strong>。</p><p>视觉跟踪效果如下：</p><p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/DJI_0908.mp4" width="100%"></video></p><h1 id="环绕摄影"><a href="#环绕摄影" class="headerlink" title="环绕摄影"></a>环绕摄影</h1><p>环绕摄影通俗理解就是无人机围绕某个点画圆，由于新手很难画出一个比较完整的圆形，又需要这个功能，这个时候就需要<code>Rainbow无人机控制软件</code>来使用【环绕】功能。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaed89d3256.png" alt="image-20220416181900530" style="zoom:50%;" /><p>具体使用方法不多解释，举一反三。</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>最后的想法是可以利用无人机摄影+后期来实现如右侧的同款赛博朋克效果<a href="httpss://www.bilibili.com/video/BV1F54y1y78E/?spm_id_from=333.788.recommend_more_video.1">长安大学【赛博朋克】</a>。看我有没有的时间来弄吧。就这样。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaee04d44a7.png" alt="image-20220416182427906" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算叶面积</title>
      <link href="/2022/04/22/%E5%BE%AE%E8%BD%AF%E5%A4%A9%E5%9D%91/Winform/%E8%AE%A1%E7%AE%97%E5%8F%B6%E9%9D%A2%E7%A7%AF/"/>
      <url>/2022/04/22/%E5%BE%AE%E8%BD%AF%E5%A4%A9%E5%9D%91/Winform/%E8%AE%A1%E7%AE%97%E5%8F%B6%E9%9D%A2%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周三晚上我们上了一节关于叶面积的测定方法的实验课，在课上我想出了一种测定思路，我的想法是通过固定比例尺拍照转换为灰度图来遍历图像像素判断叶的像素，然后再通过比例尺算法计算叶的面积，从程序的角度来看是可行的，只要给定输入固定比例尺的图像，就可以批量输出结果。</p><p>本来我是没打算写这个程序的，不过昨晚学习学累了，就突然想到这个事情，我就想这弄一下吧，然后就弄出来了，程序基于Win平台，使用的是C#，Winform开发技术（主要是快）。至于WPF的美化版我懒得弄了。</p><h1 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h1><p>我早上吃完饭随手摘的银杏的叶子，然后放在一张A4纸上拍照，单击【选择图片】导入程序即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb6f8c3307.png" alt="image-20220422085545367" style="zoom:80%;" /><p>本方法精度取决于比例尺，所以如果想要大规模应用，需要固定相机和拍摄底的距离即可。</p><h1 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h1><ol><li>先判断是否导入了选定图片，导入成功则显示预览图，失败则提醒，二次验证是否规定了比例尺，两者具备则可以正常计算面积</li><li>计算面积前需要将图像转换为灰度图，然后根据算法统计叶子所占的像素，然后根据比例尺算出每个像素的面积，然后加和返回结果。</li></ol><h1 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">LeafArea</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//预览图片</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button2_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> filePath = OpenFile();</span><br><span class="line">            <span class="keyword">if</span>(filePath == <span class="string">&quot;无&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                retrunMes.ForeColor = Color.Red;</span><br><span class="line">                retrunMes.Text = <span class="string">&quot;错误，未指定图片&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Image img = Image.FromFile(filePath);</span><br><span class="line">                pictureBox1.Image = img;</span><br><span class="line">                retrunMes.ForeColor = Color.Green;</span><br><span class="line">                retrunMes.Text = <span class="string">&quot;加载图片成功&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算叶面积</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pictureBox1.Image == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox.Show(<span class="string">&quot;请选择图片&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pixel.Text == <span class="string">&quot;&quot;</span> || cm.Text == <span class="string">&quot;&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    MessageBox.Show(<span class="string">&quot;请填写比例设定&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Image bwImg = BlackWhiteChange(pictureBox1);     <span class="comment">//转化为灰度图</span></span><br><span class="line">                    pictureBox1.Image = bwImg;</span><br><span class="line">                    retrunMes.Text = <span class="string">&quot;计算叶面积中...&quot;</span>;</span><br><span class="line">                    retrunMes.Text = <span class="string">&quot;叶面积为&quot;</span> + CalculateArea(LeafPixel(bwImg)) + <span class="string">&quot;平方厘米&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择图片路径</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">OpenFile</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            OpenFileDialog dialog = <span class="keyword">new</span> OpenFileDialog();</span><br><span class="line">            dialog.Multiselect = <span class="literal">false</span>;<span class="comment">//禁止选择多个文件</span></span><br><span class="line">            dialog.Title = <span class="string">&quot;请选择文件夹&quot;</span>;</span><br><span class="line">            dialog.Filter = <span class="string">&quot;所有文件(*.*)|*.*&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> dialog.FileName;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;无&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转化灰度图</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Image <span class="title">BlackWhiteChange</span>(<span class="params">PictureBox pic</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> varH = pic.Image.Height;    <span class="comment">//获取图像高度</span></span><br><span class="line">            <span class="built_in">int</span> varW = pic.Image.Width;     <span class="comment">//获取图像宽度</span></span><br><span class="line">            Bitmap bitmap = <span class="keyword">new</span> Bitmap(varW,varH);  <span class="comment">//更具宽高创建灰度图对象</span></span><br><span class="line">            Bitmap rgbmap = (Bitmap)pic.Image;  <span class="comment">//RGB图像</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; varW; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; varH; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Color nowColor = rgbmap.GetPixel(i, j);     <span class="comment">//获取当前颜色像素</span></span><br><span class="line">                    <span class="built_in">int</span> r, g, b, <span class="keyword">value</span> = <span class="number">0</span>;</span><br><span class="line">                    r = nowColor.R;</span><br><span class="line">                    g = nowColor.G;</span><br><span class="line">                    b = nowColor.B;</span><br><span class="line">                    <span class="keyword">value</span> = (r + g + b) / <span class="number">3</span>;      <span class="comment">//加权平均生成灰度图</span></span><br><span class="line">                    bitmap.SetPixel(i, j, Color.FromArgb(<span class="keyword">value</span>, <span class="keyword">value</span>, <span class="keyword">value</span>));     <span class="comment">//生成灰度图</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> bitmap;      <span class="comment">//返回生成的灰度图</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算叶面积像素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">LeafPixel</span>(<span class="params">Image img</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> num =<span class="number">0</span>;</span><br><span class="line">            Bitmap bitmap = (Bitmap)img;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;像素宽度&#123;0&#125;，长度&#123;0&#125;&quot;</span>, img.Width,img.Height);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; img.Width; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; img.Height; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Color nowColor = bitmap.GetPixel(i, j);     <span class="comment">//获取当前颜色像素</span></span><br><span class="line">                    <span class="built_in">int</span> r;</span><br><span class="line">                    r = nowColor.R;</span><br><span class="line">                    <span class="keyword">if</span> (r &lt; <span class="number">100</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        num++;      <span class="comment">//计算叶面积占的像素</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;所占像素为&#123;0&#125;&quot;</span>, num);</span><br><span class="line">            <span class="keyword">return</span> num;     <span class="comment">//返回所占像素值</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据像素和比例算面积</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">CalculateArea</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">double</span> real = <span class="built_in">double</span>.Parse(cm.Text)/<span class="built_in">double</span>.Parse(pixel.Text);  <span class="comment">//计算一个像素是多少厘米</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;单像素面积为&#123;0&#125;&quot;</span>, real);</span><br><span class="line">            <span class="built_in">double</span> realone = real * real;    <span class="comment">//一个像素的面积</span></span><br><span class="line">            result = realone * num;     <span class="comment">//总像素面积</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;总面积为&#123;0&#125;&quot;</span>, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>程序不难，如果后续改进的话可以将遍历图片部分的算法更换其他灵活的算法，计算的速度应该可以翻几倍，因为<code>.NET</code>默认的遍历像素的算法比较耗时，如果采用锁定内存或者非安全代码来使用引用指针话速度会更快。</p><p>关于叶面积测定仪，我个人也想到了这种方法，不过这种方法是从单片机的角度来考虑的，相比较程序来说便携和快速的结果是最大的优势，但是对于大规模的计算来说，程序会相对较好，给定输入，返回输出。</p><p>关于纸质量测定法，我个人认为如果通过复印机的方式直接复印叶子的样子出来，然后剪切叶子的形状称量重量会相对精确一些，比较人手画的相对误差大。前提是排除了复印机墨的质量。</p>]]></content>
      
      
      <categories>
          
          <category> 微软天坑 </category>
          
          <category> Winform </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于我的人生第一台无人机</title>
      <link href="/2022/04/12/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E5%8F%B0%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
      <url>/2022/04/12/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E5%8F%B0%E6%97%A0%E4%BA%BA%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我快忘记我什么时候有了买无人机的念头了，我记得最近思考这个问题是今年过年的时候，也就是寒假的时候，我也快忘记我当时想的什么了，在4月1日下单购买了<strong>我人生中第一台无人机——大疆MINI SE</strong>，如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9a0b27cb.png" alt="image-20220412205834391" style="zoom:80%;" /><h1 id="关于购买和使用感受"><a href="#关于购买和使用感受" class="headerlink" title="关于购买和使用感受"></a>关于购买和使用感受</h1><p>我买的是大疆截至目前写文章时最便宜的无人机，单机只需要1999，它采用的是增强WIFI图传，1200万像素，不支持变焦，从价格角度来说这是一个相对便宜的入门级无人机，从使用感官来说，WIFI图传的确不是很友好，不过对于这个价格来说，2000块钱要什么自行车。</p><p>综合来说在这个价位作为一款入门级大疆无人机，已经是非常不错了，我本人在校园测试，如果高度在100m及以上，水平可以拉锯500m起步，我拉了500m就没有再拉距。</p><p>一些无人机的问题：</p><p>【无人机FCC是什么？要不要弄】</p><p>如下图，图片内容版权归原作者所有，此处仅作引用说明，侵删。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9a48ded6.png" alt="image-20220412212716380" style="zoom:67%;" /><p>通俗来说就是一种不同国家对于信号频率的限制，而FCC，即美国的标准可以让我们的无人机图传信号和距离更远更稳定，相对来说会增加一定的耗电量，关于要不要弄，我目前人是很懒的，能不动手就不动手，所以我没弄。</p><p>【WIFI图传怎么样？】</p><p>我只能说郊区效果还可以，市区我见过100m没信号的，市内干扰太大了，所以我个人建议预算充足的情况下，加1000买mini 2吧。</p><p>【有没有什么办法增强信号？】</p><p>要么改遥控器和无人机，要么购买相关增强天线，至于相关增强天线是否真的有用，我持有保留意见，因为我买的还在路上，不知道，他们飞友说是有一定的用的。</p><h1 id="关于一些我随手拍的图片"><a href="#关于一些我随手拍的图片" class="headerlink" title="关于一些我随手拍的图片"></a>关于一些我随手拍的图片</h1><p>最近人也变懒了，图片就传一些，其他带宽有限，我也不想通过这种方式来呈现所有图片，所以就看看吧。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9a8ad989.png" alt="image-20220412213339393" style="zoom: 80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9acb871a.png" alt="image-20220412213407831" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9b0e34c2.png" alt="image-20220412213426277" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9b5627fa.png" alt="image-20220412213440238" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9b9ac3c5.png" alt="image-20220412213456454" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9bdf188a.png" alt="image-20220412213511286" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9c233fb0.png" alt="image-20220412213528566" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9c63c7f4.png" alt="image-20220412213543998" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9ca15e16.png" alt="image-20220412213559702" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9cee0f1e.png" alt="image-20220412213614440" style="zoom:80%;" /><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p><strong>卡密萨马，给我再多一点时间让我掌握最后的正射拍摄和倾斜摄影吧！！！</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9d8eb3f9.png" alt="image-20220412212559668" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【NEW-2.0】R-创建数据集</title>
      <link href="/2022/03/07/%E8%AF%AD%E8%A8%80%E6%A0%91/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-2.0%E3%80%91%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
      <url>/2022/03/07/%E8%AF%AD%E8%A8%80%E6%A0%91/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-2.0%E3%80%91%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="数据集的概念"><a href="#数据集的概念" class="headerlink" title="数据集的概念"></a>数据集的概念</h1><p>数据集是由数据构成的矩形数组，行表示观测（记录），列表示变量（字段）。</p><p><code>R</code>有许多用于<strong>存储数据的结构，包括标量，向量，数组，数据框和列表</strong>。</p><p><code>R</code>可以处理的<strong>数据类型包括数值型，字符型，逻辑型，复数型和原生型</strong>。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p><strong>向量是用于存储数据的一维数组</strong>。</p><h3 id="创建向量"><a href="#创建向量" class="headerlink" title="创建向量"></a>创建向量</h3><p><strong>利用<code>c()</code>可以用来创建向量</strong>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;你好&quot;</span><span class="punctuation">,</span><span class="string">&quot;世界&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><blockquote><p>注：单个向量之内的数据类型需要相同。<strong>一个向量不可以混合多种数据类型</strong></p></blockquote><h3 id="访问向量元素"><a href="#访问向量元素" class="headerlink" title="访问向量元素"></a>访问向量元素</h3><p>通过<strong>指定向量中元素的位置来访问元素</strong>，例如：</p><ul><li><code>a[c(1)]</code>来表示指定访问向量<code>a</code>中第一个元素。</li><li><code>a[c(1，3)]</code>来表示指定访问向量<code>a</code>中第一个和第三个元素。</li><li><code>a[c(1:3)]</code>来表示访问向量<code>a</code>中第一个到第三个元素。</li></ul><p>【从<code>C</code>和<code>C#</code>角度看】</p><ul><li>向量就是规定类型的一维数组，通过函数<code>c(数据内容，间隔采用,号)</code>来创建。</li><li>访问数组中元素通过下标来访问，使用函数<code>向量变量[c(下标位置)]</code></li></ul><blockquote><p>需要注意的是：**<code>R</code>语言的数字是从1开始的，而不是0.**</p></blockquote><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p><strong>矩阵是一个二维数组。</strong></p><h3 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h3><p><strong>通过函数<code>matrix</code>来创建</strong>。函数源码如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="punctuation">(</span>data <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> <span class="built_in">dimnames</span> <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">)</span> </span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> <span class="punctuation">(</span><span class="built_in">is.object</span><span class="punctuation">(</span>data<span class="punctuation">)</span> <span class="operator">||</span> <span class="operator">!</span><span class="built_in">is.atomic</span><span class="punctuation">(</span>data<span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line">    data <span class="operator">&lt;-</span> as.vector<span class="punctuation">(</span>data<span class="punctuation">)</span></span><br><span class="line">  .Internal<span class="punctuation">(</span>matrix<span class="punctuation">(</span>data<span class="punctuation">,</span> nrow<span class="punctuation">,</span> ncol<span class="punctuation">,</span> byrow<span class="punctuation">,</span> <span class="built_in">dimnames</span><span class="punctuation">,</span> <span class="built_in">missing</span><span class="punctuation">(</span>nrow<span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="built_in">missing</span><span class="punctuation">(</span>ncol<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>data：二维数组数据内容</strong></li><li><strong>nrow：（数值）行数，默认<code>1</code></strong></li><li><strong>ncol：（数值）列数，默认<code>1</code></strong></li><li><strong>byrow：（布尔）填充数值是从列开始还是从行开始，<code>FLASE</code>默认值，表示从列开始填充</strong></li><li><strong>dimnames：（两个参数的<code>list</code>）行列名称重命名，默认<code>NULL</code></strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个矩阵,按列填充</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>a<span class="punctuation">)</span></span><br><span class="line">     <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">1</span>    <span class="number">5</span>    <span class="number">9</span>   <span class="number">13</span>   <span class="number">17</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">2</span>    <span class="number">6</span>   <span class="number">10</span>   <span class="number">14</span>   <span class="number">18</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">3</span>    <span class="number">7</span>   <span class="number">11</span>   <span class="number">15</span>   <span class="number">19</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">4</span>    <span class="number">8</span>   <span class="number">12</span>   <span class="number">16</span>   <span class="number">20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个矩阵,按行填充</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>a<span class="punctuation">)</span></span><br><span class="line">     <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span>    <span class="number">4</span>    <span class="number">5</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">6</span>    <span class="number">7</span>    <span class="number">8</span>    <span class="number">9</span>   <span class="number">10</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="punctuation">]</span>   <span class="number">11</span>   <span class="number">12</span>   <span class="number">13</span>   <span class="number">14</span>   <span class="number">15</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="punctuation">]</span>   <span class="number">16</span>   <span class="number">17</span>   <span class="number">18</span>   <span class="number">19</span>   <span class="number">20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个矩阵,按行填充,并重命名</span></span><br><span class="line"><span class="operator">&gt;</span> rname <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;第一行&quot;</span><span class="punctuation">,</span><span class="string">&#x27;第二行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第四行&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> cname <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;第一列&quot;</span><span class="punctuation">,</span><span class="string">&#x27;第二列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第四列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第五列&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="literal">TRUE</span><span class="punctuation">,</span><span class="built_in">list</span><span class="punctuation">(</span>rname<span class="punctuation">,</span>cname<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>a<span class="punctuation">)</span></span><br><span class="line">       第一列 第二列 第三列 第四列 第五列</span><br><span class="line">第一行      <span class="number">1</span>      <span class="number">2</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">5</span></span><br><span class="line">第二行      <span class="number">6</span>      <span class="number">7</span>      <span class="number">8</span>      <span class="number">9</span>     <span class="number">10</span></span><br><span class="line">第三行     <span class="number">11</span>     <span class="number">12</span>     <span class="number">13</span>     <span class="number">14</span>     <span class="number">15</span></span><br><span class="line">第四行     <span class="number">16</span>     <span class="number">17</span>     <span class="number">18</span>     <span class="number">19</span>     <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="访问矩阵元素"><a href="#访问矩阵元素" class="headerlink" title="访问矩阵元素"></a>访问矩阵元素</h3><p>同理也是<strong>通过矩阵下标来表示位置</strong>，<code>矩阵名称[x,y]</code>，<code>x</code>表示行数，<code>y</code>表示列数。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个矩阵,按行填充,并重命名</span></span><br><span class="line"><span class="operator">&gt;</span> rname <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;第一行&quot;</span><span class="punctuation">,</span><span class="string">&#x27;第二行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第四行&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> cname <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;第一列&quot;</span><span class="punctuation">,</span><span class="string">&#x27;第二列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第四列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第五列&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="literal">TRUE</span><span class="punctuation">,</span><span class="built_in">list</span><span class="punctuation">(</span>rname<span class="punctuation">,</span>cname<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问第二行元素</span></span><br><span class="line"><span class="operator">&gt;</span> a<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span></span><br><span class="line">第一列 第二列 第三列 第四列 第五列 </span><br><span class="line">     <span class="number">6</span>      <span class="number">7</span>      <span class="number">8</span>      <span class="number">9</span>     <span class="number">10</span> </span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问第二行第三个元素</span></span><br><span class="line"><span class="operator">&gt;</span> a<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问第二行第三，四个元素</span></span><br><span class="line"><span class="operator">&gt;</span> a<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">第三列 第四列 </span><br><span class="line">     <span class="number">8</span>      <span class="number">9</span> </span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> a<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">第三列 第四列 </span><br><span class="line">     <span class="number">8</span>      <span class="number">9</span> </span><br></pre></td></tr></table></figure><p>【从<code>C</code>和<code>C#</code>角度看】</p><ul><li>矩阵是已经嵌套好的二维数组，更加偏向于数学上的线性代数。</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是矩阵的加强版，它的<strong>维度可以大于2</strong>。</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>通过<strong>函数<code>array</code>创建</strong>，函数原型示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array<span class="punctuation">(</span>data <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> <span class="built_in">dim</span> <span class="operator">=</span> <span class="built_in">length</span><span class="punctuation">(</span>data<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">dimnames</span> <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong>data：数组的数据</strong></li><li><strong>dim：数组的长度，<code>c(行数,列数,维度)</code></strong></li><li><strong>dimnames：(<code>List</code>类型)数组行列维度名称</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个一维数组</span></span><br><span class="line"><span class="operator">&gt;</span> name1 <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;第一行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第二列&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> name2 <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;第一列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第二列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三列&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> name3 <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;第一层&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第二层&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三层&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第四层&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">24</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">c</span> <span class="operator">&lt;-</span> array<span class="punctuation">(</span>a<span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="built_in">list</span><span class="punctuation">(</span>name1<span class="punctuation">,</span>name2<span class="punctuation">,</span>name3<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">c</span></span><br><span class="line"><span class="punctuation">,</span> <span class="punctuation">,</span> 第一层</span><br><span class="line"></span><br><span class="line">       第一列 第二列 第三列</span><br><span class="line">第一行      <span class="number">1</span>      <span class="number">3</span>      <span class="number">5</span></span><br><span class="line">第二列      <span class="number">2</span>      <span class="number">4</span>      <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">,</span> <span class="punctuation">,</span> 第二层</span><br><span class="line"></span><br><span class="line">       第一列 第二列 第三列</span><br><span class="line">第一行      <span class="number">7</span>      <span class="number">9</span>     <span class="number">11</span></span><br><span class="line">第二列      <span class="number">8</span>     <span class="number">10</span>     <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">,</span> <span class="punctuation">,</span> 第三层</span><br><span class="line"></span><br><span class="line">       第一列 第二列 第三列</span><br><span class="line">第一行     <span class="number">13</span>     <span class="number">15</span>     <span class="number">17</span></span><br><span class="line">第二列     <span class="number">14</span>     <span class="number">16</span>     <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">,</span> <span class="punctuation">,</span> 第四层</span><br><span class="line"></span><br><span class="line">       第一列 第二列 第三列</span><br><span class="line">第一行     <span class="number">19</span>     <span class="number">21</span>     <span class="number">23</span></span><br><span class="line">第二列     <span class="number">20</span>     <span class="number">22</span>     <span class="number">24</span></span><br></pre></td></tr></table></figure><h3 id="数组元素的访问"><a href="#数组元素的访问" class="headerlink" title="数组元素的访问"></a>数组元素的访问</h3><p>同上，使用元素位置来访问，代码示例</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个一维数组</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">24</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">c</span> <span class="operator">&lt;-</span> array<span class="punctuation">(</span>a<span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问数组第二层第二行第二列元素</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">c</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="数据框"><a href="#数据框" class="headerlink" title="数据框"></a>数据框</h2><p>数据框类似于Excel，是一种键值对的格式，它可以<strong>混合使用多种数据类型</strong>。</p><h3 id="创建数据框"><a href="#创建数据框" class="headerlink" title="创建数据框"></a>创建数据框</h3><p>通过**使用函数<code>data.frame()</code>**，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.frame<span class="punctuation">(</span>...<span class="punctuation">,</span> row.names <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> check.rows <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">           check.names <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> fix.empty.names <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">           stringsAsFactors <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong>…：数据内容</strong></li><li><strong>row.names：行名称</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个数据框</span></span><br><span class="line"><span class="operator">&gt;</span> name <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;小明&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;小亮&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;小亮&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> classNum <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;林学一班&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;林学二班&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;林学三班&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> rname <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;第一行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第二行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三行&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>name<span class="punctuation">,</span>classNum<span class="punctuation">,</span>row.names <span class="operator">=</span> rname<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> a</span><br><span class="line">       name classNum</span><br><span class="line">第一行 小明 林学一班</span><br><span class="line">第二行 小亮 林学二班</span><br><span class="line">第三行 小亮 林学三班</span><br></pre></td></tr></table></figure><h3 id="数据框元素的访问"><a href="#数据框元素的访问" class="headerlink" title="数据框元素的访问"></a>数据框元素的访问</h3><p>可以通过元素位置索引来访问，**<code>数据框名称[第几列]</code>，表示访问第几列元素。<code>数据框名称[第几行,第几列]</code>或者**如果想要表现其中两个数据关系，可以通过<code>table(数据框名称$列/行名称)</code>来实现。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个数据框</span></span><br><span class="line"><span class="operator">&gt;</span> name <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;小明&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;小亮&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;小亮&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> classNum <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;林学一班&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;林学二班&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;林学三班&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> rname <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;第一行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第二行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三行&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>name<span class="punctuation">,</span>classNum<span class="punctuation">,</span>row.names <span class="operator">=</span> rname<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问第一列数据</span></span><br><span class="line"><span class="operator">&gt;</span> a<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">       name</span><br><span class="line">第一行 小明</span><br><span class="line">第二行 小亮</span><br><span class="line">第三行 小亮</span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问第一行第1,2个数据</span></span><br><span class="line"><span class="operator">&gt;</span> a<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">       name classNum</span><br><span class="line">第一行 小明 林学一班</span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 获取行列数据的关系</span></span><br><span class="line"><span class="operator">&gt;</span> table<span class="punctuation">(</span>a<span class="operator">$</span>classNum<span class="punctuation">,</span>a<span class="operator">$</span>name<span class="punctuation">)</span></span><br><span class="line">          </span><br><span class="line">           小亮 小明</span><br><span class="line">  林学二班    <span class="number">1</span>    <span class="number">0</span></span><br><span class="line">  林学三班    <span class="number">1</span>    <span class="number">0</span></span><br><span class="line">  林学一班    <span class="number">0</span>    <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们在每次访问变量元素的时候，都需要输入<code>数据框名称$列/行名称</code>，会比较繁琐，可以通过<strong>使用函数<code>attach()</code>和<code>detach()</code>或者单独使用函数<code>with()</code>来简化代码</strong>。</p><p><strong>或者使用<code>$</code>来访问元素</strong>。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个数据框</span></span><br><span class="line"><span class="operator">&gt;</span> name <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;小明&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;小亮&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;小亮&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> classNum <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;林学一班&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;林学二班&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;林学三班&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> rname <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;第一行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第二行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三行&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>name<span class="punctuation">,</span>classNum<span class="punctuation">,</span>row.names <span class="operator">=</span> rname<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问name列</span></span><br><span class="line"><span class="operator">&gt;</span> a<span class="operator">$</span>name</span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;小明&quot;</span> <span class="string">&quot;小亮&quot;</span> <span class="string">&quot;小亮&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问name列的第二个元素</span></span><br><span class="line"><span class="operator">&gt;</span> a<span class="operator">$</span>name<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;小亮&quot;</span></span><br></pre></td></tr></table></figure><h2 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h2><p>暂欠</p><p>通过函数<code>factor</code>来创建.</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><strong>列表也是一种一维数组，它可以嵌套多种数据类型</strong>。</p><h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><p>使用函数<code>list()</code>来创建，函数原型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span><span class="punctuation">(</span>...<span class="punctuation">)</span>;</span><br></pre></td></tr></table></figure><p>当然你也可以给列表中的参数命名，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(name1=object1,....)</span><br></pre></td></tr></table></figure><h1 id="数据的输入"><a href="#数据的输入" class="headerlink" title="数据的输入"></a>数据的输入</h1><p><code>R</code>可以从键盘，文本文件，Excel和Access，流行的统计软件，特殊格式的文件以及多种关系数据库导入数据。</p><blockquote><p>关于向R中导入数据的权威指南参见<a href="httpss://cran.r-project.org/doc/manuals/R-data.pdf">R Data Import&#x2F;Export手册</a></p></blockquote><h2 id="使用键盘输入数据"><a href="#使用键盘输入数据" class="headerlink" title="使用键盘输入数据"></a>使用键盘输入数据</h2><p><strong>使用<code>edit()</code>函数调用产生一个输入数据的文本框，输入数据</strong>即可完成键入数据。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个数据框</span></span><br><span class="line">a <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>name<span class="operator">=</span>character<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span>classNum<span class="operator">=</span>character<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span>Num<span class="operator">=</span>numeric<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 键入数据框内容</span></span><br><span class="line">a <span class="operator">&lt;-</span> edit<span class="punctuation">(</span>a<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 打印数据框内容</span></span><br><span class="line">print<span class="punctuation">(</span>a<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>弹出输入数据的文本框样式：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbff8c2923.png" alt="image-20220505211928183" style="zoom:80%;" /><blockquote><p><code>character(0)</code>是空字符型创建，<code>numeric(0)</code>是空数值型，<code>logical(0)</code>是空逻辑型</p></blockquote><h2 id="从带分隔符的文本文件导入数据"><a href="#从带分隔符的文本文件导入数据" class="headerlink" title="从带分隔符的文本文件导入数据"></a>从带分隔符的文本文件导入数据</h2><p>即从常规的<code>TXT</code>文本中读取数据，需要注意的是<strong>该文件需要是<code>ASCII</code>编码的文件</strong>。</p><blockquote><p>关于如何查看<code>TXT</code>文件是否是<code>ASCII</code>编码以及如何转换成<code>ASCII</code>编码的文件请自行百度</p></blockquote><p><strong>读取需要使用<code>read.table()</code>函数</strong>，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">read.table<span class="punctuation">(</span>file<span class="punctuation">,</span> header <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="built_in">quote</span> <span class="operator">=</span> <span class="string">&quot;\&quot;&#x27;&quot;</span><span class="punctuation">,</span></span><br><span class="line">           dec <span class="operator">=</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span> numerals <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;allow.loss&quot;</span><span class="punctuation">,</span> <span class="string">&quot;warn.loss&quot;</span><span class="punctuation">,</span> <span class="string">&quot;no.loss&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">           row.names<span class="punctuation">,</span> col.names<span class="punctuation">,</span> as.is <span class="operator">=</span> <span class="operator">!</span>stringsAsFactors<span class="punctuation">,</span></span><br><span class="line">           na.strings <span class="operator">=</span> <span class="string">&quot;NA&quot;</span><span class="punctuation">,</span> colClasses <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> nrows <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">           skip <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> check.names <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> fill <span class="operator">=</span> <span class="operator">!</span>blank.lines.skip<span class="punctuation">,</span></span><br><span class="line">           strip.white <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> blank.lines.skip <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">           comment.char <span class="operator">=</span> <span class="string">&quot;#&quot;</span><span class="punctuation">,</span></span><br><span class="line">           allowEscapes <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> flush <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">           stringsAsFactors <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">           fileEncoding <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> encoding <span class="operator">=</span> <span class="string">&quot;unknown&quot;</span><span class="punctuation">,</span> text<span class="punctuation">,</span> skipNul <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>file</code>：即文件路径</strong></li><li><strong><code>header</code>：（布尔值）即文件开头的是否是变量而不是数据</strong></li><li><strong><code>sep</code>：自定义数据分隔符，默认为空格</strong></li><li><strong><code>row.names</code>：自定义行名称</strong></li><li><strong><code>col.names</code>：自定义列名称</strong></li></ul><blockquote><p>文件路径<strong>如果提供的是相对路径，则需要将文件放在工作目录下</strong>，如果是绝对路径则不需要，<strong>绝对路径使用正斜杠</strong>。</p></blockquote><p>文本文件内容如下，第一行为列名称，数据通过<code>|</code>分割。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名|班级</span><br><span class="line">小明|林学一班</span><br><span class="line">小张|林学二班</span><br><span class="line">小亮|林学三班</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是在Win中，<code>TXT</code>文件最后需要以回车结尾，至于为什么可以参考<a href="httpss://zhuanlan.zhihu.com/p/380574688">CRLF和LF的差异</a></p></blockquote><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文本文件内容</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&#x27;D:/DATA/R/test.txt&#x27;</span><span class="punctuation">,</span>header <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>sep <span class="operator">=</span> <span class="string">&#x27;|&#x27;</span><span class="punctuation">,</span>row.names <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;第一行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第二行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三行&#x27;</span><span class="punctuation">)</span>  <span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> a</span><br><span class="line">       姓名     班级</span><br><span class="line">第一行 小明 林学一班</span><br><span class="line">第二行 小张 林学二班</span><br><span class="line">第三行 小亮 林学三班</span><br></pre></td></tr></table></figure><h2 id="导入Excel数据"><a href="#导入Excel数据" class="headerlink" title="导入Excel数据"></a>导入Excel数据</h2><p><strong>读取Excel最好的方式是将Excel导出为<code>csv</code>文件（逗号分隔文件），然后使用前面的读取文本来读取</strong>。</p><h3 id="使用R包读取Excel数据"><a href="#使用R包读取Excel数据" class="headerlink" title="使用R包读取Excel数据"></a>使用R包读取Excel数据</h3><p>在Windows系统中，可以<strong>使用<code>RODBC</code>包来访问Excel文件。电子表格第一行应当包含变量&#x2F;列的名称</strong>。</p><p>首先，<strong>下载安装<code>RODBC</code>包</strong>：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&#x27;RODBC&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>使用该包读取Excel文件，Excel文件内容如下：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姓名     班级 学号</span><br><span class="line">小明 林学一班  <span class="number">123</span></span><br><span class="line">小亮 林学二班  <span class="number">321</span></span><br><span class="line">小张 林学三班  <span class="number">345</span></span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 载入RODBC包</span></span><br><span class="line">library<span class="punctuation">(</span>RODBC<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 打开链接</span></span><br><span class="line">A <span class="operator">&lt;-</span> odbcConnectExcel2007<span class="punctuation">(</span><span class="string">&#x27;test.xlsx&#x27;</span><span class="punctuation">)</span> <span class="comment"># 注：如果你的电脑是32位的使用方法odbcConnectExcel(&#x27;test.xlsx&#x27;)</span></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">a <span class="operator">&lt;-</span> sqlFetch<span class="punctuation">(</span>A<span class="punctuation">,</span><span class="string">&#x27;Sheet1&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 关闭链接</span></span><br><span class="line">odbcClose<span class="punctuation">(</span>A<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 输出数据</span></span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">  姓名     班级 学号</span><br><span class="line"><span class="number">1</span> 小明 林学一班  <span class="number">123</span></span><br><span class="line"><span class="number">2</span> 小亮 林学二班  <span class="number">321</span></span><br><span class="line"><span class="number">3</span> 小张 林学三班  <span class="number">345</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>A &lt;- odbcConnectExcel2007(&#39;test.xlsx&#39;)</code>：A是打开Excel的一个链接通路，传入参数为Excel文件路径</strong></li><li><strong><code>a &lt;- sqlFetch(A,&#39;Sheet1&#39;)</code>：第一个参数传入打开的通路，第二个参数是表示第几个表</strong></li></ul><blockquote><p>如果你在<code>library(RODBC)</code>的时候报需要更高版本R的支持，可以选择手动导入旧版本包或者更新R版本</p></blockquote><p>当然，如果觉得上述繁琐，<strong>有一个最简单的方法，使用<code>xlsx</code>宏包中的 <code>read.xlsx()</code>函数</strong>。函数原型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">read.xlsx<span class="punctuation">(</span></span><br><span class="line">  file<span class="punctuation">,</span></span><br><span class="line">  sheetIndex<span class="punctuation">,</span></span><br><span class="line">  sheetName <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  rowIndex <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  startRow <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  endRow <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  colIndex <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  as.data.frame <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">  header <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">  colClasses <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">  keepFormulas <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">  encoding <span class="operator">=</span> <span class="string">&quot;unknown&quot;</span><span class="punctuation">,</span></span><br><span class="line">  password <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>file</code>：文件路径</strong></li><li><strong><code>sheetIndex</code>：文件中第几个表的索引</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>xlsx<span class="punctuation">)</span></span><br><span class="line">a <span class="operator">&lt;-</span> read.xlsx<span class="punctuation">(</span><span class="string">&#x27;test.xlsx&#x27;</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure><h3 id="从剪切板上读取Excel数据"><a href="#从剪切板上读取Excel数据" class="headerlink" title="从剪切板上读取Excel数据"></a>从剪切板上读取Excel数据</h3><p>通过将要输入的内容复制到剪切板，然后读取剪切板的内容来输入数据。</p><p><strong>通过<code>read.delim(&#39;clipboard&#39;)</code>函数来实现</strong>。</p><blockquote><p>在运行该函数之前，务必先复制正确的数据内容</p></blockquote><h2 id="从网页抓取数据"><a href="#从网页抓取数据" class="headerlink" title="从网页抓取数据"></a>从网页抓取数据</h2><blockquote><p>暂欠</p></blockquote><h2 id="从XML中导入数据"><a href="#从XML中导入数据" class="headerlink" title="从XML中导入数据"></a>从XML中导入数据</h2><blockquote><p>暂欠</p></blockquote><h2 id="访问数据框系统"><a href="#访问数据框系统" class="headerlink" title="访问数据框系统"></a>访问数据框系统</h2><p>如果写过程序的小伙伴可能会很熟悉这里，<strong>使用<code>RODBC</code>包提供的接口来链接数据库，该方法几乎可以连接市面上所有数据库系统</strong>。包中相关函数说明如下：</p><blockquote><p>注：在使用<code>RODBC</code>包访问数据库之前，需要根据自己的电脑下载相关的<code>ODBC</code>驱动。</p></blockquote><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>odbcConnect(dsn,uid=&quot;&quot;,pwd=&quot;&quot;)</code></td><td>建立数据库的连接</td></tr><tr><td><code>sqlFetch(channel,sqltable)</code></td><td>读取数据库中的某个表到一个数据框中</td></tr><tr><td><code>sqlQuery(channel,query)</code></td><td>向数据框提交查询并返回一个结果</td></tr><tr><td><code>sqlSave(channel,mydf,tablename=&quot;&quot;,append=FALSE)</code></td><td>将数据框写入或者更新(<code>append=True</code>)到数据库中的某个表</td></tr><tr><td><code>sqlDrop(channel,sqtable)</code></td><td>删除数据库中的某个表</td></tr><tr><td><code>close(channel)</code></td><td>关闭数据库的连接</td></tr></tbody></table><p>该包提供的是面向数据库的双向通路，既可以读取数据库也可以写入数据库。</p><p>关于该包的更多更详细的用法，自行查看包的相关说明。</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【10.0】C-文件</title>
      <link href="/2022/02/28/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%9010.0%E3%80%91%E6%96%87%E4%BB%B6/"/>
      <url>/2022/02/28/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%9010.0%E3%80%91%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>程序中数据的输入可以从键盘读取，但是对于大量的数据，人工输入的效率过于低下，而且对于多次运行的工作极为不便。所以可以通过程序对文件进行读取，然后将结果保存到另一个文件中，这样可以大幅度提高效率。</p><h1 id="文件概述"><a href="#文件概述" class="headerlink" title="文件概述"></a>文件概述</h1><h2 id="文件的定义"><a href="#文件的定义" class="headerlink" title="文件的定义"></a>文件的定义</h2><p>文件指存储在外部存储介质中的有序数据集合，如系统头文件<code>stdio.h</code>，程序所生成的源文件<code>.c</code>文件，编译后产生的<code>.obj</code>目标文件，链接后生成的<code>.exe</code>执行文件。</p><h2 id="文件的分类"><a href="#文件的分类" class="headerlink" title="文件的分类"></a>文件的分类</h2><ol><li><p>从用户的角度来看，文件可以分为普通文件和设备文件</p><p>普通文件是驻留在存储介质上的有序数据集。。普通文件依据其存储内容可以分为程序文件，如源文件，头文件等，以及数据文件，存储待输入的原始数据和输出的结果数据文件。</p><p><strong>C语言将所有外部设备都看作文件，这就是设备文件，如显示器，打印机，键盘等，将它们对系统的输入，输出等同于对磁盘文件的读和写</strong>。通常将显示器作为标准输出文件，在屏幕上的显示即是向标准输出文件输出，<code>printf()</code>，<code>putchar()</code>称为标准输出函数即原因。键盘则作为标准输入文件，从键盘上输入即标准输入文件读入数据，因此<code>scanf()</code>，<code>getchar()</code>称为标准输入函数。</p></li><li><p><strong>虽然文件在计算中皆是用二进制 0，1 来表达与存储，但从文件的编码方式来看，文件可以分为 ASCII码文件和二进制码文件</strong>。一般文件的最基本存储单位为字节（8位二进制），文件即是由一个个字节按一定顺序构成的，但每个字节表达含义不同，则文件编码方式也不同。</p><p>ASCII码文件：也称为文本文件。在磁盘中存放的文件的每个字节都是对应字符的ASCII码。例如，对数值5678存储为对应字符5，6，7，8的ASCII码，形式为：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbbe530b8f.png" alt="image-20220218143616511" style="zoom: 80%;" /><p>ASCII码文件可在屏幕上按字符显示，因此方便阅读，如源程序文件，头文件便ASCII码文件。</p><p>二进制文件：文件在磁盘中存放的是对应数值的二进制形式。如数值5678存储的二进制表示为 0001011000101110 。二进制文件的优点在于节省存储空间，但是可读性较差。</p><p><strong>C语言在处理文件时，并不区分类型，都按字节处理，看成字符流。输入&#x2F;输出字符流的开始和结束也只是由程序控制而不受物理符号（如回车符）的控制。因此也将这种文件称为流式文件或流文件，这是文件较为重要的一个概念。</strong></p></li></ol><h1 id="文件类型指针"><a href="#文件类型指针" class="headerlink" title="文件类型指针"></a>文件类型指针</h1><p>在C语言中，对文件的所有操作都是通过文件类型指针来进行的。文件类型指针是指向文件结构体变量的指针。所谓文件结构体变量是指<strong>文件处理时，在缓存区开辟的文件信息描述区，而该信息描述区是以一个结构体变量来描述和记录文件的当前状态（如文件名，文件大小等）。描述和记录文件状态的结构体变量称为文件结构体变量，其结构体类型由系统定义，名为<code>FILE</code>，包含在头文件<code>stdio.h</code>中</strong>，因此文件操作必须使用<code>#include &lt;stdio.h&gt;</code>命令。C语言便是通过操作指向文件结构体变量的指针来进行文件处理，有时也简称为指向文件的指针或者文件指针。</p><p><code>FILE</code>结构体类型的形式大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="type">short</span> _level;<span class="comment">//缓冲区满空程度 </span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> _flag;<span class="comment">//文件号</span></span><br><span class="line">   <span class="type">char</span> _fd;<span class="comment">//文件描述符</span></span><br><span class="line">   <span class="type">short</span> _size;<span class="comment">//缓存区的大小</span></span><br><span class="line">   <span class="type">char</span> *_buffer;       <span class="comment">//数据缓冲区首地址</span></span><br><span class="line">   <span class="type">int</span> _cleft;      <span class="comment">//缓冲区中剩下的字符</span></span><br><span class="line">   <span class="type">int</span> _mode;       <span class="comment">//文件的操作模式</span></span><br><span class="line">   <span class="type">char</span> *_curp;     <span class="comment">//指针当前位置</span></span><br><span class="line">   <span class="type">char</span> *_nextc;        <span class="comment">//下个字符的位置</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> _istemp;        <span class="comment">//临时文件指示</span></span><br><span class="line">   <span class="type">short</span> _token;        <span class="comment">//有效性标记</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不同C语言系统<code>FILE</code>类型的定义会有少许不同。文件指针的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE * 指针变量标识符;</span><br></pre></td></tr></table></figure><p>一般习惯写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE * fp;</span><br></pre></td></tr></table></figure><p>通过指针<code>fp</code>指向某个具体文件来对文件进行操作。</p><blockquote><p><code>fp</code>是：file Pointer 的缩写</p></blockquote><h1 id="文件的打开，读写和关闭"><a href="#文件的打开，读写和关闭" class="headerlink" title="文件的打开，读写和关闭"></a>文件的打开，读写和关闭</h1><p><strong>在进行文件的读写之前需要先打开文件，读写完毕之后必须关闭文件，打开与关闭文件是必不可少的操作</strong>。打开文件即是建立文件指针与文件的关系，关闭则是释放指针与文件的联系，同时保证缓冲区中的数据写入文件。</p><h2 id="文件的打开函数fopen"><a href="#文件的打开函数fopen" class="headerlink" title="文件的打开函数fopen()"></a>文件的打开函数<code>fopen()</code></h2><p><code>fopen()</code>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE * <span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">const</span> <span class="type">char</span> * mode)</span>;</span><br></pre></td></tr></table></figure><p>利用<code>fopen()</code>函数打开文件方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE * fp;</span><br><span class="line">fp=fopen(<span class="string">&quot;文件名&quot;</span>,<span class="string">&quot;文件操作方式标识符&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line">fp=fopen(<span class="string">&quot;myfile&quot;</span>,<span class="string">&quot;w&quot;</span>);<span class="comment">//以只写的方式打开文件myfile</span></span><br></pre></td></tr></table></figure><p><strong>调用函数时，系统会在缓冲区为文件开辟一个文件信息描述区，获得该文件信息描述区（文件结构变量）的地址，并将它赋值给指针<code>fp</code>，从而<code>fp</code>与文件联系起来，通过<code>fp</code>便可以实现对文件的各种操作。如果文件不能打开（打开文件失败），则<code>fopen()</code>函数返回空指针<code>NULL</code>（其值为0）.</strong></p><p>文件名可以包含文件路径，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp=fopne(<span class="string">&quot;C:\\test\nyfile&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br></pre></td></tr></table></figure><p>上述打开文件方式，为ANSIC规定方式。</p><blockquote><p>American National Standards Institute（ANSI——美国国家标准学会）</p></blockquote><p>文件操作方式标识符如下标：</p><table><thead><tr><th align="center">文件操作方式标识符</th><th align="left">意义</th></tr></thead><tbody><tr><td align="center">“r”</td><td align="left">以只读的方式打开一个文本文件，只允许读数据</td></tr><tr><td align="center">“w”</td><td align="left">以只写的方式打开或建立一个文本文件，只允许写数据</td></tr><tr><td align="center">“a”</td><td align="left">以追加方式打开一个文本文件，并在文件末尾增加数据</td></tr><tr><td align="center">“rb”</td><td align="left">以只读方式打开一个二进制文件，只允许读数据</td></tr><tr><td align="center">“wb”</td><td align="left">以只写方式打开或建立一个二进制文件，只允许写数据</td></tr><tr><td align="center">“ab”</td><td align="left">以追加方式打开一个二进制文件，并在文件末尾写数据</td></tr><tr><td align="center">“r+”</td><td align="left">以读写方式打开一个文本文件，允许读和写</td></tr><tr><td align="center">“w+”</td><td align="left">以读写方式打开或者建立一个文本文件，允许读和写</td></tr><tr><td align="center">“a+”</td><td align="left">以读写方式打开一个文本文件，允许读，或者在文件末尾追加数据</td></tr><tr><td align="center">“rb+”</td><td align="left">以读写方式打开一个二进制文件，允许读和写</td></tr><tr><td align="center">“wb+”</td><td align="left">以读写方式打开或者建立一个二进制文件，允许读和写</td></tr><tr><td align="center">“ab+”</td><td align="left">以读写方式打开一个二进制文件，允许读，或在文件末尾追加数据</td></tr></tbody></table><p>需要注意的是：</p><ol><li><p><strong>以只读方式<code>r</code>打开文件时，该文件必须以及存在，否则出错，且只能进行读取操作。</strong></p></li><li><p><strong>以只写方式<code>w</code>打开文件时，如果文件不存在，则以指定的文件名新建文件，若打开的文件已经存在，则原文件内容消失，重写写入内容且只能进行写操作。</strong></p></li><li><p><strong>以追加方式<code>a</code>打开文件，若文件不存在则出错，若文件存在则向文件末尾追加新的信息</strong></p></li><li><p>如一个文件无法打开，或者打开出错，将无法进行正确读写操作，如果不对文件打开加以判断，则用户无法了解是否可以进行下一步操作，<strong>因此文件操作除打开，关闭这两个要素外，还需要打开判断</strong>。**如果打开出错，<code>fopen()</code>函数将返回一个空指针<code>NULL</code>**，因此在程序中可以使用下面的语句进行判断是否打开：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">&quot;myfile&quot;</span>,<span class="string">&quot;w&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error: fail in opening myfile&quot;</span>);</span><br><span class="line">    getch();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>getch()</code>函数是获取字符，但是不显示在屏幕上。</p><p><code>exit(1)</code>是系统级别的函数，表示异常退出，<code>exit(0)</code>表示正常退出。</p></blockquote></li><li><p>文本文件读入内存时，需要将ASCII码转换成二进制码，写入磁盘时，再把二进制码转换成ASCII码，因此文本文件的读写相比于二进制文件，需要花费转换时间。</p></li></ol><h2 id="文件的关闭函数fclose"><a href="#文件的关闭函数fclose" class="headerlink" title="文件的关闭函数fclose()"></a>文件的关闭函数<code>fclose()</code></h2><p>文件打开成功并操作完毕后，如不关闭文件，文件读写的数据可能丢失。<strong>因为文件的操作是通过缓冲区进行的，读写数据是先放入缓冲区，满时才写入文件，如操作后缓冲区未满，又未关闭文件，则缓冲区中的数据将丢失，因此必须使用文件关闭命令，将缓冲区的数据写入文件</strong>。文件关闭函数<code>fclose()</code>原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fpoint)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><p><strong>如果关闭成功，则<code>fclose()</code>函数返回 0 ，否则返回 EOF（-1）</strong>。通过判断<code>fclose()</code>函数返回值可知晓文件是否正常关闭。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((rNum=fclose(fp)!=<span class="number">0</span>))</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error:fail in file close&quot;</span>);</span><br></pre></td></tr></table></figure><p>文件关闭不仅可以保存数据，同时还会释放文件结构体变量所占存储空间，可节省系统资源。</p><p>【关于EOF的说明】</p><p>以下内容来源于百度百科 <a href="httpss://baike.baidu.com/item/EOF/1017800?fr=aladdin">EOF</a></p><p><em>在C语言中，或更精确地说成C标准函数库中表示文件结束符（end of file）。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以<a href="httpss://baike.baidu.com/item/字符">字符</a>的<a href="httpss://baike.baidu.com/item/ASCII">ASCII</a>代码值的形式存放。我们知道，<a href="httpss://baike.baidu.com/item/ASCII代码">ASCII代码</a>值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。</em></p><h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><p>除了打开，打开判断，关闭这三个文件操作要素外，对文件实际的改变操作是中间对文件的读和写。C语言提高多种文件读写函数，也包含在头文件<code>stdio,h</code>中，主要有：</p><ul><li><strong>文件字符读&#x2F;写函数：<code>fgetc()</code>&#x2F;<code>fputc()</code></strong></li><li><strong>文件字符串读&#x2F;写函数：<code>fgets()</code>&#x2F;<code>fputs()</code></strong></li><li><strong>文件格式化读&#x2F;写函数：<code>fprintf()</code>&#x2F;<code>fscanf()</code></strong></li><li><strong>文件数据块读&#x2F;写函数：<code>fread()</code>&#x2F;<code>fwrite()</code></strong></li></ul><p>所有读函数，都必须是读或读写方式打开文件；所有写函数，都必须是写或者读写的方式，或者追加方式打开文件。如果希望重建文件，则采用只写或者读写的方式打开文件，如果希望保留原文件内容，从后面开始新内容，则用追加或者读写方式打开文件。</p><ol><li><p><strong>文件字符读写函数</strong></p><ul><li><p>**文件读字符函数<code>fgetc()</code>**，函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE * fpoint)</span>;</span><br></pre></td></tr></table></figure><p><code>fgetc()</code>函数调用形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=fgetc(fp);</span><br></pre></td></tr></table></figure><p>其中<code>c</code>为字符变量，也可以是数组字符元素等。**<code>fgetc()</code>函数每次从文件中读取一个字符，返回值为该字符的 ASCII 码，如返回值为 EOF ，则表示已到达文件结束位置。**</p><p><strong>打开文件后，<code>fgetc()</code>函数读取的是第一个字符，再调用<code>fgetc()</code>函数则依次读取下一关字符，如果读至结束则返回 EOF</strong> 。实际上，读写位置是由文件内部的位置指针控制的，打开时，位置指针指向第一个字节，并随着函数的调用后移，该位置指针由系统自动设置，不需要用户定义。</p></li><li><p>**文件写字符函数<code>fputc()</code>**，函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c,FILE * fpoint)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">fputc(字符量,文件fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">fputc(c,fp);</span><br></pre></td></tr></table></figure><p><strong><code>fputc()</code>函数每次向文件写入一个字符，写入成功则返回字符的 ASCII 码值，写入失败则返回 EOF</strong>。</p></li></ul><p>【实例】显示<code>.txt</code>文件内容并写入新内容，再显示新内容</p><p> 【代码示例】</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PutOut</span><span class="params">(FILE *fp)</span>;      <span class="comment">//输出文件内容函数原型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteNew</span><span class="params">(FILE *fp)</span>;        <span class="comment">//输入新内容函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">FILE *fp;       <span class="comment">//声明文件指针</span></span><br><span class="line"><span class="comment">//文件指针指向文件并设置打开失败输出</span></span><br><span class="line"><span class="comment">//a+ 允许读和追加</span></span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">&quot;txt.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error: fail in opening myfile&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">PutOut(fp);     <span class="comment">//输出原内容</span></span><br><span class="line">WriteNew(fp);   <span class="comment">//输入新内容</span></span><br><span class="line">PutOut(fp);     <span class="comment">//输出新内容</span></span><br><span class="line">fclose(fp);     <span class="comment">//关闭文件指针</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出原文件的内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PutOut</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件的内容：\n&quot;</span>);</span><br><span class="line">rewind(fp);     <span class="comment">//将文件指针移动到开始处</span></span><br><span class="line"><span class="type">char</span> c = fgetc(fp);</span><br><span class="line"><span class="keyword">while</span> (c&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line">c = fgetc(fp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加新内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteNew</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n请输入新增内容:\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> x = getchar();</span><br><span class="line"><span class="keyword">while</span> (x!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">fputc(x, fp);</span><br><span class="line">x = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  【输出】</p>  <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbbf22ec6e.png" alt="image-20220220164146907" style="zoom:80%;" /></li><li><p><strong>文件字符串读写函数</strong></p><ul><li><p>**文件字符串读函数<code>fgets()</code>**，函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n,FILE * fpoint)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line">fgets(字符数组名,n,文件指针);</span><br></pre></td></tr></table></figure><p>其功能是从文件指针所指文件中读取一个长度为<code>n-1</code>的字符串，在最后一个字符之后加上字符串结束标志<code>\0</code>后，存入一个字符数组中。</p><p>**若<code>fgets()</code>函数执行成功，则返回字符数组首元素的地址，如果一开始就遇到文件尾或者数据错误，则返回<code>NULL</code>**。</p></li><li><p>**文件字符串写函数<code>fputs()</code>**，函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">char</span> * <span class="built_in">string</span>,FILE * fpoint)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line"><span class="built_in">fputs</span>(字符串，文件指针);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;Hello&quot;</span>,fp);</span><br></pre></td></tr></table></figure><p><strong>其功能是往文件中写入一个字符串，其中字符串可以是字符串常量，也可以是有赋值的字符数组。如果写入成功，则返回一个非负值，反之则返回 E0F （-1）。</strong></p></li></ul><p>【实例】读取文件前10个字符输出显示，然后从键盘输入字符串写入文件并显示</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CloseFile</span><span class="params">(FILE *fp)</span>;       <span class="comment">//关闭文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpenFile</span><span class="params">(FILE *fp)</span>;        <span class="comment">//打开文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadFile</span><span class="params">(FILE *fp,<span class="type">int</span> num)</span>;        <span class="comment">//读取文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteFile</span><span class="params">(FILE *fp)</span>;       <span class="comment">//写入文件函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE *fp=fopen(<span class="string">&quot;txt.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    OpenFile(fp);</span><br><span class="line">    ReadFile(fp,<span class="number">12</span>);</span><br><span class="line">    WriteFile(fp);</span><br><span class="line">    ReadFile(fp,<span class="number">20</span>);</span><br><span class="line">    CloseFile(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpenFile</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error: fail in opening myfile&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文件关闭函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CloseFile</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadFile</span><span class="params">(FILE * fp,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n读取文件内容： &quot;</span>);</span><br><span class="line">    rewind(fp);</span><br><span class="line">    <span class="type">char</span> c[<span class="number">20</span>];</span><br><span class="line">    fgets(c, num, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n文件内容读取完毕\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写入文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteFile</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n请输入要添加的内容: &quot;</span>);</span><br><span class="line">    fseek(fp, <span class="number">8</span>, SEEK_END);<span class="comment">//将指针移到文件最后</span></span><br><span class="line">    <span class="type">char</span> x[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fputs</span>(x, fp)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内容接收完毕\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbbf745b74.png" alt="image-20220220185220626" style="zoom:80%;" /><blockquote><p><a href="httpss://www.runoob.com/cprogramming/c-function-fseek.html">关于库函数<code>fseek()</code>的说明</a>或者查看下面的文件定义的说明</p></blockquote></li><li><p><strong>文件格式化读写函数</strong></p><ul><li><p>**文件格式化读函数<code>fscanf()</code>**。</p><p><code>fscanf()</code>函数与<code>scanf()</code>函数功能类似，区别在于<code>scanf()</code>函数从标志输入文件（即键盘）读取，<code>fscanf()</code>函数则是从文件中读取。函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE * fpoint,<span class="type">char</span> * format,[argument...])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line"><span class="built_in">fscanf</span>(文件指针，格式控制字符串，输入项列表);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">fscanf</span>(fp,<span class="string">&quot;%c%d&quot;</span>,&amp;c,&amp;a);</span><br></pre></td></tr></table></figure></li><li><p>**文件格式化写函数<code>fprintf()</code>**。</p><p><code>fprintf()</code>函数与<code>printf()</code>函数功能类似，区别在于<code>pritnf()</code>函数输出到标志输出文件（即显示器），<code>fprintf()</code>函数则输出到磁盘文件。函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE * fpoint,<span class="type">char</span> * format,[argument...])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line"><span class="built_in">fprintf</span>(文件指针，格式控制字符串，输出项列表);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;%c%d&quot;</span>,c,a);</span><br></pre></td></tr></table></figure></li></ul><p>【实例】读取指定数量字符，并写入文件其 ASCII 码值</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpenFile</span><span class="params">(FILE *fp)</span>;        <span class="comment">//打开文件函数原型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CloseFile</span><span class="params">(FILE *fp)</span>;       <span class="comment">//关闭文件函数原型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpeFile</span><span class="params">(FILE *fp)</span>;        <span class="comment">//操作文件函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;txt.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    OpenFile(fp);</span><br><span class="line">    OpeFile(fp);</span><br><span class="line">    CloseFile(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpenFile</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error: fail in opening myfile&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文件关闭函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CloseFile</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpeFile</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n读取文件内容： &quot;</span>);</span><br><span class="line">    rewind(fp);</span><br><span class="line">    <span class="type">char</span> a, b;</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%c%c&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c%c(前两个字符)&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n文件内容读取完毕\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在写入文件&quot;</span>);</span><br><span class="line">    fseek(fp, <span class="number">8</span>, SEEK_END);<span class="comment">//将文件指针移到最后</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d%d&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写入文件完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbbfcbfc3b.png" alt="image-20220220193029544" style="zoom:80%;" /><blockquote><p>需要注意的是每次读取文件的时候，注意将文件指针使用<code>rewind()</code>函数移动到开始</p></blockquote></li><li><p><strong>文件数据块读写函数</strong></p><p><strong>所谓数据块读写是指一次读取一组数据，</strong>如数组，结构体变量等。数据块读写函数调用形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fread(buffer,size,count,fp);</span><br><span class="line">fwrite(buffer,size,count,fp);</span><br></pre></td></tr></table></figure><p><strong>其中<code>buffer</code>为输入或者输出数据首地址，为指针变量，<code>size</code>为数据块长度（字节数），<code>count</code>表示要读写的数据块的个数，<code>fp</code>为文件指针</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">fread(str,<span class="number">3</span>,<span class="number">5</span>,fp);</span><br></pre></td></tr></table></figure><p>即从<code>fp</code>所指的文件中每次读取 3 个字节，读取 5 次，存入数组<code>str</code>中。</p><p><strong><code>fread()</code>以及<code>fwrite()</code>函数的返回值都是整型，如果该整数和<code>count</code>相等，则表示读写是成功的，否则表示读写不正确。</strong></p><p>【实例】某超市把以下4种库存商品的信息写入 commodity.dat 文件中，并读出来进行检测。</p><table><thead><tr><th>商品编号</th><th>商品名称</th><th>商品价格</th><th>商品库存量</th></tr></thead><tbody><tr><td>1001</td><td>电视</td><td>4500</td><td>10</td></tr><tr><td>1002</td><td>空调</td><td>8000</td><td>15</td></tr><tr><td>1003</td><td>冰箱</td><td>5000</td><td>6</td></tr><tr><td>1004</td><td>洗衣机</td><td>6000</td><td>30</td></tr></tbody></table><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Commodity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;Commodity;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化数据</span></span><br><span class="line">    Commodity commd[<span class="number">4</span>] = &#123;&#123;<span class="number">1001</span>,<span class="string">&quot;电视&quot;</span>,<span class="number">4500</span>,<span class="number">10</span>&#125;, &#123;<span class="number">1002</span>,<span class="string">&quot;空调&quot;</span>,<span class="number">4500</span>,<span class="number">10</span>&#125;, &#123;<span class="number">1001</span>,<span class="string">&quot;冰箱&quot;</span>,<span class="number">4500</span>,<span class="number">10</span>&#125;, &#123;<span class="number">1001</span>,<span class="string">&quot;洗衣机&quot;</span>,<span class="number">4500</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line">    Commodity commd2[<span class="number">4</span>];</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;commodity.dat&quot;</span>,<span class="string">&quot;ab+&quot;</span>);        <span class="comment">//打开文件指针</span></span><br><span class="line">    fwrite(commd, <span class="keyword">sizeof</span>(Commodity), <span class="number">4</span>, fp);    <span class="comment">//将缓冲区数据写入文件</span></span><br><span class="line">    rewind(fp);     <span class="comment">//指针指向文件开头</span></span><br><span class="line">    fread(commd2, <span class="keyword">sizeof</span>(Commodity), <span class="number">4</span>, fp);        <span class="comment">//将数据写入文件缓冲区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件中的内容为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d | %s | %d | %d \n&quot;</span>, commd2[i].id,commd2[i].name,commd2[i].num,commd2[i].price);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc014ea74.png" alt="image-20220220200605907" style="zoom:80%;" /></li></ol><h1 id="文件的定位"><a href="#文件的定位" class="headerlink" title="文件的定位"></a>文件的定位</h1><p>前面的实例中多次使用了<code>rewind()</code>函数，用来将文件位置指针返回到文件开头。所以，我们在操作文件时，应该先清楚文件位置指针在什么位置，根据位置来进行处理。<strong>文件定位函数便是操作文件位置指针用于判断以及其指定其位置的函数</strong>。</p><p><strong>文件定位函数包含在头文件<code>stdio.h</code>中</strong>。</p><ol><li><p><strong><code>rewind()</code>函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE * fpoint)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line">rewind(fp);</span><br></pre></td></tr></table></figure><p>不论当前指针位置在哪里，<code>rewind()</code>函数都将文件位置指针返回文件开头。</p></li><li><p><strong><code>fseek()</code>函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE * fpoint,<span class="type">long</span> offset,<span class="type">int</span> origin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line">fseek(fp,位移量，起始点);</span><br></pre></td></tr></table></figure><p><strong><code>fseek()</code>函数用于把文件位置指针移动到指定位置上。起始点有3个取值：</strong></p><ul><li><strong>0（<code>SEEK_SET</code>）表示文件开始位置；</strong></li><li><strong>1（<code>SEEK_CUR</code>）表示当前位置;</strong></li><li><strong>2（<code>SEEK_END</code>）表示文件末尾；</strong></li></ul><p><strong>位移量表示从起始点开始移动的字节数，为长整型。位移量为正表示文件指针向文件末尾移动，反之则向文件开头方向移动。</strong>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">8</span>,SEEK_END);</span><br></pre></td></tr></table></figure><p>表示移动文件位置指针到文件的末尾，共移动 8 个字节。</p></li><li><p><strong><code>ftell()</code>函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line">loog <span class="title function_">ftell</span><span class="params">(FILE * fpoint)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line">loog n = ftell(fp);</span><br></pre></td></tr></table></figure><p>**<code>ftell()</code>函数用于寻找位置指针的当前位置。返回值为位置指针当前位置相对于文件首的偏移字节数。如果调用出错，则返回<code>-1L</code>**。</p></li><li><p><strong><code>feof()</code>函数</strong></p><p><strong><code>feof()</code>函数用于判断文件位置指针是否在文件结束位置。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE * stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line">feof(fp);</span><br></pre></td></tr></table></figure><p><strong><code>feof()</code>函数返回值为 1 表示位置指针在文件末尾，否则返回 0 。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【9.0】C-结构体与共用体</title>
      <link href="/2022/02/27/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%909.0%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%85%B1%E7%94%A8%E4%BD%93/"/>
      <url>/2022/02/27/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%909.0%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%85%B1%E7%94%A8%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>C语言的数据类型分为基本数据类型和构造数据类型</strong>，之前的<code>int</code>,<code>float</code>等数据类型都是基本数据类型，都是C语言事先定义好的数据类型，编程时直接使用即可。<strong>C语言还允许用户自定义数据类型，称为构造数据类型，例如：数组，以及下面的结构体和共用体。</strong></p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体(structure)是由不同数据类型的数据所组成的集合体，是构造数据类型，<strong>其特点是可以由不同的数据类型构成</strong>。</p><p>每一个结构体有一个名字，称为结构体名。一个结构体由若干成员组成，每个成员都有自己的名字，称为结构体成员名。结构体成员是组成结构体的要素，每个成员的数据类型可以不同。</p><p>简单来描述结构体来说如下表：</p><table><thead><tr><th align="center">学号</th><th align="center">姓名</th><th align="center">性别</th><th align="center">成绩</th></tr></thead><tbody><tr><td align="center">xxx</td><td align="center">xxx</td><td align="center">xxx</td><td align="center">xxx</td></tr></tbody></table><p>对于一个结构体来说就是头行，我们现在定义他的名称为：学生信息，那么组成学生信息的成员就是：学号，姓名，性别，成绩。这几个元素就是学生信息结构体的成员&#x2F;元素。对于各种元素他们的类型是可以不同的。</p><h2 id="结构体类型的定义"><a href="#结构体类型的定义" class="headerlink" title="结构体类型的定义"></a>结构体类型的定义</h2><p>语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    数据类型 成员<span class="number">1</span>的名字;</span><br><span class="line">    数据类型 成员<span class="number">2</span>的名字;</span><br><span class="line">    数据类型 成员<span class="number">3</span>的名字;</span><br><span class="line">   ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>struct</code>是结构体类型标识符，是关键词。结构体名由标识符组成，称为结构体类型名，由用户指定。大括号<code>&#123;&#125;</code>中的结构体成员表，称为结构体。</strong></p><p>【实例】对于上面的举例表格的结构体实现如下：</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>//结构体名<span class="title">studentInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;<span class="comment">//学号</span></span><br><span class="line">    <span class="type">char</span> name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> sex;<span class="comment">//性别</span></span><br><span class="line">    <span class="type">float</span> score;<span class="comment">//成绩</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>【说明】</p><p>如上定义的<code>studentInfo</code>是一种自定义的新数据类型，系统不会对它分配实际的存储空间，只是一种自定义数据模板。</p><p>声明结构体需要注意以下几点：</p><ol><li><p><strong>结构体声明描述了结构体的组织形式，在程序编译时并不为它分配存储空间</strong>。只是规定了一种特定的数据结构类型以及它所占用的存储空间。</p></li><li><p><strong>结构体成员可以是任意类型</strong>。所以，结构体可以嵌套使用，即一个结构体可以称为另一个结构体的成员，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>//学生信息结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;<span class="comment">//学号</span></span><br><span class="line">    <span class="type">char</span> name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> sex;<span class="comment">//性别</span></span><br><span class="line">    <span class="type">float</span> score;<span class="comment">//分数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data</span> <span class="title">birthday</span>;</span><span class="comment">//出生日期</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> year;<span class="comment">//年份</span></span><br><span class="line">    <span class="type">int</span> mouth;<span class="comment">//月份</span></span><br><span class="line">    <span class="type">int</span> day;<span class="comment">//日份</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>结构体声明可以在任意位置</strong>，如果声明在自定义函数内，则只可以在自定义函数内调用，如果声明在自定义函数外，则可以在从声明点到最后范围内调用。<strong>一般情况下，是在源文件的开头对结构体进行声明</strong>。</p></li><li><p>结构体成员名可以与程序中其他变量同名，系统会自动识别它们，两种不会混淆。</p></li></ol><h2 id="结构体变量的定义"><a href="#结构体变量的定义" class="headerlink" title="结构体变量的定义"></a>结构体变量的定义</h2><p>结构体变量定义一般采用下面三种形式：</p><ol><li><p><strong>先声明结构体类型再定义变量</strong>，其定义形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>//结构体声明</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span> <span class="title">test</span>;</span><span class="comment">//结构体定义</span></span><br></pre></td></tr></table></figure><p><strong>在定义了结构体变量后，系统会为结构体变量分配存储空间。</strong></p><p>若程序规模比较大，可将对结构体类型的声明集中放到一共文件中（以<code>.h</code>为后缀的头文件）。若其他源文件需要用到此结构体类型，则可以用<code>#include</code>命令将该头文件包含到本文件中，便于修改和使用。</p></li><li><p><strong>在声明结构体类型同时定义结构体变量</strong>，其定义形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    数据类型 成员<span class="number">1</span>的名字;</span><br><span class="line">    数据类型 成员<span class="number">2</span>的名字;</span><br><span class="line">    数据类型 成员<span class="number">3</span>的名字;</span><br><span class="line">   ···</span><br><span class="line">&#125;结构体变量名表;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>//结构体声明</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;a,b,c;<span class="comment">//定义三个studentInfo类型的结构体变量</span></span><br></pre></td></tr></table></figure></li><li><p><strong>直接定义结构体变量，不出现结构体名</strong>，其定义形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>//注意：此处结构体名没了</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    数据类型 成员<span class="number">1</span>的名字;</span><br><span class="line">    数据类型 成员<span class="number">2</span>的名字;</span><br><span class="line">    数据类型 成员<span class="number">3</span>的名字;</span><br><span class="line">   ···</span><br><span class="line">&#125;结构体变量名表;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>//结构体声明</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;a,b,c;</span><br></pre></td></tr></table></figure></li></ol><p>结构体变量定义需要注意：</p><ol><li>结构体数据类型的定义描述了结构体的类型的模式，不分配存储空间；而结构体变量定义则是在编译时为结构体变量分配存储空间。</li><li>结构体变量中的成员可以单独使用，其作用和地位与一般变量一致</li><li>**结构体变量占用存储空间的大小是各成员所需内存量的总和，在程序中可以用<code>sizeof()</code>函数来实现，即<code>sizeof(结构体名)</code>**。需要注意的是：有时与<code>sizeof()</code>函数计算出来的值不是完全一样的，这个实际的内存量，不仅与所定义的结构体类型有关，还与计算机系统以及编译系统有关。通常系统为结构体变量分配内存大小，会大于或等于所有成员所占用内存字节数的总和。</li></ol><h2 id="用typedef定义数据类型"><a href="#用typedef定义数据类型" class="headerlink" title="用typedef定义数据类型"></a>用<code>typedef</code>定义数据类型</h2><p><strong>关键字<code>typedef</code>用于为系统固有的或者自定义数据类型定义一个别名</strong>。数据类型的别名通常使用大写字母，这不是强制性的，只是为了与已有数据类型区分。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTNUM;<span class="comment">//定义int类型的别名为INTNUM</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    INTNUM a = <span class="number">2</span>;<span class="comment">//使用别名声明并定义变量值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：2</p><p>同样的也可以使用<code>typedef</code>来定义结构体数据类型，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">&#125;a=&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> <span class="title">info</span>;</span><span class="comment">//将结构体类型关键字定义为info</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体变量的引用"><a href="#结构体变量的引用" class="headerlink" title="结构体变量的引用"></a>结构体变量的引用</h2><p>在定义结构体变量后，如果需要引用结构体变量，需要注意的是不可以将结构体整体作为输入和输出，只能对具体成员进行输入输出，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是错误的,S是结构体变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,S);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是正确的</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,S.num);</span><br></pre></td></tr></table></figure><p>也就是说，访问结构体成员变量的语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用格式</span></span><br><span class="line">结构体名.成员名称</span><br><span class="line">    </span><br><span class="line"><span class="comment">//如果结构体嵌套结构体类型，则调用就一直 . 下去就行</span></span><br><span class="line">结构体名.嵌套结构体.嵌套结构体成员名称</span><br></pre></td></tr></table></figure><blockquote><p>结构体变量不能进行整体输入和输出，当时允许相同结构体类型的结构体变量赋值，例如：<code>S1=S2</code>。</p></blockquote><h2 id="结构体变量的初始化"><a href="#结构体变量的初始化" class="headerlink" title="结构体变量的初始化"></a>结构体变量的初始化</h2><p>可以在定义结构体变量的同时初始化，语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">strust 结构体类型名 结构体变量名 = &#123;初始化数据&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line">strust Student <span class="built_in">std</span>=&#123;<span class="string">&quot;小明&quot;</span>,<span class="number">2</span>,<span class="number">98</span>&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li><strong>初始化数据与数据之间用逗号隔开</strong></li><li>初始化数据的数量要和结构体成员对应且相等</li><li>初始化数据对应的数据类型一致</li></ol><p>结构体变量初始化代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">&#125;a=&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> <span class="title">a</span>=</span>&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><h1 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h1><p>一个结构体变量中可以存放一组数据，即excel表中“一行”数据。如果数据有很多行，即对应很多个对象，这时就可以使用结构体数组来表示。结构体数组的元素是一个结构体类型的变量。</p><h2 id="结构体数组的定义"><a href="#结构体数组的定义" class="headerlink" title="结构体数组的定义"></a>结构体数组的定义</h2><p>结构体数组必须先定义，后引用。代码格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span>//声明结构体类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> <span class="title">s</span>[10];</span><span class="comment">//声明结构体数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span>//声明结构体类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">&#125;s[<span class="number">10</span>];<span class="comment">//声明结构体数组</span></span><br></pre></td></tr></table></figure><h2 id="结构体数组的初始化"><a href="#结构体数组的初始化" class="headerlink" title="结构体数组的初始化"></a>结构体数组的初始化</h2><p>结构体数组也可以在初始化的同时进行初始化，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudnentInfo</span> <span class="title">stfinfo</span>[10]=</span>&#123;&#123;<span class="number">1</span>,<span class="string">&quot;test&quot;</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="string">&quot;test1&quot;</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="string">&quot;test2&quot;</span>,<span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>上述示例代码是对结构图数组前三个元素进行初始化。</p><h2 id="结构体数组的引用"><a href="#结构体数组的引用" class="headerlink" title="结构体数组的引用"></a>结构体数组的引用</h2><p>【实例】求下表成绩平均值</p><table><thead><tr><th>姓名</th><th>性别</th><th>成绩</th></tr></thead><tbody><tr><td>张三</td><td>1</td><td>98</td></tr><tr><td>李四</td><td>1</td><td>80</td></tr><tr><td>小明</td><td>0</td><td>68</td></tr></tbody></table><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span>//声明结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> <span class="title">info</span>;</span><span class="comment">//重定义类型名称</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Avg</span><span class="params">(info a[<span class="number">10</span>])</span>;<span class="comment">//自定义函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    info a[<span class="number">10</span>] = &#123;&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">1</span>, <span class="number">98</span>&#125;, &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">1</span>, <span class="number">80</span>&#125;, &#123;<span class="string">&quot;小明&quot;</span>, <span class="number">0</span>, <span class="number">68</span>&#125;&#125;;<span class="comment">//初始化结构体数组数据</span></span><br><span class="line">    Avg(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Avg</span><span class="params">(info a[<span class="number">10</span>])</span>&#123;<span class="comment">//自定义函数，计算平均值</span></span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + a[i].num;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = sum / <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;三位同学的平均分为：%f&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出结果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbb6dc20e4.png" alt="image-20220209122926651" style="zoom:80%;" /><h1 id="结构体指针变量"><a href="#结构体指针变量" class="headerlink" title="结构体指针变量"></a>结构体指针变量</h1><p>结构体指针变量是指向结构体变量的指针，该指针变量的值是结构体变量的起始地址。</p><h2 id="指向结构体变量的指针"><a href="#指向结构体变量的指针" class="headerlink" title="指向结构体变量的指针"></a>指向结构体变量的指针</h2><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;a=&#123;<span class="number">1</span>,<span class="string">&quot;小明&quot;</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> *<span class="title">p</span>;</span><span class="comment">//声明结构体指针变量</span></span><br><span class="line">    p = &amp;a;<span class="comment">//将结构体a的地址传给指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;学生的姓名为%s&quot;</span>, (*p).name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的可以在声明就初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> *<span class="title">p</span>=</span>&amp;a;</span><br></pre></td></tr></table></figure><p>C语言规定了两种用于访问结构体成员的运算符，一种是成员运算符，也就是<code>.</code>；另一种是指向运算符，也称为箭头运算符，其语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">结构体指针变量名-&gt;成员名</span><br><span class="line">    </span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line">p-&gt;name;</span><br><span class="line"><span class="comment">//上面等价于下面</span></span><br><span class="line">(*p).name;</span><br></pre></td></tr></table></figure><h2 id="指向结构体数组的指针"><a href="#指向结构体数组的指针" class="headerlink" title="指向结构体数组的指针"></a>指向结构体数组的指针</h2><p>定义一个结构体数组S s[30]，若要定义结构体指针变量p.将其指向结构体数组，方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> *<span class="title">p</span>=</span>s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> *<span class="title">p</span>=</span>&amp;s[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>*<span class="title">p</span>;</span></span><br><span class="line">p=s;</span><br></pre></td></tr></table></figure><p>它们都是获取了结构体数组<code>s</code>的首地址，如下图，可以通过改变指针的指向位置来实现不同元素的访问。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbb7309696.png" alt="image-20220209160431876" style="zoom:40%;" /><p>例如：使用<code>p-&gt;sC</code>引用的是<code>s[0].sC</code>的值，同样的使用<code>(p+1)-&gt;sC</code>引用的是<code>s[1].sC</code>的值。</p><h2 id="结构体变量和结构体指针变量作为函数参数"><a href="#结构体变量和结构体指针变量作为函数参数" class="headerlink" title="结构体变量和结构体指针变量作为函数参数"></a>结构体变量和结构体指针变量作为函数参数</h2><p>与其他普通的数据类型一样，既可以定义结构体类型的变量，数组，指针，也可以将结构体类型作为函数参数的类型和返回值的类型。将一个构造体变量的值传递给另一个函数，有如下三种方法：</p><ol><li><p>用结构体的单个成员作为函数参数，向一个结构体传递结构体的单个成员</p><p>用单个结构体成员作为函数实参，与其他普通数据类型的变量作函数实参完全一样，都是值传递调用，在函数内部对其进行操作，不会引起结构体成员值的变化。</p></li><li><p>用结构体变量作为函数参数，向函数传递结构体的完整结构</p><p>用结构体变量作为函数实参，向函数传递是结构体的完整结构，即将整个结构体成员的内容复制给被调函数。在函数内可用成员运算符引用其结构体成员。因为这种传递方式也是值传递调用，所以，在函数内对形参结构体成员值的修改不会影响相应实参结构体成员的值</p></li><li><p>用结构体指针或者结构体数组作为函数参数，向函数传递结构体的地址。</p><p>用指向结构体的指针变量或结构体数组作为函数实参的实质是向函数传递结构体的地址，因为是地址调用，所以在函数内部对形参的成员值的修改会影响到实参结构体成员的值。</p></li></ol><p>【实例】如下学生成绩信息表</p><table><thead><tr><th>学号</th><th>高数成绩</th><th>英语成绩</th></tr></thead><tbody><tr><td>101</td><td>87</td><td>80</td></tr><tr><td>102</td><td>59</td><td>69</td></tr><tr><td>103</td><td>97</td><td>83</td></tr></tbody></table><p>要求在主函数中输入学生信息，编写一个自定义函数，将高数成绩为59分的同学成绩改为60，然后将修改后的学生信息在主函数中输出。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span>//声明结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> mathScore;</span><br><span class="line">    <span class="type">int</span> englishScore;</span><br><span class="line">&#125;info;<span class="comment">//并重命名关键词为info</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fix</span><span class="params">(info *a)</span>;<span class="comment">//自定义函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    info s[<span class="number">3</span>] = &#123;&#123;<span class="number">101</span>, <span class="number">87</span>, <span class="number">80</span>&#125;, &#123;<span class="number">102</span>, <span class="number">59</span>, <span class="number">69</span>&#125;, &#123;<span class="number">103</span>, <span class="number">97</span>, <span class="number">83</span>&#125;&#125;;<span class="comment">//结构体数组初始化</span></span><br><span class="line">    Fix(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fix</span><span class="params">(info *a)</span>&#123;<span class="comment">//自定义函数:查询并修改等于59分数的值</span></span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;<span class="comment">//记录一共修改了几处</span></span><br><span class="line">    <span class="type">int</span> mark = <span class="number">0</span>;<span class="comment">//记录是否发生修改标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;mathScore==<span class="number">59</span>)<span class="comment">//判断是否要修改</span></span><br><span class="line">        &#123;</span><br><span class="line">            a-&gt;mathScore = <span class="number">60</span>;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;englishScore==<span class="number">59</span>)<span class="comment">//判断是否要修改</span></span><br><span class="line">        &#123;</span><br><span class="line">            a-&gt;englishScore = <span class="number">60</span>;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num&gt;mark)<span class="comment">//根据标记，判断是否修改过值，如果修改过，输出修改后的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;学号：%d\n&quot;</span>, a-&gt;num);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;高数成绩：%d\n&quot;</span>, a-&gt;mathScore);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;英语成绩：%d\n&quot;</span>, a-&gt;englishScore);</span><br><span class="line">        &#125;</span><br><span class="line">        a++;<span class="comment">//移动指针到下一个结构体元素</span></span><br><span class="line">        mark = num;<span class="comment">//修正标记回正</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共修改 %d 处&quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbb7853f21.png" alt="image-20220209170839824" style="zoom:80%;" /><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>这是一种常见的线性数据结构，它是动态进行内存分配的一种结构，链表根据需要开辟存储空间。</p><p>在没学习链表之前，如果存储数量较多同类型数据时，通常会使用数组。比如要存储一个班级相关成绩的信息。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> score[<span class="number">40</span>];</span><br></pre></td></tr></table></figure><p><strong>在使用数组的时候，总有一个问题困扰我们：数组应该有多大？</strong></p><p>在大多数情况下，我们并不能确定要使用多大的数组，所以一般情况下，我们将数组定义的足够大。这样，程序在运行时就申请了固定大小的足够大的存储空间。即使知道该班级的学生数，但是如果因为某种特殊原因人数有增加或者减少，又必须重新修改程序，扩大和缩小数组的存储空间。<strong>这种分配固定大小的内存分配方法称为静态内存分配</strong>。这种内存分配方法存在比较严重的缺陷：在大多数情况下会浪费大量的内存空间，在少数情况下，当定义数组不够大时，还可能出现下标越界错误，甚至导致严重后果。</p><p>这时候动态分配内存的链表就可以解决如上问题：</p><p><strong>动态内存分配是指在程序执行过程中根据需要动态地分配或者回收存储空间的内存分配方法</strong>。动态内存分配不像数组等静态内存分配方法那样需要预先分配存储空间，而是由系统根据程序需求临时分配，且分配的大小就是程序要求的大小。</p><p>链表数据集合中的每个数据存储在称为结点的结构体中，一个结点通过该结点中存储的另一个结点的存储地址（指针）来访问另一个结点，如果按照这种方法把所有结点依次串联起来，称为链表。</p><p>链表是由结点组成的数据集合，而结点存储空间的建立与撤销是采用动态内存分配与撤销函数在程序运行时完成的。因此，链表是一种动态数据结构。</p><h2 id="链表的类型及定义"><a href="#链表的类型及定义" class="headerlink" title="链表的类型及定义"></a>链表的类型及定义</h2><p>链表是用一组任意的存储单元存储线性表元素的一种数据结构。</p><p><strong>链表又分为单链表，双向链表和循环链表等。</strong></p><p>链表一般采用图形方式直观描述结点之间的连接关系。这种描述链表逻辑关系的结构图形称为链表图。</p><ol><li><p><strong>单链表</strong></p><p>单链表是最简单的一种链表，其数据元素是单项排列的，如下图</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbb7c63c8f.png" alt="image-20220209182734259" style="zoom:80%;" /><p>从上图可以看出，单链表有一个“头指针”变量，图中用<code>h</code>表示，它存放一个地址，该地址指向单链表中的第一个元素。单链表中每个元素称为结点，每个结点都包括两部分：一部分数据域——存放用户要用的实际数据；另一部分是指针域——存放下一个结点的地址，用指针变量表示。单链表中最后一个结点的指针域位空（NULL），表面单链表到此结束。</p><p>空链表表示单链表中没有结点信息，它用一个值NULL的指针变量表示。</p><p><strong>单链表中各元素在内存中可以不是连续存放的。要查找某一元素，必须先找到上一个元素，根据它的指针域找到下一个元素的存储地址。如果不提供头指针，则整个链表都无法访问。</strong></p><p>单链表的数据结构可以用结构体来实现，一个结构体变量可以包含若干成员，这些成员可以是数值类型，字符类型，数组类型，也可以是指针类型。利用指针类型成员存放下一个结点的指针。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码实现了一个数据域为<code>int</code>类型变量的结点类型，成员变量<code>next</code>是一个指针变量，一般称为后继指针，该指针所指向的数据类型是该结构体类型。</p><p>或者可以利用<code>typedef</code>给这个自定义的数据类型起个名字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Node</span>;</span></span><br></pre></td></tr></table></figure><p>一个单链表就是由内存中若干个<code>Node</code>类型的结构体变量构成的。在实际应用时，单链表的数据域不限于单个的整型，实型或者字符型，它可能由若干个成员变量组成。在单链表中，知道指向某个结点的指针，很容易得到该结点的后继结点的位置，但是要得到该结点的直接去前驱结点位置，则须从头指针出发进行搜索。</p></li><li><p><strong>循环单链表</strong></p><p>循环链表如下图，它的特点是最后一个结点的指针域存放着第一个结点的存储地址，这样一来，链表中所有的结点构成一个环，从每个结点都能搜索到其直接前驱和直接后继结点。</p><p>循环单链表的优点是从任何一个结点出发，都能到达其他任何结点。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbb80c805b.png" alt="image-20220209202106504" style="zoom:80%;" /></li><li><p><strong>双向链表</strong></p><p>如果为每个结点增加一个指向直接前驱结点的指针域，就可以构成双向链表 。双向链表可以沿着求前驱和求后继两个方向搜索结点。</p><p>双向链表的结点数据结构实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span><span class="comment">//后继结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">previous</span>;</span><span class="comment">//前驱结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="处理动态链表的函数"><a href="#处理动态链表的函数" class="headerlink" title="处理动态链表的函数"></a>处理动态链表的函数</h2><p>   链表结构是动态分配存储空间的，即在需要时才开辟一个结点的存储空间。动态分配和释放存储空间需要用到以下几个库函数：</p><ol><li><p><code>malloc()</code>函数。函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><p>其作用是在内存的动态存储区中分配一个长度为<code>size</code>的连续空间。其参数是一个无符号整型数，返回值是一个指向所分配的连续存储区域的起始地址的指针。还有一点必须注意的是，当函数未能成功分配存储空间（如内存不足）就会返回一个<code>NULL</code>指针。所以在调用该函数时应该检测返回值是否为<code>NULL</code>并执行相应的操作。</p><blockquote><p><code>malloc</code>全称：memory allocation（内存分配）</p></blockquote></li><li><p><code>calloc()</code>函数。函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">calloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n,<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><p>其作用是在内存的动态区存储中分配<code>n</code>个长度为<code>size</code>的连续空间。函数返回一个指向分配域起始地址的指针；如果分配不成功（如内存空间不足），返回<code>NULL</code>。</p><p>用<code>calloc()</code>函数可以为一维数组开辟动态存储空间，<code>n</code>为数组元素个数，每个元素长度为<code>size</code>。</p><blockquote><p><code>calloc</code>全称：clear allocation（内存清空）</p></blockquote></li><li><p><code>free()</code>函数。</p><p>由于内存区域是有限的，不能无限制的分配下去，而且一个程序要尽量节省资源，所以当所分配的内存区域不在需要时，就要释放它，以便其他的变量或者程序使用。这时要用到<code>free()</code>函数。函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span>;</span><br></pre></td></tr></table></figure><p>其作用是释放由<code>p</code>指向的内存区，这部分内存区能被其他变量使用。<code>p</code>是调用<code>calloc()</code>或者<code>malloc()</code>函数返回的指针值，<code>free()</code>函数无返回值。</p></li></ol><h2 id="动态链表的基本操作"><a href="#动态链表的基本操作" class="headerlink" title="动态链表的基本操作"></a>动态链表的基本操作</h2><ol><li><p><strong>单链表的建立</strong>（含头结点的尾插法）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10<span class="comment">//定义单链表的长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>//结点的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;NODE;</span><br><span class="line"><span class="comment">//自定义创建单链表函数</span></span><br><span class="line">NODE * <span class="title function_">createList</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    NODE *head;     <span class="comment">//单链表的头指针</span></span><br><span class="line">    NODE *p;        <span class="comment">//指向当前要插入列表的结点</span></span><br><span class="line">    NODE *r;        <span class="comment">//指向单链表最后一个结点</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//为头结点申请存储空间并检测是否分配成功</span></span><br><span class="line">    <span class="keyword">if</span> ((head=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE)))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;      <span class="comment">//头结点的指针域设置为空</span></span><br><span class="line">    r = head;<span class="comment">//将r的指针指向head的地址</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//p结点总指向当前处理结点</span></span><br><span class="line">        <span class="keyword">if</span> ((p=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE)))==<span class="literal">NULL</span>)<span class="comment">//创建新结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;data);       <span class="comment">//从键盘读入数据，存入当前结点的数据域</span></span><br><span class="line">        r-&gt;next = p;        <span class="comment">//将r的指针指向的指针域指向p,形成单链表</span></span><br><span class="line">        r = p;<span class="comment">//再将r指向最新的尾结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;<span class="comment">//将未结点赋NULL表示最后一个</span></span><br><span class="line">    <span class="keyword">return</span> head;<span class="comment">//返回头结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义遍历输出单链表元素数值的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(NODE *L)</span>&#123;</span><br><span class="line">    NODE *p;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    NODE *h;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个整数，建立单链表\n&quot;</span>, N);</span><br><span class="line">    h = createList(N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;单链表内容如下：\n&quot;</span>);</span><br><span class="line">    printList(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbb88c9b58.png" alt="image-20220217142850646" style="zoom:80%;" /></li><li><p><strong>单链表的查找运算</strong></p><p>对单链表进行查找的思路为：从单链表中第一个结点开始依次向后扫描，检测其数据域是否是所要查找的数值，如果是要查找的值着查找成功，反之则继续查找至单链表的末尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义查找方法,传入单链表和要查找的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">locate</span><span class="params">(NODE *L,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    NODE *p = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;<span class="comment">//记录位置</span></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data!=x)<span class="comment">//判断是否为空链表以及值是否相同</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;<span class="comment">//如果不符合，index+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p=<span class="literal">NULL</span>)<span class="comment">//如是空链表则直接返回0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;<span class="comment">//反之将记录位置返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>单链表的插入操作</strong></p><p>单链表的插入：假设在一个单链表中存在两个连续结点p,q(其中p为q的直接前驱)，若我们需要在p于q之间插入一个新结点s,那么需要先为s分配存储空间并完成数据域的赋值，然后让p的指针指向存储s的地址，将s的指针指向q的地址，这样就完成了插入操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表插入操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(NODE *L,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    NODE *s, *p, *q;</span><br><span class="line">    <span class="keyword">if</span> ((s=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE)))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = x;    <span class="comment">//将要插入元素的值赋值给s</span></span><br><span class="line">    p = L-&gt;next;        <span class="comment">//p指向链表的第一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)     <span class="comment">//如果p的指针不是空，则继续遍历单链表元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;      <span class="comment">//直到最后一个元素，则q是最后一个元素</span></span><br><span class="line">        p = p-&gt;next;    </span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = q-&gt;next;      <span class="comment">//将新插入的指针域获取原指针域指向</span></span><br><span class="line">    q-&gt;next = s;        <span class="comment">//将原来的指针域指向新指针域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>单链表的删除操作</strong></p><p>删除结点只需要让前驱结点指向后继结点即可，如下示意图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbb8da042b.png" alt="image-20220217173742005" style="zoom: 50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除单链表元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteList</span><span class="params">(NODE *L,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    NODE *q, *p;</span><br><span class="line">    p = L;</span><br><span class="line">    q = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (q!=<span class="literal">NULL</span> &amp;&amp; q-&gt;data!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表中没有要删除的元素&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除一个元素后的单链表如下：\n&quot;</span>);</span><br><span class="line">        printList(L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈，队列和链表都属于线性结构。线性结构的特点是，在数据元素的非空有限集中：</p><ol><li>存在唯一的一个被称为“第一个”的数据元素</li><li>存在唯一的一个被称为“最后一个”的数据元素</li><li>除第一个之外，集合中的每个数据元素均只有一个前驱</li><li>除最后一个之外，集合中每个数据元素都只有一个后继</li></ol><p><strong>栈和队列都是操作受限制的特殊线性表。</strong></p><p><strong>栈是一种只允许在表头进行插入和删除的特殊线性表，其操作的原则是后进先出，故栈又称为后进先出表，称为LIFO（Last In First Out）表。</strong></p><p><strong>队列是删除操作只在表头进行，插入操作只在表尾进行的特殊线性表，其操作原则是先进先出，简称FIFO（First In First Out）。</strong></p><h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><p><strong>共用体，有的也称为联合体（Union），是将不同类型的数据组织在一起共同占用同一段内存的一种构造数据类型</strong>。同样都是将不同类型的数据组织在一起，但与结构体不同的是，共用体是从同一起始地址开始存放成员的值，即让所有成员共享同一段存储空间。共用体与结构体的类型定义方法相似，只是关键字变为<code>union</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> 共用体名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    数据类型 成员名称;</span><br><span class="line">    数据类型 成员名称;</span><br><span class="line">    数据类型 成员名称;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">test</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>共用体数据类型和结构体数据类型都属于构造数据类型，都可以由程序员根据实际需要来定义，其不同之处在于，共用体的所有成员共同占用一段内存，<strong>共用体变量所占用内存空间大小取决于其他成员中占内存空间最多的那个成员变量</strong>；而结构体的每个成员各自占用一段内存，结构体变量所占用的内存空间大小取决于所有成员占用内存空间的大小总和。</p><p>【实例】查看共用体和结构体占用情况</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">test</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tests</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">test</span> <span class="title">a</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tests</span> <span class="title">b</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共用体占用内存：%lld\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体占用内存：%lld\n&quot;</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbb949862d.png" alt="image-20220217190935208" style="zoom:67%;" /><blockquote><p>利用<code>sizeof()</code>函数测得的值一般会大于或者等于成员所需的内存量总和</p></blockquote><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><p>枚举，即“一个一个列举”之意，当某些变量仅由有限个数据值组成时，通常使用枚举类型表示。枚举数据表示描述的是一组整型值的集合。<strong>声明枚举类型需要使用关键字<code>enum</code>。</strong>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,…&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">weekday</span>&#123;</span>sun,mon,tue,wed,thu,fri,sat&#125;;</span><br></pre></td></tr></table></figure><p><strong>枚举类型如果做不做的规定，默认从0开始对应到枚举元素上</strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">weekday</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        sun,</span><br><span class="line">        mon,</span><br><span class="line">        tue,</span><br><span class="line">        wed,</span><br><span class="line">        thu,</span><br><span class="line">        fri,</span><br><span class="line">        sat</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">weekday</span> <span class="title">a</span>;</span></span><br><span class="line">    a = sun;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：0</p><p>如果想要自定义的，可以使用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">weekday</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        sun,</span><br><span class="line">        mon=<span class="number">2</span>,</span><br><span class="line">        tue,</span><br><span class="line">        wed,</span><br><span class="line">        thu,</span><br><span class="line">        fri,</span><br><span class="line">        sat</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">weekday</span> <span class="title">a</span>;</span></span><br><span class="line">    a = mon;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：2</p><blockquote><p>上述代码中<code>sun</code>实际对应0，而<code>mon</code>规定是2，后面的<code>tue</code>则是3，<code>wed</code>是4…依次类推</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【8.0】C-指针</title>
      <link href="/2022/02/25/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%908.0%E3%80%91%E6%8C%87%E9%92%88/"/>
      <url>/2022/02/25/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%908.0%E3%80%91%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>兜兜转转，终于到了指针，作为C语言最重要的功能。也是C语言最强大，最复杂的机制。</p><p>指针在C程序中应用非常广泛，从基本的数据结构，如链表和树，到大型程序中常用的数据索引和复杂数据结构的组成，都离不开指针的使用。之所以说指针时C最强大的机制，在于<strong>指针可以使程序员直接按地址直接访问指定的存储空间，也可以在权限许可范围内对存储空间的数据进行任意解释和操作</strong>。</p><blockquote><p><strong>Pointer</strong>是指针的英文单词</p></blockquote><h1 id="变量的地址和指针"><a href="#变量的地址和指针" class="headerlink" title="变量的地址和指针"></a>变量的地址和指针</h1><p>在程序中，当我们定义一个变量时，首先要定义变量的数据类型，<strong>数据类型决定了一个变量在内存中所占用的存储空间的大小</strong>。其次要定义变量名。<strong>C语言的编译系统会根据变量的类型在适当的时候为指定的变量分配存储空间</strong>。例如，在Visual C++环境下，一个<code>int</code>类型数据占据4个字节的存储空间。</p><p>在计算机内部，所有的存储空间都要统一进行“编号”，即所有的存储空间都要有地址，<strong>每一存储空间具有唯一的内存地址</strong>。系统为每一个已定义的变量分配一定的存储空间，使变量名与内存的一个地址相对应，<strong>为一个变量进行赋值操作，实质就是要将变量的值存入系统为该变量分配的存储空间中，即变量的值要存入变量名对应的内存地址中</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j,k;</span><br></pre></td></tr></table></figure><p>编译程序可能会为它们在内存中做如下图形式的分配。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abba7ab63dd.png" alt="image-20220121233931059" style="zoom:80%;" /><p>也就是说变量<code>i</code>占据以2000开始的4字节，<code>j</code>占据从2004开始的<code>4</code>字节，<code>k</code>占据从2008开始的<code>4</code>字节。在确定了变量的地址之后，就可以通过变量名对内存中变量对应的地址进行操作。对编程者来说，可以使用变量名进行程序设计。程序运行时需要进行计算时，要根据地址取出变量所对应的存储空间中存放的值，参与各种运算，计算结果最后还要存入变量名对应的存储空间中。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10</span>;</span><br><span class="line">j = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>语句<code>i=10</code>是将整数值10存入从2000开始的地址单元，语句<code>j=20</code>是将整数值20存入2004开始的地址单元。而</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = i + j;</span><br></pre></td></tr></table></figure><p>则是将2000中存放的值和2004中存放的值取出来相加，然后放入2008开始的单元中去。这个赋值语句执行完毕后的情况如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abba7eb7c60.png" alt="image-20220121235125248" style="zoom:80%;" /><p><strong>通过变量名获取变量的地址，再从变量的地址对应的存储空间中取值，或将某值存入变量地址对应的存储空间中的过程，称为直接寻址访问</strong>。</p><p><strong>如果将变量<code>i</code>的地址存放在另一个变量<code>p</code>中，通过访问变量<code>p</code>，间接达到访问变量<code>i</code>的目的，这种方式称为变量的间接访问。保存其他变量地址的变量就称为指针变量</strong>。因此，我们可以认为：<strong>指针是用于指向其他变量的变量</strong>。</p><p>要取出变量<code>i</code>的值10，既可以通过使用变量<code>i</code>直接访问，也可以通过变量<code>i</code>的地址间接访问。</p><p>间接访问变量<code>i</code>的方法是：从地址为3000的存储空间中，先找到变量<code>i</code>在存储空间中的地址2000，再从地址为2000的单元中取出<code>i</code>的值10，这种对应关系如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abba8253054.png" alt="image-20220122000408286" style="zoom:80%;" /><p><strong>所谓指针变量，就是专门用来保存指针的一类变量，它的值是其他变量的地址，该地址就是某个变量在存储空间中对应的存放位置</strong>。这种间接存取关系反应了指针的特性。</p><blockquote><p><strong>要注意区分“值”和“地址”</strong></p></blockquote><p>指针用于存放其他数据的地址，指针可以指向变量，利用指针可以引用变量；指针还可以指向数组，利用指针可以访问数组中的所有元素；指针还可以指向函数，存放函数的入口地址，利用指针调用函数；指针还可以指向结构体（欠结构体，后面有），引用结构体变量的成员。</p><h1 id="指针变量的定义"><a href="#指针变量的定义" class="headerlink" title="指针变量的定义"></a>指针变量的定义</h1><p>指针变量与一般变量一样，必须先声明后使用。定义一个指针变量需要解决两个问题：一是声明指针变量的名字，二是声明指针变量指向的数据类型，即指针变量所指的变量的数据类型。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">类型声明符 *指针变量名</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> *a;<span class="comment">//声明了整型指针变量</span></span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><p>指针变量名前面的符号<code>*</code>在声明&#x2F;定义时不可以省略，它是把其后变量声明为指针类型的标志。</p></li><li><p>其他类型的变量允许和指针变量在同一个语句中定义。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,*p;</span><br></pre></td></tr></table></figure></li><li><p><strong>指针变量定义中的数据类型是指针指向的目标数据类型，而不是指针变量的数据类型。指针变量的数据类型由<code>*</code>声明为指针类型</strong>。</p></li></ol><h1 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h1><h2 id="取地址运算符"><a href="#取地址运算符" class="headerlink" title="取地址运算符"></a>取地址运算符</h2><p><strong><code>&amp;</code>运算符是取地址运算符，它是单目运算符，其功能是返回其后所跟操作数的地址</strong>，其结合性为从右向左，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">10</span>,*p;</span><br><span class="line">p=&amp;i;</span><br></pre></td></tr></table></figure><p>将变量<code>i</code>的地址赋值给<code>p</code>。这个赋值语句可以理解为<code>p</code>接收<code>i</code>的地址，如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abba869bb1b.png" alt="image-20220122134457031" style="zoom:80%;" /><blockquote><p>注意区分取地址运算符<code>&amp;</code>与双目运算符<code>&amp;</code>（按位与）</p></blockquote><h2 id="指针运算符"><a href="#指针运算符" class="headerlink" title="指针运算符"></a>指针运算符</h2><p><strong><code>*</code>运算符是指针运算符</strong>，也称为间接运算符，它也是单目运算符。<strong>其功能是取该指针变量所指向的存储单元的值</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">10</span>,*p,y;<span class="comment">//声明和定义x=10，指针类型p,和整型变量y</span></span><br><span class="line">p=&amp;x;<span class="comment">//指针类型p取得x变量的地址</span></span><br><span class="line">y=*p;<span class="comment">//将指针类型p指向的地址的值，即10赋值给y变量</span></span><br></pre></td></tr></table></figure><h2 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h2><h3 id="指针变量的初始化"><a href="#指针变量的初始化" class="headerlink" title="指针变量的初始化"></a>指针变量的初始化</h3><p>指针变量的初始化，就是在定义指针变量的同时为其赋初值。由于指针变量是指针类型，所赋初值应是一个地址值。其一般格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 * 指针变量名=地址<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>其中地址形式有多种，例如：&amp;变量名，数组名，其他的指针变量等。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取一般变量地址</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *p=&amp;i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符数组</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> *p=a;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><p>不能用未声明的变量给指针变量赋初值，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;i;</span><br><span class="line"><span class="type">int</span> i;</span><br></pre></td></tr></table></figure></li><li><p>当用一个变量地址为指针变量赋值时，该变量的数据类型必须与指针变量指向的数据类型一致。</p></li><li><p><strong>除0之外，一般不把其他整数作为初值赋给指针变量。程序运行期间，变量的地址是由计算机分配的，当用一个整数作为指针变量赋初值后，可能会造成难以预料的后果。当用0对指针赋初值时，系统会将该指针变量初始化为一个空指针，不指向任何对象。</strong></p></li></ol><h3 id="使用赋值语句赋值"><a href="#使用赋值语句赋值" class="headerlink" title="使用赋值语句赋值"></a>使用赋值语句赋值</h3><p>语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">指针变量=地址;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> *p,i;</span><br><span class="line">p=&amp;i;</span><br></pre></td></tr></table></figure><p>另外，指针变量和一般变量一样，存放在它们之中的值可以改变，也就是说可以改变它们的指向，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>,*p;</span><br><span class="line">p=&amp;a;</span><br><span class="line">p=&amp;b;</span><br></pre></td></tr></table></figure><p>通过指针访问它所指向的一个变量是以间接访问的形式进行的，所以比直接访问一个变量要费时间，而且不直观，因为通过指针要访问哪一个变量，取决于指针的值（即指向），例如<code>*p1=*p2;</code>实际上是将<code>p2</code>的变量的值赋值给<code>p1</code>变量的值。由于指针是变量，可以通过改变指向来间接访问不同的变量，这给编写者以灵活性，使程序代码编写更加间接灵活。</p><blockquote><p><strong><code>数据类型 *</code>+<code>变量名</code>表示指针类型，<code>*</code>+<code>变量名</code>表示取指针的值</strong>。</p></blockquote><h2 id="空指针与void指针"><a href="#空指针与void指针" class="headerlink" title="空指针与void指针"></a>空指针与<code>void</code>指针</h2><h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p><strong>空指针就是不指向任何对象的指针，表示该指针没有指向任何存储空间</strong>。构造空指针有下面两种方法：</p><ul><li><p>赋0值，这是唯一的允许不经转换就赋予指针的数值。</p></li><li><p>赋<code>NULL</code>值，<code>NULL</code>值等于0，即两者等价，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">p=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>引入空指针的目的就是为了防止使用指针出错</strong>。</p><p><strong>空指针常常用来初始化指针，避免野指针的出现</strong>。</p><p>对指针变量赋0或者NULL值与不赋值是不同的。指针变量赋0值后，该指针被初始化为空指针，空指针是不可以使用的。<strong>而指针变量未赋值时，可以是任意值，可能指向任何地方，该指针被形象的称为野指针</strong>。不要使用野指针，否则可能会出现意外错误。</p><p>为了避免上述错误的发生，<strong>习惯的做法是定义指针变量时立即将其初始化为空指针，在使用指针之前再给指针变量赋值</strong>，也就是在指针有了具体指向之后再使用指针。</p><h3 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a><code>void</code>指针</h3><p>C语言规定，<strong>指针变量可以定义为<code>void</code>类型</strong>，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *p;</span><br></pre></td></tr></table></figure><p>这里<code>p</code>仍然是一个指针变量，且有自己的内存空间，但不指定<code>p</code>指向哪种类型的变量。在这种情况下，应该注意：</p><ol><li><p><strong>任何指针都可以赋值给<code>void</code>指针</strong>。</p></li><li><p><strong><code>void</code>指针赋值给其他类型指针需要进行类型转换</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *t=(<span class="type">int</span> *)p;<span class="comment">//需要强制类型转换</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>void</code>指针不能参与指针运算，除非进行转换</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span> *c;</span><br><span class="line">    c++;<span class="comment">//编译出错，原因是不知道c的指向的类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h1><p>在函数之间可以传递变量的值，同样也可以传递地址（指针）。<strong>函数与指针的相关关系：指针作为函数的参数，函数的返回值为指针以及指向函数的指针</strong>。</p><h2 id="指针作为函数参数"><a href="#指针作为函数参数" class="headerlink" title="指针作为函数参数"></a>指针作为函数参数</h2><p>问题从编写一个两个数交换的问题出手。</p><p>【实例】编写<code>swap</code>函数，实现交换两个整型变量的值。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;<span class="comment">//函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数交换前a的值为%d,b的值为%d\n&quot;</span>, a, b);</span><br><span class="line">    Swap(a, b);<span class="comment">//交换函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数交换后a的值为%d,b的值为%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    x = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后a的值为%d,b的值为%d\n&quot;</span>, a, b);<span class="comment">//输出交换后的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abba8eb7738.png" alt="image-20220123004855594" style="zoom:80%;" /><p>【说明】从输出结果来看就可以知晓，对于调用函数来说，是实现了数的交换，但是只是形参的交换，而实参<code>a</code>,<code>b</code>并没有发生交换。这与我们想要的结果相差甚远，怎么办？</p><p>以指针为参数的函数就可以解决这个问题了，虽然全局函数也可以实现，但是对于程序来说，每次都需要全局函数的对于程序的可维护，可读性有一定的影响。</p><p>【实例】以指针为参数的交换<code>swap</code>函数，实现两数的交换。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数交换前a的值为%d,b的值为%d\n&quot;</span>, a, b);</span><br><span class="line">    Swap(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数交换后a的值为%d,b的值为%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    x = *a;</span><br><span class="line">    *a = *b;<span class="comment">//获取传入值的存储空间并赋值</span></span><br><span class="line">    *b = x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后a的值为%d,b的值为%d\n&quot;</span>, *a, *b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abba92d49b4.png" alt="image-20220123142514403" style="zoom:80%;" /><p>但是如果将上面的代码进行简单的调整，得到的结果又是不同的，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数交换前a的值为%d,b的值为%d\n&quot;</span>, a, b);</span><br><span class="line">    Swap(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数交换后a的值为%d,b的值为%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *x;</span><br><span class="line">    x = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后a的值为%d,b的值为%d\n&quot;</span>, *a, *b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abba9661ed9.png" alt="image-20220123142933842" style="zoom:80%;" /><p>调整后的代码<code>a=b</code>，只是在形参<code>a</code>和<code>b</code>指针的地址发生了交换，而对于地址指向的存储空间内容没有发生交换，也就是说仅仅是交换了形参<code>a</code>和<code>b</code>之间存储的变量地址。对于调整前的代码来说<code>*a=*b</code>，意味着将指针<code>a</code>指向的变量的存储空间的值修改成指针<code>b</code>指向的存储空间的值，也就是说修改了指针指向地址的存储空间，也就实现了原变量的值交换。</p><p><strong>“指针变量所指向单元的存储空间的值”和“指针变量存储的地址值是根本不同的。前者指的是指针指向单元的值，而后者指的是指针变量的值。</strong></p><h2 id="指针作为函数的返回值"><a href="#指针作为函数的返回值" class="headerlink" title="指针作为函数的返回值"></a>指针作为函数的返回值</h2><p>除了可以将基本类型作为函数返回值类型之外，还可以将地址作为函数返回值，<strong>当把地址作为函数的返回值时，该函数称为指针函数</strong>。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型 * 函数名(形参列表)&#123;</span><br><span class="line">函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong>函数名前面的<code>数据类型 *</code>表示该函数的返回类型为某数据类型的指针</strong>。</p><p>【实例】输入若干数值，判断并获取最大值，且值的范围在$100$~$0$之间。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">Max</span><span class="params">()</span>;<span class="comment">//函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *max;</span><br><span class="line">    max = Max();<span class="comment">//返回指针赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大值为：%d&quot;</span>, *max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> * <span class="title function_">Max</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> max;<span class="comment">//静态局部变量，防止方法执行完毕内存被释放，值不存在</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n&lt;<span class="number">100</span> &amp;&amp; n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;max)&#123;</span><br><span class="line">            max = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;max;<span class="comment">//返回指针值，即地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abba9a8673a.png" alt="image-20220124152521719" style="zoom:80%;" /><blockquote><p>如果函数返回指针，注意不要返回局部变量的地址，因为局部变量在执行完成函数后被释放了，返回的是野指针。</p></blockquote><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p><strong>在定义一个函数之后，编译系统为每个函数确定一个入口地址，当调用该函数时，系统会从入口地址开始指向该函数。存放函数的入口地址的指针就是一个指向函数的指针，简称函数指针</strong>。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型标识符 (*指针变量名)();</span><br></pre></td></tr></table></figure><p><strong>类型标识符是函数的返回值的类型。需要注意的是，由于C语言中，括号的优先级比<code>*</code>高，因此，<code>* 指针变量名</code>外部必须使用括号，否则指针变量名首先与后面的括号结合，就是前面说明的“返回指针的函数”</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">P</span><span class="params">()</span>;<span class="comment">//函数返回值类型为指针的函数，该指针指向整型</span></span><br><span class="line"><span class="type">int</span> (*p)();<span class="comment">//指向函数的指针，该函数返回值类型为整型</span></span><br></pre></td></tr></table></figure><p>与变量指针一样，必须给函数指针赋值，才能指向具体的函数。由于函数名代表了该函数的入口地址，因此，一个简单的方法就是直接使用函数名来为函数指针赋值，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">函数指针名=函数名;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fun</span><span class="params">()</span>;<span class="comment">//函数原型声明</span></span><br><span class="line"><span class="type">int</span> (*F)();<span class="comment">//指向函数的指针声明</span></span><br><span class="line">F=Fun;<span class="comment">//指向函数指针的地址指向Fun函数</span></span><br></pre></td></tr></table></figure><p>函数指针经定义和赋值之后，在程序中就可以引用该指针，目的是调用被指针指向的函数，可以通过这种方式增加对函数调用的方式。</p><p>【实例】使用函数指针，计算两个数的和</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*P)(<span class="type">int</span>,<span class="type">int</span>); <span class="comment">//声明函数指针</span></span><br><span class="line">    P = Plus;<span class="comment">//指针指向函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;俩者的和为:%d&quot;</span>,P(<span class="number">3</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbaa18a6ba.png" alt="image-20220124161442567" style="zoom:80%;" /><p>【实例】关于函数指针的一些用法</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;  <span class="comment">//加法函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;  <span class="comment">//减法函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;  <span class="comment">//乘法函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span> (*P)(<span class="type">int</span>, <span class="type">int</span>))</span>;  <span class="comment">//自定义函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;俩者的和为:%d\n&quot;</span>,Fun(<span class="number">3</span>,<span class="number">2</span>,Plus));    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;俩者的差为:%d\n&quot;</span>,Fun(<span class="number">3</span>,<span class="number">2</span>,Sub));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;俩者的积为:%d\n&quot;</span>,Fun(<span class="number">3</span>,<span class="number">2</span>,Mul));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> (*P)(<span class="type">int</span>,<span class="type">int</span>))</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> P(a, b); <span class="comment">//自定义函数调用函数指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;  <span class="comment">//加法函数</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;   <span class="comment">//减法函数</span></span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;   <span class="comment">//乘法函数</span></span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbaa5c34e0.png" alt="image-20220124162921494" style="zoom:80%;" /><p>这样在调用函数的时候，可以直接传入指定函数，就可以执行函数。</p><h1 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h1><h2 id="一维数组的指针表示"><a href="#一维数组的指针表示" class="headerlink" title="一维数组的指针表示"></a>一维数组的指针表示</h2><h3 id="定义指向一维数组的指针变量"><a href="#定义指向一维数组的指针变量" class="headerlink" title="定义指向一维数组的指针变量"></a>定义指向一维数组的指针变量</h3><p>在C语言中，指针和数组有紧密的联系，其原因在于，凡是由数组下标完成的操作都可以用指针来实现。我们以及知道，在数组中可以通过数组的下标来确定唯一数组元素在数组中的顺序和存储地址，这种方式也称为下标表示法。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,x;</span><br><span class="line">x=a[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>对于数组的引用可以使用指针表示法来实现。由于每个数组元素相当于一个变量，因此指针变量既然可以指向一般变量，同样也可以指向数组中的元素，也就是可以用指针来访问数组中的元素。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *c=&amp;a[<span class="number">2</span>];<span class="comment">//获取指定元素的地址指针</span></span><br></pre></td></tr></table></figure><p>由于一维数组的数组名是一个地址常量，程序运行时，它的值是一个一维数组第一元素的地址。所以可以通过数组名把数组的首地址赋值给指针变量，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p=a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);</span><br></pre></td></tr></table></figure><p>输出结果：1，输出的是数组<code>a</code>的首地址，即第一个元素的值。</p><p>由此可知，<code>&amp;a[0]</code>，<code>a</code>，<code>*p</code>指向同一单元，是数组<code>a</code>的首地址。</p><h3 id="通过指针引用数组元素"><a href="#通过指针引用数组元素" class="headerlink" title="通过指针引用数组元素"></a>通过指针引用数组元素</h3><p>C语言规定：<strong>如果指针变量<code>p</code>已指向数组中的一个元素，这<code>p+1</code>指向同一数组中的下一个元素</strong>。</p><p>引入指针变量后，现在可以通过两种方式来访问数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规方式</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> c=a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针方式</span></span><br><span class="line"><span class="type">int</span> *p,a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//声明指针p和数组</span></span><br><span class="line">p=a;<span class="comment">//指针指向数组首地址</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">3</span>; a++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p++);<span class="comment">//输出指针指向数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：1，2，3</p><h3 id="数组中的指针运算"><a href="#数组中的指针运算" class="headerlink" title="数组中的指针运算"></a>数组中的指针运算</h3><ol><li><p>加减算术运算</p><p>对于指向数组的指针变量，可以加上或者减去一个整数<code>n</code>。设<code>p</code>是指向数组<code>a</code>的指针变量，则<code>p+n</code>，<code>p-n</code>，<code>p++</code>，<code>p--</code>等运算都是合法的。<strong>指针变量加减整数的意义是将指针指向的位置向前或者向后移动<code>n</code>个位置，这里加减的单位不是以字节为单位，而是以指向的数据类型所占用的字节数为单位。</strong></p><p>【实例】指针算术运算示例</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, *p, y = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]=%d    &quot;</span>, i, a[i]);    <span class="comment">//常规方法遍历输出数组元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = a;  <span class="comment">//指针指向数组首地址</span></span><br><span class="line">    y = *++p;   <span class="comment">//变量值赋值为指针向后移动一位的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ny=%d  &quot;</span>, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针值为：%d&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbaabc59eb.png" alt="image-20220127001930767" style="zoom:80%;" /></li><li><p>两个指针变量之间的运算</p><p>两个指针变量之间的加减运算是不合法的，也是无意义的，但是<strong>指针变量之间可以进行关系运算</strong>。</p><p>假设指针<code>p</code>和指针<code>q</code>指向同一数组的元素，那么：</p><ul><li><code>p&lt;q</code>：当<code>p</code>所指的元素在<code>q</code>所指的前面时，表达式值为1；反之则为0；</li><li><code>p&gt;q</code>：当<code>p</code>所指的元素在<code>q</code>所指的后面时，表达式值为1；反之则为0；</li><li><code>p==q</code>：当<code>p</code>和<code>q</code>指向同一元素时，表达式值为1；反之则为0；</li><li><code>p!=q</code>：当<code>p</code>和<code>q</code>不指向同一元素时，表达式值为1；反之则为0；</li></ul><p><strong>指针变量还可以与<code>0</code>或者<code>NULL</code>比较</strong>。</p><p><strong>设<code>p</code>为指针变量，则<code>p==0</code>或者<code>p==NULL</code>表面是空指针，它不指向任何变量；</strong><code>p!=0</code>或者<code>p!=NULL</code>表示<code>p</code>指针不是空指针。</p><p>【实例】指针变量间的关系运算</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, *y, *x;</span><br><span class="line">    x = a;</span><br><span class="line">    y = a;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x&lt;p\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;地址为：%p 值为：%d\n&quot;</span>, x,*x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;地址为：%p 值为：%d&quot;</span>, y,*y);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x&gt;p\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;地址为：%p 值为：%d\n&quot;</span>, x,*x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;地址为：%p 值为：%d&quot;</span>, y,*y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\ny指针是空指针&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\ny指针不是空指针&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbab01de0a.png" alt="image-20220127005945082" style="zoom:80%;" /></li></ol><h2 id="二维数组的指针表示"><a href="#二维数组的指针表示" class="headerlink" title="二维数组的指针表示"></a>二维数组的指针表示</h2><h3 id="用二维数组名表示数组元素"><a href="#用二维数组名表示数组元素" class="headerlink" title="用二维数组名表示数组元素"></a>用二维数组名表示数组元素</h3><p>如果有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[M][N];</span><br></pre></td></tr></table></figure><p>则**将二维数组中的元素<code>a[i][j]</code>转换为唯一线性地址的一般公式为：线性地址$&#x3D; a+i \times M + j$**。</p><p>其中：<code>a</code>为数组的首地址，<code>M</code>和<code>N</code>分别为二维数组行和列的元素个数。</p><p>如下代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>],*p;</span><br><span class="line">p=a[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//指针变量指向数组a的第一个元素</span></span><br></pre></td></tr></table></figure><p>则二维数组<code>a</code>的数据元素在内存中的存储顺序以及地址关系如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbab40b728.png" alt="image-20220127155652235" style="zoom:75%;" /><p>对于数组元素<code>a[i][j]</code>，用数组名<code>a</code>的表示形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*(a+i) 取出指向i层首地址的地址</span></span><br><span class="line"><span class="comment">//*(a+i)+j 将该地址在该层移动j个单位，即指向第i层的第j个元素</span></span><br><span class="line"><span class="comment">//*(*(a+i)+j) 取出指针指向地址的值，即取出第i层的第j个元素的值</span></span><br><span class="line">*(*(a+i)+j);</span><br></pre></td></tr></table></figure><blockquote><p>数组名是一种常量指针</p></blockquote><p>【实例】关于数组指针相关问题理解</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//定义了一维数组c,二维数组a,三维数组x</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;,c[<span class="number">2</span>]=&#123;<span class="number">5</span>,<span class="number">6</span>&#125;,x[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>&#125;&#125;,&#123;&#123;<span class="number">3</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">4</span>&#125;&#125;&#125;;</span><br><span class="line"><span class="comment">//获取一维数组首地址的值，因为数组名是常量指针，默认指向首元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;一维数组：%d\n&quot;</span>, *c);</span><br><span class="line">    <span class="comment">//获取二维数组第一层的第二个元素</span></span><br><span class="line">    <span class="comment">//*a指的是首层地址，+1是在该层的基础上移动一个单位，即首层第二个元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二维数组：%d\n&quot;</span>, *(*a+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//a[1]以及指明了数组第二层首元素的地址，*取其值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二维数组：%d\n&quot;</span>, *a[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//*x取首层元素首地址，**x取首层元素首层元素的地址，***x取首层元素首层元素首层元素的值</span></span><br><span class="line">    <span class="comment">//因为是三维数组，所以嵌套三层才能确定具体元素的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;三维数组：%d\n&quot;</span>, ***x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbab85df0e.png" alt="image-20220127165316574" style="zoom:80%;" /><h3 id="用指针表示二维数组元素"><a href="#用指针表示二维数组元素" class="headerlink" title="用指针表示二维数组元素"></a>用指针表示二维数组元素</h3><p>根据下图可知，可以通过对指针的加减来实现对二维数组元素的指向。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbabb70a89.png" alt="image-20220127172259536" style="zoom:70%;" /><p>对于如下代码，指针指向数组元素<code>a[x][y]</code>的公式为：</p><p>$$p+M \times N +y$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[M][N];</span><br><span class="line"><span class="type">int</span> *p=a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>a[0]</code>和<code>*a</code>指的是同一个地址</strong>，即首层首元素地址。</p></blockquote><p>【实例】利用指针输出二维数组元素值</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;,*p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;第%d层第%d个元素的值为：%d\n&quot;</span>, i+<span class="number">1</span>, j+<span class="number">1</span>, *(p + j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbac00d4cf.png" alt="image-20220127173247410" style="zoom:80%;" /><p><strong>在C语言中，可以将一个二维数组理解为若干个一维数组构成的一维数组</strong>。所以对于<code>a[3][3]</code>数组来说，可以分解为三个一维数组：<code>a[0][0]</code>，<code>a[0][1]</code>，<code>a[0][2]</code>……<code>a[2][0]</code>，<code>a[2][1]</code>，<code>a[2][2]</code>，即可以看作由<code>a[0][0]</code>，<code>a[1][0]</code>，<code>a[2][0]</code>三个行首元素数组。</p><p><strong>行指针是一种特殊的指针变量，它们专门用于指向一维数组</strong>。定义一个行指针一般的格式是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型关键字 (*行指针名)[M]</span><br></pre></td></tr></table></figure><p>其中<code>M</code>规定了行指针所指一维数组的长度，而类型关键字则指明了一维数组的类型。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[M];</span><br></pre></td></tr></table></figure><p>定义了行指针<code>p</code>，可以使用该行指针指向二维数组单行元素为<code>M</code>个的整型数组。</p><p>【实例】使用行指针输出二维数组中全部的元素值</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>(*p)[<span class="number">3</span>],a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;<span class="comment">//声明行指针</span></span><br><span class="line">    p = a;<span class="comment">//行指针指向首行数组首地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(*p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>对<code>p</code>层加减操作是改变层数的指向，对<code>*p</code>的操作是改变的元素的指向</strong>。</p></blockquote><p>【关于指针指向多维数组的个人看法】</p><p>C语言底层就是将多维数组，例如二维数组，看成两个一维数组，这就意味着，对于二维数组<code>a</code>，之前说过数组是一个常量指针，那么<code>a</code>是指向第一个一维数组的指针，也就是说<code>a</code>存储的是一个地址，这也就是为什么如果使用普通指针指向二维数组<code>a</code>，例如：<code>*a</code>获取的只是第一个一维数组的地址，而<code>**a</code>才是获取第一个一维数组第一个元素的首元素的值。</p><h2 id="指针与字符串"><a href="#指针与字符串" class="headerlink" title="指针与字符串"></a>指针与字符串</h2><p>C语言没有字符串变量，对字符串的访问有两种方法。</p><ol><li><p>使用字符数组来存放一个字符串，然后采用字符数组来完成操作。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">12</span>]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br></pre></td></tr></table></figure></li><li><p>使用字符指针指向一个字符串</p><p>如果把字符数组的首地址赋给一个指针变量，那么这个指针变量指向这个数组，就可以对齐完成数组操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字符串常量对字符指针进行初始化，此时指针变量指向字符串的首地址。</span></span><br><span class="line"><span class="type">char</span> *str=<span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure></li></ol><p>【实例】编写程序完成字符串的输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;hello world&quot;</span>;<span class="comment">//初始化字符串指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第三个字符是：%c\n&quot;</span>, str[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *str++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbac958199.png" alt="image-20220202135336254" style="zoom:80%;" /><blockquote><p>虽然没有定义数组<code>str</code>，但是字符串在内存中的存储方式为数组，即<code>str[2]</code>&#x3D;<code>*(str+2)</code></p></blockquote><h1 id="指针数组和指向指针的指针"><a href="#指针数组和指向指针的指针" class="headerlink" title="指针数组和指向指针的指针"></a>指针数组和指向指针的指针</h1><h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><ol><li><p><strong>指针数组的定义</strong></p><p>如果数组中每个元素的数据类型为指针类型，则这种数组称为指针数组，它是指针的集合。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">类型 * 数组名[常量表达式];</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">10</span>];<span class="comment">//表示定义一个由10个指针变量构成的指针数组。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指针数组在字符串中的使用</strong></p><p>指针数组常用来表示一组字符串，这时指针数组的每个元素被赋予每个字符串的首地址。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str[<span class="number">7</span>]=&#123;<span class="string">&quot;Sunday&quot;</span>,<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>当然也可以使用一个二维数组来表示上面的信息，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> week[<span class="number">7</span>][<span class="number">10</span>]=&#123;<span class="string">&quot;Sunday&quot;</span>,<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>它们在内存的存储结结构如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbacf36f89.png" alt="image-20220202145531918" style="zoom:80%;" /><p>该数组一共占用70个字节。</p><p>如果采用指针数组来表示，由于指针数组的每个元素都是指针，因此指向每个元素的首地址，通过首地址访问该字符串。相对于二维数组可以节省内存空间。如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbad33e881.png" alt="image-20220202150211185" style="zoom:80%;" /><p>【实例】编写程序，用星期的英文名来初始化字符指针数组，输入整数，当数为0~6时，输出对应星期的英文名，否则显示错误信息。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PutOut</span><span class="params">(<span class="type">char</span> *p[], <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *weekday[<span class="number">7</span>] = &#123;<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数值&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;value);</span><br><span class="line">    PutOut(weekday,value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PutOut</span><span class="params">(<span class="type">char</span> *p[],<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value&gt;=<span class="number">0</span> &amp;&amp; value&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p[value]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输出格式不正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbad82ce60.png" alt="image-20220202152854487" style="zoom:80%;" /></li></ol><h2 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h2><p>一个指针可以指向任何一种数据类型，包括指向一个指针。当指针变量<code>p</code>中存放另一个指针<code>q</code>的地址时，则称为指针型指针，也称为多级指针。指针型指针（二级指针）的语法格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">类型标识符 ** 指针变量名;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> ** p;</span><br></pre></td></tr></table></figure><p>由于指针变量的类型是被指针所指的变量的类型，因此，上述定义中的类型标识符应为：被指针类型的指针指向的指针所指的变量的类型。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">2</span>;<span class="comment">//初始化整型变量x=2</span></span><br><span class="line"><span class="type">int</span> *p;<span class="comment">//声明指针p</span></span><br><span class="line"><span class="type">int</span> **q;<span class="comment">//声明二级指针q</span></span><br><span class="line">p=&amp;x;<span class="comment">//定义指针p指向变量x</span></span><br><span class="line">q=&amp;p;<span class="comment">//定义二级指针q指向指针p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**q);<span class="comment">//输出二级指针所指向指针指向的值</span></span><br></pre></td></tr></table></figure><p>对于输出值：<code>**q</code>&#x3D;<code>*(*q)</code>&#x3D;<code>*p</code>&#x3D;<code>x</code></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbadc5a8d9.png" alt="image-20220202154439120" style="zoom:80%;" /><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>指针很重要，万物皆指针！！！</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【7.0】C-预处理命令</title>
      <link href="/2022/02/21/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%907.0%E3%80%91%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/02/21/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%907.0%E3%80%91%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>预处理是在进行编译的第一遍扫描（扫描语法和词法）之前所做的工作，是C语言的一个重要功能，它由预处理程序负责完成。</p><p>前面的代码已经多次使用<code>#</code>开头的预处理命令，例如：<code>#include &lt;stdio.h&gt;</code>等，在源程序中这些命令都放在函数之外，而且一般都放在源文件的前面。</p><p>C语言提供了多种预处理命令，如宏定义，文件包含，条件编译等。<strong>C语言的预处理命令均是以<code>#</code>开始，末尾不加分号</strong>。合理的使用预处理指令可以使得程序便于阅读，修改和调试。</p><h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><p><strong>在C语言源程序中允许用一个标识符来表示一个字符串，称为宏。被定义为宏的标识符称为宏名。在编译预处理时，对程序中所有出现的宏名，都用宏定义的字符串去替换，这称为宏替换或者宏展开</strong>。</p><p>宏定义是由源程序中的宏定义命令完成的，宏替换是由预处理程序自动完成的。</p><p>宏定义是C语言提供的三种常用预处理命令中的一种，使用宏定义可以防止出错，并且可以提高程序的可移植性和可读性。宏分为不带参数和带参数两种。</p><h2 id="不带参数的宏定义"><a href="#不带参数的宏定义" class="headerlink" title="不带参数的宏定义"></a>不带参数的宏定义</h2><p>不带参数的宏定义语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 标识符 字符串</span></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br></pre></td></tr></table></figure><p>其中<code>#</code>表示这是一条预处理命令。<code>define</code>为宏定义命令。标识符就是所谓的符号常量，也称为宏名。字符串可以是参数，表达式，格式串等。</p><p>预处理工作也称为宏展开，就是将宏名替换为字符串。掌握宏的关键就是“换”。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br></pre></td></tr></table></figure><p>它的作用就是指定标识符<code>PI</code>来代替常量3.14。在编写程序的时候，所有的3.14都可以使用<code>PI</code>来表示，而对于源程序编译的时候，将由预处理程序进行宏替换，即将<code>PI</code>的部分再替换回3.14，然后再进行编译。</p><p>关于宏定义的说明：</p><ol><li><p><strong>宏名习惯上用大写字母表示，以便于与变量区别</strong>，不过你也可以使用小写</p></li><li><p>使用宏可以提高程序的拓展性和易读性。</p></li><li><p><strong>预处理是在编译之前进行的处理，而编译的工作之一就是语法检查，也就是说，预处理不做语法检查</strong>。</p></li><li><p>宏定义不是语句，<strong>在句末不必加分号，如果加上分号，则连分号一起替换</strong>。</p></li><li><p><strong>宏定义必须写在函数外，默认其作用域为：从宏定义命令开始到程序结束。</strong></p><p><strong>如果要终止其作用域可以使用<code>#undef</code>命令</strong>，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//很多代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PI</span></span><br><span class="line"><span class="comment">//又是很多代码</span></span><br></pre></td></tr></table></figure><p>表示该宏定义只在<code>main</code>函数中有效。</p></li><li><p>宏定义允许嵌套，在宏定义的字符串中可以使用已定义的宏名。在宏展开时由预处理程序层层替换。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3,14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C 2*PI</span></span><br><span class="line"><span class="comment">//以上宏定义的不限制顺序，例如下面的和上面的结果是一致的</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C 2*PI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3,14</span></span><br></pre></td></tr></table></figure></li><li><p>宏定义不分配存储空间，变量定义才分配存储空间。</p></li><li><p>宏定义以回车符结束，如果宏定义超过一行，可以在行末加反斜杠<code>\</code>来续行。</p></li><li><p>宏定义中也可以没有替换的字符串，这种宏定义常作为条件编译检测的一个标志。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG</span></span><br></pre></td></tr></table></figure><p>【关于宏定义无字符串的意义】</p><p>【说明】<strong>这部分解释需要学会下面的条件编译命令再看</strong></p><p>比如：<code>#define USEHDMI</code>表示定义<code>USEHDMI</code>这个宏，但内容是空的，这样的宏一般不会用于替换<br>-用途：在程序中会这样用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">ifdef</span> USEHDMI</span></span><br><span class="line">... <span class="comment">//宏被定义时的处理程序</span></span><br><span class="line">\<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">... <span class="comment">//宏未被定义时的程序</span></span><br><span class="line">\<span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样假设我们在使用HDMI接口时会在头文件中写：<code>#define USEHDMI</code>，或写<code>#define USEHDMI 1</code>也是一样的，否则用默认模式可注释此句或写：<code>#undef USEHDMI</code>，即可实现程序增加处理HDMI接口的部分，或者去除。</p><blockquote><p>以上解释出自<a href="httpss://zhidao.baidu.com/question/1365904455539906219.html">c++程序中宏定义只有宏名没有字符串是怎么一回事</a></p></blockquote></li><li><p><strong>字符，字符串和注释中永远不做宏处理</strong>，即如果在其中包含宏字符，不会进行宏替换处理。</p><blockquote><p>需要注意的是，变量和宏名不可以相同</p></blockquote><p>【实例】验证宏名和字符串</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PI %f\n&quot;</span>, PI);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abba2b35887.png" alt="image-20220121162246646" style="zoom:80%;" /></li></ol><h2 id="带参数的宏定义"><a href="#带参数的宏定义" class="headerlink" title="带参数的宏定义"></a>带参数的宏定义</h2><p>C语言允许宏带有参数。宏定义中的参数称为形参，宏调用中的参数称为实参。对于带参数的宏，在调用中，不仅要宏展开，还要用实参去代替形参。</p><p>带参数的宏定义一般形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名(参数列表) 字符串</span></span><br></pre></td></tr></table></figure><p>在字符串中可以含有多个形参。</p><p>带参数宏调用的一般形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">宏名(实参列表)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S(a,b) a*b</span></span><br><span class="line">area=S(<span class="number">3</span>,<span class="number">2</span>);<span class="comment">//第一步替换为area=a*b,第二部替换为area=3</span></span><br></pre></td></tr></table></figure><p>【实例】利用带参数的宏定义求三个数的最小值</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Min(a,b) (a&lt;b)?a:b  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z, min;   <span class="comment">//声明三个数值和最小值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三个数值&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    min = Min(x, y);</span><br><span class="line">    min = Min(min, z);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最小值为;%d&quot;</span>, min);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出结果】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abba302b946.png" alt="image-20220121164749966" style="zoom:80%;" /><p>关于带参数的宏定义需要注意以下几点：</p><ol><li><p><strong>宏名和参数的括号间不能有空格</strong>。</p></li><li><p>宏替换只做替换，不做计算，不做表达式求解。</p></li><li><p>在宏定义中形参是标识符，而宏调用中的实参可以是表达式。</p></li><li><p>在带参数宏定义中，形参不分配存储空间，因此不必进行类型声明，而宏调用中的实参有具体的值，要用它们去替换形参，因此必须进行类型声明。</p></li><li><p>带参数的宏和带参数函数很相似，但有本质上的不同：</p><p>函数调用在编译后程序运行时进行，占用运行时间（分配内存，保留现场，值传递，返回值）；宏替换在编译前进行，不分配内存，不占用运行时间，只占用编译时间。</p><p>在函数中，形参和实参是两个不同的量，各有自己的作用域，调用时要把实参传递给形参，进行“值传递”；而在带参数宏中，只是符号替换，不存在值传递。</p><p>函数只有一个返回值，利用宏可以设法得到多个返回值；</p><p>宏展开使源程序边长。</p></li><li><p>宏定义也可以用来定义多个语句，在宏调用时，把这些语句替换到源程序中。</p></li></ol><h2 id="撤销宏定义命令"><a href="#撤销宏定义命令" class="headerlink" title="撤销宏定义命令"></a>撤销宏定义命令</h2><p>宏定义命令<code>#define</code>应该写在函数外面，通常写在一个文件开头，这样宏定义的作用范围是整个文件。<strong>可以使用命令<code>#undef</code>撤销已定义的宏，终止该宏定义的作用域</strong>。</p><p>【实例】撤销已定义的宏示例</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14<span class="comment">//宏定义PI=3.14</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;派值为;%f&quot;</span>, PI);</span><br><span class="line">    Test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PI<span class="comment">//终止宏定义PI</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, PI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abba34c4cd7.png" alt="image-20220121170916060" style="zoom:80%;" /><h1 id="文件包含命令"><a href="#文件包含命令" class="headerlink" title="文件包含命令"></a>文件包含命令</h1><p><strong>文件包含是指一个源文件可以将另一个源文件的全部内容包含进来，即将另一个文件包含到本文件中</strong>。文件包含命令是以<code>#include</code>开头的预处理命令，在前面的部分使用各种C语言自带的函数时已经使用了文件包含命令。在C语言中，这个命令可以使得程序分为多个模块，被不同的程序员编写。有些公用的符号常量或宏定义等可以单独组成一个文件，在其他文件的开头用文件包含命令包含该文件即可使用。这样可以避免在每个文件开头编写这些公用量，从而节省时间，减少出错。</p><p>文件包含命令语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;文件名&quot;</span></span></span><br><span class="line"><span class="comment">//格式2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;文件名&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>格式1：系统先在本程序文件所在的磁盘和路径下寻找包含文件，若找不到，再按系统规定的路径搜索包含文件</strong>。</p><p><strong>格式2：系统仅按规定的路径搜索包含文件：在包含文件目录中查找（包含目录是由用户在设置环境是设置的），而不在源文件目录去查找。</strong></p><p>需要注意的是：</p><ol><li><strong>一个<code>#include</code>命令只能包含一个文件，若有多个文件要包含，则需要用多个<code>#include</code>命令</strong>。</li><li>为了避免寻找包含文件时出错，如果是包含系统头文件通常使用格式2，其他情况使用格式1</li><li><strong>由于被包含文件的内容全部出现在源程序清单中，所以其内容必须是C语言的源程序清单，否则编译时会出错</strong>。</li><li>文件包含允许嵌套，即在一个被包含的文件中又可以包含另一个文件。</li><li>文件包含命令还有一个很重要的功能：能将多个源程序清单合并成一个源程序进行编译。</li></ol><p>【实例】包含多个文件合并编译</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(a,b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PutOut</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输出结果为：\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件3：主入口</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;2.1.c&quot;</span><span class="comment">//载入文件1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;2.2.c&quot;</span><span class="comment">//载入文件2</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    PutOut();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Plus(<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abba3a76d98.png" alt="image-20220121183257670" style="zoom:80%;" /><h1 id="条件编译命令"><a href="#条件编译命令" class="headerlink" title="条件编译命令"></a>条件编译命令</h1><p><strong>一般情况下，源程序中所有的行都参加编译，但有时希望其中的部分内容只有在满足一定的条件下才进行编译，即对一部分内容指定编译条件，这就是条件编译</strong>。条件编译命令将决定哪些代码被编译，哪些不被编译。可将表达式的值或某个特定宏是否被定义作为编译条件。</p><p>条件编译有三种语法格式，代码如下：</p><ul><li><p>格式一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式1</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>      </span></span><br></pre></td></tr></table></figure><p>其功能是，<strong>如果标识符已使用<code>#define</code>命令定义则对程序段1进行编译，否则对程序段2进行编译</strong>。如果没有程序段2，则可以写为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>        </span></span><br></pre></td></tr></table></figure></li><li><p>格式二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 标识符</span></span><br><span class="line">程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> 标识符</span></span><br><span class="line">程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>        </span></span><br></pre></td></tr></table></figure><p><strong>与格式一不同的是由<code>#ifdef</code>变为<code>#ifndef</code>，它的功能是，如果标识符未被<code>#define</code>命令定义，则对程序段1进行编译，否则对程序段2进行编译</strong>。</p><p>【实例】进行条件编译命令</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> PI</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, PI);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PI未定义&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abba3faef50.png" alt="image-20220121210007943" style="zoom:80%;" /></li><li><p>格式三：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 常量表达式</span></span><br><span class="line">程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>        </span></span><br></pre></td></tr></table></figure><p>其功能是，<strong>如果常量表达式的值为真（非0），则对程序段1进行编译，反之则对程序段2进行编译。</strong>因此可以使程序在不同条件下完成不同的功能。</p><p>【实例】测试格式三</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> c 1 <span class="comment">//c的值非0时，执行加法，反之执行减法</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> c</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a加b的和为：%d&quot;</span>, a + b);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a和b的差为：%d&quot;</span>,a-b);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abba43f26c6.png" alt="image-20220121211515511" style="zoom:80%;" /><blockquote><p>对于预处理命令里的标识符或者变量，和代码中定义的不通用，且名称不可重复</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【NEW-1.0】概要</title>
      <link href="/2022/02/20/%E8%AF%AD%E8%A8%80%E6%A0%91/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-1.0%E3%80%91%E6%A6%82%E8%A6%81/"/>
      <url>/2022/02/20/%E8%AF%AD%E8%A8%80%E6%A0%91/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-1.0%E3%80%91%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h1><p>关于R语言的一些入门基本操作和一些基础要点，已经在我的博客R语言栏目下发布过相关文章，文章导航：</p><ul><li><a href="httpss://helloseraphine.top/index.php/archives/76.html">【1.1】R语言入门</a></li><li><a href="httpss://helloseraphine.top/index.php/archives/99.html">【1.2】R基础语法</a></li><li><a href="httpss://helloseraphine.top/index.php/archives/104.html">【1.3】R基础运算</a></li><li><a href="httpss://helloseraphine.top/index.php/archives/115.html">【1.4】R数据类型</a></li><li><a href="httpss://helloseraphine.top/index.php/archives/145.html">【1.5】R逻辑语句</a></li><li><a href="httpss://helloseraphine.top/index.php/archives/146.html">【1.6】函数</a></li><li><a href="httpss://helloseraphine.top/index.php/archives/148.html">【1.7】R包</a></li></ul><p>以及IDE相关操作指南的文章导航：</p><ul><li><a href="httpss://helloseraphine.top/index.php/archives/126.html">RStudio IDE使用指南</a></li></ul><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>因为下学期有R语言这门课程，所以我新开 NEW 部分的文章，作为新的笔记和相关文档说明，NEW系列的文章会更加偏向于实战部分，简单来说就是应用方面，而之前的笔记文章是偏向于概念上手方面。</p><p>关于 NEW 系列文章的说明如上所述，本文已经水完了（雾</p><p>下面推荐一首歌，出自迪士尼《后裔》系列，属于音乐剧：表现的是一对恋人其中一位对两者关系认知的纠结，表现她复杂的心理情绪。自行欣赏吧！！！</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbfabe8a80.jpg" alt="image-20220207233254612" style="zoom:100%;" />]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【6.0】C-函数</title>
      <link href="/2022/02/18/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%906.0%E3%80%91%E5%87%BD%E6%95%B0/"/>
      <url>/2022/02/18/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%906.0%E3%80%91%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>函数是组成C语言的基本单位，为了提高程序设计的质量和效率，C系统提高了大量的标准函数。例如前面部分提到的<code>printf()</code>，<code>scanf()</code>等函数。同样的，我们可以根据我们的实际需求来定义我们的函数。</p><p>【关于<code>Function</code>(函数)翻译问题】</p><p>如果你学过或者接触过现代的一些计算机语言，获取你会了解到一个词——“<strong>方法</strong>”。不论是函数也好，方法也罢，都是出自这个次——<code>Function</code>，就个人经验而言，这是个翻译的历史遗留问题，早起计算机进入我国的时候，那个时候没有相关的经验和相关书籍的参考，再加上一开始的计算机是数学领域发展起来的，就通俗的直译为——函数，由于现代计算机的发展和大量的经验，对于程序员来说，函数这个词非常的抽象，没有办法形成——望文知意，经过本土化，翻译为方法更复合实际，所以你如果接触过相对现代一些的教程都是说是方法而不是函数。</p><p>当然还有另一个说法，是对于面向过程编程语言，称为函数，而面向对象编程语言，称为方法。</p><p>（PS：面向对象编程是在面向对象过程编程的基础上发展而来的）</p><p>以上两种解释没有谁对谁错，此处仅做说明，以防初学者出现歧义。</p><h1 id="函数概述"><a href="#函数概述" class="headerlink" title="函数概述"></a>函数概述</h1><h2 id="函数的概念"><a href="#函数的概念" class="headerlink" title="函数的概念"></a>函数的概念</h2><p>在前面的所有示例中，一个程序中只有一个<code>main()</code>函数。对于复杂的程序，如果只有一个<code>main()</code>函数，将会影响程序的可读性，也不能体现程序的结构化设计的思想。因此，需要将某种特定功能的代码定义为函数，一个程序由<code>main()</code>函数和若干函数组成，每个函数在程序中形成即相对独立又相互联系的模块。**<code>main()</code>函数可以调用其他函数，其他函数也可以相互调用**。</p><p>一个简单的函数代码示例：</p><p>【实例】实现两数加法运算。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">()</span>;<span class="comment">//声明函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, Plus(x, y));<span class="comment">//调用函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;<span class="comment">//函数定义</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p><strong>从用户使用的角度来说，C语言的函数可以分为库函数和用户自定义函数</strong>。库函数是系统提供的，用户不必自己定义而可以直接使用。<strong>库函数由系统预定义在相应的文件中，使用时需要在程序的开头把该函数所在的头文件包含进来</strong>。例如，为了调用<code>printf()</code>，<code>scanf()</code>函数，需要调用<code>#include &lt;stdio.h&gt;</code>包含<code>stdio.h</code>头文件；为了调用<code>sqrt()</code>，<code>log()</code>函数，需要调用<code>#include &lt;math.h&gt;</code>包含<code>math.h</code>头文件。</p><p>使用库函数需要注意以下几个问题：</p><ul><li>函数的功能</li><li>函数参数的数目和顺序，以及每个参数的意义以及类型</li><li>函数的返回值的意义以及类型</li><li>需要使用的包含文件</li></ul><blockquote><p>常用的标准函数库参考<a href="httpss://www.runoob.com/cprogramming/c-standard-library-stddef-h.html">C 标准库</a></p></blockquote><p>有关问题底层大全等可以查询<a href="httpss://docs.microsoft.com/zh-cn/documentation/">微软文档</a>。</p><h1 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h1><h2 id="函数定义的格式"><a href="#函数定义的格式" class="headerlink" title="函数定义的格式"></a>函数定义的格式</h2><p><strong>函数由函数名，形参列表和函数体组成</strong>。函数名是用户为函数起的名字，用来标识唯一一个函数；函数的形参列表用来接受调用函数传递的数据，形参列表可以为空，此时函数名后的括号不可以省略；函数体是函数实现自身功能的一组语句。</p><ol><li><p><strong>无参数函数的定义格式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类型声明符 函数名称()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**类型声明符指定函数值的类型，即函数返回值的类型。如果一个函数没有返回值，该函数的返回值类型为<code>void</code>**。函数名称的命名规则与变量的名称规则相同。</p></li><li><p><strong>有参数函数的定义格式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型声明符 函数名称(形参列表声明)&#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，类型声明符号指定函数返回值的类型，可以是任何有效类型，如果省略类型声明符号，系统默认函数的返回值为<code>int</code>类型。如果函数只是执行相关操作而不需要返回值，则可以使用<code>void</code>。</p><p>有参函数在函数名称后的括号内必须有形式参数表，用于调用函数和被调用函数之间的数据传递，故必须对其进行类型声明，这由形式参数声明部分完成。一般情况下，函数执行需要多少原始外部数据，就有多少个形参数据，<strong>形参之间用逗号隔开</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;<span class="comment">//定义自定义函数</span></span><br><span class="line">    <span class="keyword">return</span> a + b;<span class="comment">//返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>空函数</strong></p><p>C语言中可以有空函数，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型声明符 函数名()\</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该函数，什么工作都不做。在主函数调用该函数，可以暂时表示某功能，后期扩充的时候填充该函数。</p></li></ol><h2 id="形式参数和实际参数"><a href="#形式参数和实际参数" class="headerlink" title="形式参数和实际参数"></a>形式参数和实际参数</h2><p>在调用有参函数时，主调函数和被调函数之间往往有数据传递关系。<strong>在定义函数时函数名后面小括号内的变量为形式参数（简称形参）</strong>，函数调用时用于接收主调函数传来的数据。在调用函数时，<strong>主调函数的函数调用语句的函数名后面小括号的参数称为实际参数（简称实参）</strong>。</p><p>【实例】编写函数求三个整数中的最小值</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MaxV</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">if</span> (a&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        max = a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        max = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max&lt;c)</span><br><span class="line">    &#123;</span><br><span class="line">        max = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> z = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大值为：%d&quot;</span>, MaxV(x,y,z));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9adc0f02.png" alt="image-20220116221916755" style="zoom:80%;" /></p><p>【实例】求三个实数的平均值</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Age</span><span class="params">(<span class="type">float</span> a,<span class="type">float</span> b,<span class="type">float</span> c)</span>&#123;</span><br><span class="line">    <span class="type">float</span> x = (a + b + c) / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> x = <span class="number">6</span>;</span><br><span class="line">    <span class="type">float</span> y = <span class="number">3</span>;</span><br><span class="line">    <span class="type">float</span> z = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大值为：%f&quot;</span>, Age(x,y,z));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9b54adb2.png" alt="image-20220116222636066" style="zoom:80%;" /></p><blockquote><p>如果你把形参的类型改为<code>int</code>类型，则返回的值为4</p></blockquote><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>通常是系统通过函数调用使主函数从被调函数得到一个确定的值，这就是函数的返回值。<strong>在C语言中，是通过<code>return</code>语句来实现的</strong>。<code>return</code>语句一般有以下3种形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> 表达式;</span><br><span class="line"><span class="keyword">return</span> (表达式);</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li><code>return</code>语句有双重作用：<strong>它使得函数从被调函数中退出，返回到调用的代码处，并向调用函数返回一个确定的值</strong>。</li><li>一个函数中可以用有多个<code>return</code>语句，执行到哪一个<code>return</code>语句，哪个<code>return</code>语句就起作用。</li></ol><h1 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h1><p>所谓函数的调用，是指一个函数（主调函数）暂时中断本函数的运行，转去执行另一个函数（被调函数）的过程。被调函数执行完成后，返回调用函数中断处继续调用函数的运行，则是一个返回过程。<strong>函数的一次调用必定伴随着一个返回过程，在函数的调用和返回这个过程中，两个函数之间发生信息的交换</strong>。</p><h2 id="函数调用的一般形式"><a href="#函数调用的一般形式" class="headerlink" title="函数调用的一般形式"></a>函数调用的一般形式</h2><p>语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(参数列表);</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>如果调用无参函数，则实参列表可以没有，但是括号不能省略。</li><li>实参列表的参数类型和个数必须与形参相同且顺序一致，多个实参之间用逗号隔开。</li></ol><h2 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a>函数的调用方式</h2><p>按照被调用函数在主调函数中出现的位置和完成的功能划分，函数调用有如下方式：</p><ol><li><p>把函数调用作为一个语句。此时一般不需要返回值，只需要执行特定的操作。</p></li><li><p>在表达式中调用函数，这种表达式称为函数表达式。此时要求函数返回一个值参与运算，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=c*Plus(a,b,c);</span><br></pre></td></tr></table></figure></li><li><p>将函数调用作为另一个函数调用的参数。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;和为：%d&quot;</span>,Sum(a,b));</span><br></pre></td></tr></table></figure></li></ol><p>【实例】编写函数判断一个数是否是素数</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsPrimeint</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">1</span> || x==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果一个数n可以被2~(n-1)之间的数除，则不是素数，返回1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x<span class="number">-2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x%(i+<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> prime;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;prime);</span><br><span class="line">    <span class="keyword">if</span> (IsPrimeint(prime)==<span class="number">1</span>)<span class="comment">//根据返回值来判断是否是素数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d不是素数&quot;</span>, prime);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d是素数&quot;</span>, prime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9bba4146.png" alt="image-20220116232953286" style="zoom:80%;" /></p><h2 id="函数的调用过程"><a href="#函数的调用过程" class="headerlink" title="函数的调用过程"></a>函数的调用过程</h2><p>代码示例如上面的示例，图示如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9bfaf396.png" alt="image-20220116233320143" style="zoom:80%;" /><h2 id="函数的原型声明"><a href="#函数的原型声明" class="headerlink" title="函数的原型声明"></a>函数的原型声明</h2><p>与变量的定义和使用一样，<strong>函数的调用也要遵循“先声明，后调用”</strong>的原则。在一个函数调用另一个函数时，需要具备以下条件：</p><ol><li><p>被调函数必须已经存在。</p></li><li><p>如果使用库函数，需要提前引用相关库函数。</p></li><li><p><strong>如果使用用户自定义函数，并且该函数与主调函数在同一个文件中，这时被调用函数应该放在主调函数之前定义。如果函数调用的位置在函数定义之前，则在函数调用之前必须对所调用的函数进行函数原型声明</strong>，函数原型声明的语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型声明符 函数名(形参表);</span><br></pre></td></tr></table></figure></li></ol><p>函数原型声明是向编译器表示一个函数的名称，将接收什么样的参数和有什么样的返回值，使编译器能够检查函数调用的合法性。实际上就是函数定义时的函数头，最后加上分号构成的声明语句。<strong>与函数头的区别是，函数声明中的形参列表中可以只写类型名，而不写形参名</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">average</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y,<span class="type">float</span> z)</span>;</span><br><span class="line"><span class="comment">//可以写为</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">average</span><span class="params">(<span class="type">float</span>,<span class="type">float</span>,<span class="type">float</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><p>在C语言中进行函数调用时，有两种不同的参数传递方式：<strong>值传递和地址传递</strong>。</p><ol><li><p><strong>值传递</strong></p><p><strong>在函数调用时，实参将其值传递给形参</strong>。这种传递方式即为值传递。</p><p>C语言规定，实参对形参的数据传递是值传递，即单向传递，也就是只能由实参传递给形参而不能由形参传递回来给实参。这是因为，<strong>在内存中，实参和形参占用不同的存储单元</strong>。在调用函数时，给形参分配存储单元，并将实参对应的值传递给形参，调用结束后，形参的存储单元会被释放，实参的存储单元仍要保留维持原值。因此，在执行一个被调用函数时，形参的变化不会改变实参的值。</p></li><li><p><strong>地址传递</strong></p><p><strong>地址传递指的是函数调用时，实参将某些量的地址传递给形参</strong>。这样实参和形参指向同一个内存空间，在执行被调函数的过程中，对形参所指向的空间中的内容改变能够直接影响到实参的值。</p><blockquote><p>在地址传递方式下，形参和实参可以是指针变量（欠-指针）</p></blockquote></li></ol><h1 id="函数的嵌套调用和递归调用"><a href="#函数的嵌套调用和递归调用" class="headerlink" title="函数的嵌套调用和递归调用"></a>函数的嵌套调用和递归调用</h1><h2 id="函数的嵌套调用"><a href="#函数的嵌套调用" class="headerlink" title="函数的嵌套调用"></a>函数的嵌套调用</h2><p>C语言中的函数的定义是相互平行的，在定义函数时，一个函数不能包含另一个函数。但是，一个函数在被调用的过程中可以调用其他函数，这就是函数的嵌套调用。</p><p>如下为常规的嵌套调用图示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9c554ed3.png" alt="image-20220117144058984" style="zoom:80%;" /><p>【实例】计算1+$2!$+$3!$+·····+$10!$。（使用嵌套函数）</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sum</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//自定义函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fac</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//自定义函数原型声明</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//和的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Sum(Fac(i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;阶乘的和为：%d&quot;</span>, sum);</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sum</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    sum += num;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求阶乘</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fac</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res *= (i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9ca6d775.png" alt="image-20220117145914488" style="zoom:80%;" /><h2 id="函数的递归调用"><a href="#函数的递归调用" class="headerlink" title="函数的递归调用"></a>函数的递归调用</h2><p><strong>在调用一个函数的过程中又直接或者间接的调用该函数本身，称为函数的递归调用</strong>。</p><p>递归是一种非常实用的程序设计技术。许多问题具有递归的特性，在某些情况下，用其他方法很难解决的问题，利用递归可以轻松解决。</p><p>【实例】利用递归安抚计算$n!$。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> facRes = <span class="number">1</span>;<span class="comment">//阶乘结果返回值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fac</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//自定义阶乘函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);<span class="comment">//获取要求的阶乘</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d!阶乘的结果为：%d&quot;</span>,num, Fac(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//阶乘计算</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fac</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        facRes *= num;</span><br><span class="line">        Fac(num - <span class="number">1</span>);<span class="comment">//递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> facRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9ce7006a.png" alt="image-20220117153716073" style="zoom:80%;" /><h1 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h1><p>关于函数的形参前面说明过支持任何类型的参数，同样的数组也是支持的。</p><h2 id="一维数组作为函数参数"><a href="#一维数组作为函数参数" class="headerlink" title="一维数组作为函数参数"></a>一维数组作为函数参数</h2><p><strong>用数组名作为函数实参时，向形参传递的是数组的地址值</strong>。在定义数组形参时，只需要在后面跟一个方括号就可以。</p><p>【实例】求一组整数的平均值（一维数组）</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Avg</span><span class="params">(<span class="type">int</span> x[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平均值为：%f&quot;</span>, Avg(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求平均函数</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Avg</span><span class="params">(<span class="type">int</span> x[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9d2e076f.png" alt="image-20220117161707032" style="zoom:80%;" /><h2 id="二维数组作为函数的参数"><a href="#二维数组作为函数的参数" class="headerlink" title="二维数组作为函数的参数"></a>二维数组作为函数的参数</h2><p><strong>可以使用二维数组名作为函数参数，此时的实参可以直接使用二维数组名，在被调函数中可以指定形参所有维数的大小，也可以省略一维大小的声明</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> x[<span class="number">3</span>][<span class="number">10</span>])</span>;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> x[][<span class="number">10</span>])</span>;</span><br></pre></td></tr></table></figure><p>这两个声明都是合法的，<strong>但是不能把第二维或者更高维度的大小省略</strong>，例如下面的定义说不合法的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> x[][])</span>;</span><br></pre></td></tr></table></figure><p>在第二维相同的情况下，形参数组的第一维可以与实参数组不同，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实参为：</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">//形参可以定义为：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">10</span>])</span>;</span><br><span class="line"><span class="comment">//形参或者为：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">8</span>][<span class="number">10</span>])</span>;</span><br></pre></td></tr></table></figure><p>以上两种形参定义都是可以的，这是形参数组和实参数组都是由相同类型的一维数组组成的，<strong>C语言系统不检查第一维度的大小</strong>。</p><p>【实例】实现两个 3 $\times$ 4 矩阵A和B的加法运算。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a[][<span class="number">4</span>], <span class="type">int</span> b[][<span class="number">4</span>])</span>;<span class="comment">//自定义函数原型声明</span></span><br><span class="line"><span class="type">int</span> res[<span class="number">3</span>][<span class="number">4</span>];<span class="comment">//矩阵和结果</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)<span class="comment">//获取需要计算的矩阵A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入矩阵A第%d行数据 | &quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;a[i][<span class="number">0</span>], &amp;a[i][<span class="number">1</span>], &amp;a[i][<span class="number">2</span>], &amp;a[i][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)<span class="comment">//获取需要计算的矩阵B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入矩阵B第%d行数据 | &quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;b[i][<span class="number">0</span>], &amp;b[i][<span class="number">1</span>], &amp;b[i][<span class="number">2</span>], &amp;b[i][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;矩阵的和为:\n&quot;</span>);</span><br><span class="line">    Plus(a, b);<span class="comment">//调用自定义函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//矩阵和计算函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>],<span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>])</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i][j] = a[i][j] + b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, res[i][<span class="number">0</span>], res[i][<span class="number">1</span>], res[i][<span class="number">2</span>], res[i][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9d73d0a2.png" alt="image-20220117212546625" style="zoom:80%;" /><h1 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h1><p>C语言程序是由一些函数组成的。每个函数都是相对独立的代码块，这些代码只局限于该函数。因此，在非特殊说明下，一个函数的代码对于程序的其他部分来说是隐藏的，它既不会影响程序的其他部分，也不会受程序其他部分的影响。也就是说一个函数的代码和数据不可能与另一个函数的代码和数据相互作用。这是因为它们分别有着自己的作用域。<strong>根据作用域的不同，变量分为两种类型：局部变量和全局变量</strong>。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p><strong>在函数内部定义的变量称为局部变量。局部变量的作用域仅局限于定义它的函数中</strong>。例如：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9db6b91e.png" alt="image-20220117213754751"  /><p>说明：</p><ol><li>主函数<code>main()</code>中定义的变量也是局部变量，仅在<code>main()</code>函数中有效。</li><li><strong>形参也是局部变量</strong>，只能在定义它的函数中有效。</li><li>不同的函数中，可以使用相同名称的局部变量，它们代表不同的对象，互不干扰。</li></ol><p>【实例】判断下述代码的运行结果</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9dfcaa5b.png" alt="image-20220117214820769" style="zoom:80%;" /><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p><strong>在函数体外定义的变量称为全局变量</strong>，全局变量的作用域是从它的定义点开始到文件结束，即位于全局变量定义后面的所有函数都可以使用该变量。</p><p>说明：</p><p><strong>如果要在定义全局变量之前使用函数中的使用该变量，则需要在该函数中使用关键词<code>extern</code>对全局变量进行外部声明</strong>。</p><p>【实例】<code>extern</code>关键字使用</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> a, b;<span class="comment">//全局变量原型声明</span></span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d&quot;</span>, a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a, b;</span><br></pre></td></tr></table></figure><p>【输出】 a&#x3D;1 b&#x3D;2</p><p>【实例】全局变量与局部变量同名，分析结果</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    Test(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数变量%d&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b+ ++a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9e44a6b3.png" alt="image-20220117222317221" style="zoom:80%;" /><p>利用全局变量可以减少函数实参的个数，从而减少内存空间以及传递数据时的时间消耗。但是一般还是建议除非必要，尽量不要使用全局变量，因为：</p><ol><li><strong>全局变量使函数的执行依赖于外部变量，降低了程序的通用性</strong>。模块化程序设计要求各个模块之间的“关联性”应尽量的小，函数尽可能是封闭的，只通过参数与外界发生联系。</li><li>降低程序的清晰性。</li><li>全局变量在整个程序的执行过程中都会占用存储空间。</li></ol><h1 id="变量的存储类别"><a href="#变量的存储类别" class="headerlink" title="变量的存储类别"></a>变量的存储类别</h1><p><strong>从变量的作用域，即空间的角度看，变量分为局部变量和全局变量</strong>。</p><p><strong>从变量的生存期，即变量的存在时间看，变量可以分为静态变量和动态变量</strong>。静态变量和动态变量是按照其存储方式来区分的。<strong>静态存储方式是指在程序运行期间分配固定的存储空间，程序执行完毕才释放。动态存储方式是在程序运行期间根据需要动态的分配存储空间</strong>，一旦动态过程结束，不论程序是否结束，都将释放存储空间。</p><p><strong>在C语言中，供用户使用的存储空间分为三部分，即程序区，静态存储区和动态存储区。</strong></p><ul><li><strong>程序区：存放用户程序</strong>。</li><li><strong>静态存储区：存放全局变量，静态局部变量和外部变量</strong>。</li><li><strong>动态存储区：存放局部变量，函数形参变量</strong>。</li></ul><blockquote><p><strong>CPU寄存器存放寄存器变量</strong></p></blockquote><p>【关于静态局部变量的作用】</p><p>我在看到静态局部变量的时候，第一反应是这个有什么用？局部使用使用完成都不再使用，为何使用静态来占用内存，目前我大概理解两种静态局部变量的适用情况：</p><ul><li><p>变量如果没有赋初值，对于一般的变量其值系统给的是<code>NULL</code>，静态局部变量系统会赋予初始值0；</p></li><li><p>静态局部变量占用内存，其值会一直保存，可以适用于需要多次调用某方法，但是值要增加的条件等，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">Plus</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主函数变量%d&quot;</span>, Plus());<span class="comment">//调用三次，获得三次不同的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a;<span class="comment">//静态局部变量</span></span><br><span class="line">    a++;<span class="comment">//自增</span></span><br><span class="line">    <span class="keyword">return</span> a;<span class="comment">//返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：主函数变量1 主函数变量2 主函数变量3</p></li></ul><blockquote><p>详细相关静态局部变量的内容查看<strong>局部变量的存储类型-静态局部变量</strong></p></blockquote><p>C语言有4种变量存储类别声明符，用来通知编译程序采用哪种方式存储变量，这4种变量存储类别声明符是：</p><ul><li><strong>自动变量声明符<code>auto</code>（一般省略）</strong></li><li><strong>静态变量声明符<code>static</code></strong></li><li><strong>外部变量声明符<code>extern</code></strong></li><li><strong>寄存器变量声明符<code>register</code></strong></li></ul><h2 id="局部变量的存储类型"><a href="#局部变量的存储类型" class="headerlink" title="局部变量的存储类型"></a>局部变量的存储类型</h2><p><strong>局部变量可有3种存储类型：自动变量，局部静态变量和寄存器变量</strong>。</p><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><p>自动变量是C语言中使用最多的一种变量。因为建立和释放这种类型的变量，都是系统自动进行的，所以称为自动变量。声明自动变量的语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">auto</span>] 类型声明符 变量名;</span><br></pre></td></tr></table></figure><p>其中，<code>auto</code>是自动变量存储类别声明符，一般可以省略。如果省略，系统默认该变量为<code>auto</code>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="type">int</span> a;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure><p>自动变量是在动态存储区分配存储单元的。在一个函数中定义自动变量，在调用次函数时才会给变量分配存储空间，当函数执行完毕，这些单元被释放，自动变量中存放的数据也随之丢失。每次调用函数，自动变量重新被赋值，且其默认初值是不确定的。</p><h3 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h3><p>如果希望在函数调用结束后仍然保留其中定义的局部变量的值，则可以将局部变量定义为局部静态变量。声明局部静态变量的语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> 类型声明符 变量名;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>局部静态变量是在静态存储区分配存储单元的。<strong>一个变量被声明为静态，在编译时即分配存储空间，在整个程序运行期间都不释放。因此，函数调用结束后，它的值并不消失，其值能够保持连续性</strong>。</li><li>局部静态变量是在编译过程中赋予初值的，且只赋予一次初值，在程序运行时其初值已定，以后每次调用函数时，都不再赋予初值，而是保留上一次函数调用结束时的结果。</li><li><strong>局部静态变量在未显式初始化时，编译系统把它们初始化为 <code>0</code>（整型变量），<code>0.0</code>（实型变量），<code>\0(空字符)</code>（字符型变量）</strong>。</li></ol><h3 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h3><p>寄存器变量具有与自动变量完全相同的性质。<strong>当把一个变量指定为寄存器存储类型时，系统将它们放在CPU中的一个寄存器中，通常把使用频率较高的变量（如循环次数较多的循环变量）定义为<code>register</code>类型</strong>。</p><p>【实例】寄存器变量的应用</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; i+<span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d * %d = %d &quot;</span>, j, i, j * i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9eb9c809.png" alt="image-20220117235837946" style="zoom:80%;" /><p>说明：</p><ol><li><strong>只有局部自动变量和形参可以作为寄存器变量，其他（如全局变量，局部静态变量则不行）</strong>。</li><li><strong>只有<code>int</code>,<code>char</code>和指针类型变量可以定义为寄存器类型，而<code>long</code>,<code>double</code>和<code>float</code>型变量不能设定为寄存器类型，因为它们的数据长度已经超出通用寄存器本身的位长。</strong></li><li>可用于变量空间分配的寄存器的个数依赖于具体的机器</li></ol><h2 id="全局变量的存储类别"><a href="#全局变量的存储类别" class="headerlink" title="全局变量的存储类别"></a>全局变量的存储类别</h2><p>全局变量是在静态存储区域分配单元的，其默认值初值为0。全局变量的存储类型有两种，即外部<code>extern</code>类型和静态<code>static</code>类型。</p><h3 id="外部全局变量"><a href="#外部全局变量" class="headerlink" title="外部全局变量"></a>外部全局变量</h3><p><strong>在多个源程序文件的情况下，如果在一个文件中要引用其他文件中定义的全局变量，则应该在需要引用变量的文件中，使用<code>extern</code>进行该变量的声明</strong>。</p><p>【实例】调用其他文件的全局变量</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件一代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span>;<span class="comment">//在文件二自定义函数原型声明</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">32</span>;<span class="comment">//全局变量声明定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">Test();<span class="comment">//调用文件二自定义函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文件二代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;<span class="comment">//文件一全局变量原型声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> c = a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】32</p><p>说明：</p><ol><li><p><code>extern</code>只能用来声明变量，不能用来定义变量。因为它不会生成新的变量，只是表示该变量已在其他地方有过定义。</p></li><li><p><code>extern</code>用来声明变量时，类型名可以写，也可以不写，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">extern</span> a;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>extern</code>不能用来初始化变量</strong>，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h3><p>在程序设计时，<strong>如果希望在一个文件中定义的全局变量仅限于被本文件引用，而不能被其他文件访问，则可以在定义次全局变量前面加上<code>static</code>关键词</strong>，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure><p>此时，全局变量的作用域仅限于本文件内，其他文件中即使进行了<code>extern</code>声明，也无法使用该变量。</p><p>由此可见，<strong>静态全局变量与外部全局变量在同一个文件的作用域是一样的，但是外部全局变量的作用域可以延伸至其他程序文件，而静态全局变量在被定义的文件以外是不可见的</strong>。</p><h1 id="内部函数和外部函数"><a href="#内部函数和外部函数" class="headerlink" title="内部函数和外部函数"></a>内部函数和外部函数</h1><p>C语言由函数组成的，这些函数既可以在一个文件中也可以在多个不同的文件中，根据函数的使用范围，可以将其分为<strong>内部函数和外部函数</strong>。</p><h2 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h2><p>使用存储类别<code>static</code>定义的函数称为内部函数，其一般形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> 类型声明符 函数名(形参表);</span><br></pre></td></tr></table></figure><p>内部函数又称为静态函数。内部函数只能被本文件中的其他函数所调用，而不能被其他外部文件调用。使用内部函数，可以使函数局限于所在文件，如果在不同的文件中有同名函数，则互不干扰。</p><h2 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h2><p><strong>使用存储类别<code>extern</code>（或者没有指定存储类别）定义的函数，其作用域是整个程序的各个文件，可以被其他文件的任何函数调用，称为外部函数</strong>。一般函数没有指定存储类别，都是外部函数。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> 类型声明符 函数名(形参表);</span><br></pre></td></tr></table></figure><p>由于函数都是外部性质的，因此，在定义函数时，关键字<code>extern</code>可以省略。</p><p>在调用函数的文件中，一般要用<code>extern</code>声明所用的函数是外部函数。</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【4.0】C-循环结构及其应用</title>
      <link href="/2022/02/16/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%905.0%E3%80%91%E6%95%B0%E7%BB%84/"/>
      <url>/2022/02/16/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%905.0%E3%80%91%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于大规模的数据，尤其是相互之间存在一定的联系的数据，怎么表示和组织才能达到高效呢？C语言的数组类型为同类型的数据组织提供了一种有效的形式。</p><p>同样的，字符串应用广泛，但C语言中没有专门的字符串类型，字符串是使用字符数组来存放的。</p><h1 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h1><h2 id="一维数组的定义和引用"><a href="#一维数组的定义和引用" class="headerlink" title="一维数组的定义和引用"></a>一维数组的定义和引用</h2><h3 id="一维数组的定义"><a href="#一维数组的定义" class="headerlink" title="一维数组的定义"></a>一维数组的定义</h3><p>在C语言中使用数组前必须先进行定义。一维数组的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式声明</span></span><br><span class="line">类型声明符 数组名[常量表达式];</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> c[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li><p>类型声明符是任一种基本数据类型或者构造数据类型，即<code>int</code>，<code>float</code>，<code>char</code>等基本数据类型，以及结构体数据类型。从这里可以看出，数组是建立在其他数据类型的基础之上的，因此数组是构造类型。</p></li><li><p>数组名是用户定义的数组标识符，命名规则遵循标识符命名规则。对于数组元素来说，它们具有一个共同的名字，即数组名。</p><blockquote><p>需要注意的是，数组的名称不可以与其他变量名相同</p></blockquote></li><li><p><strong>方括号中的常量表达式表示数组元素的个数，也成为数组的长度</strong>。</p><blockquote><p>不能在方括号中用变量来表示数组元素的个数，但可以使用符号常数或者常量表达式</p></blockquote></li></ol><h3 id="一维数组元素的存储"><a href="#一维数组元素的存储" class="headerlink" title="一维数组元素的存储"></a>一维数组元素的存储</h3><p>每个数组元素都占用内存中的一个存储单元，每个元素都是一个变量，可以像以前使用普通变量一样使用，不过使用的是数组的索引。<strong>系统在内存中为数组元素分配连续的存储单元</strong>。</p><p>例如，定义语句<code>int a[15]</code>，声明了以下几个问题：</p><ol><li>数组名为<code>a</code></li><li>数组元素的数据类型为<code>int</code></li><li>数组元素的下标值是从0开始的。</li><li>数组名<code>a</code>是数组存储区的首地址，即存放数组第一个元素的地址。<strong>a等价于<code>&amp;a[0]</code>，因此数组名是一个地址常量。不能对数组名进行赋值或者运算</strong>。</li></ol><h3 id="一维数组元素的引用"><a href="#一维数组元素的引用" class="headerlink" title="一维数组元素的引用"></a>一维数组元素的引用</h3><p>对数组元素的引用与对变量的引用类似，与变量引用不同的是，只能对单个数组元素进行引用，而不能一次引用整个数组。一维数组元素的引用格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[下标]</span><br></pre></td></tr></table></figure><p>【实例】从键盘输入10个整数，求其中的最大数并输出</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个数值：&quot;</span>);</span><br><span class="line">    <span class="type">int</span> num[<span class="number">10</span>];    <span class="comment">//定义数组存放10个数值</span></span><br><span class="line">    <span class="type">int</span> max;    <span class="comment">//最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)     </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num[i]);    <span class="comment">//记录输入数值</span></span><br><span class="line">    &#125;</span><br><span class="line">    max = num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (max&lt;num[j])</span><br><span class="line">        &#123;</span><br><span class="line">            max = num[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大值为：%d&quot;</span>, max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb93605863.png" alt="image-20220112202101454" style="zoom:80%;" /><h2 id="一维数组的初始化"><a href="#一维数组的初始化" class="headerlink" title="一维数组的初始化"></a>一维数组的初始化</h2><p><strong>与一半变量初始化一样，数组的初始化就是在定义数组的同时，给其数组元素赋予初值</strong>。</p><blockquote><p>数组的初始化是在编译阶段进行的，这样减少运行时间，提高效率</p></blockquote><p>一维数组的初始化语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">类型声明符 数组名[常量表达式]=&#123;数值<span class="number">1</span>，数值<span class="number">2</span>，···，数值n&#125;;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//以上示例代码，相当于：</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>,a[<span class="number">1</span>]=<span class="number">2</span>,a[<span class="number">2</span>]=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>C语言对数组的初始化有以下几点规定：</p><ol><li><p><strong>可以只给部分数组元素赋初值</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>只能给数组元素逐个赋值，不能给数组整体赋值。</p></li><li><p><strong>如果给全部元素赋值，则在数组声明中，可以不给出数组元素的个数</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="一维数组实例"><a href="#一维数组实例" class="headerlink" title="一维数组实例"></a>一维数组实例</h3><p>【实例】给定$n$个任意数，按由小到大对其排序，并输出排序结果。</p><blockquote><p>详细看数据结构部分（欠数据结构），经典的排序问题</p></blockquote><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><h2 id="二维数组的定义和引用"><a href="#二维数组的定义和引用" class="headerlink" title="二维数组的定义和引用"></a>二维数组的定义和引用</h2><p>前面介绍的数组只有一个下标，称为一维数组，其数组元素也成为单下标变量。在实际问题中，很多问题是二维甚至是多维的，比如常见的矩阵就是二维的，因此C语言允许构造多维数组。</p><h3 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h3><p>二维数组定义的语法格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">类型声明符 数组名[常量表达式<span class="number">1</span>][常量表达式<span class="number">2</span>];</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p><strong>其中，常量表达式1表示第一维的长度，常量表达式2表示第二维的长度</strong>。</p><blockquote><p>数组元素的个数&#x3D;常量表达式1 $\times$ 常量表达式2</p></blockquote><h3 id="二维数组的存储"><a href="#二维数组的存储" class="headerlink" title="二维数组的存储"></a>二维数组的存储</h3><p><strong>二维数组在概念上是二维的，比如说矩阵，但是其存储器单元是按一维线性排列的</strong>。在一维存储器中存放二维数组，有两种方式：一种是按行排列，即放完一行之后顺次放入第二行；另一种是按列排列，即放完一列之后再顺次放入第二列。<strong>在C语言中，二维数组是按行排列的</strong>。例如：<code>int x[2][3];</code></p><p>先放第一行，即<code>x[0][0]</code>，<code>x[0][1]</code>，<code>x[0][2]</code>，再放第二行，即<code>x[1][0]</code>，<code>x[1][1]</code>，<code>x[1][2]</code>。如图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb93c24d1b.png" alt="image-20220113212405628" style="zoom:80%;" /><h3 id="二维数组的引用"><a href="#二维数组的引用" class="headerlink" title="二维数组的引用"></a>二维数组的引用</h3><p>与一维数组一样，不能对一个二维数组整体进行引用，只能对具体的数据元素进行引用。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[下标<span class="number">1</span>][下标<span class="number">2</span>];</span><br></pre></td></tr></table></figure><blockquote><p>要注意下标越界问题，部分编译系统不会检查下标越界问题</p></blockquote><h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><p>二维数组的初始化即定义数组的同时对其元素赋值，初始化有两种方法：</p><ol><li><p><strong>把初始化值括在一对大括号内</strong>，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure><p>初始化的结果是：<code>x[0][0]=1</code>，<code>x[0][1]=2</code>，<code>x[0][2]=3</code>，<code>x[1][0]=4</code>，<code>x[1][1]=5</code>，<code>x[1][2]=6</code>。</p></li><li><p><strong>把多维数组分解成多个一维数组</strong>，也就是把二维数组看作是一种特殊的一维数组，该数组的每一个元素又是一个一维数组。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>说明：</p><ol><li><p><strong>可以只对部分元素赋值，未赋值的元素自动取0值</strong>。</p></li><li><p><strong>如果对全部元素赋初值，则第一维的长度可以不给出</strong>。例如，对二维数组初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure><p>即第一维度的长度可以省略，但是第二维度的长度不能省略。</p></li></ol><h3 id="二维数组的应用实例"><a href="#二维数组的应用实例" class="headerlink" title="二维数组的应用实例"></a>二维数组的应用实例</h3><p>【实例】某公司2020年上半年产品销售统计表如下表所示，求每种产品的月平均销售量和所有产品的总月平均销售量。</p><table><thead><tr><th>月份</th><th>产品A</th><th>产品B</th><th>产品C</th><th>产品D</th><th>产品E</th></tr></thead><tbody><tr><td>1</td><td>30</td><td>21</td><td>50</td><td>35</td><td>42</td></tr><tr><td>2</td><td>35</td><td>15</td><td>60</td><td>40</td><td>40</td></tr><tr><td>3</td><td>32</td><td>18</td><td>56</td><td>37</td><td>50</td></tr><tr><td>4</td><td>40</td><td>25</td><td>48</td><td>42</td><td>48</td></tr><tr><td>5</td><td>36</td><td>23</td><td>52</td><td>33</td><td>46</td></tr><tr><td>6</td><td>41</td><td>19</td><td>55</td><td>39</td><td>52</td></tr></tbody></table><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> A[<span class="number">5</span>][<span class="number">6</span>] =&#123;  &#123;<span class="number">30</span>, <span class="number">35</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">36</span>, <span class="number">41</span>&#125; ,  </span><br><span class="line">                    &#123;<span class="number">21</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">25</span>, <span class="number">23</span>, <span class="number">19</span>&#125;,   </span><br><span class="line">                    &#123;<span class="number">50</span>, <span class="number">60</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">52</span>, <span class="number">55</span>&#125;,   </span><br><span class="line">                    &#123;<span class="number">35</span>, <span class="number">40</span>, <span class="number">37</span>, <span class="number">42</span>, <span class="number">33</span>, <span class="number">39</span>&#125;,   </span><br><span class="line">                    &#123;<span class="number">42</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">48</span>, <span class="number">46</span>, <span class="number">52</span>&#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">    <span class="type">float</span> yuePing;  <span class="comment">//每种产品的月平均销售量</span></span><br><span class="line">    <span class="type">float</span> zongYue;  <span class="comment">//所有产品的总月平均销售量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            yuePing += A[i][j];<span class="comment">//产品总和</span></span><br><span class="line">            <span class="keyword">if</span> (j==<span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;产品%d月平均销售量为：%.2f\n&quot;</span>,i+<span class="number">1</span>,yuePing/<span class="number">6</span>);</span><br><span class="line">                zongYue += yuePing/<span class="number">6</span>;<span class="comment">//每件产品总和的和</span></span><br><span class="line">                yuePing = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i+<span class="number">1</span>==<span class="number">5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;所有产品月平均销售量为：%.2f&quot;</span>, zongYue/<span class="number">5</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb941b54a7.png" alt="image-20220115162021891" style="zoom:80%;" /></p><h1 id="字符数组和字符串"><a href="#字符数组和字符串" class="headerlink" title="字符数组和字符串"></a>字符数组和字符串</h1><p>前面说明的都是数值型数组，即数组元素都是数值。<strong>还有一种数组，其每个元素都是字符，也就是说数组元素的数据类型是<code>char</code>，初次之外与数值型数组没有区别</strong>。</p><p>字符串应用广泛，但是C语言中没有专门的字符串类型，<strong>字符串是存放在字符数组中的</strong>。</p><h2 id="字符数组的定义和初始化"><a href="#字符数组的定义和初始化" class="headerlink" title="字符数组的定义和初始化"></a>字符数组的定义和初始化</h2><p>字符型数组的语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line"><span class="type">char</span> 数组名[字符个数];</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">char</span> c[<span class="number">2</span>]=&#123;<span class="string">&quot;ch&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>**字符数组也可以是二维或者多维数组，例如：<code>char c[2][2]</code>**。</p><p>同样，字符数组也允许在定义时进行初始化赋值，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符常量赋值</span></span><br><span class="line"><span class="type">char</span> c[<span class="number">6</span>]=&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//字符串常量赋值</span></span><br><span class="line"><span class="type">char</span> c[<span class="number">5</span>]=&#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>**字符型数组初始化时，提供的数据个数如果小于数组元素的个数，则多余的数组元素初始化为空字符<code>\0</code>，而数值型数组初始化为<code>0</code>**。</p><blockquote><p><code>\0</code>在C语言中定义为<code>NULL</code>，即空字符</p></blockquote><p>【实例】编写程序，输出”Hello,world”。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码一</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">12</span>]=&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;\,&#x27;</span>,<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码二</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">12</span>]=&#123;<span class="string">&quot;Hello,world&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb94822f22.png" alt="image-20220115171917918" style="zoom:80%;" /></p><blockquote><p>如果你足够细心的话，会发现，<strong>字符数组的长度多余实际字符长度</strong>，详细原因见字符串</p></blockquote><p>【关于字符数组长度&#x3D;初始化字符长度问题】</p><p>如果你使用如下代码输出，就会发现一些奇怪的输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">5</span>] = &#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c);    <span class="comment">//输出全部字符数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，规定5个字符，但是初始化的时候就给5个字符，按照之前说的<code>printf</code>函数必须遇到<code>\0</code>才会停止输出。那么在GCC编译器上，输出的结果为：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb94c37a1b.png" alt="image-20220115202945078" style="zoom:80%;" /></p><p>在Visual Studio 2019 IDE上的输出结果为：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb94f8b715.png" alt="image-20220115203201315" style="zoom:80%;" /></p><p>这也是著名的“烫烫烫”问题，详细原因可以参考<a href="httpss://zhuanlan.zhihu.com/p/92004659">烫烫烫烫烫烫！ - 汇智动力IT学院的文章 - 知乎</a>。</p><p><strong>简单来说，对于编译器来说，一次编译过程中会做很多初始化的工作，在这个工作中为了对内存的高效合理化应用，会提前在没用的内存或者需要调度它用的内存写入一些字符来标识，当发生内存溢出的时候，这些本来标识的字符被当作数据处理，例如中文处理，在中文编码就变成了“烫烫烫”</strong>。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>前面说明字符串常量时，说明了对于实际字符小于声明字符长度的，其余字符会被<code>\0</code>赋值。因此<strong>C编译器以<code>\0</code>来判断字符串是否结束，而不是通过字符长度来判断字符串长度</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">6</span>]=&#123;<span class="string">&quot;China&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>赋值结果为：数组<code>c</code>含有6个字符，前五个组成”China”，最后一位字符为<code>\0</code>，即空字符。</p><p>需要注意的是：</p><ol><li><p>初始化字符数组时不可以超出数组长度</p></li><li><p><strong>用字符串常量初始化时，字符数组长度可以省略，其数组存放字符个数由赋值的字符串长度决定</strong>。</p><blockquote><p>实际长度&#x3D;实际字符长度+1（<code>\0</code>）</p></blockquote></li><li><p><strong>用字符常量初始化时，如果省略字符数组长度，则实际长度&#x3D;实际字符长度</strong>。</p></li></ol><h2 id="字符数组的输入和输出"><a href="#字符数组的输入和输出" class="headerlink" title="字符数组的输入和输出"></a>字符数组的输入和输出</h2><p>字符数组的输入和输出有两种方法：<strong>一种是逐个把字符输入&#x2F;输出，另一种方法是整个字符串一次输入&#x2F;输出</strong>。</p><p>**<code>scanf</code>&#x2F;<code>printf</code>函数可以输入&#x2F;输出任何类型的数据，若要输入&#x2F;输出字符，则格式为<code>%c</code>，若要输入&#x2F;输出字符串，格式为<code>%s</code>**。</p><ol><li><p>字符数组的输入。从键盘逐个读取字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,字符数组元素地址);</span><br></pre></td></tr></table></figure></li><li><p>从键盘读取一串字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,字符数组名);</span><br></pre></td></tr></table></figure></li><li><p>字符数组的输出。从键盘逐个输出字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,字符数组元素地址);</span><br></pre></td></tr></table></figure></li><li><p>从键盘输出一串字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,字符数组名);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>需要注意的是，输出字符串时，遇到<code>\0</code>则结束。</p></blockquote><p>【<strong>关于输入字符串超出数组字符长度问题</strong>】</p><p>问题源于如下代码，代码很简单，输入字符串，输出字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">3</span>];<span class="comment">//定义字符数组</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c);<span class="comment">//输入字符存储字符数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c);<span class="comment">//输入字符输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们正常按照字符数量输入字符，则输出结果：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb954afb51.png" alt="image-20220115193556578" style="zoom:80%;" /></p><p>但是如果我们故意多输入一些字符，则输出结果：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb957c2db2.png" alt="image-20220115193639617" style="zoom:80%;" /></p><p>首先我们需要明确几点规则：</p><ol><li><strong>对于字符数组，每个字符数组最后一位一定是一个<code>\0</code>字符</strong>。</li><li><strong>对于<code>printf()</code>函数来说，输出字符是自动截取到<code>\0</code>字符</strong>。</li><li><strong>对于数组溢出问题，不在C编译器的预编译报错范围</strong>，也就是说数组溢出问题需要程序员自行负责。</li></ol><p><strong>所以对于直接获取字符串输入来说，获取多少编译器就在最后+<code>\0</code>字符，然后<code>printf</code>函数输出字符串，是读取到<code>\0</code>才会停止，导致即使超出字符数组长度，也可以原样输出的原因</strong>。</p><p>那么问题升级一下，如果我在输入字符串的时候，输入了空格会怎么办？代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">5</span>];  <span class="comment">//容纳5个字符</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c); <span class="comment">//输入字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, c[<span class="number">3</span>]); <span class="comment">//输出第四个字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c);    <span class="comment">//输出全部字符数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb95cf3e80.png" alt="image-20220115195643582" style="zoom:80%;" /></p><blockquote><p>0对应的是<a href="https://c.biancheng.net/c/ascii/">ASCII</a>码的<code>NULL</code>，即空字符，也就是C语言的<code>\0</code>。</p></blockquote><p>可以看到，<strong>如果我们在输入字符串的时候，输入空格，那么空格会被默认为<code>\0</code>字符，即<code>NULL</code>（空字符）</strong>。那么，我们真的想要输出空格怎么办？</p><p><strong>可以使用<code>%[^\n]</code>来告诉输入函数，以回车作为字符串输入的结束</strong>。对于上面的代码，我们修改后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">5</span>];  <span class="comment">//容纳5个字符</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, c); <span class="comment">//输入字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, c[<span class="number">3</span>]); <span class="comment">//输出第四个字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c);    <span class="comment">//输出全部字符数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb960d7548.png" alt="image-20220115200213805" style="zoom:80%;" /></p><p>可以得知，32是<a href="https://c.biancheng.net/c/ascii/">ASCII</a>的空格字符。在输入的时候，我们规定编译器在回车的地方认为是字符串的结束，即在该处加上了<code>\0</code>字符，这样就解决了这个问题。</p><h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h2><p>**在C语言标准库函数中，提供了一些专门用于处理字符串的函数，常用的有<code>gets()</code>,<code>puts()</code>,<code>strlen()</code>,<code>strcmp()</code>,<code>strlwr</code>,<code>strupr()</code>,<code>strcat()</code>,<code>strcpy()</code>,<code>strncpyy()</code>**函数。</p><blockquote><p>在使用这些函数之前，需要引入专门的函数库，即<code>#include &lt;string.h&gt;</code></p></blockquote><ol><li><p><strong><code>gets()</code>，<code>puts()</code>是字符串输入&#x2F;输出函数</strong>。</p><p>其中，<code>gets()</code>函数是字符串输入函数。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gets(字符数组名);</span><br></pre></td></tr></table></figure><p>函数功能：获取输入的字符串到指定变量中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(字符数组名);</span><br></pre></td></tr></table></figure><p>函数功能：输出指定字符串，同<code>printf</code>，也是截取到字符<code>\0</code>。</p></li><li><p><strong><code>strlen()</code>函数事获取字符串长度函数</strong>。语法格式如下：</p><blockquote><p><code>strlen</code>是英文<code>string length</code>的缩写，即字符串长度。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(字符数组名);</span><br></pre></td></tr></table></figure><blockquote><p>在Visual Studio 2019 编译器上是截取<code>\0</code>之前的字符实际长度，而在GCC编译器中，是截取全部的字符长度，即包含<code>\0</code>字符的长度。（修正：如果字符数组长度没有大于实际长度1位，这输出的长度包含<code>\0</code>字符，即实际长度+1，反之，这输出正确的数组实际长度）</p></blockquote></li><li><p><strong><code>strcmp()</code>函数是字符串比较函数</strong>。语法格式如下：</p><blockquote><p><code>strcmp</code>是英文<code>string compare</code>的缩写，即字符串比较。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(字符数组<span class="number">1</span>，字符数组<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>函数功能：<strong>将两个字符数组的字符串从左到右逐个比较，比较字符的ASCII码大小，并由函数返回值返回比较结果</strong>。（<strong>字符串的比较原理：每个字符串ASCII码的和做比较</strong>）</p><ul><li>字符串1&#x3D;字符串2，返回值&#x3D;0</li><li>字符串1&gt;字符串2，返回值&gt;0</li><li>字符串1&lt;字符串2，返回值&lt;0</li></ul><p>【大坑说明】</p><p>注意这里有个大坑，如果我们常规的字符数组初始化<code>char c[2]=&#123;&quot;he&quot;&#125;;</code>末尾没有<code>\0</code>字符，则编译器在获取该字符串的时候会溢出，也就是说编译器底层获取的<code>c[2]</code>实际的值已经不是<code>he</code>了。而对于<code>scanf()</code>&#x2F;<code>puts()</code>来说，它会自动在最后加上<code>\0</code>字符，所以不会出现这种问题。</p><blockquote><p>当初始化字符数组规定字符&#x3D;实际赋值，这会出现<code>\0</code>字符丢失，如果按照C语言规定，初始化数组时规定字符&gt; 实际初始化赋值一位，则不会出现这个问题</p></blockquote></li><li><p><strong><code>strlwr()</code>和<code>strupr()</code>函数，是字符串大小写转换函数</strong>。函数语法格式如下：</p><blockquote><p><code>strlwr</code>是英文<code>string lower</code>(case)的缩写，即字符串小写（字母）</p><p><code>struper</code>是英文<code>string upper</code>(case)的缩写，即字符串大写（字母）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换小写字母函数</span></span><br><span class="line">   strlwr(字符数组名);</span><br><span class="line">   <span class="comment">//转换大写字母函数</span></span><br><span class="line">   strupr(字符数组名);</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">char</span> c[<span class="number">6</span>] = &#123;<span class="string">&quot;hello&quot;</span>&#125;;<span class="comment">//小写字母初始化</span></span><br><span class="line">       <span class="type">char</span> b[<span class="number">6</span>] = &#123;<span class="string">&quot;HELLO&quot;</span>&#125;;<span class="comment">//大写字母初始化</span></span><br><span class="line">       <span class="built_in">puts</span>(strupr(c));<span class="comment">//转换为大写</span></span><br><span class="line">       <span class="built_in">puts</span>(strlwr(b));<span class="comment">//转换为小写</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb965ca450.png" alt="image-20220115215932091" style="zoom:80%;" /></p></li><li><p><strong><code>strcat()</code>是字符串连接函数</strong>。语法格式如下：</p><blockquote><p><code>strcat</code>是英文<code>string catenate</code>的缩写，即字符串连接。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(字符数组名<span class="number">1</span>，字符数组名<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>函数功能：把字符数组2中的字符串连接到字符数组1中字符串的后面，并删去字符串1后的串标志<code>\0</code>。函数返回值为字符数组1的首地址</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">16</span>] = &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">6</span>] = &#123;<span class="string">&quot;HELLO&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="built_in">strcat</span>(c, b));<span class="comment">//拼接字符串数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9697cbf9.png" alt="image-20220115223420492" style="zoom:80%;" /></p><blockquote><p>需要注意的是，合并字符数组时，第一个字符数组的长度要足够长，否则不足以容纳全部字符数组2</p></blockquote></li><li><p><strong><code>strcpy()</code>&#x2F;<code>strncpy()</code>是字符串复制函数</strong>。语法格式如下：</p><blockquote><p><code>strcpy</code>是英文<code>string copy</code>的缩写，即字符串复制。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复制全部字符数组</span></span><br><span class="line"><span class="built_in">strcpy</span>(字符数组<span class="number">1</span>,字符数组<span class="number">2</span>);</span><br><span class="line"><span class="comment">//复制指定长度的字符串数组</span></span><br><span class="line"><span class="built_in">strncpy</span>(字符数组<span class="number">1</span>,字符数组<span class="number">2</span>,n);</span><br></pre></td></tr></table></figure><p><strong>函数功能：（<code>strcpy</code>）把字符数组2中的字符串复制到字符组1中。串结束标志<code>\0</code>也一同复制；（<code>strncpy</code>）把字符数组2中的前n个字符复制到字符数组1中，取代字符数组1中原有的前n个字符</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strcpy</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">6</span>] = &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">6</span>] = &#123;<span class="string">&quot;HELLO&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="built_in">strcpy</span>(c, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb96d9a226.png" alt="image-20220116160131040" style="zoom:80%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strncpy</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">16</span>] = &#123;<span class="string">&quot;helloleoleiming&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">6</span>] = &#123;<span class="string">&quot;HELLO&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(c,b,<span class="number">6</span>);<span class="comment">//复制字符数组b前六个字符到C</span></span><br><span class="line">    c[<span class="number">6</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//将c的第七个字符变为结束字符“\0”</span></span><br><span class="line">    <span class="built_in">puts</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb97154e63.png" alt="image-20220116163403734" style="zoom:80%;" /></p><p>如果你足够细心，会疑问直接复制不可以吗？为什么要多此一举？**实际上<code>strncpy</code>函数不会给末尾加上结束符号，即<code>\0</code>**。所以需要手动添加。</p><blockquote><p>我在GCC编译器上测试这样是可以通过的，但是在Visual Studio 2019上测试不通过，原因还是上面提到的<strong>实际上<code>strncpy</code>函数不会给末尾加上结束符号，即&#96;\0</strong>。</p></blockquote><ul><li>个人感觉这是个历史遗留问题，此方法暂时不建议使用。</li></ul></li></ol><h2 id="字符数组应用实例"><a href="#字符数组应用实例" class="headerlink" title="字符数组应用实例"></a>字符数组应用实例</h2><p>【实例】编程实现凯撒加密，即是将加密文本中的每个字符替换成为其后面的第k个字符。</p><p>【代码示例】【伪装凯撒加密】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100 <span class="comment">//设置最大加密字符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Bit 12 <span class="comment">//设置加密位数</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入加密文本：&quot;</span>);</span><br><span class="line">    <span class="type">char</span> text[MAX]; <span class="comment">//定义加密字符变量</span></span><br><span class="line">    gets(text); <span class="comment">//获取字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(text); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        text[i] += Bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密后的文本为：%s&quot;</span>,text);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9755894a.png" alt="image-20220116164848886" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【4.0】C-循环结构及其应用</title>
      <link href="/2022/02/12/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%904.0%E3%80%91%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2022/02/12/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%904.0%E3%80%91%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>循环是程序的一种基本结构，它可以解决很多有用的问题，特别是那些重复性有规律的事情。</p><h1 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a><code>while</code>循环语句</h1><p><code>while</code>循环语句的语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)&#123;</span><br><span class="line">    语句系列;<span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>while</code>语句的执行过程是：根据表达式判断，如果为真，则执行循环体，一直执行循环体，直到<code>break;</code>才会跳出循环</strong>。</p><blockquote><p>需要注意的是，<code>while</code>是在循环前，先判断</p></blockquote><p>【实例】求 $n!$。</p><p>【代码示例1】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要求的阶乘：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    sum = n;</span><br><span class="line">    <span class="keyword">if</span> (n&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (n&gt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum *= (n<span class="number">-1</span>);</span><br><span class="line">                n = n - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;阶乘的结果为： %ld&quot;</span>,sum);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;阶乘的结果为：1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的数值非法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【示例代码2】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> s;</span><br><span class="line">    s = <span class="number">1</span>;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要求的阶乘：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        s *= i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d的阶乘结果为：%ld&quot;</span>, n, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出1】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb8e0e3c9e.png" alt="image-20220112000315699" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb8e4badac.png" alt="image-20220112000419537" style="zoom:80%;" /><p>【输出2】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb8e8193d7.png" alt="image-20220112000533569" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb8e4badac.png" alt="image-20220112000419537" style="zoom:80%;" /><h1 id="do-while循环语句"><a href="#do-while循环语句" class="headerlink" title="do-while循环语句"></a><code>do-while</code>循环语句</h1><p>在<code>while</code>语句中，是在执行循环体之前进行循环条件判断的。因此，在有的时候，需要在循环体执行后进行判断，也就是说循环体的语句无论什么条件下都至少要执行一次。为了方便这种情况，C语言提供了<code>do-while</code>语句，语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span> (表达式);</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb8ef4cc62.png" alt="image-20220112141915117" style="zoom:67%;" /><p>该语句的执行过程为：执行循环体结束，判断表达式，如果为真，则继续执行循环体，反之则跳出循环体。</p><p>【实例】求$1+2+3+4+······+100$，即$\sum\limits_{i &#x3D; 1}^{100}i$。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum += k;</span><br><span class="line">        k++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (k&lt;=<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;和为：%d&quot;</span>,sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb8f45f89b.png" alt="image-20220112142526030" style="zoom: 80%;" /></p><h1 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a><code>for</code>循环语句</h1><p><strong>对循环状态的初始化和对循环控制变量的修改，是循环语句中不可缺少的两个组成部分。为了便于描述，阅读和检查，C语言提供了与<code>while</code>语句和<code>do-while</code>语句功能相似的<code>for</code>语句。</strong><code>for</code>语句是控制循环语句最广泛的一种循环控制语句。其功能是某段程序代码执行若干次，特别适合已知循环次数的情况。其语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>表达式1常为赋值表达式，用来确定循环结构中的控制循环次数的变量的初始值，实现循环控制变量的初始化。</li><li>表达式2常为关系表达式或者逻辑表达式，用来判断循环是否继续执行，通常将循环控制变量与某一值进行比较来判断是否继续执行循环体。</li><li>表达式3为表达式语句，用来描述控制变量的变化，常为自增或者自减表达式。</li></ul><p>【实例】输入10个整数，求这10个整数的和。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个整数：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;和为：%d&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><p><code>for</code>循环中的表达式1，表达式2，表达式3都是选择项，即可以缺省，但分号<code>;</code>不可以缺省。</p></li><li><p>省略表达式1，表示不对循环控制变量赋初值。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;表达式<span class="number">1</span>；表达式<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>实际上表达式1可以写在for语句结构的外面。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">20</span>;<span class="keyword">for</span>(;表达式<span class="number">1</span>;表达式<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>一般使用这种格式的原因是：循环控制变量的初值不是已知常量值，而是需要通过前面的语句执行计算得到。</p></li><li><p>省略表达式2，表示不用判断循环条件是否成立，循环条件总是满足的。此时如果不做其他处理时，则为死循环，类似于<code>while(1)</code>的效果。</p></li><li><p>省略表达式3，可以在循环体中进行控制。</p></li><li><p>省略三个表达式，可以使用<code>break;</code>来控制跳出循环。</p></li><li><p><code>for</code>语句的循环体可以是空语句，表示当循环满足时空操作。一般用于延时处理，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++);</span><br></pre></td></tr></table></figure><p>表示循环空循环了10000次，占用一定的时间，起到了延时效果。</p></li><li><p>在<code>for</code>语句中，表达式1和表达式3都可以是一项或者多项。相当于多一项，各项之间用<code>,</code>隔开。</p></li></ol><blockquote><p><code>for</code>结构不是狭义上的计数式循环，是广义上的循环结构。</p></blockquote><p>【实例】猴子吃桃问题，猴子第一天摘下若干桃子，当即吃了一半，还不过瘾，又多吃了一个，第二天早上又将剩下的桃子吃了一半，又多吃了一个。以后每天早上都这么吃，直到第10天早上只剩下1个桃子，求第一天共摘了多少桃子？</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        sum *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;和为：%d&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb8fd044b7.png" alt="image-20220112152758146" style="zoom:80%;" /><h1 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h1><p><strong>一个循环语句中包含另一个完整的循环结构，称为循环的嵌套。</strong>嵌套在内的称为内循环，嵌套内循环的循环称为外循环。理论上循环的嵌套是无限的。</p><p>对于双重循环来说，内层循环的执行次数为：内层次数 $\times$ 外层次数。</p><p>【实例】输出十行星号（<code>*</code>）半金字塔形</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb9007d7b5.png" alt="image-20220112162331985" style="zoom:80%;" /><h1 id="break语句和continue语句"><a href="#break语句和continue语句" class="headerlink" title="break语句和continue语句"></a><code>break</code>语句和<code>continue</code>语句</h1><p>在循环结构的循环体中，可以使用<code>break</code>语句和<code>continue</code>语句来控制循环的流程。<strong>其中<code>break</code>语句的功能是从循环体中退出，提前结束循环；<code>continue</code>语句的功能则是终止本次循环，跳出本次循环体中剩余未执行的语句，转向下一次循环是否执行的循环条件判断</strong>。</p><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a><code>break</code>语句</h2><p><code>break</code>语句的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>break</code>语句只能出现在<code>switch</code>语句或者循环语句的循环体中</p></blockquote><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a><code>continue</code>语句</h2><p><code>continue</code>语句格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><code>continue</code>语句只能出现在<code>while</code>，<code>do-while</code>和<code>for</code>循环语句的循环体中。</li></ol><h1 id="goto语句和标号"><a href="#goto语句和标号" class="headerlink" title="goto语句和标号"></a><code>goto</code>语句和标号</h1><p><code>goto</code>语句是无条件转移语句。其功能是改变程序控制的流程，无条件地将控制转移到语句标号所在处。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> 语句标号;</span><br></pre></td></tr></table></figure><p>其中：**语句标号用标识符来命名，当它放在某个语句行前面做该语句行的标识时，它的后面需要有冒号<code>:</code>**。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error:语句;</span><br></pre></td></tr></table></figure><p>在C语言中，语句标号通常与<code>goto</code>语句配合使用，表示无条件跳转到语句标号指定的语句位置。<strong>在程序中，标号必须与<code>goto</code>语句处于同一个函数中，但可以不在同一个循环层中</strong>。</p><p><code>goto</code>语句不常用，主要是因为大量使用它会破坏程序的结构化，使程序的流程混乱，可读性降低。</p><p>【实例】求$1+2+3+4+······+100$，即$\sum\limits_{i &#x3D; 1}^{100}i$。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    loop:<span class="keyword">if</span> (i&lt;=<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;和为:%d&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb8f45f89b.png" alt="image-20220112142526030" style="zoom: 80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【3.0】C-选择结构及其应用</title>
      <link href="/2022/02/11/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%903.0%E3%80%91%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2022/02/11/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%903.0%E3%80%91%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分东西不多，相对简单，快速上手，通俗易懂。</p><h1 id="关系运算符和关系表达式"><a href="#关系运算符和关系表达式" class="headerlink" title="关系运算符和关系表达式"></a>关系运算符和关系表达式</h1><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>在程序中经常需要比较两个量的大小关系，以决定程序的下一步进行的工作。比较两个量的运算符称为关系运算符。通俗来讲，也就是比较运算，即将两个操作数比较并产生运算结构0（假）或1（真）。C语言提供的关系运算符有6种，例如：</p><table><thead><tr><th align="left">运算符</th><th>功能</th></tr></thead><tbody><tr><td align="left">&lt;</td><td>小于</td></tr><tr><td align="left">&lt;&#x3D;</td><td>小于或等于</td></tr><tr><td align="left">&gt;</td><td>大于</td></tr><tr><td align="left">&gt;&#x3D;</td><td>大于或等于</td></tr><tr><td align="left">&#x3D;&#x3D;</td><td>等于</td></tr><tr><td align="left">!&#x3D;</td><td>不等于</td></tr></tbody></table><p>说明：</p><ol><li>C语言中的关系运算符与数学中的（&gt;,&gt;&#x3D;等）不一样。</li><li>以上6种关系运算符中，前4种（&lt;,&lt;&#x3D;,&gt;,&gt;&#x3D;）的优先级相同，后两种(&#x3D;&#x3D;,!&#x3D;)的优先级相同，前4种优先级高于后两种。</li><li>关系运算符的结合性为从左到右。</li></ol><h2 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h2><p>关系表达式是指用关系运算符将两个数（或者表达式）连接起来进行关系运算的式子，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>&lt;<span class="number">2</span>;</span><br><span class="line">a&gt;b;</span><br><span class="line">a&lt;a+b;</span><br></pre></td></tr></table></figure><p><strong>关系表达式的结果是逻辑值，即真值或者假值，其中1为真，0为假，真值表示关系表达式表示关系成立，反之则不成立</strong>。</p><h2 id="优先级和结合性"><a href="#优先级和结合性" class="headerlink" title="优先级和结合性"></a>优先级和结合性</h2><p>关系运算符的结合性都是自左向右的。</p><blockquote><p>注意运算符的优先级</p></blockquote><h1 id="逻辑运算符和逻辑表达式"><a href="#逻辑运算符和逻辑表达式" class="headerlink" title="逻辑运算符和逻辑表达式"></a>逻辑运算符和逻辑表达式</h1><p>C语言中，对参与逻辑运算的所以数值，都转化为逻辑“真”或“假”后才参与逻辑运算，<strong>如果参与逻辑运算的数值为0，则把它作为逻辑“假”处理，而所有非0的数值都作为逻辑“真”处理</strong>。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><strong>C语言中有3种逻辑运算符：逻辑与（和）（&amp;&amp;），逻辑或（||），逻辑非（！）</strong>，详细如下表：</p><table><thead><tr><th>运算符</th><th>功能</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与（和），双目运算符，左右两数为“真”则为真，反之为“假”</td></tr><tr><td>||</td><td>或，双目运算符，左右都为“假”则为假，反之为“真”</td></tr><tr><td>！</td><td>非，单目运算符，对操作符取反</td></tr></tbody></table><h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><p>逻辑表达式是由逻辑运算符将逻辑量连接起来构成的式子。对象可以是任何类型的数据，但<strong>运算结果一定是整型值，并且只有两个值：1和0，分别表示真和假</strong>。</p><p>说明：</p><ol><li>对于<code>a&amp;&amp;b</code>，只有<code>a</code>的值为真时，才需要判断<code>b</code>的值。</li><li>对于<code>a||b</code>，只有<code>a</code>的值为真时，才不需要判断<code>b</code>的值。</li><li>对于$2&lt;a&lt;3$这类表达式，C语言中的实现为<code>(a&gt;2)&amp;&amp;(a&lt;3)</code>。</li></ol><h2 id="优先级和结合性-1"><a href="#优先级和结合性-1" class="headerlink" title="优先级和结合性"></a>优先级和结合性</h2><p>三种运算符的优先级由高到低依次为：<code>!</code>，<code>&amp;&amp;</code>，<code>||</code>。</p><p>逻辑运算符中的<code>&amp;&amp;</code>和<code>||</code>的结合性为从左向右，<code>!</code>的结合性为从右向左。</p><p>【实例】逻辑运算符的应用</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    a = <span class="number">12</span>;</span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a与b的结果为 %d\n&quot;</span>, a &amp;&amp; b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a与b的结果为 %d\n&quot;</span>, a || b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b取反的结果为 %d&quot;</span>, !b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出结果】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb88e9891e.png" alt="image-20220107202757950" style="zoom:80%;" /></p><h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><code>if</code>语句</h1><p><strong><code>if</code>语句是条件选择语句，它先对给定条件进行判断，根据判定的结果（真或假）决定要执行的语句。<code>if</code>语句有<code>if</code>分支，<code>if-else</code>分支和嵌套的<code>if</code>语句3种形式</strong>。</p><h2 id="if分支"><a href="#if分支" class="headerlink" title="if分支"></a><code>if</code>分支</h2><p><code>if</code>分支是最简单的条件语句，<code>if</code>分支语句的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)</span><br><span class="line">    语句<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>其中，表达式一般为逻辑语句或者关系表达式。语句1可以是一条简单的居于或者多条语句，<strong>当为多条语句时，需要用大括号<code>&#123;&#125;</code>，将这些语句括起来，构成复合语句</strong>。<br><code>if</code>分支语句的执行过程是：当表达式值为真（非0）时，会执行语句1，反之则不执行。</p><p>【实例】从键盘输入一个整数，如果输入的是2的倍数，则显示“成功”，反之则不显示<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);    <span class="comment">//获取输入</span></span><br><span class="line">    <span class="keyword">if</span> (a%<span class="number">2</span>==<span class="number">0</span>)     <span class="comment">//取余判断</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功&quot;</span>);     <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出结果】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb892c4f37.png" alt="image-20220107212112534" style="zoom:80%;" /></p><h2 id="if-else分支"><a href="#if-else分支" class="headerlink" title="if-else分支"></a><code>if-else</code>分支</h2><p><code>if</code>分支语句只允许在条件为真时指定要执行的语句，而<code>if-else</code>分支还可以在条件为假时指定要执行的语句。<code>if-else</code>分支语句的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    语句<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>还是上面2的整数的例子，稍微改进一下，如果不是2的倍数，则输出“不是2的倍数”。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);    <span class="comment">//获取输入</span></span><br><span class="line">    <span class="keyword">if</span> (a%<span class="number">2</span>==<span class="number">0</span>)     <span class="comment">//取余判断</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d是2的倍数&quot;</span>,a);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d不是2的倍数&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb896a0ba9.png" alt="image-20220107212335429" style="zoom:80%;" /></p><p>【实例】输入三个值，如果三个值均大于0且符合任意两个之和大于第三个，则计算以这三个值为边的三角形面的结果。<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a, b, c;    <span class="comment">//定义三边长</span></span><br><span class="line">    <span class="type">double</span> s;   <span class="comment">//定义面积</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="keyword">if</span> (a+b&gt;c &amp;&amp; a+c&gt;b &amp;&amp; b+c&gt;a &amp;&amp; a&gt;<span class="number">0</span> &amp;&amp; b&gt;<span class="number">0</span> &amp;&amp; c&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = <span class="built_in">sqrt</span>(( a + b + c )*(a + b - c)*(a + c - b)*(b + c - a))/<span class="number">4</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;三角形的面积为%f&quot;</span>, s);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出错啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出结果】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb89a9a720.png" alt="image-20220107214623210" style="zoom:80%;" /></p><blockquote><p>已知三边，求三角形面积参考 <a href="httpss://baike.baidu.com/item/%E6%B5%B7%E4%BC%A6%E5%85%AC%E5%BC%8F/106956?fr=aladdin">海伦公式</a></p></blockquote><h2 id="嵌套的if语句"><a href="#嵌套的if语句" class="headerlink" title="嵌套的if语句"></a>嵌套的<code>if</code>语句</h2><p>简单的<code>if</code>语句只能通过给定条件的判断执行两种操作，而不能多种操作中选择一个，此时嵌套的<code>if</code>语句解决了这个问题。**<code>if</code>语句中又包含一个或者多个<code>if</code>语句时，称为<code>if</code>语句的嵌套**。<br>常用的<code>if</code>语句嵌套有以下两种形式：</p><ul><li><p>形式一，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)</span><br><span class="line">    <span class="keyword">if</span>(表达式)</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span>(表达式)</span><br><span class="line">        语句<span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        语句<span class="number">4</span>;</span><br></pre></td></tr></table></figure></li><li><p>形式二，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">2</span>)</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">3</span>)</span><br><span class="line">    语句<span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式n)</span><br><span class="line">    语句n;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    语句n+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>【实例】将学生成绩按分数输出 A B C D E 等级<br>【补充】成绩对照关系表</p><table><thead><tr><th>百分制</th><th>等级</th></tr></thead><tbody><tr><td>90$\leq$score$\leq$100</td><td>A</td></tr><tr><td>80$\leq$score$&lt;$90</td><td>B</td></tr><tr><td>70$\leq$score$&lt;$80</td><td>C</td></tr><tr><td>60$\leq$score$&lt;$70</td><td>D</td></tr><tr><td>0$\leq$score$&lt;$60</td><td>E</td></tr></tbody></table><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> score;  <span class="comment">//定义分数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入分数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score);    <span class="comment">//获取输入的分数</span></span><br><span class="line">    <span class="keyword">if</span> (score&gt;<span class="number">100</span> || score &lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的成绩不合法&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &lt;=<span class="number">100</span> &amp;&amp; score&gt;=<span class="number">90</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该同学的成绩等级为 A&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">90</span> &amp;&amp; score &gt;=<span class="number">80</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该同学的成绩等级为 B&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">80</span> &amp;&amp; score &gt;=<span class="number">70</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该同学的成绩等级为 C&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">70</span> &amp;&amp; score &gt;=<span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该同学的成绩等级为 D&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该同学的成绩等级为 E&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出结果】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb8a004ad4.png" alt="image-20220107221041613" style="zoom:80%;" /></p></li></ul><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a><code>switch</code>语句</h2><p>对于常规的两种选择可以使用<code>if-else</code>语句，那么对于两种及以上的多种选择则需要<code>switch</code>语句的帮助了。当然你也可以通过使用嵌套的<code>if-else</code>语句来实现多种选择。</p><p><code>switch</code>语句的一般格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">    语句系列<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量表达式<span class="number">2</span>:</span><br><span class="line">    语句系列<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//default可以为空    </span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【实例】在键盘上输入 1<del>7 实现输出对应的星期几，如果输入的值不是 1</del>7，则输出非法数据。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数值：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="keyword">switch</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期天&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的数据非法&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】</p><ol><li><code>break</code>表示跳出当前循环。</li><li><code>case</code>的循序是任意的，也就是说<code>default</code>可以放到最前面或者任意一个位置。</li></ol><h2 id="条件运算符和条件表达式"><a href="#条件运算符和条件表达式" class="headerlink" title="条件运算符和条件表达式"></a>条件运算符和条件表达式</h2><p><strong>条件运算符很特殊，它是C语言中唯一一个三目运算符</strong>，也就是说，<strong>它要求要有三个运算对象</strong>。条件表达式的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表达式<span class="number">1</span> ? 表达式<span class="number">2</span> : 表达式<span class="number">3</span> ;</span><br></pre></td></tr></table></figure><p><strong>条件表达式的执行过程：如果表达式1的值为真，则执行表达式2，反之则执行表达式3</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=a&gt;b?a:b;</span><br></pre></td></tr></table></figure><p>若a大于b，则c的值由a赋值，反之，则c的值由b赋值。</p><blockquote><p>比较两个数最大值可以使用该方法</p></blockquote><p>说明：</p><ol><li><p>条件运算符的优先级低于算术运算符，关系运算符以及逻辑运算符，<strong>仅高于赋值运算符和逗号运算符</strong>。</p></li><li><p><strong>条件运算符的结合性为从左到右</strong>，当有条件运算符镶嵌时，按照从右到左的顺序依次运算。</p></li><li><p>条件表达式中三个表达式的类型可以不同，其中表达式1表示条件，只能是0或者非0的结果；当表达式2和表达式3的类型不同时，<strong>条件表达式值的类型为两者中较高的类型（可以参考自动类型转换阶级）</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">a&lt;b?<span class="number">3</span>:<span class="number">4.0</span>;</span><br></pre></td></tr></table></figure><p>该例子的值为 3.0 而不是整型数 3 。</p></li></ol><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>【实例】经典问题，对于输入的年份，计算该年份是否为闰年。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入年份：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;year);</span><br><span class="line">    <span class="keyword">if</span> (year%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (year%<span class="number">100</span> !=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d 为闰年&quot;</span>, year);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (year%<span class="number">400</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d 为闰年&quot;</span>, year);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d 不是闰年&quot;</span>, year);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d 不是闰年&quot;</span>, year);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】闰年判断规则：</p><ol><li>能被4整除且不能被100整除。</li><li>世纪年能被400整除的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【7.1】查找</title>
      <link href="/2022/02/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%907.1%E3%80%91%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/02/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%907.1%E3%80%91%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>查找表：是一种数据集合（记录），可以理解为你要从哪里查找</p><p>查找表可以分为<strong>静态查找</strong>表和<strong>动态查找表</strong></p><ul><li>静态查找：只需要执行查找操作</li><li>动态查找：除了查找之外还需要增&#x2F;删除数据元素</li></ul><h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>顺序查找是我们最开始，也是最熟悉的查找方式，就是一个一个查找（遍历）。</p><h2 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h2><p><strong>顺序查找又称“线性查找”，通常用于线性表</strong>。其查找模式是线性的。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sTable</span>&#123;</span></span><br><span class="line">ElemType a[MaxSize];</span><br><span class="line"><span class="type">int</span> TableLen;</span><br><span class="line">&#125;STable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Serach_Seq</span><span class="params">(STable s,ElemType data)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.TableLen; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (data == s.a[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;下标为:%d&quot;</span>, i);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>哨兵模式查找还是顺序查找，<strong>不过它将数组的 0 号元素空出来填充为需要查找的元素，查找方向改为从后向前查找</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序查找——哨兵模式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Serach_Seq2</span><span class="params">(STable s, ElemType data)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = s.TableLen; data != s.a[i]; i--);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h1><p>折半查找就是我们常说的<strong>二分查找</strong>，<strong>它只适用于有序的顺序表</strong>。</p><p>二分查找需要借助最高位和最低位的指针，每次根据<code>low+high/2</code>结果向下取整，根据和<code>mid</code>指针指向的值大小比较，获取区间，依次比较到最后。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5a5c4ddd.png" alt="image-20220901082019481" style="zoom: 67%;" /><p>当比较到最后的时候，如下图所示，<strong>当<code>low</code>指针超过<code>high</code>指针的时候表示查找失败</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5a97e5b5.png" alt="image-20220901082556151" style="zoom: 67%;" /><p>其代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">ElemType num;</span><br><span class="line">ElemType data[Maxsize];</span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找——递归查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Serach</span><span class="params">(List l,ElemType sdata,<span class="type">int</span> low,<span class="type">int</span> high)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (high + low) / <span class="number">2</span>;<span class="comment">//折半</span></span><br><span class="line"><span class="keyword">if</span> (sdata&gt;l.data[mid])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Binary_Serach(l, sdata, mid + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sdata&lt; l.data[mid])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Binary_Serach(l, sdata, low, mid - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">List l;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">l.data[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">l.num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;其位置为: %d&quot;</span>, Binary_Serach(l,<span class="number">3</span>,<span class="number">0</span>,<span class="number">9</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上是通过递归实现的二叉查找，由于递归的效率相对较低，如下使用迭代来实现二叉查找：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉查找——迭代</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search2</span><span class="params">(List l,ElemType sdata)</span> &#123;</span><br><span class="line"><span class="type">int</span> low = <span class="number">0</span>, high = l.num - <span class="number">1</span>, mid;</span><br><span class="line"><span class="keyword">while</span> (low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">mid = (high + low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (sdata &lt; l.data[mid])</span><br><span class="line">&#123;</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sdata &gt; l.data[mid])</span><br><span class="line">&#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h1><p>分块查找查找思想如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5c04e04c.png" alt="image-20220903085157039" style="zoom:67%;" /><p>通过将数据分块划分大小，先判断数据区间，然后再到指定的数据区间进行顺序查找。</p><h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><p>二叉排序树是利用了二叉树的结构，通过根节点来区分排序数据，如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5c40daf7.png" alt="image-20220903085942168" style="zoom: 80%;" /><p>其结构特点：<strong>左子树结点 &lt; 根节点值 &lt; 右子树结点值</strong></p><blockquote><p>前排提醒：二叉排序树的代码基础是在<a href="httpss://www.helloseraphine.top/2022/08/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%905-1%E3%80%91%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">【5.1】树与二叉树</a>的基础上编写的</p></blockquote><h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><p>采用<strong>迭代搜索</strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉排序树——迭代搜索</span></span><br><span class="line">TreeNode* <span class="title function_">BST_Serach</span><span class="params">(Tree t,<span class="type">int</span> sdata)</span> &#123;</span><br><span class="line">TreeNode* tempnode = t;</span><br><span class="line"><span class="keyword">while</span> (tempnode != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sdata &lt; tempnode-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">tempnode = tempnode-&gt;lchild;<span class="comment">//小于往左走</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sdata &gt;tempnode-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">tempnode = tempnode-&gt;rchild;<span class="comment">//大于往右走</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> tempnode;<span class="comment">//找到了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用<strong>递归搜索</strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉排序树——递归搜索</span></span><br><span class="line">TreeNode* <span class="title function_">BST_Serach2</span><span class="params">(TreeNode* t, <span class="type">int</span> sdata)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (t!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sdata &lt;t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Serach2(t-&gt;lchild, sdata);<span class="comment">//小于往左走</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sdata &gt;t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Serach2(t-&gt;rchild, sdata);<span class="comment">//大于往右走</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>当插入的值相同时则不允许插入，反之则类似于搜索，找到对应的位置插入。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树插入——迭代插入</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BST_Insert</span><span class="params">(Tree* t, <span class="type">int</span> sdata)</span> &#123;</span><br><span class="line">TreeNode* tempnode = (*t);</span><br><span class="line">TreeNode* front = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (tempnode != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">front = tempnode;</span><br><span class="line"><span class="keyword">if</span> (sdata &lt; tempnode-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">tempnode = tempnode-&gt;lchild;<span class="comment">//小于往左走</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sdata &gt; tempnode-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">tempnode = tempnode-&gt;rchild;<span class="comment">//大于往右走</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入失败：已存在结点\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> tempnode;<span class="comment">//找到了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tempnode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">tempnode-&gt;data = sdata;</span><br><span class="line">tempnode-&gt;lchild = tempnode-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (sdata&lt; front-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">front-&gt;lchild = tempnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">front-&gt;rchild = tempnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入成功\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> tempnode;<span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>二叉树的删除还要保证其二叉排序树的特性，则有三种情况：</p><ul><li><strong>删除的是叶子结点</strong>：直接删除即可</li><li><strong>删除的结点只有左子树或者右子树</strong>：删除结点，然后让其子树替代它的位置即可</li><li><strong>删除的结点存在左右子树</strong><ul><li>选择将右子树的最小值（即删除节点右子结点的左结点）作为删除结点的新结点。</li><li>也可以选择将左子树的最大值（即删除节点左子树的左结点）作为删除结点的新结点</li></ul></li></ul><p>代码示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树删除</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(Tree* t,<span class="type">int</span> ddata)</span> &#123;</span><br><span class="line">TreeNode* delnode = (*t);<span class="comment">//要删除的结点</span></span><br><span class="line">TreeNode* delnodeF = <span class="literal">NULL</span>;<span class="comment">//要删除的结点的父结点</span></span><br><span class="line">TreeNode* newnode = <span class="literal">NULL</span>;<span class="comment">//要替换删除的结点</span></span><br><span class="line">TreeNode* newnodeF = <span class="literal">NULL</span>;<span class="comment">//要替换删除的结点的父结点</span></span><br><span class="line"><span class="keyword">while</span> (delnode !=<span class="literal">NULL</span> &amp;&amp; delnode-&gt;data!=ddata)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ddata &lt; delnode-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">delnodeF = delnode;<span class="comment">//获取其父结点</span></span><br><span class="line">delnode = delnode-&gt;lchild;<span class="comment">//小于往左走</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ddata &gt; delnode-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">delnodeF = delnode;<span class="comment">//获取其父结点</span></span><br><span class="line">delnode = delnode-&gt;rchild;<span class="comment">//大于往右走</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要删除的结点没找到</span></span><br><span class="line"><span class="keyword">if</span> (delnode ==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;未查找到要删除的结点\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要删除的结点存在左右子树</span></span><br><span class="line"><span class="keyword">if</span> (delnode-&gt;lchild!=<span class="literal">NULL</span> &amp;&amp; delnode-&gt;rchild !=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">newnodeF = delnode-&gt;rchild;<span class="comment">//让要替换删除结点的结点的父结点是删除结点的右孩子，因为我要用右子树的最小值替换删除结点</span></span><br><span class="line">newnode = newnodeF-&gt;lchild;<span class="comment">//暂时设定要替换删除的结点</span></span><br><span class="line"><span class="keyword">while</span> (newnode-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">newnodeF = newnode;<span class="comment">//获取其父结点</span></span><br><span class="line">newnode = newnode-&gt;lchild;<span class="comment">//一直往左走，直到最后一个</span></span><br><span class="line">&#125;</span><br><span class="line">delnode-&gt;data = newnode-&gt;data;<span class="comment">//新结点替换要删除的结点</span></span><br><span class="line">newnodeF-&gt;lchild = newnode-&gt;rchild;<span class="comment">//要替换结点的父结点的左指针指向替换结点的右指针</span></span><br><span class="line"><span class="built_in">free</span>(newnode);<span class="comment">//释放结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反之则要删除的结点要么是叶子结点要么存在一个子树</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果要删除的结点左子树为空</span></span><br><span class="line"><span class="keyword">if</span> (delnode-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (delnodeF-&gt;lchild==delnode)</span><br><span class="line">&#123;</span><br><span class="line">delnodeF-&gt;lchild = delnode-&gt;lchild;<span class="comment">//左子树成为替换的结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">delnodeF-&gt;rchild = delnode-&gt;lchild;<span class="comment">//左子树成为替换的结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (delnodeF-&gt;lchild == delnode)</span><br><span class="line">&#123;</span><br><span class="line">delnodeF-&gt;lchild = delnode-&gt;rchild;<span class="comment">//左子树成为替换的结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">delnodeF-&gt;rchild = delnode-&gt;rchild;<span class="comment">//左子树成为替换的结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(delnode);<span class="comment">//释放结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除结点成功\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h1><p>二叉平衡树是在二叉排序树的基础上做了一些改动，这些改动确保了二叉平衡树是“平衡”的，类似于最优哈夫曼树，其规定了：<strong>树上任一结点的左子树和右子树的高度之差不超过1</strong>如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5cad5b08.png" alt="image-20220904081205438" style="zoom:80%;" /><p><strong>结点的平衡因子 &#x3D; 左子树高 - 右子树高</strong></p><h2 id="插入操作-1"><a href="#插入操作-1" class="headerlink" title="插入操作"></a>插入操作</h2><p>当我们对二叉平衡树做插入操作时，有概率将破坏平衡二叉树的平衡性，例如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5ce8ad6a.png" alt="image-20220904083034248" style="zoom:80%;" /><p>我们<strong>通过对最小二叉不平衡树进行调整就可以达到二叉平衡树的结果</strong>。</p><p>根据插入位置的不同而引起的“不平衡”，可以分为：</p><ul><li><strong>LL</strong>：新元素插在了某节点左孩子的左子树中</li><li><strong>RR</strong>：新元素插在了某节点右孩子的右子树中</li><li><strong>LR</strong>：新元素插在了某节点左孩子的右子树中</li><li><strong>RL</strong>：新元素插在了某节点右孩子的左子树中</li></ul><p>其上各种情况的调整方法如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5d28a9c7.png" alt="image-20220904083519069" style="zoom:80%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><p>我个人认为可以通过<strong>将二叉树的数据进行排序，再组织二叉平衡树的方法会更加简单</strong>，或者说有规律。</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><blockquote><p>408 难民课程（🤣）</p></blockquote><p>红黑树也是一种二叉排序树的优化，它的诞生是<strong>由于对平衡二叉树的插入和删除很容易被破坏其平衡性</strong>，以至于不得不计算其平衡因子，来使其达到平衡，这样就<strong>导致了在插入和删除操作就需要耗费大量的时间开销</strong>。而<strong>对于红黑树来收，插入和删除很多时候不会破坏“红黑”特性</strong>，<strong>无需频繁调整；即使需要调整，也可以在常数级时间内完成</strong>。</p><p><strong>红黑树的特性：</strong></p><ul><li><strong>左子树结点值 $\leqslant$  根节点的值 $\leqslant$ 右子树结点值</strong></li><li><strong>每个结点或是红色，或是黑色</strong></li><li><strong>根节点是黑色的</strong></li><li><strong>叶结点（外部结点，NULL结点，失败结点）均是黑色的</strong></li><li><strong>不存在两个相邻的红结点（即红结点的父结点和孩子结点均是黑色）</strong></li><li><strong>对于每个结点，从该结点到任一叶结点的简单路径上，所含黑结点数目相同</strong></li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5d72c0f5.png" alt="image-20220904094302945" style="zoom:67%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><p>其结构体实现如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RBnode</span> &#123;</span></span><br><span class="line">ElemType key;<span class="comment">//数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RBnode</span>* <span class="title">parent</span>;</span><span class="comment">//父结点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RBnode</span>* <span class="title">lchild</span>;</span><span class="comment">//左孩子指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RBnode</span>* <span class="title">rchild</span>;</span><span class="comment">//右孩子指针</span></span><br><span class="line"><span class="type">int</span> color;<span class="comment">//结点颜色，可用0/1标识</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>结点的黑高：从某结点出发（不含）到达任一空叶结点的路径上黑结点总数</li></ul><p>其性质：</p><ul><li><strong>从根结点到叶结点的最长路径不大于最短路径的 2 倍</strong></li><li><strong>有 n 个内部结点的红黑树高度 $h \leq 2 log_2{(n+1)}$</strong></li></ul><p>红黑树还有最要么的<strong>插入和删除操作</strong>，十分繁琐，自行百度，谷歌查询，或者参考<a href="httpss://www.bilibili.com/video/BV1Pp4y1D7u1">【数据结构】红 黑 树</a> 。</p><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>B 树原理上和二叉排序树类似，例如如下图的 5 叉查找树所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5dc28be7.png" alt="image-20220905080219195" style="zoom: 67%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><p>B 树，又称<strong>多路平衡查找树</strong>，与二叉平衡树不同的是，对于一棵 m 阶 B 树或者为空树，或者满足如下条件：</p><ul><li>树种<strong>每个结点最多有 m 棵子树</strong>，即<strong>至多含有 m-1 个关键字</strong>。</li><li>若根结点不是终端结点，则至少有两颗子树（平衡）。</li><li><strong>除根结点外所有非叶子结点至少有 $\frac{m}{2}$ 棵子树</strong>，即<strong>至少含有 $\frac{m}{2} -1$ 个关键字</strong>（向上取整）</li><li><strong>所有叶子结点都出现在同一层上</strong>，且不携带信息（空结点，或者说失败结点）。</li></ul><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>B+ 树类似于分块查找和 B 树的结合体，如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5e087f6f.png" alt="image-20220905080803627" style="zoom:67%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><p>一颗 m 阶的 B+ 树需要满足如下条件：</p><ul><li>每个分支结点最多有 m 棵子树</li><li>非叶根结点至少有两颗子树，其他分支结点至少有 $\frac{m}{2}$ 棵子树（向上取整）</li><li><strong>结点子树的个数与关键字相等</strong></li><li><strong>所有叶结点包含全部关键字</strong>以及指向相应记录的指针，叶结点中将关键字按大小顺序排序，并且<strong>相邻叶结点按大小顺序相互连接起来</strong></li></ul><h1 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h1><p><strong>散列表（Hash Table），又称哈希表。其特点是：数据元素关键字与其存储地址直接相关</strong>。即通过一个散列函数，将关键字输入，输出其存储地址。</p><p>如果不同关键字，通过散列函数映射到了同一个存储地址，则将这些关键字称为“同义词”。</p><p>其存储地址已经有其他“同义词”存储了，这个情况称为“冲突”。</p><h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>解决冲突的方法之一——<strong>拉链法</strong>。如下图所示，通过取余将数据映射在一个数组范围，而数组通过指针来存储数据，这样发生冲突后，将其链接下去即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5e4ad68c.png" alt="image-20220905082508256" style="zoom:67%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p><strong>开放定址法是指可存放新关键字的空闲地址向它的同义词表项开放，也向非同义词表项开放</strong>。</p><p>需要注意的是：<strong>使用开放定址法做删除操作的时候，需要进行逻辑上的删除</strong>，而不是物理上的删除</p><h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><p><strong>即发生冲突时，每次往后探测相邻的下一个单元是否为空</strong>。</p><p>如下图所示，如果散列映射出现冲突了，则向下寻找空位存放</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5e8ed0cf.png" alt="image-20220905084659096" style="zoom:80%;" /><p>线性探测法很<strong>容易造成同义词，非同义词“聚集（堆积）”现象</strong>，严重影响查找效率。</p><h4 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h4><p>即<strong>当发生冲突的时候，每次寻址存放的时候按照：$d_i &#x3D; 0^2,1^2,-1^2,2^2,-2^2…$</strong> 方式寻址存放。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5ec24b24.png" alt="image-20220905085308600" style="zoom:80%;" /><h4 id="伪随机序列法"><a href="#伪随机序列法" class="headerlink" title="伪随机序列法"></a>伪随机序列法</h4><p>即发生冲突的时候，使用伪随机序列进行寻址存放。</p><h3 id="再散列法"><a href="#再散列法" class="headerlink" title="再散列法"></a>再散列法</h3><p><strong>即如果发生冲突，则对散列值进行二次散列计算</strong>，直到不冲突为止。</p><h2 id="常用散列函数"><a href="#常用散列函数" class="headerlink" title="常用散列函数"></a>常用散列函数</h2><h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p><strong>即对关键字做取模运算，例如：$H(key) &#x3D; key , %  ,p$</strong> 。要求是：</p><ul><li>散列表长度为 m ，<strong>则取一个不大于 m 但是最接近或者等于 m 的质数 p</strong>。</li></ul><h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><p>即<strong>直接使用关键字定位存储地址，或者对关键字做线性函数处理再定位存储地址</strong>。例如：**$H(key) &#x3D; key$ 或者 $H(key) &#x3D; a \times key + b$** 。</p><p>它适合<strong>关键字分布基本连续的情况</strong>。</p><h3 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h3><p><strong>即在关键字中选取数码分布比较均匀的若干位作为散列地址</strong>。例如，在记录手机号的散列映射的时候，大部分的手机号的开头都是不尽相似的，178，176等，这个时候如果选取开头的数码作为散列映射，则会出现大量的映射在同一个存储地址内，这个时候我们可以选择手机号的后四位来映射，会相对映射的均匀一些。</p><h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h4><p><strong>取关键字的平方值的中间几位作为散列地址</strong>。</p><p><strong>这种方法得到的散列地址与关键字每位都有关系</strong>，因此其分布比较均匀，<strong>适用于关键字每位取值不够均匀或者小于散列地址所需的位数</strong>。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>快要结束啦，就剩下排序啦！</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5f0c6bb9.png" alt="image-20220905085637169" style="zoom: 25%;" />]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【8.1】排序</title>
      <link href="/2022/02/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%908.1%E3%80%91%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/02/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%908.1%E3%80%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构的最后一部分了，排序也是在前面的数据结构的基础上来解决实际问题的。</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>排序算法可以根据数据量的大小分为：</p><ul><li>内部排序：数据都在内存中</li><li>外部排序：数据太多，无法全部存放在内存中</li></ul><p>关于下述的各种排序算法是基于如下的方法结构来实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int<span class="comment">//存放的数据类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">//最大数组容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了新的List类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">ElemType data[MaxSize];<span class="comment">//数据数组</span></span><br><span class="line"><span class="type">int</span> num;<span class="comment">//数组的实际大小，即实际存放数据数量</span></span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历输出List</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(List l)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;List数据为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l.num; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, l.data[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建List</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CreatList</span><span class="params">(List* l)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数据：&quot;</span>);</span><br><span class="line"><span class="type">int</span> data, i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;data);</span><br><span class="line"><span class="keyword">while</span> (data!=<span class="number">-999</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i&gt;MaxSize<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;超出最大数组长度\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">l-&gt;data[i] = data;</span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">&#125;</span><br><span class="line">l-&gt;num = i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;List创建完成\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序算法的思想是对于某个要排序的序列，假定第一个元素已经是排完序的序列中，从第二个元素开始扫描，如果第二个元素大于第一个元素（升序），则不移动，反之则第一个和第二个元素交换位置，保证前面的比后面的小，依次类推，直到所有元素排序完成。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序——升序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(List* l)</span> &#123;</span><br><span class="line"><span class="type">int</span> j,temp = <span class="number">0</span>;<span class="comment">//j是移动前指针，temp用来存放正在比较的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; l-&gt;num; i++)</span><br><span class="line">&#123;</span><br><span class="line">j = i<span class="number">-1</span>;</span><br><span class="line">temp = l-&gt;data[i];<span class="comment">//当前扫描到的要排序元素的值</span></span><br><span class="line"><span class="comment">//如果扫描到的值比它前面的值小或者等于</span></span><br><span class="line"><span class="keyword">while</span>(temp &lt; l-&gt;data[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//则将其前面值向后移动一位</span></span><br><span class="line">l-&gt;data[j+<span class="number">1</span>] = l-&gt;data[j];</span><br><span class="line"><span class="comment">//直到前面的值没有比他大的了</span></span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将正在比较的元素放到新的位置</span></span><br><span class="line">l-&gt;data[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">List l;<span class="comment">//声明List</span></span><br><span class="line">CreatList(&amp;l);<span class="comment">//创建List</span></span><br><span class="line">PrintList(l);<span class="comment">//输出List现在的内容（未排序）</span></span><br><span class="line">InsertSort(&amp;l);<span class="comment">//进行插入排序</span></span><br><span class="line">PrintList(l);<span class="comment">//输出排序后的List内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae63774e2d.png" alt="image-20220905110158101" style="zoom:80%;" /><blockquote><p>稳定性：稳定</p></blockquote><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是插入排序的优化版本，它通过引入增量来减少插入排序遍历的次数。如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae63bd9be0.png" alt="image-20220906190855924" style="zoom:80%;" /><p>上图采用增量 4 ，则意味着第一轮将序号 (0,4),(1,5)等每个括号看成一个单独的序列采用插入排序，即增量 4 这轮，排序结果为下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae63fa8e86.png" alt="image-20220906191115941" style="zoom:80%;" /><p><strong>然后再对增量不断做 $d(增量) &#x3D; \frac{d(增量)}{2}$   直到增量为 1，也就是变成了普通的插入排序</strong>。</p><p>其代码实现如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序——升序(递归) inc表示增量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(List* l,<span class="type">int</span> inc)</span> &#123;</span><br><span class="line"><span class="type">int</span> tempdata,j;<span class="comment">//临时数据变量，临时标识</span></span><br><span class="line"><span class="comment">//只要增量大于1就一直执行</span></span><br><span class="line"><span class="keyword">while</span> (inc&gt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l-&gt;num-inc; i++)</span><br><span class="line">&#123;</span><br><span class="line">j = i;</span><br><span class="line">tempdata = l-&gt;data[i + inc];</span><br><span class="line"><span class="comment">//当标识大于0并且后面增量数据小于前面的数据</span></span><br><span class="line"><span class="keyword">while</span> (l-&gt;data[j]&gt; l-&gt;data[j + inc]&amp;&amp; j&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//交换数据</span></span><br><span class="line">l-&gt;data[j + inc] = l-&gt;data[j];</span><br><span class="line">l-&gt;data[j] = tempdata;</span><br><span class="line"><span class="comment">//向前比较到小于0就标识前面同一个增量内的比较完了</span></span><br><span class="line">j = j - inc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">inc = inc / <span class="number">2</span>;<span class="comment">//每次增量减半</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">List l;<span class="comment">//声明List</span></span><br><span class="line">CreatList(&amp;l);<span class="comment">//创建List</span></span><br><span class="line">PrintList(l);<span class="comment">//输出List现在的内容（未排序）</span></span><br><span class="line">ShellSort(&amp;l,<span class="number">4</span>);<span class="comment">//希尔排序</span></span><br><span class="line">PrintList(l);<span class="comment">//输出排序后的List内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae646e2e73.png" alt="image-20220906200537472" style="zoom:80%;" /><blockquote><p>稳定性：不稳定</p></blockquote><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序故名思意，<strong>通过将两个数据两个数据的比较，每次将一个最大&#x2F;最小值“运送”到排序队列的队头，依次“运送”，直到所有的数都被“运送”完成了</strong>；在这个过程中，将一个最大&#x2F;最小值“运送”就类似于冒泡一样，一步一步上升。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序——升序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(List* l)</span> &#123;</span><br><span class="line"><span class="type">int</span> tempdata, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j&lt;l-&gt;num<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l-&gt;num<span class="number">-1</span>; i &gt; j; i--)</span><br><span class="line">&#123;</span><br><span class="line">tempdata = l-&gt;data[i];</span><br><span class="line"><span class="keyword">if</span> (tempdata&lt;l-&gt;data[i<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">l-&gt;data[i] = l-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">l-&gt;data[i - <span class="number">1</span>] = tempdata;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">List l;<span class="comment">//声明List</span></span><br><span class="line">CreatList(&amp;l);<span class="comment">//创建List</span></span><br><span class="line">PrintList(l);<span class="comment">//输出List现在的内容（未排序）</span></span><br><span class="line">BubbleSort(&amp;l);<span class="comment">//冒泡排序</span></span><br><span class="line">PrintList(l);<span class="comment">//输出排序后的List内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae64b9f6ef.png" alt="image-20220906200315949" style="zoom:80%;" /><blockquote><p>稳定性：稳定</p></blockquote><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>快速排序</strong>顾名思义，<strong>是排序算法中最快的排序方式</strong>。</p><p>快速排序通过选择一个基准元素（默认第一个元素），使用两个指针<code>low</code>和<code>high</code>分别指向数组最低位和最高位，分别和基准元素进行比较，向中间靠拢，直到<code>low</code>大于等于<code>high</code>表示一次排序结束。再使用分好的左右两列，再次进行快速排序，最后完成排序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列划分</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(List* l, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line"><span class="type">int</span> tempdata = l-&gt;data[low];<span class="comment">//tempdata作为基准元素</span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; l-&gt;data[high] &gt;= tempdata)</span><br><span class="line">&#123;</span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line">l-&gt;data[low] = l-&gt;data[high];</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; l-&gt;data[low] &lt; tempdata)</span><br><span class="line">&#123;</span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line">l-&gt;data[high] = l-&gt;data[low];</span><br><span class="line">&#125;</span><br><span class="line">l-&gt;data[low] = tempdata;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序——升序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(List* l,<span class="type">int</span> low,<span class="type">int</span> high)</span> &#123;</span><br><span class="line"><span class="type">int</span> pivotops;</span><br><span class="line"><span class="keyword">if</span> (low&lt;high)</span><br><span class="line">&#123;</span><br><span class="line">pivotops = Partition(l, low, high);</span><br><span class="line">QuickSort(l, low, pivotops - <span class="number">1</span>);</span><br><span class="line">QuickSort(l, pivotops + <span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">List l;<span class="comment">//声明List</span></span><br><span class="line">CreatList(&amp;l);<span class="comment">//创建List</span></span><br><span class="line">PrintList(l);<span class="comment">//输出List现在的内容（未排序）</span></span><br><span class="line">QuickSort(&amp;l,<span class="number">0</span>,l.num<span class="number">-1</span>);<span class="comment">//快速排序</span></span><br><span class="line">PrintList(l);<span class="comment">//输出排序后的List内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae650d8454.png" alt="image-20220906213631740" style="zoom:80%;" /><blockquote><p>稳定性：不稳定</p></blockquote><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>简单选择排序，也就是我们最简单常用的排序，即遍历获得最小值存入排序序列，然后再遍历最小值存入，依次反复，直到所有关键字都被排序完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单选择排序——升序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(List* l)</span> &#123;</span><br><span class="line"><span class="type">int</span> tempdata,index, j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l-&gt;num<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">tempdata = l-&gt;data[i];</span><br><span class="line">index = i;</span><br><span class="line">j = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j; j &lt; l-&gt;num; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l-&gt;data[j]&lt;tempdata)</span><br><span class="line">&#123;</span><br><span class="line">tempdata = l-&gt;data[j];</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">l-&gt;data[index] = l-&gt;data[i];</span><br><span class="line">l-&gt;data[i] = tempdata;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">List l;<span class="comment">//声明List</span></span><br><span class="line">CreatList(&amp;l);<span class="comment">//创建List</span></span><br><span class="line">PrintList(l);<span class="comment">//输出List现在的内容（未排序）</span></span><br><span class="line">SelectSort(&amp;l);<span class="comment">//快速排序</span></span><br><span class="line">PrintList(l);<span class="comment">//输出排序后的List内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae654f3c40.png" alt="image-20220906221059999" style="zoom:80%;" /><blockquote><p>稳定性：不稳定</p></blockquote><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>In <a href="httpss://en.wikipedia.org/wiki/Computer_science">computer science</a>, a <strong>heap</strong> is a specialized <a href="httpss://en.wikipedia.org/wiki/Tree_(data_structure)">tree</a>-based <a href="httpss://en.wikipedia.org/wiki/Data_structure">data structure</a> which is essentially an <a href="httpss://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">almost complete</a>[<a href="httpss://en.wikipedia.org/wiki/Heap_(data_structure)#cite_note-1">1]</a> tree that satisfies the <strong>heap property</strong>: in a <em>max heap</em>, for any given <a href="httpss://en.wikipedia.org/wiki/Node_(computer_science)">node</a> C, if P is a parent node of C, then the <em>key</em> (the <em>value</em>) of P is greater than or equal to the key of C. In a <em>min heap</em>, the key of P is less than or equal to the key of C.[<a href="httpss://en.wikipedia.org/wiki/Heap_(data_structure)#cite_note-2">2]</a> The node at the “top” of the heap (with no parents) is called the <em>root</em> node.</p><blockquote><p>内容来源：【Wiki百科】<a href="httpss://en.wikipedia.org/wiki/Heap_(data_structure)">Heap (data structure)</a></p></blockquote><p><strong>堆（Heap）</strong>，<strong>是一种树类型的数据结构</strong>，根据其排序特性可以分为：</p><ul><li><strong>大根堆</strong>：若满足 $L(i) \geq L(2i)$ 且 $L(i) \geq L(2i+1)$ （$1 \leq i \leq \frac{n}{2}$） </li><li><strong>小根堆</strong>：若满足 $L(i) \leq L(2i)$ 且 $L(i) \leq L(2i+1)$ （$1 \leq i \leq \frac{n}{2}$）</li></ul><h3 id="大根堆的建立"><a href="#大根堆的建立" class="headerlink" title="大根堆的建立"></a>大根堆的建立</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae65a24f39.png" alt="image-20220907170111338" style="zoom:80%;" /><p>大根堆的示例如上所示，其代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其存储结构和排序的List是同一个，只是我多给它命名了一个名称用来区分</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">ElemType data[MaxSize];</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">&#125;List,Heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立大根堆（根据传入的List数组再调整大根堆）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatHeap</span><span class="params">(Heap* h)</span> &#123;</span><br><span class="line"><span class="type">int</span> tempdata;<span class="comment">//临时最大值变量位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = (h-&gt;num/<span class="number">2</span>)<span class="number">-1</span>; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">&#123;</span><br><span class="line">tempdata = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//如果存在右子树，判断右子树和左子树哪个大</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span>*i + <span class="number">2</span> &lt;= h-&gt;num<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (h-&gt;data[<span class="number">2</span>*i+<span class="number">1</span>]&lt;h-&gt;data[<span class="number">2</span>*i+<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">tempdata = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根结点小于子结点</span></span><br><span class="line"><span class="keyword">if</span> (h-&gt;data[i]&lt;h-&gt;data[tempdata])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span>*i+<span class="number">2</span>==tempdata)</span><br><span class="line">&#123;</span><br><span class="line">tempdata = h-&gt;data[<span class="number">2</span> * i + <span class="number">2</span>];</span><br><span class="line">h-&gt;data[<span class="number">2</span> * i + <span class="number">2</span>] = h-&gt;data[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tempdata = h-&gt;data[<span class="number">2</span> * i + <span class="number">1</span>];</span><br><span class="line">h-&gt;data[<span class="number">2</span> * i + <span class="number">1</span>] = h-&gt;data[i];</span><br><span class="line">&#125;</span><br><span class="line">h-&gt;data[i] = tempdata;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PrintList(*h);//这行代码实际执行过程不必执行，只是调试的时候查看实时的调整过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>现在利用上面建立好的大根堆来排序，每次将最开始的元素（即大根堆的根）和大根堆最后一个元素互换位置，然后再对更换位置后除了最后一个元素，进行大根堆建立，建立成新的大根堆后，其新的根一定是最大值，也通之前一样，将其换到新大根堆的最后（实际数组的导数第二个），依次类推，直到完成整个大根堆的排序。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序——升序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(Heap* h)</span> &#123;</span><br><span class="line"><span class="type">int</span> tempdata,j=<span class="number">0</span>,num = h-&gt;num<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (j&lt;num)</span><br><span class="line">&#123;</span><br><span class="line">tempdata = h-&gt;data[<span class="number">0</span>];<span class="comment">//获取堆顶值，即最大值</span></span><br><span class="line">h-&gt;data[<span class="number">0</span>] = h-&gt;data[h-&gt;num <span class="number">-1</span>];<span class="comment">//将最后一位元素换到堆顶</span></span><br><span class="line">h-&gt;data[h-&gt;num - <span class="number">1</span>] = tempdata;;<span class="comment">//最大值，即原来堆顶换到最后</span></span><br><span class="line">h-&gt;num--;<span class="comment">//将堆的长度-1</span></span><br><span class="line">CreatHeap(h);<span class="comment">//将置换后的堆重新整理成堆</span></span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">h-&gt;num = j+<span class="number">1</span>;<span class="comment">//最后将堆的实际数量复原，因为后序遍历显示堆排序结果的方法需要使用堆的数量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;堆排序完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">List l;<span class="comment">//声明List</span></span><br><span class="line">CreatList(&amp;l);<span class="comment">//创建List</span></span><br><span class="line">PrintList(l);<span class="comment">//输出List现在的内容（未排序）</span></span><br><span class="line">CreatHeap(&amp;l);<span class="comment">//建立大根堆</span></span><br><span class="line">PrintList(l);<span class="comment">//输出List现在的内容（未排序）</span></span><br><span class="line">HeapSort(&amp;l);<span class="comment">//进行堆排序</span></span><br><span class="line">PrintList(l);<span class="comment">//输出排序后的List内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae65f38db3.png" alt="image-20220907171009211" style="zoom:80%;" /><blockquote><p>稳定性：不稳定</p></blockquote><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>归并排序是可以将多个数组（排序好的）来合并成一个排序的新数组</strong>，根据合并的数组数目可以分为：二路归并，三路归并等，一般情况下我们都以二路归并为默认。<strong>因为归并其递归特性，所以我们在对数组进行排序的时候，可以数组看作又每个单个元素组成的“单个元素数组”，然后对其使用并归排序</strong>，这样就完成了整个并归排序。其过程如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae66329e96.png" alt="image-20220907171530940" style="zoom: 50%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序——升序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(List* l,<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span> &#123;</span><br><span class="line"><span class="type">int</span>* copy[MaxSize];<span class="comment">//创建辅助数组</span></span><br><span class="line"><span class="type">int</span> i, j, k;<span class="comment">//i表示辅助数组的low指针，j表示辅助数组的mid下一个指针即两路合并的第二路开始指针，K表示要将最小的数放在原排序序列的哪里</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l-&gt;num; i++)</span><br><span class="line">&#123;</span><br><span class="line">copy[i] = l-&gt;data[i];<span class="comment">//将要排序的数组复制一份给辅助数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = low,j=mid+<span class="number">1</span>,k=low; i &lt;= mid &amp;&amp; j&lt;=high; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (copy[i]&lt;copy[j])</span><br><span class="line">&#123;</span><br><span class="line">l-&gt;data[k] = copy[i];<span class="comment">//最小值的放回原数组</span></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">l-&gt;data[k] = copy[j];<span class="comment">//最小值的放回原数组</span></span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 如果最后发现两路数组其中剩下一组没有比较完，则按顺序一次放入即可</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line">l-&gt;data[k] = copy[i];</span><br><span class="line">k++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line">l-&gt;data[k] = copy[j];</span><br><span class="line">k++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序——升序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(List* l, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (low + high) / <span class="number">2</span>;<span class="comment">//求Mid值</span></span><br><span class="line">MergeSort(l, low, mid);<span class="comment">//先排序并并归左半边</span></span><br><span class="line">MergeSort(l, mid + <span class="number">1</span>, high);<span class="comment">//再排序并并归右半边</span></span><br><span class="line">Merge(l, low, mid, high);<span class="comment">//最后完成并归</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">List l;<span class="comment">//声明List</span></span><br><span class="line">CreatList(&amp;l);<span class="comment">//创建List</span></span><br><span class="line">PrintList(l);<span class="comment">//输出List现在的内容（未排序）</span></span><br><span class="line">MergeSort(&amp;l, <span class="number">0</span>, l.num);<span class="comment">//并归排序</span></span><br><span class="line">PrintList(l);<span class="comment">//输出List现在的内容（未排序）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae66c3840e.png" alt="image-20220908105037724" style="zoom:80%;" /><blockquote><p>稳定性：稳定</p></blockquote><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>例如下图的序列进行排序，我们可以通过<strong>先进行个位排序，再进行十分位排序，再进行百分位排序，完成最终的排序</strong>。有点迭代的思想，个位的排序可以让其在个位有先后，十分位排序在个位有序的基础上让其十分位有序，然后百分位在个位和十分位有序的基础上，再让百分位有序就完成整个排序。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae67019952.png" alt="image-20220908105411196" style="zoom:80%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><p> 外部排序，是因为<strong>我们有时候处理的数据量太大而导致不可能一次性将其装入内存进行处理，这个时候就要利用内存和外存的交换来完成排序</strong>，这个过程就是外部排序。</p><p>外部排序逻辑如下所示，通过将每一块磁盘块或者说数据块从一块一块开始利用归并排序，排序好一块就写入外存，直到完成整个外存的排序。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae67375873.png" alt="image-20220908145249849" style="zoom: 67%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><h2 id="优化外部排序"><a href="#优化外部排序" class="headerlink" title="优化外部排序"></a>优化外部排序</h2><p>因为归并排序的特性可以知道，<strong>随着开辟的内存缓冲区越多，即归并段同时归并的越多，对磁盘的读写越少，同时就减少了排序时间</strong>。需要注意的是<strong>这个归并段并不是可以无线增大的，因为内存缓冲区开辟的越多，对于内存的开销也就越大</strong>。内存中排序所需要消耗的时间也会增加。如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae67749b1a.png" alt="image-20220908145824801" style="zoom:67%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><p>即优化方向：</p><ul><li><strong>增加归并路数</strong></li><li><strong>减少初始归并段数量</strong></li></ul><h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><p>因为增加归并路数可以一定程度优化排序所消耗的时间，但是带来的问题是：<strong>K路的归并，意味着每次取得最小值&#x2F;最大值就需要进行 $K-1$ 次的对比</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae67b7abcd.png" alt="image-20220908150304017" style="zoom:67%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><p>败者树就是我们常规所理解的比赛的层级方式，通过败者树可以缩短比较关键词的次数，进而缩短排序时间。</p><p>如下图所示，在第一次归并的时候进行 $K-1$ 次归并计算出败者树，在非叶子结点其数值指向归并段的位置，即第一次归并得到其最小值来自归并段3号，其中的第一个元素 1 是最小值，写入排序序列即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae67ec94da.png" alt="image-20220908150632953" style="zoom:67%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><p>接下来，再从归并段冠军中获取下一个元素，进行比较，如下图所示：</p><p>因为第一次的时候就已经得到败者树，所以<strong>新元素只需要根据败者树路径比较即可，不必要和每个元素再次进行比较</strong>，这样可以有限的缩短比较次数。一次类推。知道所有元素比较完成。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae68269077.png" alt="image-20220908150951704" style="zoom:67%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><h3 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h3><p><strong>通过置换置换-选择排序可以利用有限的内存空间，构建更长的归并段</strong>，其实现过程如下：</p><p>如下图，内存只能开辟如下三个数据的空间，通过每次将其中的最小值写入归并段1，并记录其值在变量<code>MiniMax</code>中，然后从外存中将新的数值填充到内存中替代换出去的位置，再从中选择比变量<code>MiniMax</code>大但是又是其中最小的值，并写入归并段，再将变量<code>MiniMax</code>记录为新的值，如此反复。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae686c1f9e.png" alt="image-20220908151443421" style="zoom:67%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><p>直到内存工作区的三个记录值都小于<code>MiniMAX</code>的值，则意味着第一个归并段完成了，再从此记录第二个归并段，一次就可以记录完成所有的排序序列分成长度不等的归并段。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae68a75691.png" alt="image-20220908152020828" style="zoom:67%;" /><h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><p>我们通过置换-选择排序，最终利用有限的内存，获得了不同长度的归并段，如下图，因为长度不同的归并段，每次需要读写磁盘的次数不同，造成其消耗的时间不同，下图中的<code>R1,R2,R3...</code>表示归并段，其结点数据表示读写磁盘次数，<strong>因为结点带有权值，不难想到前面树的部分的哈夫曼树，构建最优带权路径长度，来减少对磁盘的读写，最终减少排序时间</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae68e5a240.png" alt="image-20220908153452400" style="zoom:67%;" /><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>路漫漫其修远兮，所以，开摆！！！</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae692a85f7.png" alt="image-20220908154157719" style="zoom:33%;" />]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【6.1】图</title>
      <link href="/2022/02/01/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%906.1%E3%80%91%E5%9B%BE/"/>
      <url>/2022/02/01/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%906.1%E3%80%91%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>图比较复杂，涉及的算法相对较多。</p><h1 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h1><p>图，就是例如下图的东西，图可以分为</p><ul><li>有向图：即带有明确的方向指向的图，可以使用 $&lt;a,c&gt;$ 表示从 A 到 C 顶点的路径</li><li>无向图：不带有明确的方向指向的图，可以使用 $(a,c)$ 表示从 A 到 C 顶点的路径</li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae4ecb2e67.png" alt="image-20220829004344707" style="zoom:80%;" /><blockquote><p>图注：有向图</p></blockquote><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae4ee3a3e9.png" alt="image-20220829024720161" style="zoom:80%;" /><blockquote><p>图注：无向图</p></blockquote><p>对于图来说，要求边的两端必须存在“顶点”，否则它不是图。同样的，对于图来说，也不存在空图的概念。</p><p>从图的结构来说，又可以分为：<strong>简单图</strong>和<strong>多重图</strong>。</p><ul><li>简单图<ol><li>不存在重复边</li><li>不存在顶点到自身的边</li></ol></li><li>多重图<ol><li>允许重复边</li><li>允许存在顶点到自身的边</li></ol></li></ul><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><ul><li><p>图的阶：图里面的顶点（或者叫结点）个数</p></li><li><p><strong>顶点的度</strong></p><ul><li>无向图：顶点的边数</li><li>有向图：入度 + 出度<ul><li>出度：从顶点指向外面顶点的边</li><li>入度：指向顶点的边</li></ul></li></ul></li><li><p><strong>路径：两个顶点之间的顶点序列</strong>，例如下图：A 到 B 的路径为：A,C,B</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae4f34770b.png" alt="image-20220829025426751" style="zoom:80%;" /></li><li><p>回路：第一个顶点和最后一个顶点相同的路径</p></li><li><p><strong>简单路径</strong>：在路径序列中，顶点不重复出现的路径</p></li><li><p>简单回路：除了第一个顶点和最后一个顶点外，其余顶点不出现重复的回路</p></li><li><p><strong>路径长度：路径上边的数目</strong></p></li><li><p><strong>点到点的距离</strong>：从顶到到另一个顶点的<strong>最短路径</strong>作为距离，如果不存在最短路径，则认为两点不存在路径，记作 $\infty$ </p></li><li><p>连通：在无向图中，顶点和顶点间存在路径</p></li><li><p>强连通：在<strong>有向图</strong>中，顶点和顶点间存在相互路径</p></li><li><p>完全图</p><ul><li>无向完全图：无向图中任意两个顶点之间都存在边</li><li>有向完全图：有向图中任意两个顶点之间存在反复相反的两条弧</li></ul></li></ul><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>图的存储结构可以分为：</p><ul><li><strong>邻接矩阵</strong></li><li><strong>邻接表</strong></li><li><strong>十字链表</strong></li><li><strong>邻接多重表</strong></li></ul><p>如上的存储结构（方法），是对无向图和有向图的不同解决方案。</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵的思路很简单，将顶点序列建立二维数组，用 0 或者 1 来表示顶点间的连通性，图示如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae4fb65031.png" alt="image-20220829030718451" style="zoom:80%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><p>如上的存储方式可以采用二维数组的方式来存储，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">char</span> Vertex[Maxsize];<span class="comment">//存放顶点的数组</span></span><br><span class="line">ElemType Edge[Maxsize][Maxsize];<span class="comment">//存放顶点关系的数组</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的总共顶点数和弧的数目</span></span><br><span class="line">&#125;Chart;</span><br></pre></td></tr></table></figure><p>如上可知：<strong>对于邻接矩阵来说，最大的问题是如果存储的边的密度很低的话，会造成大量的空间浪费</strong>。</p><h3 id="邻接矩阵的性质"><a href="#邻接矩阵的性质" class="headerlink" title="邻接矩阵的性质"></a>邻接矩阵的性质</h3><p>如果将邻接矩阵与自身相乘（矩阵相乘），则对应的结果表示了顶点和顶点间是否存在路径为 1 的路径，如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae4ff3f2e5.png" alt="image-20220829031641842" style="zoom:80%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><p>同理，如果你<strong>将其与自身相乘 n 次，则对应的结果意味着顶点和顶点间是否存在长度为 n 的路径</strong>。</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接表采用顺序存储和链式存储相互结合的方法，如下图所示，你会发现它和树部分的“孩子表示法”很类似。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae502d1957.png" alt="image-20220829031940891" style="zoom: 67%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><p>图示逻辑上理解起来类似于树的“堂兄弟表示法”，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//边，弧</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//弧指向的结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">next</span>;</span><span class="comment">//指向下条弧的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* first;<span class="comment">//第一条边</span></span><br><span class="line">&#125;VNode,AdjList[Maxsize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">AdjList vertices;<span class="comment">//数组存储顶点</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的总共顶点数和弧的数目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>邻接表法的缺点是：寻找顶点的入度或者入边很不方便</strong>。</p><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>注：十字链表是用来存储<strong>有向图</strong>而设计的。具体示例如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5073d1aa.png" alt="image-20220829033432151" style="zoom: 67%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p><strong>对于邻接矩阵存储无向图来说，会存在大量的数据冗余和空间浪费，而邻接多重表就是为了解决这两个问题而产生的解决方案</strong>，示例如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae50b71187.png" alt="image-20220829033710277" style="zoom: 67%;" /><p>注：邻接多重表是用来存储<strong>无向图</strong>而设计的。</p><h1 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h1><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>Adjacent(G,X,Y)</code></td><td>判断图 G 是否存在边 &lt;x,y&gt; 或者 (x,y)</td></tr><tr><td><code>NeighBors(G,X)</code></td><td>列出图 G 中与结点 X 邻接的边</td></tr><tr><td><code>InsertVertex(G,X)</code></td><td>在图 G 中插入顶点 X</td></tr><tr><td><code>DeleteVertex(G,X)</code></td><td>在图 G 中删除顶点 X</td></tr><tr><td><code>AddEdge(G,X,Y)</code></td><td>若无向边 (x,y) 或者有向边 &lt;x,y&gt; 不存在，则向图 G 中添加该边</td></tr><tr><td><code>FirstNeighbor(G,X)</code></td><td>求图 G 中顶点 X 的第一个邻接点，若存在则返回顶点号，不存在返回 -1</td></tr><tr><td><code>NextNeighbor(G,X,Y)</code></td><td>找图 G 中顶点 Y 的除了邻接点 X 的其他邻接点，若存在则返回顶点号，不存在返回 -1</td></tr><tr><td><code>Get_edge_value(G,X,Y)</code></td><td>获取图 G 中边 (X,Y) 或者 &lt;X,Y&gt;对应的权值</td></tr><tr><td><code>Set_edge_value(G,X,Y)</code></td><td>设置图 G 中边 (X,Y) 或者 &lt;X,Y&gt;对应的权值</td></tr><tr><td><code>Adjacent(G,X,Y)</code></td><td>判断图 G 是否存在边 (X,Y) 或者 &lt;X,Y&gt;</td></tr></tbody></table><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h2><p>图的广度优先遍历和树的广度优先遍历（层次遍历）很类似，例如下面的图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae50f475d6.png" alt="image-20220830012444047" style="zoom:80%;" /><p>我们选择一个顶点开始进行图的广度优先遍历，例如 A 顶点，<strong>第一步将 A 压入辅助队列中，A 出队的时候获取其下一个顶点 B C D 压入队列，依次类推，直到队列为空</strong>。但是图和树不同的是，图有可能出现回环，而树不可能，树的结构保证了每个结点都只会被遍历一次，而图如果出现回环那么同一个顶点会被遍历多次，这个时候就需要再定义一个辅助数组，用来记录哪个结点是否被遍历过。</p><p>对于不同图的存储方式和不同的图的类型，其广度优先代码略有不同，代码如下所示。</p><p>前排说明：请创建一个头文件，名称为<code>图的存储结构.h</code>，代码如下，此头文件需要被使用图的地方进行引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line"><span class="type">char</span> Vertex[Maxsize];<span class="comment">//存放顶点的数组</span></span><br><span class="line">ElemType Edge[Maxsize][Maxsize];<span class="comment">//存放顶点关系的数组</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的总共顶点数和弧的数目</span></span><br><span class="line">&#125;GMatrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接表法*/</span></span><br><span class="line"><span class="comment">//边，弧</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//弧指向的结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">next</span>;</span><span class="comment">//指向下条弧的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">char</span> data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* first;<span class="comment">//第一条边</span></span><br><span class="line">&#125;VNode,AdjList[Maxsize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">AdjList vertices;<span class="comment">//数组存储顶点</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的总共顶点数和弧的数目</span></span><br><span class="line">&#125;GraphAdjList;</span><br></pre></td></tr></table></figure><h3 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>考虑到需要使用辅助队列完成图的广度优先遍历，需要再创建一个名称为<code>图队列.h</code>的头文件，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;图的存储结构.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemTypeQ int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列元素结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemTypeQ data; <span class="comment">//二叉树结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span> <span class="comment">//下一个结点的指针</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头结点结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">front</span>;</span> <span class="comment">//队列队头指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">rear</span>;</span>  <span class="comment">//队列队尾指针</span></span><br><span class="line">    <span class="type">int</span> size;   <span class="comment">//队列的大小</span></span><br><span class="line">&#125;QHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列-带头结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(QHead* q)</span> &#123;</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;    <span class="comment">//队头指针初始化</span></span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>; <span class="comment">//队尾指针初始化</span></span><br><span class="line">    q-&gt;size = <span class="number">0</span>;    <span class="comment">//初始化队列大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列初始化成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(QHead* q, ElemTypeQ data)</span> &#123;</span><br><span class="line">    QNode* qn = (QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));  <span class="comment">//新元素结点申请内存空间</span></span><br><span class="line">    qn-&gt;data = data;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;size &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qn-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//尾指针为空</span></span><br><span class="line">        q-&gt;front = qn;  <span class="comment">//头指针指向第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        qn-&gt;next = q-&gt;rear-&gt;next;   <span class="comment">//新元素的下一个元素指针指向队尾指针的下一个</span></span><br><span class="line">        q-&gt;rear-&gt;next = qn; <span class="comment">//原来的队尾元素指向新队尾元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;rear = qn;   <span class="comment">//尾指针指向第一个元素</span></span><br><span class="line">    q-&gt;size++;  <span class="comment">//队列的长度+1</span></span><br><span class="line">    <span class="comment">//printf(&quot;元素 %d 入队成功,当前队列长度为:%d\n&quot;, data, q-&gt;size);</span></span><br><span class="line">    <span class="comment">//GetHead(q);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队操作</span></span><br><span class="line">ElemTypeQ <span class="title function_">DeQueue</span><span class="params">(QHead* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>)  <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    QNode* tempNode = q-&gt;front;</span><br><span class="line">    ElemTypeQ tempdata = tempNode-&gt;data; <span class="comment">//获取队头元素</span></span><br><span class="line">    q-&gt;front = tempNode-&gt;next;  <span class="comment">//队头指向新的队头元素</span></span><br><span class="line">    <span class="built_in">free</span>(tempNode); <span class="comment">//释放出队元素的内存空间</span></span><br><span class="line">    q-&gt;size--;  <span class="comment">//队列元素-1</span></span><br><span class="line">    <span class="keyword">return</span> tempdata;    <span class="comment">//返回出队元素数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取队头元素</span></span><br><span class="line">ElemTypeQ <span class="title function_">GetHead</span><span class="params">(QHead* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空队列\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;  <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>, q-&gt;front-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Destory</span><span class="params">(QHead* q)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DeQueue(q);</span><br><span class="line">    &#125;</span><br><span class="line">    InitQueue(q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列已销毁\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下是图的广度优先遍历代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接矩阵-图*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;图的存储结构.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;图队列.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGraph</span><span class="params">(GMatrix* g)</span> &#123;</span><br><span class="line">g-&gt;arcnum = <span class="number">0</span>;<span class="comment">//边数目初始化零</span></span><br><span class="line">g-&gt;vexnum = <span class="number">0</span>;<span class="comment">//点数目初始化零</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; Maxsize; k++)</span><br><span class="line">&#123;</span><br><span class="line">g-&gt;Vertex[k] = <span class="number">0</span>;<span class="comment">//初始化顶点数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Maxsize; j++)</span><br><span class="line">&#123;</span><br><span class="line">g-&gt;Edge[i][j] = <span class="number">0</span>;<span class="comment">//边的关系初始化为零</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;图已初始化\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在图中插入顶点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertVertex</span><span class="params">(GMatrix* g, <span class="type">char</span> v)</span> &#123;</span><br><span class="line"><span class="comment">//判断图是否已满</span></span><br><span class="line"><span class="keyword">if</span> (g-&gt;Vertex[Maxsize<span class="number">-1</span>]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;图已满，无法添加顶点:%c&quot;</span>, v);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果找到数组值为0 表示可以插入顶点</span></span><br><span class="line"><span class="keyword">if</span> (g-&gt;Vertex[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">g-&gt;Vertex[i] = v;<span class="comment">//插入新顶点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顶点:%c 插入图位置:%d 成功&quot;</span>, v, i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出错&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建图</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CreatGraph</span><span class="params">(GMatrix* g)</span> &#123;</span><br><span class="line"><span class="comment">/*建立图的顶点和边数*/</span></span><br><span class="line"><span class="type">int</span> tempVex =<span class="number">0</span>, tempEdge=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入顶点数和边数,例如：2,3(英文的逗号)\n&quot;</span>);</span><br><span class="line"><span class="comment">//获取输入的顶点和边数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;tempVex, &amp;tempEdge);</span><br><span class="line"><span class="keyword">if</span> (tempVex&gt;Maxsize || tempEdge &gt; <span class="number">10000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顶点或者边数超出预定范围\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对图的边数和顶点赋值</span></span><br><span class="line">g-&gt;vexnum = tempVex;</span><br><span class="line">g-&gt;arcnum = tempEdge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*建立图的顶点信息*/</span></span><br><span class="line">tempVex = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入顶点信息\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> tempdata;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;tempdata);</span><br><span class="line"><span class="keyword">while</span> (tempdata != <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tempVex&gt;=Maxsize || tempVex&gt;g-&gt;vexnum<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入顶点信息超出预定大小\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">g-&gt;Vertex[tempVex] = tempdata;</span><br><span class="line">tempVex++;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;tempdata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*建立图的边的关系*/</span></span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;<span class="comment">//临时指针</span></span><br><span class="line">tempVex = <span class="number">0</span>;<span class="comment">//临时指针</span></span><br><span class="line">tempEdge = <span class="number">0</span>;<span class="comment">//存储输入的数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入边的信息\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tempEdge);</span><br><span class="line"><span class="keyword">while</span> (tempEdge != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt; Maxsize<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入顶点信息超出预定数组&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">g-&gt;Edge[index][tempVex] = tempEdge;</span><br><span class="line">tempVex++;</span><br><span class="line"><span class="keyword">if</span> (tempVex&gt;g-&gt;vexnum<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">index++;</span><br><span class="line">tempVex = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tempEdge);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;图建立完成\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第一个邻接点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FirstNeighbor</span><span class="params">(GMatrix* g, <span class="type">int</span> vex)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g-&gt;Edge[vex][i]==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找到第一个邻接点为:%c\n&quot;</span>, g-&gt;Vertex[i]);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;未查找到邻接点\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回除了该点的下一个邻接点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextNeighbor</span><span class="params">(GMatrix* g, <span class="type">int</span> vex,<span class="type">int</span> nextVex)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = nextVex+<span class="number">1</span>; i &lt; g-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g-&gt;Edge[vex][i] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找到第一个邻接点为:%c\n&quot;</span>, g-&gt;Vertex[i]);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;未查找到邻接点\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历(BFS)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(GMatrix* g,<span class="type">int</span> vex)</span> &#123;</span><br><span class="line">ElemType isSerach[Maxsize];<span class="comment">//辅助数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">&#123;</span><br><span class="line">isSerach[i] = <span class="number">0</span>;<span class="comment">//初始化数组</span></span><br><span class="line">&#125;</span><br><span class="line">QHead q;<span class="comment">//辅助队列</span></span><br><span class="line">InitQueue(&amp;q);<span class="comment">//初始化赋值队列</span></span><br><span class="line"><span class="type">int</span> tempdata,deqdata;<span class="comment">//临时变量</span></span><br><span class="line">EnQueue(&amp;q, vex - <span class="number">1</span>);<span class="comment">//遍历开始点入队</span></span><br><span class="line">isSerach[vex <span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//如果队列不为空，则继续遍历</span></span><br><span class="line"><span class="keyword">while</span> (q.size!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">deqdata = DeQueue(&amp;q);<span class="comment">//出队顶点</span></span><br><span class="line">tempdata = deqdata;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出队顶点为:%c\n&quot;</span>, g-&gt;Vertex[tempdata]);</span><br><span class="line">tempdata = FirstNeighbor(g, tempdata);</span><br><span class="line"><span class="keyword">if</span> (isSerach[tempdata]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">EnQueue(&amp;q, tempdata);<span class="comment">//压入第一个顶点</span></span><br><span class="line">isSerach[tempdata] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (tempdata!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">tempdata = NextNeighbor(g, deqdata, tempdata);</span><br><span class="line"><span class="keyword">if</span> (tempdata != <span class="number">-1</span> &amp;&amp; isSerach[tempdata] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">EnQueue(&amp;q, tempdata);<span class="comment">//压入第一个顶点</span></span><br><span class="line">isSerach[tempdata] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;图广度优先遍历完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//程序入口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">GMatrix g;<span class="comment">//声明图</span></span><br><span class="line">InitGraph(&amp;g);<span class="comment">//初始化图</span></span><br><span class="line">CreatGraph(&amp;g);<span class="comment">//创建图</span></span><br><span class="line">BFS(&amp;g, <span class="number">4</span>);<span class="comment">//广度优先遍历图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的图（无向图）示例如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae51869ab6.png" alt="image-20220830013902867" style="zoom:80%;" /><p>我们从顶点 A 开始广度优先遍历，运行结果如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae51c1992a.png" alt="image-20220830013948174" style="zoom:80%;" /><p>其中红框部分表示其的存储矩阵输入，蓝色框表示遍历输出的结果，即 A B E F C D。</p><p>当然，你也可以使用有向图来进行测试，例如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5209551c.png" alt="image-20220830014209554" style="zoom:80%;" /><p>当你使用上述有向图进行广度优先遍历的时候，如果是从顶点 A 开始广度优先遍历，则可以得到完整的遍历序列，如果你从 B 开始则会得到不包含 A 的遍历序列，<strong>事实上，如果你使用包含多个图的森林来测试上述广度优先算法，也会出现如果没有被指向的顶点被漏掉的情况</strong>。</p><p>这个时候就需要改进我们的广度优先算法，还记得我们为了避免广度优先遍历多次同一个顶点的时候我们创建了一个辅助数组用来记录每个顶点是否被遍历过吗？这个时候我们就可以继续利用它，遍历这个数组，如果还存在没有被遍历的顶点，则从这个顶点开始，再次进行一次广度优先遍历即可。</p><h3 id="邻接表-1"><a href="#邻接表-1" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接表图*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;图的存储结构.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;图队列.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGraph</span><span class="params">(GraphAdjList* g)</span> &#123;</span><br><span class="line">g-&gt;arcnum = <span class="number">0</span>;<span class="comment">//边数初始化为零</span></span><br><span class="line">g-&gt;vexnum = <span class="number">0</span>;<span class="comment">//顶点数初始化为零</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">&#123;</span><br><span class="line">g-&gt;vertices[i].data = <span class="number">0</span>;<span class="comment">//顶点数组初始化为零</span></span><br><span class="line">g-&gt;vertices[i].first = <span class="literal">NULL</span>;<span class="comment">//顶点数组初始化为零</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;图初始化完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建邻接表图</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CreatGraph</span><span class="params">(GraphAdjList* g)</span> &#123;</span><br><span class="line"><span class="type">int</span> tempVex = <span class="number">0</span>, tempArc = <span class="number">0</span>;<span class="comment">//声明并初始化两个临时变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入顶点数和边数,例如：2,3(英文的逗号)\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;tempVex, &amp;tempArc);<span class="comment">//获取输入的顶点数和边数</span></span><br><span class="line">g-&gt;vexnum = tempVex;<span class="comment">//顶点数写入图</span></span><br><span class="line">g-&gt;arcnum = tempArc;<span class="comment">//边数写入图</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入顶点信息\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> tempdata;</span><br><span class="line">tempVex = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;tempdata);<span class="comment">//读取要存储的顶点信息</span></span><br><span class="line"><span class="keyword">while</span> (tempdata != <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果超出自己给出的顶点数或者默认的最大顶点数</span></span><br><span class="line"><span class="keyword">if</span> (tempVex &gt;g-&gt;vexnum<span class="number">-1</span>|| tempVex &gt;Maxsize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;超出预定顶点数目\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">g-&gt;vertices[tempVex].data = tempdata;<span class="comment">//读取的顶点信息写入顶点数组</span></span><br><span class="line">tempVex++;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;tempdata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法插入链表部分</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入边表信息，以 -1 表示结束输入\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tempVex);<span class="comment">//读取边表信息</span></span><br><span class="line"><span class="comment">//头插法建立边信息表</span></span><br><span class="line"><span class="keyword">while</span> (tempVex != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ArcNode* arcnode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));<span class="comment">//创建第一个边</span></span><br><span class="line">arcnode-&gt;adjvex = tempVex;<span class="comment">//边信息值赋值给创建的边</span></span><br><span class="line">arcnode-&gt;next = g-&gt;vertices[i].first;<span class="comment">//创建的边的下一条指针指向源顶点指向的边</span></span><br><span class="line">g-&gt;vertices[i].first = arcnode;<span class="comment">//顶点指向第一条边</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tempVex);<span class="comment">//读取边表信息</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;图建立成功\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历（BFS）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(GraphAdjList* g,<span class="type">int</span> vex)</span> &#123;</span><br><span class="line"><span class="type">int</span> isSerach[Maxsize];<span class="comment">//声明辅助数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">&#123;</span><br><span class="line">isSerach[i] = <span class="number">0</span>;<span class="comment">//初始化辅助数组</span></span><br><span class="line">&#125;</span><br><span class="line">QHead q;<span class="comment">//声明队列</span></span><br><span class="line">InitQueue(&amp;q);<span class="comment">//初始化辅助队列</span></span><br><span class="line"></span><br><span class="line">EnQueue(&amp;q, vex - <span class="number">1</span>);<span class="comment">//第一个顶点入队</span></span><br><span class="line">isSerach[vex - <span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//表示第一个顶点已经遍历过了</span></span><br><span class="line"></span><br><span class="line">ElemTypeQ data = <span class="number">0</span>;</span><br><span class="line">ArcNode* tempnode;</span><br><span class="line"><span class="keyword">while</span> (q.size!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">data = DeQueue(&amp;q);<span class="comment">//出队操作</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顶点 %c 已出队\n&quot;</span>, g-&gt;vertices[data]);</span><br><span class="line">tempnode = g-&gt;vertices[data].first;</span><br><span class="line"><span class="keyword">while</span> (tempnode!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果这个顶点没有被遍历过</span></span><br><span class="line"><span class="keyword">if</span> (isSerach[tempnode-&gt;adjvex]!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">EnQueue(&amp;q, tempnode-&gt;adjvex);<span class="comment">//入队下一个顶点</span></span><br><span class="line">isSerach[tempnode-&gt;adjvex] = <span class="number">1</span>;<span class="comment">//表面该顶点已经被遍历了</span></span><br><span class="line">&#125;</span><br><span class="line">tempnode = tempnode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;广度优先遍历图完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序入口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">GraphAdjList g;</span><br><span class="line">InitGraph(&amp;g);</span><br><span class="line">CreatGraph(&amp;g);</span><br><span class="line">BFS(&amp;g, <span class="number">1</span>);<span class="comment">//从图中顶点 A 位置开始广度优先遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果以下图顶点 A 位置开始广度优先遍历，运行结果如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5209551c.png" alt="image-20220830014209554" style="zoom:80%;" /> <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae529871e4.png" alt="image-20220830033428161" style="zoom:80%;" /><p>同样的，邻接表创建的无向图也可以使用上述代码进行广度优先遍历，当然，代码依旧存在对于如果没有入度的顶点无法遍历到的情况，解决办法和邻接矩阵部分一样，额外定义遍历辅助数组，查看辅助数组中是否存在未遍历的顶点，如果有，就以该顶点为广度优先遍历的起点开始遍历。</p><h3 id="广度优先生成树"><a href="#广度优先生成树" class="headerlink" title="广度优先生成树"></a>广度优先生成树</h3><p>因为广度优先遍历会产生一定的遍历次序，所以可以通过广度优先遍历生成一颗对应的广度优先生成树，图示如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae52f3384a.png" alt="image-20220830034207729" style="zoom:80%;" /><h2 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h2><p>深度优先遍历类似于树的“深度优先遍历”，例如下图，<strong>如果在 A 开始深度优先遍历，则会先获取 A 点的数据，然后遍历 A 的第一个链接的顶点 E ，获取第一个链接的顶点 E 的数据，然后再遍历 E 的第一个链接的顶点，如果不为空，则继续向下遍历获取数据，直到其子顶点为<code>NULL</code>，则会遍历其父顶点的另一个子顶点</strong>。</p><p>你会发现<strong>它的逻辑其实就是递归遍历</strong>，由于图的性质，在实现的时候依旧需要使用辅助数组来标识哪个顶点被遍历过。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5332c5aa.png" alt="image-20220830192941014" style="zoom:80%;" /><h3 id="邻接矩阵-2"><a href="#邻接矩阵-2" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>现在来邻接矩阵实现深度优先遍历，首先需要声明一个全局变量<code>int isSerach[Maxsize];</code>用来做辅助数组，记得在使用深度优先遍历前将辅助数组初始化为 0 ，表示顶点没有被访问过。</p><p>如下代码只需要放在上面邻接矩阵的广度优先遍历方法的下面即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GMatrix g, <span class="type">int</span> vex)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;遍历顶点:%c\n&quot;</span>, g.Vertex[vex]);</span><br><span class="line">isSerach[vex] = <span class="number">1</span>;<span class="comment">//标识已经遍历过顶点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g.Edge[vex][i]==<span class="number">1</span> &amp;&amp; isSerach[i] !=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">DFS(g, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序入口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">GMatrix g;<span class="comment">//声明图</span></span><br><span class="line">InitGraph(&amp;g);<span class="comment">//初始化图</span></span><br><span class="line">CreatGraph(&amp;g);<span class="comment">//创建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">&#123;</span><br><span class="line">isSerach[i] = <span class="number">0</span>;<span class="comment">//初始化辅助数组</span></span><br><span class="line">&#125;</span><br><span class="line">DFS(g, <span class="number">0</span>);<span class="comment">//深度优先遍历邻接矩阵图 从顶点 A 开始</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试图如下，从下图的顶点 A 开始深度优先遍历。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5332c5aa.png" alt="image-20220830192941014" style="zoom:80%;" /><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae53f8251e.png" alt="image-20220830195702611" style="zoom:80%;" /><p>同样的，如果图中存在顶点不存在入度，或者是森林图的情况，则需要另外声明一个函数来遍历辅助数组，查看哪个顶点还未被遍历过，对未被遍历过的顶点进行再次的深度优先遍历。</p><h3 id="邻接表-2"><a href="#邻接表-2" class="headerlink" title="邻接表"></a>邻接表</h3><p>如下深度优先遍历方法代码只需要在前面广度优先遍历的邻接表的<code>.c</code>文件中添加到最后即可。但是仍需创建一个全局变量<code>int isSerach[Maxsize];</code>，用来做辅助数组，记得在执行深度优先遍历前将辅助数组初始化为<code>0</code>，即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">&#123;</span><br><span class="line">isSerach[i] = <span class="number">0</span>;<span class="comment">//初始化辅助数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphAdjList g,<span class="type">int</span> vex)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前顶点为：%c\n&quot;</span>, g.vertices[vex].data);</span><br><span class="line">isSerach[vex] = <span class="number">1</span>;</span><br><span class="line">ArcNode* arcnode = g.vertices[vex].first;<span class="comment">//临时顶点</span></span><br><span class="line"><span class="keyword">while</span> (arcnode!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (isSerach[arcnode-&gt;adjvex]!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">DFS(g, arcnode-&gt;adjvex);</span><br><span class="line">arcnode = arcnode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序入口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">GraphAdjList g;<span class="comment">//声明图</span></span><br><span class="line">InitGraph(&amp;g);<span class="comment">//初始化图</span></span><br><span class="line">CreatGraph(&amp;g);<span class="comment">//创建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">&#123;</span><br><span class="line">isSerach[i] = <span class="number">0</span>;<span class="comment">//初始化辅助数组</span></span><br><span class="line">&#125;</span><br><span class="line">DFS(g, <span class="number">0</span>);<span class="comment">//对图从顶点 A 进行深度优先遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试图如下，从下图的顶点 A 开始深度优先遍历。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5332c5aa.png" alt="image-20220830192941014" style="zoom:80%;" /><p>运行结果:</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae5484b6de.png" alt="image-20220830194024910" style="zoom:80%;" /><p>同样的，如果图中存在顶点不存在入度，或者是森林图的情况，则需要另外声明一个函数来遍历辅助数组，查看哪个顶点还未被遍历过，对未被遍历过的顶点进行再次的深度优先遍历。</p><h3 id="深度优先生成树"><a href="#深度优先生成树" class="headerlink" title="深度优先生成树"></a>深度优先生成树</h3><p>同广度优先生成树，随着深度优先的遍历顺序，可以对应的生成一棵深度优先生成树。</p><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>生成树的理解如下图，左边的图可以产生如右边的两种生成树（当然不止这两种），其生成树的特点是连通的，且边数目等于顶点数目 -1.</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae54d19108.png" alt="image-20220830200438476" style="zoom:80%;" /><p><strong>最小生成树是在如上的基础上，边存在权值，如果生成树的边权值之和最小的树，被称为最小生成树</strong>。</p><p>获取最小生成树的算法有两种：</p><ul><li><p><strong>Prim（普利姆）算法</strong></p><p><strong>从图中某个顶点开始构建生成树，每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。</strong></p></li><li><p><strong>Kruskal（克鲁斯卡尔）算法</strong></p><p><strong>每次选择一条权值最小的边，使得这两条边的两头联通，直到所有的结点都连通。</strong></p></li></ul><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>最短路径问题，直接用应用带入，例如我们的导航是如何直到我们和目的地之间的最优最短路径呢？</p><p>关于最短路径问题可以分为如下情况：</p><ul><li><strong>单源最短路径</strong><ul><li><strong>BFS 算法（无权图）</strong></li><li><strong>Dijkstra 算法（带权图，无权图）</strong></li></ul></li><li><strong>各顶点间的最短路径</strong><ul><li><strong>Floyd 算法（带权图，无权图）</strong></li></ul></li></ul><h2 id="BFS-算法"><a href="#BFS-算法" class="headerlink" title="BFS 算法"></a>BFS 算法</h2><p>BFS 也就是广度优先遍历算法，可以求得无权图（或者说权都为 1）的图的单源最短路径。</p><p>实现思路和广度优先遍历无差别，只是在广度优先遍历在读取结点数据的时候需要做两个操作，<strong>创建两个数组，分别表示遍历开始顶点到当前顶的距离和表示自己上一个最近的顶点是谁</strong>。在每次广度优先遍历顶点的时候，将两个数组进行相关赋值操作，遍历完成后，两个数组就包含了当前广度优先遍历顶点到其他顶点的最短路径信息。</p><p>此处用邻接矩阵来做代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广度优先-最短路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS_Min_Distance</span><span class="params">(GMatrix* g,<span class="type">int</span> vex)</span> &#123;</span><br><span class="line">ElemType path[Maxsize];<span class="comment">//记录上一个顶点</span></span><br><span class="line">ElemType d[Maxsize];<span class="comment">//记录顶点间的距离</span></span><br><span class="line">ElemType isSerach[Maxsize];<span class="comment">//辅助数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">&#123;</span><br><span class="line">isSerach[i] = <span class="number">0</span>;<span class="comment">//初始化数组</span></span><br><span class="line">path[i] = <span class="number">-1</span>;</span><br><span class="line">d[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">QHead q;<span class="comment">//辅助队列</span></span><br><span class="line">InitQueue(&amp;q);<span class="comment">//初始化赋值队列</span></span><br><span class="line"><span class="type">int</span> tempdata, deqdata;<span class="comment">//临时变量</span></span><br><span class="line">EnQueue(&amp;q, vex - <span class="number">1</span>);<span class="comment">//遍历开始点入队</span></span><br><span class="line">isSerach[vex - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">d[vex - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//如果队列不为空，则继续遍历</span></span><br><span class="line"><span class="keyword">while</span> (q.size != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">deqdata = DeQueue(&amp;q);<span class="comment">//出队顶点</span></span><br><span class="line">tempdata = deqdata;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出队顶点为:%c\n&quot;</span>, g-&gt;Vertex[tempdata]);</span><br><span class="line">tempdata = FirstNeighbor(g, tempdata);</span><br><span class="line"><span class="keyword">if</span> (isSerach[tempdata] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">EnQueue(&amp;q, tempdata);<span class="comment">//压入第一个顶点</span></span><br><span class="line">isSerach[tempdata] = <span class="number">1</span>;</span><br><span class="line">d[tempdata] = d[deqdata] + <span class="number">1</span>;</span><br><span class="line">path[tempdata] = deqdata;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (tempdata != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">tempdata = NextNeighbor(g, deqdata, tempdata);</span><br><span class="line"><span class="keyword">if</span> (tempdata != <span class="number">-1</span> &amp;&amp; isSerach[tempdata] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">EnQueue(&amp;q, tempdata);<span class="comment">//压入第一个顶点</span></span><br><span class="line">isSerach[tempdata] = <span class="number">1</span>;</span><br><span class="line">d[tempdata] = d[deqdata] + <span class="number">1</span>;</span><br><span class="line">path[tempdata] = deqdata; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;图广度优先遍历完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>Dijkstra（迪杰斯特拉）算法是一种可以求带权图的最短路径的算法，例如下面的图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae553c655a.png" alt="image-20220830221648062" style="zoom:80%;" /><p>该算法需要创建 3 个数组，其作用如下：</p><ul><li><strong><code>final[]</code>：记录顶点是否被连通了。</strong></li><li><strong><code>dist[]</code>：记录顶点关于已连通路径的权值。</strong></li><li><strong><code>path[]</code>：记录顶点和算法开始遍历顶点（单源）的路径，实际上是记录和最近上一个顶点。</strong></li></ul><p>例如，我们从顶点 A 开始算法遍历，首先需要进行数组初始化，初始化结果如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae557cfc87.png" alt="image-20220830222508474" style="zoom:80%;" /><p>上述 A 顶点的<code>final[]</code>的<code>True</code>表示顶点 A 是目前连通路径中，因为只有一个<code>True</code>，所以它是目前连通路径的唯一顶点，也是初始顶点，而<code>dist[]</code>中的权值表示从顶点 A 到 A 可以直接连通的顶点的权值（带权路径长度），由图可知，顶点 A 和其他顶点都存在通路，所以 BCDE 的<code>dist[]</code>的值是顶点 A 到它们的路径权值，而<code>path</code>数组表示从顶点 A 到其中的任何一个顶点的路径（当前顶点的上一个路径）。</p><p>完成上面的初始化工作后，现在开始遍历<code>dist[]</code>数组，找到其中<code>dist[]</code>数值最小的（即权值最小）的，让它成为最短（即结果）路径的一个顶点，即顶点 E 。然后再做类似于初始化的工作，得到的数组结果如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae55c0bc8a.png" alt="image-20220830223723290" style="zoom:80%;" /><p>数组<code>final[]</code>将顶点 E 的数值修改为<code>True</code>表示顶点 E 已经是最短路径中的一个顶点了，这个时候以顶点 E 为开始，计算从 E 到和它连通的顶点的权值和顶点 A 到它的权值和是否比 A 到其他顶点的权值低，如 C 顶点到 E 的权值为 1 ，A 到 C的原先权值为 3 ，如果从 A 到 E 再到 C 的权值则为 $3+1&#x3D;4$ 比 A 到 C 的权值高，则不覆盖 C 的<code>dist[]</code>值，而与 E 连通的另一个顶点 D 同样的，如果 A 到 E 再到 D 的权值为 $3+6&#x3D;9$，而其值比 A 到 D 的权值高，所以也不覆盖，然后从中选取权值最低的 C 作为新的顶点，依次类推。</p><h2 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h2><p>关于 Floyd 算法其思路可以参考 <a href="httpss://www.bilibili.com/video/BV14R4y1x7GB?p=1&t=588">求最短路径Floyd算法！</a> </p><p>这个算法就算录视频说明也要说上一阵，不想打字了，自行参考吧  :）</p><p>算法的示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Floyd 算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Floyd</span><span class="params">(GMatrix g)</span> &#123;</span><br><span class="line"><span class="type">int</span> path[Maxsize][Maxsize];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Maxsize; j++)</span><br><span class="line">&#123;</span><br><span class="line">path[i][j] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; g.vexnum; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.vexnum; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g.Edge[i][j]&gt; g.Edge[i][k]+ g.Edge[k][j])</span><br><span class="line">&#123;</span><br><span class="line">g.Edge[i][j] = g.Edge[i][k] + g.Edge[k][j];</span><br><span class="line">path[i][j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：算法是在邻接矩阵存储格式下实现的</p></blockquote><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>拓扑排序适用于 DAG 图（Directed Acyclic Graph），即有向无环图。人话来说就是图中不能出现回环。</p><p>拓扑排序可以解决下图的顺序问题：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae56749272.png" alt="image-20220831003334997" style="zoom:67%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><p>拓扑排序可以解决上述 AOV 网（Activity On Vertex Network）的执行顺序问题。其解决方案：</p><blockquote><p>AOV 人话来说就是用顶点来表示一个个的事件&#x2F;活动</p></blockquote><ol><li><strong>从 AOV 网中选择一个没有前驱（入度为 0 ）的顶点并输出</strong></li><li><strong>从网中删除该顶点和所有以它为起点的有向边</strong></li><li><strong>重复上述操作，直到当前 AOV 网为空 或者 当前网中不存在无前驱的顶点为止</strong></li></ol><p>拓扑排序代码示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Topological</span><span class="params">(GMatrix g)</span> &#123;</span><br><span class="line">QHead q;<span class="comment">//声明辅助队列</span></span><br><span class="line">InitQueue(&amp;q);<span class="comment">//初始化队列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.vexnum; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i==g.vexnum<span class="number">-1</span> &amp;&amp; g.Edge[i][j]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">EnQueue(&amp;q, j);<span class="comment">//将无入度的顶点入队</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; g.vexnum<span class="number">-1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">g.Edge[j][k] = <span class="number">0</span>;<span class="comment">//将关于无入度的顶点删除边</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顶点数据为:&quot;</span>);</span><br><span class="line"><span class="comment">//队列不为空，则弹出队列内容</span></span><br><span class="line"><span class="keyword">while</span> (q.size!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, g.Vertex[DeQueue(&amp;q)]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将代码放在广度优先求最短路径算法下面即可，代码以图的邻接矩阵存储结构实现的。</p><p>使用的图示例如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae56bd6c17.png" alt="image-20220831011251475" style="zoom:80%;" /><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae56fc7710.png" alt="image-20220831011032498" style="zoom: 77%;" /><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>图学完啦，学完图就没有其他的数据结构了，剩下就是如何来利用这些数据结构来应用了，比如查找和排序。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae573b7ea8.png" alt="image-20220831013625512" style="zoom:90%;" />]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【3.1】栈和队列</title>
      <link href="/2022/01/28/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%903.1%E3%80%91%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2022/01/28/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%903.1%E3%80%91%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>栈和队列是线性表的另一种变形，它拥有一些各自的特点。</p><p>如下所有代码需要做如下引用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你使用的是Visual Studio，则还需要添加如下一条引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br></pre></td></tr></table></figure><blockquote><p>关于上述引用的说明，原因参考<a href="httpss://www.helloseraphine.top/2022/08/01/C%E8%AF%AD%E8%A8%80/%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E6%80%9D%E8%80%83/#Bool%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98">关于C语言的一些零碎思考</a></p></blockquote><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h2><h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><p>栈(Stack)<strong>本质来说还是一种线性表</strong>，<strong>栈是只允许在一端进行插入或者删除操作的线性表</strong>。</p><ul><li><strong>空栈</strong>：栈中不存储任何数据</li><li><strong>栈顶</strong>：栈的最顶端</li><li><strong>栈底</strong>：栈的最低端</li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae34f8a888.png" alt="image-20220807150712587" style="zoom: 67%;" /><p>栈的特点：<strong>后进先出</strong>（Last In First Out，LIFO）</p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>InitStack()</code></td><td>初始化栈。创造一个空栈，分配内存空间</td></tr><tr><td><code>DestoryStack()</code></td><td>销毁栈。销毁并释放栈所占的内存空间</td></tr><tr><td><code>Push()</code></td><td>进栈。如果栈未满，则将新元素压入栈顶</td></tr><tr><td><code>Pop()</code></td><td>出栈。如果栈不是空栈，则将栈顶元素弹出栈</td></tr><tr><td><code>GetTop()</code></td><td>读取栈顶元素。</td></tr><tr><td><code>StackEmpty()</code></td><td>判断是否为空栈。</td></tr></tbody></table><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><h3 id="栈的顺序存储实现"><a href="#栈的顺序存储实现" class="headerlink" title="栈的顺序存储实现"></a>栈的顺序存储实现</h3><p>类似于线性表的顺序实现，不过使用的是栈的规则，即后进先出。</p><h4 id="栈的结构"><a href="#栈的结构" class="headerlink" title="栈的结构"></a>栈的结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10  <span class="comment">//栈的存储数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int    <span class="comment">//栈存储的数据类型</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[Maxsize]; <span class="comment">//存放栈的元素</span></span><br><span class="line">    <span class="type">int</span> top;    <span class="comment">//栈指针</span></span><br><span class="line">&#125;Stack;</span><br></pre></td></tr></table></figure><h4 id="初始化栈"><a href="#初始化栈" class="headerlink" title="初始化栈"></a>初始化栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(Stack * s)</span>&#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;    <span class="comment">//表示栈为空栈</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化栈:成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进栈（压入栈）"><a href="#进栈（压入栈）" class="headerlink" title="进栈（压入栈）"></a>进栈（压入栈）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//压入栈（进栈）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(Stack *s,ElemType data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top == Maxsize<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈已满，进栈失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data[s-&gt;top + <span class="number">1</span>] = data;</span><br><span class="line">    s-&gt;top++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 入栈：成功\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出栈（弹出栈）"><a href="#出栈（弹出栈）" class="headerlink" title="出栈（弹出栈）"></a>出栈（弹出栈）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//弹出栈（出栈）</span></span><br><span class="line">ElemType <span class="title function_">Pop</span><span class="params">(Stack *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空栈，弹出失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;top--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈顶元素 %d 弹出成功\n&quot;</span>, s-&gt;data[s-&gt;top + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="销毁栈"><a href="#销毁栈" class="headerlink" title="销毁栈"></a>销毁栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestoryStack</span><span class="params">(Stack *s)</span>&#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;销毁栈成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取栈顶元素"><a href="#读取栈顶元素" class="headerlink" title="读取栈顶元素"></a>读取栈顶元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取栈顶元素</span></span><br><span class="line">ElemType <span class="title function_">GetTop</span><span class="params">(Stack *s)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取栈顶元素: %d\n&quot;</span>,s-&gt;data[s-&gt;top]);</span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断空栈"><a href="#判断空栈" class="headerlink" title="判断空栈"></a>判断空栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判读是否为空栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(Stack *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈非空栈\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h4><p>共享栈是栈的另一种使用：两个栈指针，分别从栈顶和栈底计数，共享同一片物理内存空间，一定程度上提高的栈的利用率。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae355ec188.png" alt="image-20220807161207257" style="zoom: 67%;" /><h3 id="栈的链式存储实现"><a href="#栈的链式存储实现" class="headerlink" title="栈的链式存储实现"></a>栈的链式存储实现</h3><p>链式存储通用的可以有带头结点的和不带头结点的，如下代码示例为带头结点的。</p><p>其实在线性表的链式存储的头插法建立链表的时候，就是栈的一种类似情况。</p><h4 id="栈的结构-1"><a href="#栈的结构-1" class="headerlink" title="栈的结构"></a>栈的结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int    <span class="comment">//栈的元素数据类型</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//栈的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span> *<span class="title">next</span>;</span><span class="comment">//下一个位置</span></span><br><span class="line">&#125;LinkNode,*LinkStack;</span><br></pre></td></tr></table></figure><h4 id="初始化栈-1"><a href="#初始化栈-1" class="headerlink" title="初始化栈"></a>初始化栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(LinkStack *s)</span>&#123;</span><br><span class="line">    LinkNode *newNode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));   <span class="comment">//申请头结点内存空间</span></span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//头结点下一结点为空</span></span><br><span class="line">    newNode-&gt;data = <span class="number">-1</span>; <span class="comment">//数据域为-1</span></span><br><span class="line">    (*s) = newNode; <span class="comment">//指针指向头结点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈初始化头结点成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进栈（压入栈）-1"><a href="#进栈（压入栈）-1" class="headerlink" title="进栈（压入栈）"></a>进栈（压入栈）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进栈（压入栈）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(LinkStack *s,ElemType data)</span>&#123;</span><br><span class="line">    LinkNode *newNode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));   <span class="comment">//申请头结点内存空间</span></span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = (*s)-&gt;next; <span class="comment">//新结点指向头结点指向的结点</span></span><br><span class="line">    (*s)-&gt;next = newNode; <span class="comment">//头结点指向新结点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素: %d 入栈成功\n&quot;</span>, data);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出栈（弹出栈）-1"><a href="#出栈（弹出栈）-1" class="headerlink" title="出栈（弹出栈）"></a>出栈（弹出栈）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈（弹出栈）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(LinkStack *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((*s)-&gt;next ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空，弹出栈顶元素失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        LinkNode *newNode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));   <span class="comment">//申请头结点内存空间</span></span><br><span class="line">        newNode = (*s)-&gt;next;   <span class="comment">//获取栈顶元素</span></span><br><span class="line">        (*s)-&gt;next = newNode-&gt;next;     <span class="comment">//头结点指向新栈顶元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;弹出元素:%d 成功\n&quot;</span>, newNode-&gt;data);</span><br><span class="line">        <span class="built_in">free</span>(newNode);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取栈顶元素-1"><a href="#读取栈顶元素-1" class="headerlink" title="读取栈顶元素"></a>读取栈顶元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取栈顶元素</span></span><br><span class="line">ElemType <span class="title function_">GetTop</span><span class="params">(LinkStack* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((*s)-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//判断是否为空栈</span></span><br><span class="line">    LinkNode* newNode = (*s)-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> newNode-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>队列(Queue)本质也是一种线性表，其特点是：<strong>只允许在一端进行插入，在另一端进行删除</strong>的线性表。</p><ul><li><strong>入队</strong>：队列的插入操作</li><li><strong>出队</strong>：队列的删除操作</li><li><strong>队尾</strong>：允许插入操作进行的一端</li><li><strong>队头</strong>：允许删除操作进行的一端</li></ul><p><strong>队列的特点：先进先出</strong>(First in First Out，FIFO)</p><h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>InitQueue()</code></td><td>初始化队列，构造空队列</td></tr><tr><td><code>Destory()</code></td><td>销毁队列，销毁并释放队列所占的内存空间。</td></tr><tr><td><code>EnQueue()</code></td><td>入队，若队列未满，则将其加入队尾</td></tr><tr><td><code>DeQueue()</code></td><td>出队，若队列非空，则删除并返回对头元素</td></tr><tr><td><code>GetHead()</code></td><td>读取队头元素</td></tr><tr><td><code>QueueEmpty()</code></td><td>判断队列是否为空</td></tr></tbody></table><h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><h3 id="队列的顺序存储实现"><a href="#队列的顺序存储实现" class="headerlink" title="队列的顺序存储实现"></a>队列的顺序存储实现</h3><h4 id="队列的定义-1"><a href="#队列的定义-1" class="headerlink" title="队列的定义"></a>队列的定义</h4><p>队头指针始终指向第一个元素，<strong>队尾指针指向最后一个可用的位置（而不是队尾元素）</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">//队头指针</span></span><br><span class="line">    <span class="type">int</span> rear;   <span class="comment">//队尾指针</span></span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">//队列元素区域</span></span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure><h4 id="队列的初始化"><a href="#队列的初始化" class="headerlink" title="队列的初始化"></a>队列的初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(Queue *q)</span>&#123;</span><br><span class="line">    q-&gt;front = <span class="number">0</span>;   <span class="comment">//队头指针初始化</span></span><br><span class="line">    q-&gt;rear = <span class="number">0</span>;    <span class="comment">//队尾指针初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列初始化成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(Queue *q,ElemType data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((q-&gt;rear+<span class="number">1</span>)% MaxSize==q-&gt;front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已满，入队失败\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        q-&gt;data[q-&gt;rear] = data;</span><br><span class="line">        q-&gt;rear = ((q-&gt;rear+<span class="number">1</span>) % MaxSize);  <span class="comment">//取模运算获得让队列形成循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队</span></span><br><span class="line">ElemType <span class="title function_">DeQueue</span><span class="params">(Queue *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front==q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//判断是否为空队列</span></span><br><span class="line">    ElemType temp = q-&gt;data[q-&gt;front];</span><br><span class="line">    q-&gt;front =  (q-&gt;front+<span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队元素：%d 成功\n&quot;</span>, temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取队头元素"><a href="#读取队头元素" class="headerlink" title="读取队头元素"></a>读取队头元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取队头元素</span></span><br><span class="line">ElemType <span class="title function_">GetHead</span><span class="params">(Queue *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front==q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//判断是否为空队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取队头元素 %d 成功,位置:%d\n&quot;</span>, q-&gt;data[q-&gt;front],q-&gt;front);</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[q-&gt;front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front==q-&gt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空队列\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列非空队列\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的链式存储实现"><a href="#队列的链式存储实现" class="headerlink" title="队列的链式存储实现"></a>队列的链式存储实现</h3><h4 id="队列的定义（不带头结点）"><a href="#队列的定义（不带头结点）" class="headerlink" title="队列的定义（不带头结点）"></a>队列的定义（不带头结点）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列元素结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">//队列元素的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span> <span class="comment">//下一个结点的指针</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">front</span>;</span> <span class="comment">//队列队头指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">rear</span>;</span>  <span class="comment">//队列队尾指针</span></span><br><span class="line">    <span class="type">int</span> size;   <span class="comment">//队列的大小</span></span><br><span class="line">&#125;QHead;</span><br></pre></td></tr></table></figure><h4 id="队列初始化"><a href="#队列初始化" class="headerlink" title="队列初始化"></a>队列初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列-不带头结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(QHead * q)</span>&#123;</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;    <span class="comment">//队头指针初始化</span></span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>; <span class="comment">//队尾指针初始化</span></span><br><span class="line">    q-&gt;size = <span class="number">0</span>;    <span class="comment">//初始化队列大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列初始化成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入队操作-1"><a href="#入队操作-1" class="headerlink" title="入队操作"></a>入队操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(QHead *q,ElemType data)</span>&#123;</span><br><span class="line">    QNode *qn = (QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));  <span class="comment">//新元素结点申请内存空间</span></span><br><span class="line">    qn-&gt;data = data;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;size&lt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qn-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//尾指针为空</span></span><br><span class="line">        q-&gt;front = qn;  <span class="comment">//头指针指向第一个元素</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    qn-&gt;next = q-&gt;rear-&gt;next;   <span class="comment">//新元素的下一个元素指针指向队尾指针的下一个</span></span><br><span class="line">    q-&gt;rear-&gt;next = qn; <span class="comment">//原来的队尾元素指向新队尾元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;rear = qn;   <span class="comment">//尾指针指向第一个元素</span></span><br><span class="line">    q-&gt;size++;  <span class="comment">//队列的长度+1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 入队成功,当前队列长度为:%d\n&quot;</span>,data,q-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出队操作-1"><a href="#出队操作-1" class="headerlink" title="出队操作"></a>出队操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队操作</span></span><br><span class="line">ElemType <span class="title function_">DeQueue</span><span class="params">(QHead *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front==<span class="literal">NULL</span>)  <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    QNode *tempNode = q-&gt;front;</span><br><span class="line">    ElemType tempdata = tempNode-&gt;data; <span class="comment">//获取队头元素</span></span><br><span class="line">    q-&gt;front = tempNode-&gt;next;  <span class="comment">//队头指向新的队头元素</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear==tempNode)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;rear = <span class="literal">NULL</span>; <span class="comment">//如果出队最后一个，则将尾指针设置为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(tempNode); <span class="comment">//释放出队元素的内存空间</span></span><br><span class="line">    q-&gt;size--;  <span class="comment">//队列元素-1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队友元素 %d 已释放\n&quot;</span>, tempdata);</span><br><span class="line">    <span class="keyword">return</span> tempdata;    <span class="comment">//返回出队元素数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取队头元素-1"><a href="#读取队头元素-1" class="headerlink" title="读取队头元素"></a>读取队头元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取队头元素</span></span><br><span class="line">ElemType <span class="title function_">GetHead</span><span class="params">(QHead *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空队列\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;  <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>, q-&gt;front-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>队列是允许数据从一端插入，从另一端删除，而<strong>双端队列允许两端插入，两端删除</strong>的线性表。</p><p>本质上来说，不论是栈，还是队列，都是一种特殊规则的线性表。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae35f6ebcd.png" alt="image-20220809012444447" style="zoom: 50%;" /><p>当限制双端队列的一端删除和插入操作后，双端队列就变成了只有一端删除和插入的<strong>栈</strong>了，由此可以将双端队列演变成不同的类型，例如：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae3630d0fd.png" alt="image-20220809012729951" style="zoom: 60%;" /><h1 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h1><h2 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h2><h3 id="括号匹配机制"><a href="#括号匹配机制" class="headerlink" title="括号匹配机制"></a>括号匹配机制</h3><p>在我们常规的表达式中，例如 $2 \times [3 \times (3+2)+1]$ ，或者代码中的每个<code>()[]&#123;&#125;</code>的校验中，如何来校验我们在写代码的时候是否会多了个括号或者少了个括号。</p><p>经过观察你会发现，正确的匹配规则是：<strong>每一个右括号都有与之对应的唯一的左括号</strong>，现在我们就可以将一堆括号从左往右或者从右往左扫描，每次扫描到一个左括号，将其压入栈中，每扫描到一个右括号就将栈顶元素弹出，表示与之匹配。其扫描匹配过程会遇到如下情况：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae3679e4d0.png" alt="image-20220809034941462" style="zoom:50%;" /><blockquote><p>图片来源：王道数据结构</p></blockquote><h3 id="算法实例"><a href="#算法实例" class="headerlink" title="算法实例"></a>算法实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> top;    <span class="comment">//栈顶指针</span></span><br><span class="line">    ElemType brackets[MaxSize]; <span class="comment">//栈内存空间</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(Stack *s)</span>&#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;    <span class="comment">//栈顶指针设置为-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(Stack *s,ElemType data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top==MaxSize<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈已满，入栈失败\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s-&gt;top++;   <span class="comment">//栈顶指针+1</span></span><br><span class="line">        s-&gt;brackets[s-&gt;top] = data; <span class="comment">//新数据填入栈顶</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 %c 入栈成功\n&quot;</span>, data);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前栈顶指针为：%d\n&quot;</span>, s-&gt;top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">ElemType <span class="title function_">Pop</span><span class="params">(Stack *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空栈，弹出失败\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s-&gt;top--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 %c 弹出成功\n&quot;</span>, s-&gt;brackets[s-&gt;top + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;top == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;当前栈为空栈\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;当前栈顶指针为：%d,栈顶元素为 %c\n&quot;</span>, s-&gt;top,s-&gt;brackets[s-&gt;top]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;brackets[s-&gt;top + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(Stack *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断括号是否合法</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BracketCheck</span><span class="params">(<span class="type">char</span> str[],<span class="type">int</span> length)</span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    InitStack(&amp;s);  <span class="comment">//初始化栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i]==<span class="string">&#x27;(&#x27;</span> || str[i]==<span class="string">&#x27;&#123;&#x27;</span> || str[i]==<span class="string">&#x27;[&#x27;</span>)  <span class="comment">//扫描所有左括号</span></span><br><span class="line">        &#123;</span><br><span class="line">            Push(&amp;s, str[i]);   <span class="comment">//遇到左括号压入栈</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (StackEmpty(&amp;s))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;扫描到右括号，但是栈为空\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> temp = Pop(&amp;s);</span><br><span class="line">            <span class="keyword">if</span> (temp+<span class="number">1</span>==str[i] || temp+<span class="number">2</span>==str[i])<span class="comment">//()[]&#123;&#125;的ASCII码差1或者2</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;括号匹配成功，位置 %d\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;括号为：%c不匹配数组 %c位置 %d\n&quot;</span>,temp,str[i],i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i==length<span class="number">-1</span> &amp;&amp; !StackEmpty(&amp;s))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;还有未匹配的左括号在栈中\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;括号匹配合法\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行测试</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">10</span>] = &#123;<span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>&#125;;</span><br><span class="line">    BracketCheck(str, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae36e55a3f.png" alt="image-20220809034325713" style="zoom:80%;" /><h2 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h2><h3 id="表达式基础"><a href="#表达式基础" class="headerlink" title="表达式基础"></a>表达式基础</h3><p>现在看一个我们小学熟悉的式子：$(5 \times (3+2)) \div 3-2$ ，这个式子，它由于有运算符和括号优先级，而导致其计算需要一定的顺序。<strong>这种我们常见的式子被称为：中缀表达式</strong>。它由三个部分组成：<strong>操作数，运算符，界限符</strong>（即括号）。</p><p>不难发现，这三者不可缺一，否则会导致结果出错，和常规的线性代数一样，数学家发现方程式的未知数指代可以用矩阵的位置来表示。同样的，波兰的一个数学家发明了：<strong>前缀表达式（波兰表达式）和后缀表达式（逆波兰表达式）</strong>来去除了界限符的使用，同样可以正确的得到计算结果。</p><p>综上所述，表达式可以分为如下三种：</p><ul><li><strong>中缀表达式</strong>：也就是我们所熟悉的表达式，<strong>例如 $a \times b$ ，它将运算符放在两个操作数的中间</strong>。</li><li><strong>前缀表达式</strong>：波兰表达式，<strong>例如 $\times a b$ ，它将运算符放在两个操作数的前面</strong>。</li><li><strong>后缀表达式</strong>：逆波兰表达式，<strong>例如 $a b \times$ ，它将运算符放在两个操作数的后面</strong> 。</li></ul><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><h4 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h4><p>初始化一个栈，<strong>用于保存暂时还不能确定运算顺序的运算符</strong>。</p><p>从左到右处理各个元素，直到末尾。可能遇到三种情况：</p><ul><li><p><strong>遇到操作数</strong>：直接加入后缀表达式</p></li><li><p><strong>遇到界限符</strong>：遇到<code>(</code>直接入栈；遇到<code>)</code>则依次弹出栈内运算符并加入后缀表达式，直到弹出<code>(</code>为止</p><blockquote><p><code>(</code>不加入后缀表达式</p></blockquote></li><li><p><strong>遇到运算符</strong>：<strong>依次弹出栈中优先级高于或者等于当前运算符的所有运算符</strong>，并加入后缀表达式，若碰到<code>(</code>或者栈空则停止。之后再把当前运算符入栈。</p></li></ul><h4 id="后缀-前缀表达式计算"><a href="#后缀-前缀表达式计算" class="headerlink" title="后缀&#x2F;前缀表达式计算"></a>后缀&#x2F;前缀表达式计算</h4><p>后缀表达式计算：<strong>从左往右扫描，遇到操作数则压入栈中，遇到操作符，就将栈中最近的两个操作数弹出进行计算，其结果再压入栈中，直到最后，栈中只有一个元素，其就是运算结果</strong>。</p><p>前缀表达式计算：<strong>从右往左扫描，遇到操作数则压入栈中，遇到操作符，则将栈中最近的两个操作数弹出进行计算并将结果压入栈中，直到最后，栈中只有一个元素，其为运算结果</strong>。</p><blockquote><p>需要注意的是，<strong>后缀表达式</strong>中先弹出的操作数是被操作数（<strong>即<code>后弹出来的操作数 操作符 先弹出来的操作数</code><strong>），而</strong>前缀表达式</strong>中先弹出的操作数是操作数（**即<code>先弹出的操作数 操作符 后弹出来的操作数</code>**）。</p></blockquote><h4 id="中缀表达式的计算"><a href="#中缀表达式的计算" class="headerlink" title="中缀表达式的计算"></a>中缀表达式的计算</h4><p><strong>中缀表达式的计算就是上述两个算法的结合</strong>，先将中缀表达式转换为后缀表达式，再利用后缀表达式计算结果。</p><p>如下算法是两个算法的结合版，即一边转后缀表达式一边计算，而不是先后顺序，用栈实现：</p><ul><li>初始化两个栈，<strong>操作数栈和运算符栈</strong></li><li>若扫描到操作数，压入操作数栈</li><li>若扫描到运算符或者界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，<strong>每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应的运算，运算结果再压回栈内</strong>）</li></ul><h3 id="算法实例-1"><a href="#算法实例-1" class="headerlink" title="算法实例"></a>算法实例</h3><p>说明：我使用了两种方法分别实现了中缀表达式的计算</p><ul><li>第一种是常规的先将中缀表达式转换为后缀表达式，然后再通过后缀表达式来计算获得结果。</li><li>第二种是将两者结合起来，一边转换为中缀表达式一边来计算结果，即上述的<strong>中缀表达式的计算</strong>的算法说明</li></ul><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> top;    <span class="comment">//栈顶指针</span></span><br><span class="line">    ElemType brackets[MaxSize]; <span class="comment">//栈内存空间</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;    <span class="comment">//栈顶指针设置为-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(Stack* s, ElemType data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == MaxSize - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈已满，入栈失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s-&gt;top++;   <span class="comment">//栈顶指针+1</span></span><br><span class="line">        s-&gt;brackets[s-&gt;top] = data; <span class="comment">//新数据填入栈顶</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 入栈成功\n&quot;</span>, data);</span><br><span class="line">        <span class="comment">//printf(&quot;当前栈顶指针为：%d\n&quot;, s-&gt;top);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">ElemType <span class="title function_">Pop</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空栈，弹出失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s-&gt;top--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 弹出成功\n&quot;</span>, s-&gt;brackets[s-&gt;top + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;top == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;当前栈为空栈\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;当前栈顶指针为：%d,栈顶元素为 %d\n&quot;</span>, s-&gt;top, s-&gt;brackets[s-&gt;top]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;brackets[s-&gt;top + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素</span></span><br><span class="line">ElemType <span class="title function_">ReadStackHead</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(&amp;s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;brackets[s-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符优先级判断</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Priority</span><span class="params">(<span class="type">char</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="string">&#x27;*&#x27;</span> || x==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="string">&#x27;(&#x27;</span> || x==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断后缀或者前缀表达式是否正确</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CheckExpression</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="type">int</span> operand = <span class="number">0</span>;    <span class="comment">//操作数的个数</span></span><br><span class="line">    <span class="type">int</span> operator= <span class="number">0</span>;    <span class="comment">//操作符的个数</span></span><br><span class="line">    <span class="type">int</span> bracketsNum = <span class="number">0</span>;    <span class="comment">//括号计数器</span></span><br><span class="line">    <span class="type">bool</span> lastIsNum =<span class="literal">false</span>;  <span class="comment">//记录扫描到的是不是数值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span> || str[i] == <span class="string">&#x27;*&#x27;</span> || str[i] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果连续是运算符则返回表达式错误</span></span><br><span class="line">            <span class="keyword">if</span> (!lastIsNum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;输入的表达式错误\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            operator++;</span><br><span class="line">            lastIsNum = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bracketsNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bracketsNum--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果连续两个都是数值就直接返回表达式错误</span></span><br><span class="line">            <span class="keyword">if</span> (lastIsNum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;输入的表达式错误\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            operand++;</span><br><span class="line">            lastIsNum = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只有操作数的数量-运算符的数量=1以及括号都配对了</span></span><br><span class="line">    <span class="keyword">if</span> (operand == operator+<span class="number">1</span> &amp;&amp; bracketsNum ==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表达式正确\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的表达式错误\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算后缀表达式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Rpn</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    Stack s;    <span class="comment">//声明栈</span></span><br><span class="line">    InitStack(&amp;s);  <span class="comment">//初始化栈</span></span><br><span class="line">    <span class="type">int</span> ltemp = <span class="number">0</span>;  <span class="comment">//声明左临时操作数</span></span><br><span class="line">    <span class="type">int</span> rtemp = <span class="number">0</span>;  <span class="comment">//声明右临时操作数</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;    <span class="comment">//临时计算结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span> || str[i] == <span class="string">&#x27;*&#x27;</span> || str[i] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rtemp = Pop(&amp;s);    <span class="comment">//先弹出来的</span></span><br><span class="line">            ltemp = Pop(&amp;s);    <span class="comment">//后弹出来</span></span><br><span class="line">            <span class="keyword">switch</span> (str[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res = ltemp + rtemp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res = ltemp - rtemp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res = ltemp * rtemp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                res = ltemp / rtemp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Push(&amp;s, res);  <span class="comment">//结果压入栈中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Push(&amp;s, str[i]);   <span class="comment">//遇到操作数压入栈中</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;扫描到数值:%d位置:%d 已成功入栈\n&quot;</span>, str[i], i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;计算完成，返回结果:%d&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中缀表达式转后缀表达式</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ConvertRpn</span><span class="params">(<span class="type">char</span> str[],<span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!CheckExpression(str, length))   <span class="comment">//检查表达式是否正确</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack opStack;  <span class="comment">//声明运算符栈</span></span><br><span class="line">    InitStack(&amp;opStack);    <span class="comment">//初始化栈</span></span><br><span class="line">    <span class="type">char</span> rpn[MaxSize];  <span class="comment">//后缀表达式数组</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">//后缀表达式数组临时指针</span></span><br><span class="line">    <span class="type">char</span> tempchar;  <span class="comment">//创建一个临时变量承载栈弹出的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span> || str[i] == <span class="string">&#x27;*&#x27;</span> || str[i] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//空栈的时候或者扫描到的运算符优先级大于栈中运算符的优先级直接将字符压入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (StackEmpty(&amp;opStack)||  Priority((<span class="type">char</span>)str[i]) &gt; Priority((<span class="type">char</span>)ReadStackHead(&amp;opStack)))</span><br><span class="line">            &#123;</span><br><span class="line">                Push(&amp;opStack, str[i]); <span class="comment">//遇到不确定操作符压入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当扫描到的运算符优先级小于等于栈顶元素的优先级，将栈顶运算符弹出加入后缀表达式数组</span></span><br><span class="line">                <span class="keyword">if</span> (Priority((<span class="type">char</span>)str[i]) &lt;= Priority((<span class="type">char</span>)ReadStackHead(&amp;opStack)))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> ((<span class="type">char</span>)ReadStackHead(&amp;opStack)!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tempchar = Pop(&amp;opStack);   <span class="comment">//弹出运算符</span></span><br><span class="line">                        rpn[j] = tempchar;  <span class="comment">//运算符加入后缀表达式</span></span><br><span class="line">                        j++;</span><br><span class="line">                        <span class="keyword">if</span> (StackEmpty(&amp;opStack))</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Push(&amp;opStack, str[i]); <span class="comment">//遇到不确定操作符压入栈</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            Push(&amp;opStack, str[i]); <span class="comment">//遇到左括号压入栈中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            tempchar = Pop(&amp;opStack);   <span class="comment">//弹出运算符</span></span><br><span class="line">            <span class="keyword">while</span> (tempchar!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rpn[j] = tempchar;  <span class="comment">//运算符加入后缀表达式</span></span><br><span class="line">                tempchar = Pop(&amp;opStack);   <span class="comment">//弹出运算符</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            rpn[j] = str[i];    <span class="comment">//扫描到操作数，直接加入后缀表达式中</span></span><br><span class="line">            j++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;操作数 %d 放入后缀表达式数组\n&quot;</span>, str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后判断栈中有没有运算符 有就直接输出加入到后缀表达式数组</span></span><br><span class="line">    <span class="keyword">if</span> (!StackEmpty(&amp;opStack))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (opStack.top != <span class="number">-1</span>) &#123;</span><br><span class="line">            tempchar = Pop(&amp;opStack);   <span class="comment">//弹出运算符</span></span><br><span class="line">            rpn[j] = tempchar;  <span class="comment">//运算符加入后缀表达式</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出转换后的后缀表达式-因为字符问题，输出的+-*/为ASCII对应的十进制数值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;转换后的后缀表达式为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, rpn[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新数组的数量为：%d\n&quot;</span>, j);</span><br><span class="line">    <span class="comment">//转换完成的后缀表达式传递给后缀表达式计算函数</span></span><br><span class="line">    Rpn(rpn,j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这是个正确的后缀表达式，如果直接使用中缀转后缀会给表达式合法性检测返回错误，其表达式值我记得是5</span></span><br><span class="line">    <span class="comment">//char st[MaxSize] = &#123; 15,7,1,1,&#x27;+&#x27;,&#x27;-&#x27;,&#x27;/&#x27;,3,&#x27;*&#x27;,2,1,1,&#x27;+&#x27;,&#x27;+&#x27;,&#x27;-&#x27;&#125;;</span></span><br><span class="line">    <span class="comment">//中缀表达式数组——该中缀表达式正确值为16</span></span><br><span class="line">    <span class="type">char</span> st[MaxSize] = &#123; <span class="number">2</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="number">9</span>,<span class="string">&#x27;+&#x27;</span>,<span class="number">6</span>,<span class="string">&#x27;/&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;-&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="comment">//计算结果-我将中缀转后缀和后缀表达式的计算写在一起了，详情可以查看中缀转后缀表达式导数第二行</span></span><br><span class="line">    ConvertRpn(st, <span class="built_in">strlen</span>(&amp;st));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上算法，说明以及注意事项：</p><ol><li><p>需要<strong>将表达式输入到<code>main</code>函数中的<code>st</code>数组</strong>中，<strong>如果你给定的数组字符大于<code>MaxSize</code>(18)的数量</strong>建议<strong>将<code>MaxSize</code>修改为大于你输入的表达式的字符数量</strong>，以防栈溢出而出现错误。</p></li><li><p>对于你给定的式子，例如 $2 \times (2+3)$ ，<strong>除了字符需要加单引号，数值不需要加单引号(<code>&#39;&#39;</code>)<strong>，由于我利用了<code>char</code>类型的内存占用，所以</strong>你可以输入参与计算的单个数值范围为$-128 \sim 127$</strong> 。</p><blockquote><p>具体原理查看<a href="httpss://www.helloseraphine.top/2022/08/01/C%E8%AF%AD%E8%A8%80/%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E6%80%9D%E8%80%83/#char%E7%B1%BB%E5%9E%8B">关于C语言的一些零碎思考</a></p></blockquote></li><li><p>我加入了中缀表达式验证函数，<strong>原理是根据括号的匹配和操作符和运算符的关系，以及不可能出现的连续两个数值或者运算符来验证的</strong>，我不确定是否还有一些能够逃过该验证的表达式，除非你输入了非法数值。</p></li><li><p>如上代码在<code>Visual Studio</code>的<code>C++</code>模块编译可以正确运行，但是会产生一个警告<code>可能没有为“st”添加字符串零终止符</code>，在<code>Visual Studio Code</code>链接的<code>GCC</code>编译器无报错可以正确运行。</p></li></ol><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中缀表达式计算-结合版</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InfixExpCalculate</span><span class="params">(<span class="type">char</span> str[],<span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="comment">//中缀表达式合法性检测</span></span><br><span class="line">    <span class="keyword">if</span> (!CheckExpression(str, length))   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack operandStack; <span class="comment">//操作数栈</span></span><br><span class="line">    Stack operatorStack;    <span class="comment">//运算符栈</span></span><br><span class="line">    InitStack(&amp;operandStack);   <span class="comment">//初始化栈</span></span><br><span class="line">    InitStack(&amp;operatorStack);  <span class="comment">//初始化栈</span></span><br><span class="line">    <span class="comment">//遍历中缀表达式——即传入的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//扫描到运算符或者左括号</span></span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span> || str[i] == <span class="string">&#x27;*&#x27;</span> || str[i] == <span class="string">&#x27;/&#x27;</span> || str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;)&#x27;</span> || str[i]==<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;当前数值:%d,当前字符为:%c\n&quot;</span>, str[i]);</span><br><span class="line">            <span class="comment">//如果运算符栈为空或者扫描到的运算符优先级大于栈顶运算符的优先级</span></span><br><span class="line">            <span class="keyword">if</span> (StackEmpty(&amp;operatorStack) || ReadStackHead(&amp;operatorStack) == <span class="string">&#x27;(&#x27;</span>|| str[i] == <span class="string">&#x27;(&#x27;</span> || ((str[i]+<span class="number">3</span>)%<span class="number">10</span> &lt; (ReadStackHead(&amp;operatorStack))%<span class="number">10</span> &amp;&amp;  str[i]!=<span class="string">&#x27;)&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                Push(&amp;operatorStack, str[i]);   <span class="comment">//将未确定的运算符压入栈中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//弹出运算符到左括号前</span></span><br><span class="line">                <span class="keyword">while</span> (ReadStackHead(&amp;operatorStack) != <span class="string">&#x27;(&#x27;</span> &amp;&amp; !StackEmpty(&amp;operatorStack))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//弹出运算符-紧接着计算值再压回操作数栈内</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;当前操作符栈顶为   %c\n&quot;</span>, ReadStackHead(&amp;operatorStack));</span><br><span class="line">                    <span class="keyword">switch</span> ((<span class="type">char</span>)Pop(&amp;operatorStack))</span><br><span class="line">                    &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        Push(&amp;operandStack, (Pop(&amp;operandStack) + Pop(&amp;operandStack)));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        Push(&amp;operandStack, -(Pop(&amp;operandStack) - Pop(&amp;operandStack)));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        Push(&amp;operandStack, (Pop(&amp;operandStack) * Pop(&amp;operandStack)));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="type">int</span> temp1 = Pop(&amp;operandStack);</span><br><span class="line">                            <span class="type">int</span> temp2 = Pop(&amp;operandStack);</span><br><span class="line">                            Push(&amp;operandStack, temp2/temp1);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果扫描到右括号</span></span><br><span class="line">                <span class="keyword">if</span> (ReadStackHead(&amp;operatorStack) == <span class="string">&#x27;(&#x27;</span> &amp;&amp; str[i]==<span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    Pop(&amp;operatorStack); <span class="comment">//将左括号弹出</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">int</span>)str[i] !=<span class="number">33</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Push(&amp;operatorStack, str[i]);   <span class="comment">//将未确定的运算符压入栈中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//扫描到数值</span></span><br><span class="line">            Push(&amp;operandStack, str[i]);    <span class="comment">//将操作数压入操作数栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;计算结果为: %d&quot;</span>, Pop(&amp;operandStack));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> st[MaxSize] = &#123; <span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="number">15</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="number">7</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;!&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">//中缀表达式数组</span></span><br><span class="line">    <span class="comment">//char st[MaxSize] = &#123; 2,&#x27;*&#x27;,&#x27;(&#x27;,9,&#x27;+&#x27;,6,&#x27;/&#x27;,3,&#x27;-&#x27;,5,&#x27;)&#x27;,&#x27;+&#x27;,4,&#x27;!&#x27; &#125;;</span></span><br><span class="line">    <span class="comment">//计算结果</span></span><br><span class="line">    InfixExpCalculate(st, <span class="built_in">strlen</span>(st));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li><p>该<strong>代码兼容上述的第一种方法，是在同一个文件内编写的</strong>，所以如果你<strong>要使用需要将代码复制在同一个文件夹内的代码</strong>最下面。</p></li><li><p>除法部分请不要修改，我尝试使用<code>Push(&amp;operandStack, 1/(Pop(&amp;operandStack)/Pop(&amp;operandStack)));</code>来提高代码复用，很不幸，此代码逻辑上没有问题，但是无法通过编译器，给我反馈的错误是<code>整数除以零</code>，我不得已借助变量来完成运算。</p></li><li><p>使用第二章同步的中缀表达式计算需要注意，表达式仍然和第一种的规则一致，<strong>不过最后需要加上<code>&#39;!&#39;</code>来表示表达式结束</strong>，因为我尝试去少写代码，来完成更多的工作，所以请在最后加上<code>&#39;!&#39;</code>表示结束。</p></li><li><p>同样的，为了防止因为表达式的问题而导致计算结果错误，我改进了表达式检测合法函数的部分代码，如果你需要使用第二种算法来计算，则需要使用这部分检测代码，<strong>当然你也可以继续使用第一种的检测代码，不过需要将<code>for</code>循环中的<code>length</code>进行<code>-1</code>即可</strong>。改进后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断后缀或者前缀表达式是否正确</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CheckExpression</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (length&gt;=MaxSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表达式可能会溢出栈，请修改MaxSize大小&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str[length<span class="number">-1</span>] != <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;缺少表达式结束符 &#x27;!&#x27;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> operand = <span class="number">0</span>;    <span class="comment">//操作数的个数</span></span><br><span class="line">    <span class="type">int</span> operator= <span class="number">0</span>;    <span class="comment">//操作符的个数</span></span><br><span class="line">    <span class="type">int</span> bracketsNum = <span class="number">0</span>;    <span class="comment">//括号计数器</span></span><br><span class="line">    <span class="type">bool</span> lastIsNum =<span class="literal">false</span>;  <span class="comment">//记录扫描到的是不是数值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前数值:%d,当前字符:%c\n&quot;</span>, str[i], str[i]);</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span> || str[i] == <span class="string">&#x27;*&#x27;</span> || str[i] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果连续是运算符则返回表达式错误</span></span><br><span class="line">            <span class="keyword">if</span> (!lastIsNum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;输入的表达式错误,位置 %d,字符 %c\n&quot;</span>,i+<span class="number">1</span>,str[i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            operator++;</span><br><span class="line">            lastIsNum = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bracketsNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bracketsNum--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果连续两个都是数值就直接返回表达式错误</span></span><br><span class="line">            <span class="keyword">if</span> (lastIsNum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;输入的表达式错误,位置 %d,字符 %c\n&quot;</span>, i + <span class="number">1</span>, str[i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            operand++;</span><br><span class="line">            lastIsNum = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只有操作数的数量-运算符的数量=1以及括号都配对了</span></span><br><span class="line">    <span class="keyword">if</span> (operand == operator+<span class="number">1</span> &amp;&amp; bracketsNum ==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表达式正确\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的表达式错误\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：改进后的函数和第一种算法的函数不兼容，也就是说你使用第一种算法只能用第一种该函数检测合法性，而第二种算法可以选择稍微修改第一种函数代码来兼容或者使用该改进后的代码</p></blockquote></li><li><p>如上代码在<code>Visual Studio</code>的<code>C++</code>模块编译可以正确运行无报错，很不幸第二种在<code>Visual Studio Code</code>链接的<code>GCC</code>编译器可以正确运行但是计算结果会出现偏差，具体原因我并未研究。</p></li></ol><h2 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h2><p>递归函数的特点是最后执行的，最先结束，这点和栈如出一辙。</p><p>对于<code>C</code>语言来说，函数的递归就是将每个函数压入栈的过程，当最后的递归函数被返回时，则依次将其弹出函数栈来表示函数的结束，进而完成整个递归函数。</p><blockquote><p>更多详细内容查看<a href="httpss://blog.csdn.net/weixin_60478154/article/details/124548388">【C语言】函数——栈帧的创建和销毁</a></p></blockquote><p>递归适合解决的问题：可以把原始问题转换为<strong>属性相同</strong>，但是<strong>规模较小</strong>的问题。</p><h2 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h2><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p>这是树，当然这些会在后面树的部分进行详细说明：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae37c698b3.png" alt="image-20220813104157667" style="zoom:50%;" /><p>我们在遍历树的时候，就需要利用队列的队头出，队尾增。我们在遍历节点 1 的时候，需要将其子节点 2 ，3 加入到队列后紧跟节点 1 ，处理完节点 1 后将节点 1 弹出，处理节点 2 ，3 。同理处理节点 2，3 的时候将其子节点加入队列，依次反复，直到完成树的遍历。</p><h3 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h3><p>这是一个图，同样的会在后面图的部分进行详细说明：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae380dc3af.png" alt="image-20220813104624420" style="zoom:67%;" /><p>我们在对图的广度优先遍历的时候也需要用到队列的思想，和树的层次遍历类似，从节点1 开始，处理节点 1 的时候将其子节点加入到队列中，然后再处理子节点的时候再将其子节点的节点加入队列，如此反复。</p><h3 id="队列在操作系统中的应用"><a href="#队列在操作系统中的应用" class="headerlink" title="队列在操作系统中的应用"></a>队列在操作系统中的应用</h3><p>多个进程争抢使用有限的系统资源时，<strong>FCFS（First Come First Service，先来先服务）</strong>。</p><p>多个进程进行队列，先进入队列的程序（进程）会先在 CPU 执行一个时间片，然后弹出队列，执行下一个队头进程，如此反复。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>不想写啊啊啊啊啊。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae38496e45.png" alt="image-20220813112304983" style="zoom:20%;" />]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【4.1】串</title>
      <link href="/2022/01/28/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%904.1%E3%80%91%E4%B8%B2/"/>
      <url>/2022/01/28/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%904.1%E3%80%91%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于计算机的发展，人们发现对于非数值类型的处理越来越多，进而衍生出来串。</p><p>串也就是我们所使用的字符串。</p><p>如下所有代码需要做如下引用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你使用的是Visual Studio，则还需要添加如下一条引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br></pre></td></tr></table></figure><blockquote><p>关于上述引用的说明，原因参考<a href="httpss://www.helloseraphine.top/2022/08/01/C%E8%AF%AD%E8%A8%80/%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E6%80%9D%E8%80%83/#Bool%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98">关于C语言的一些零碎思考</a></p></blockquote><h1 id="串的定义和基本操作"><a href="#串的定义和基本操作" class="headerlink" title="串的定义和基本操作"></a>串的定义和基本操作</h1><h2 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h2><p><strong>串，即字符串（String）是由零个或者多个字符组成的有限序列</strong>，一般记作<code>S=&#39;a1,a2,...an&#39;</code>（$n \geqslant 0 $）。</p><p>其中<code>S</code>是串的名称，单引号括起来的字符序列是串的值，其中串字符的个数称为串的长度。<strong>当 $n &#x3D;0$ 的时候称为空串</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">&quot;Hello,World&quot;</span></span><br></pre></td></tr></table></figure><p>子串：串中任意连续个字符组成的子序列，例如：上面的子串<code>Hello</code>。</p><p><strong>串的数据对象限定为：字符集（如中文字符，英文字符）</strong>。</p><h2 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>StrAssign()</code></td><td>赋值操作，给字符串赋值</td></tr><tr><td><code>StrCopy()</code></td><td>复制操作，将两个字符串进行复制</td></tr><tr><td><code>StrEmpty()</code></td><td>判断字符串是否为空</td></tr><tr><td><code>StrLength()</code></td><td>获取字符串长度，返回串元素的个数</td></tr><tr><td><code>ClearString()</code></td><td>清空操作，清空串为空串</td></tr><tr><td><code>DestoryString()</code></td><td>销毁串</td></tr><tr><td><code>Concat()</code></td><td>串链接，链接两个字符串返回新串</td></tr><tr><td><code>SubString()</code></td><td>获取子串，根据元素位置和长度返回其子串</td></tr><tr><td><code>Index()</code></td><td>定位子串的位置（第一次出现的）</td></tr><tr><td><code>StrCompare()</code></td><td>串比较操作</td></tr></tbody></table><h1 id="串的物理结构"><a href="#串的物理结构" class="headerlink" title="串的物理结构"></a>串的物理结构</h1><h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><h4 id="静态顺序存储"><a href="#静态顺序存储" class="headerlink" title="静态顺序存储"></a>静态顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxLen 255<span class="comment">//定义串的最大长度为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">char</span> ch[MaxLen];</span><br><span class="line"><span class="type">int</span> length;<span class="comment">//串的长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><h4 id="动态顺序存储"><a href="#动态顺序存储" class="headerlink" title="动态顺序存储"></a>动态顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">char</span> *ch;<span class="comment">//用malloc函数申请一片空间，指针指向头地址</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//串的长度</span></span><br><span class="line">&#125;DString;</span><br></pre></td></tr></table></figure><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stringNode</span> &#123;</span></span><br><span class="line"><span class="type">char</span> ch;<span class="comment">//每个节点存储一个字符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stringNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;StrNode;</span><br></pre></td></tr></table></figure><p>由于<code>char</code>类型只占一个字节，而<code>struct stringNode*</code>类型指针占四个字节，所以采用上述链式存储的存储密度很低。如果想要使用链式存储，可以尝试使用如下改进：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stringNode</span> &#123;</span></span><br><span class="line"><span class="type">char</span> ch[<span class="number">4</span>];<span class="comment">//每个节点存储一个字符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stringNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;StrNode;</span><br></pre></td></tr></table></figure><p>这样每个节点存储四个字节的字符和四个字节的指针。</p><h2 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h2><p>注：本示例基本操作的实现是基于静态顺序的存储结构</p><h3 id="截取（获取）子串"><a href="#截取（获取）子串" class="headerlink" title="截取（获取）子串"></a>截取（获取）子串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求子串（获取子串）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SubString</span><span class="params">(SString* s, SString* sub, <span class="type">int</span> pos, <span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (pos + len &gt; s-&gt;length) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子串索引超出主串\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;截取的字符串为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">sub-&gt;ch[i] = s-&gt;ch[pos + i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, sub-&gt;ch[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">sub-&gt;length = len;<span class="comment">//修改子串的长度</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(SString* s1, SString* s2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s1-&gt;length==<span class="number">0</span> || s2-&gt;length==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;存在空串&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-99</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要匹配的字符串为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s2-&gt;length; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s2-&gt;ch[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1-&gt;length &amp;&amp;i&lt;s2-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s1-&gt;ch[i]!=s2-&gt;ch[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> s1-&gt;ch[i] - s2-&gt;ch[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s1-&gt;length - s2-&gt;length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定位子串的位置"><a href="#定位子串的位置" class="headerlink" title="定位子串的位置"></a>定位子串的位置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定位操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString* s, SString* sub)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;length == <span class="number">0</span> || sub-&gt;length == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;存在空串&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-99</span>;</span><br><span class="line">&#125;</span><br><span class="line">SString temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//取子串</span></span><br><span class="line">SubString(s, &amp;temp, i, sub-&gt;length);</span><br><span class="line"><span class="keyword">if</span> (StrCompare(&amp;temp, sub) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子串匹配成功，位置为：%d&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;未匹配到字符串&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">SString s = &#123; &#123; <span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span> &#125;,<span class="number">5</span> &#125;;</span><br><span class="line">SString sub = &#123; &#123; <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span> &#125;,<span class="number">2</span> &#125;;</span><br><span class="line">Index(&amp;s, &amp;sub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae3ddb71bb.png" alt="image-20220813171339807" style="zoom:80%;" /><h1 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h1><p>通俗来说就是上面所实现的字符串的操作的“定位子串的位置”，俗称“暴力解”。</p><p>现在来通过数组下标来实现朴素模式匹配算法，也就是上面的定位操作，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朴素模式匹配算法——利用数组下标</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NaiveMatch</span><span class="params">(<span class="type">char</span>* s[],<span class="type">char</span>* m[])</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;<span class="comment">//模式串下标指针</span></span><br><span class="line"><span class="type">char</span> temp[MaxLen];<span class="comment">//临时字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="built_in">strlen</span>(s)-<span class="built_in">strlen</span>(m)+<span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">SubString(s, temp, i, <span class="built_in">strlen</span>(m));<span class="comment">//获取指定长度字符串存储到临时字符串中</span></span><br><span class="line"><span class="comment">//比较截取的字符串和模式串</span></span><br><span class="line"><span class="keyword">if</span> (StrCompare(temp, s)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;<span class="comment">//模式串指针+1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">j = j - i + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果模式串指针超过了模式串的长度，意味着匹配到了合适的字符串</span></span><br><span class="line"><span class="keyword">if</span> (i&gt;<span class="built_in">strlen</span>(m))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;已匹配到字符串，位置:%d&quot;</span>, <span class="built_in">strlen</span>(s) - <span class="built_in">strlen</span>(m)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strlen</span>(s) - <span class="built_in">strlen</span>(m)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;匹配失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> s[MaxLen] = &#123; <span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span> &#125;;</span><br><span class="line"><span class="type">char</span> sub[MaxLen] = &#123; <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span> &#125;;</span><br><span class="line">NaiveMatch(&amp;s, &amp;sub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae3e2c52b7.png" alt="image-20220817021229084" style="zoom:80%;" /><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="KMP算法简介"><a href="#KMP算法简介" class="headerlink" title="KMP算法简介"></a>KMP算法简介</h2><p><em>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，<a href="httpss://baike.baidu.com/item/函数/18686609">函数</a>本身包含了模式串的局部匹配信息。KMP算法的<a href="httpss://baike.baidu.com/item/时间复杂度/1894057">时间复杂度</a>O(m+n)</em></p><blockquote><p>如上来源：百度百科<a href="httpss://baike.baidu.com/item/kmp%E7%AE%97%E6%B3%95/10951804?fromtitle=KMP&fromid=10158450&fr=aladdin">kmp算法</a></p></blockquote><p>KMP算法是在上面的朴素模式匹配算法的基础上改进而来</p><h2 id="KMP算法实例"><a href="#KMP算法实例" class="headerlink" title="KMP算法实例"></a>KMP算法实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求Next数组</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetNext</span><span class="params">(<span class="type">char</span>* m[],<span class="type">char</span>* next[])</span> &#123;</span><br><span class="line"><span class="type">int</span> i, k;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(m))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (k==<span class="number">0</span> || m[i]==m[k])</span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line">++k;</span><br><span class="line">next[i] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改进KMP算法"><a href="#改进KMP算法" class="headerlink" title="改进KMP算法"></a>改进KMP算法</h2><p>不想写，欠……</p><p>这部分内容有点繁杂，我在尝试使用更加直观的方法来说明。如上也同理，仅贴代码示例；</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae3eabfe68.png" alt="image-20220818020541675" style="zoom: 33%;" /><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>救命越来越不想写了，属实太难用文字解释了，如果用视频的话要比文字快很多。</p>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【5.1】树与二叉树</title>
      <link href="/2022/01/28/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%905.1%E3%80%91%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/01/28/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%905.1%E3%80%91%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h1><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>树是一种数据结构，它和我们现实生活中的树非常类似，其存在一个根节点，向下分裂，产生分支节点，如此，形成了如下图所示的“树”：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae446c2cdb.png" alt="image-20220818031232002" style="zoom: 67%;" /><blockquote><p>图片来源王道《数据结构》</p></blockquote><p>当然，存在一种特殊的树——空树，也就是结点树为 0 的树。</p><p>非空树的特性：</p><ul><li>有且仅有一个根节点</li><li>没有后继的结点称为“叶子结点”（终端结点）</li><li>有后继的结点称为“分支节点”（非终端结点）</li></ul><h2 id="结点之间的关系描述"><a href="#结点之间的关系描述" class="headerlink" title="结点之间的关系描述"></a>结点之间的关系描述</h2><ul><li>祖先结点：在当前指定结点前驱到根节点路径上的所有结点（即上层）</li><li>子孙结点：指定结点下面的所有结点</li><li>双亲结点：指定结点的前驱结点</li><li>孩子结点：指定结点的直接后继</li><li>兄弟结点：指定结点同一层且同一个前驱的结点</li><li>堂兄弟结点：指定结点同一层且不是同一个前驱的结点</li><li><strong>结点之间的路径：根结点到指定结点（只能从上往下）</strong></li><li><strong>路径长度：指的经过了几条边（只能从上往下）</strong></li></ul><h2 id="结点，树的属性描述"><a href="#结点，树的属性描述" class="headerlink" title="结点，树的属性描述"></a>结点，树的属性描述</h2><ul><li>结点的层次（深度）：从上往下数</li><li>结点的高度：从下往上数</li><li>树的高度（深度）：总共多少层</li><li><strong>结点的度：结点有几个分支</strong></li><li><strong>树的度：各结点的度的最大值</strong></li></ul><h2 id="树的分类"><a href="#树的分类" class="headerlink" title="树的分类"></a>树的分类</h2><ul><li>有序树：逻辑上树中的结点的<strong>各子树从左到右是有次序的</strong>，不能互换。</li><li>无序树：逻辑上树中的结点的<strong>各子树从左到右是无次序的</strong>，可以互换。</li><li>森林：是由 n 棵互不相交的树的集合</li></ul><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h2><p>二叉树就是每个分支结点都由左子树和右子树组成，图示如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae44b757e2.png" alt="image-20220818040634519" style="zoom: 67%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><p>二叉树可以分为两种：</p><ul><li>空二叉树</li><li>或者由一个根结点和两个互不相交的被称为跟的左子树和右子树组成。左子树和由子树又分别是一颗二叉树。</li></ul><p>二叉树的特点：</p><ul><li><strong>每个结点至多只有两颗子树</strong></li><li><strong>左右子树不能颠倒（二叉树是有序树）</strong></li></ul><h2 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h2><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>一颗树高为 $h$ ，且含有 $2^h-1$ 个结点的二叉树。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae44f545d4.png" alt="image-20220818041148646" style="zoom: 50%;" /><p>其特点：</p><ul><li><strong>只有最后一层有叶子结点</strong></li><li><strong>不存在度为 1 的结点（要么是 2 ，要么是 0）</strong></li><li><strong>按层序从 1 开始编号，结点 $i$ 的左孩子为 $2i$ ，右孩子为 $2i+1$ ；结点 $i$ 的父节点为 $\frac{i}{2}$ （向下取整）</strong></li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>当二叉树的其每个结点都与同高度的满二叉树编号 $1 \sim n$ 的结点一一对应时，称其为完全二叉树。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae453396ac.png" alt="image-20220818042748756" style="zoom:50%;" /><p>其特点：</p><ul><li><strong>只有最后两层可能有叶子结点</strong></li><li><strong>最多只有一个度为 1 的结点</strong></li><li><strong>按层序从 1 开始编号，结点 $i$ 的左孩子为 $2i$ ，右孩子为 $2i+1$ ；结点 $i$ 的父节点为 $\frac{i}{2}$ （向下取整）</strong></li><li><strong>$i \leqslant \frac{n}{2}$ 为分支结点，$i &gt; \frac{n}{2}$ 为叶子结点</strong></li></ul><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>一棵二叉树或者空二叉树，具有如下性质：</p><ul><li><strong>左子树</strong>上所有结点<strong>关键字均小于根节点的关键字</strong></li><li><strong>右子树</strong>上所有结点<strong>关键字均大于根节点的关键字</strong></li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae45727245.png" alt="image-20220818043620187" style="zoom: 50%;" /><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>树上任一结点的<strong>左子树和右子树的深度之差不超过 1</strong> .</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae45aa09d3.png" alt="image-20220818043902145" style="zoom:50%;" /><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><p>和线性表一样，二叉树也可以使用顺序存储和链式存储的方式来建立</p><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><h4 id="完全二叉树-1"><a href="#完全二叉树-1" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>使用顺序存储借助数组，将<strong>完全二叉树</strong>从上到下从左到右按顺序依次存储到数组中，其存储结构代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100<span class="comment">//树的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int<span class="comment">//结点存储的数据类型</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">ElemType value;<span class="comment">//二叉树结点存储的数据</span></span><br><span class="line"><span class="type">bool</span> isEmpty;<span class="comment">//表示该结点是否为空</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过建立数组来建立一个二叉树</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">TreeNode t[MaxSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用顺序存储，对于常用的<strong>完全二叉树</strong>基本操作：</p><ul><li>获取 i 的左孩子：$2i$ </li><li>获取 i 的右孩子：$2i+1$ </li><li>获取 i 的父结点：$\frac{i}{2}$ </li><li>获取 i 所在的层次：$\log_2{(n+1)}$ 或 $log_2{n} + 1$</li></ul><p>如果完全二叉树共有 n 个结点，则：</p><ul><li>判断 i 是否有左孩子：$2i \leq n$</li><li>判断 i 是否有右孩子：$2i+1 \leq n$</li><li>判断 i是否时叶子结点：$i&gt; \frac{n}{2}$</li></ul><h4 id="非完全二叉树"><a href="#非完全二叉树" class="headerlink" title="非完全二叉树"></a>非完全二叉树</h4><p>对于普通的二叉树，不可以直接使用上述的方案来存储，需要将其对应的完全二叉树内容进行重编号来排列，例如：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae45f2a08b.png" alt="image-20220818202840142" style="zoom:67%;" /><p> 如果<strong>非完全二叉树</strong>共有 n 个结点，它的一些基本操作的判断就不能使用上述的完全二叉树来判断了，只能使用定义二叉树时的关键字<code>isEmpty</code>来判断。</p><p>如果非完全二叉树采用顺序存储结构，会造成大量的空间浪费，所以对于顺序存储来说，完全二叉树是最适合的。</p><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">ElemType data;<span class="comment">//结点存储的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//左孩子和右孩子的指针</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化树</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitTree</span><span class="params">(Tree t)</span> &#123;</span><br><span class="line">t = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">t-&gt;data = <span class="number">1</span>;</span><br><span class="line">t-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">t-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae46397bcc.png" alt="image-20220818204141147" style="zoom:80%;" /><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>前排说明：如下的先中后序遍历，层次遍历是伪代码示例，在层次遍历最后我会附上可以执行的<code>C</code>代码说明。</p><h3 id="先-中-后序遍历"><a href="#先-中-后序遍历" class="headerlink" title="先&#x2F;中&#x2F;后序遍历"></a>先&#x2F;中&#x2F;后序遍历</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>先序遍历规则：<strong>根左右（NLR）</strong>，即先遍历根节点，再遍历左结点，再遍历右结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(Tree t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (t!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">GetNodeData((TreeNode*)t);<span class="comment">//先获取根结点的值</span></span><br><span class="line">PreOrder(t-&gt;lchild);<span class="comment">//再获取左边结点的值</span></span><br><span class="line">PreOrder(t-&gt;rchild);<span class="comment">//再获取右边结点的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>先序遍历规则：<strong>左根右（NLR）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(Tree t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">InOrder(t-&gt;lchild);<span class="comment">//先获取左边结点的值</span></span><br><span class="line">GetNodeData((TreeNode*)t);<span class="comment">//再获取根结点的值</span></span><br><span class="line">InOrder(t-&gt;rchild);<span class="comment">//再获取右边结点的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历和先序遍历，只需要将根节点的的获取调换位置即可。</p><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>先序遍历规则：<strong>左右根（NLR）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(Tree t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PostOrder(t-&gt;lchild);<span class="comment">//先获取左边结点的值</span></span><br><span class="line">PostOrder(t-&gt;rchild);<span class="comment">//再获取右边结点的值</span></span><br><span class="line">GetNodeData((TreeNode*)t);<span class="comment">//再获取根结点的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>层序遍历也是我们所符合逻辑上直观的遍历方式，它采用从上到下从左到右的遍历顺序遍历二叉树。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae467edf94.png" alt="image-20220820012743860" style="zoom: 67%;" /><p>实现思路：</p><ol><li>初始化辅助队列</li><li>将根节点压入队</li><li>如果队列非空，则出队读取其数据并将其左右孩子依次入队（队尾）</li><li>然后重复如上，直到队列为空</li></ol><p>代码示例（伪代码）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(Tree t)</span> &#123;</span><br><span class="line"><span class="comment">//创建辅助队列</span></span><br><span class="line">Queue s;</span><br><span class="line"><span class="comment">//将根节点压入队列</span></span><br><span class="line">AddItem(&amp;s, t);</span><br><span class="line"><span class="comment">//如果队列非空</span></span><br><span class="line"><span class="keyword">while</span> (!IsEmpty(&amp;s))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//出队元素并访问</span></span><br><span class="line">GetNodeData(DeQueue(&amp;s));</span><br><span class="line"><span class="comment">//将元素的左右孩子压入队列</span></span><br><span class="line"><span class="keyword">if</span> (t-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">AddItem(&amp;s, t-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span> (t-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">AddItem(&amp;s, t-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树遍历代码"><a href="#二叉树遍历代码" class="headerlink" title="二叉树遍历代码"></a>二叉树遍历代码</h2><p>如下代码为<strong>纯<code>C</code>语言代码</strong>，<strong>使用<code>Visual Studio</code>的<code>C/C++</code>环境编译成功</strong>，<strong>请创建两个头文件</strong>（即<code>.h</code>文件），**分别命名为<code>队列的链式存储.h</code>和<code>二叉树结构.h</code>**。</p><p>如果你问我为什么这么做？我其实是为了复用我在队列部分定义的代码而修改使用的（其实是我很懒），所以你会看到队列的头文件中定义的方法可能有部分没用上，那是因为那是队列的适合定义的代码。</p><p>各个文件内容如下：</p><h3 id="二叉树结构-h"><a href="#二叉树结构-h" class="headerlink" title="二叉树结构.h"></a>二叉树结构.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">ElemType data;<span class="comment">//结点存储的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span><span class="comment">//左孩子和右孩子的指针</span></span><br><span class="line">&#125;TreeNode, * Tree;</span><br></pre></td></tr></table></figure><h3 id="队列的链式存储-h"><a href="#队列的链式存储-h" class="headerlink" title="队列的链式存储.h"></a>队列的链式存储.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;二叉树结构.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType TreeNode*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列元素结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data; <span class="comment">//二叉树结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span> <span class="comment">//下一个结点的指针</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头结点结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">front</span>;</span> <span class="comment">//队列队头指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">rear</span>;</span>  <span class="comment">//队列队尾指针</span></span><br><span class="line">    <span class="type">int</span> size;   <span class="comment">//队列的大小</span></span><br><span class="line">&#125;QHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列-带头结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(QHead* q)</span> &#123;</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;    <span class="comment">//队头指针初始化</span></span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>; <span class="comment">//队尾指针初始化</span></span><br><span class="line">    q-&gt;size = <span class="number">0</span>;    <span class="comment">//初始化队列大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列初始化成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(QHead* q, ElemType data)</span> &#123;</span><br><span class="line">    QNode* qn = (QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));  <span class="comment">//新元素结点申请内存空间</span></span><br><span class="line">    qn-&gt;data = data;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;size &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qn-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//尾指针为空</span></span><br><span class="line">        q-&gt;front = qn;  <span class="comment">//头指针指向第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        qn-&gt;next = q-&gt;rear-&gt;next;   <span class="comment">//新元素的下一个元素指针指向队尾指针的下一个</span></span><br><span class="line">        q-&gt;rear-&gt;next = qn; <span class="comment">//原来的队尾元素指向新队尾元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;rear = qn;   <span class="comment">//尾指针指向第一个元素</span></span><br><span class="line">    q-&gt;size++;  <span class="comment">//队列的长度+1</span></span><br><span class="line">    <span class="comment">//printf(&quot;元素 %d 入队成功,当前队列长度为:%d\n&quot;, data, q-&gt;size);</span></span><br><span class="line">    <span class="comment">//GetHead(q);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队操作</span></span><br><span class="line">ElemType <span class="title function_">DeQueue</span><span class="params">(QHead* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>)  <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    QNode* tempNode = q-&gt;front;</span><br><span class="line">    ElemType tempdata = tempNode-&gt;data; <span class="comment">//获取队头元素</span></span><br><span class="line">    q-&gt;front = tempNode-&gt;next;  <span class="comment">//队头指向新的队头元素</span></span><br><span class="line">    <span class="built_in">free</span>(tempNode); <span class="comment">//释放出队元素的内存空间</span></span><br><span class="line">    q-&gt;size--;  <span class="comment">//队列元素-1</span></span><br><span class="line">    <span class="keyword">return</span> tempdata;    <span class="comment">//返回出队元素数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取队头元素</span></span><br><span class="line">ElemType <span class="title function_">GetHead</span><span class="params">(QHead* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空队列\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;  <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>, q-&gt;front-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Destory</span><span class="params">(QHead* q)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DeQueue(q);</span><br><span class="line">    &#125;</span><br><span class="line">    InitQueue(q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列已销毁\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树-c"><a href="#二叉树-c" class="headerlink" title="二叉树.c"></a>二叉树.c</h3><p>这是本体文件所在，即我定义和使用二叉树的相关方法的文件，也是<code>main</code>入口函数的位置.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;队列的链式存储.h&quot;</span><span class="comment">//引入队列文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化树</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitTree</span><span class="params">(Tree* t)</span> &#123;</span><br><span class="line">(*t) = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化结点完成\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回左节点，为空则返回NULL</span></span><br><span class="line">TreeNode* <span class="title function_">LeftNode</span><span class="params">(TreeNode* node)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> node-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回右节点，为空则返回NULL</span></span><br><span class="line">TreeNode* <span class="title function_">RightNode</span><span class="params">(TreeNode* node)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> node-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结点的数据</span></span><br><span class="line">ElemType <span class="title function_">GetNodeData</span><span class="params">(TreeNode* node)</span> &#123;</span><br><span class="line"><span class="comment">//如果结点不为空</span></span><br><span class="line"><span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;结点数据为:%d\n&quot;</span>, node-&gt;data);</span><br><span class="line"><span class="keyword">return</span> node-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(Tree* t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((*t)!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">GetNodeData((TreeNode*)(*t));<span class="comment">//先获取根结点的值</span></span><br><span class="line">PreOrder(&amp;(Tree*)(*t)-&gt;lchild);<span class="comment">//再获取左边结点的值</span></span><br><span class="line">PreOrder(&amp;(Tree*)(*t)-&gt;rchild);<span class="comment">//再获取右边结点的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(Tree* t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((*t) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">InOrder(&amp;(Tree*)(*t)-&gt;lchild);<span class="comment">//先获取左边结点的值</span></span><br><span class="line">GetNodeData((TreeNode*)(*t));<span class="comment">//再获取根结点的值</span></span><br><span class="line">InOrder(&amp;(Tree*)(*t)-&gt;rchild);<span class="comment">//再获取右边结点的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(Tree* t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((*t) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PostOrder(&amp;(Tree*)(*t)-&gt;lchild);<span class="comment">//先获取左边结点的值</span></span><br><span class="line">PostOrder(&amp;(Tree*)(*t)-&gt;rchild);<span class="comment">//再获取右边结点的值</span></span><br><span class="line">GetNodeData((TreeNode*)(*t));<span class="comment">//再获取根结点的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">LevelOrder</span><span class="params">(Tree* t)</span> &#123;</span><br><span class="line">TreeNode* tempNode;<span class="comment">//临时结点</span></span><br><span class="line">QHead q;<span class="comment">//创建辅助队列</span></span><br><span class="line">InitQueue(&amp;q);<span class="comment">//初始化辅助队列</span></span><br><span class="line">EnQueue(&amp;q, (*t));<span class="comment">//根节点数据入队</span></span><br><span class="line"><span class="keyword">while</span> (q.size!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">tempNode = DeQueue(&amp;q);</span><br><span class="line">GetNodeData(tempNode);<span class="comment">//结点出队并获取结点的值</span></span><br><span class="line"><span class="keyword">if</span> (tempNode-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">EnQueue(&amp;q, tempNode-&gt;lchild);<span class="comment">//将结点的左子树压入队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tempNode-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">EnQueue(&amp;q, tempNode-&gt;rchild);<span class="comment">//将结点的右子树压入队列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建二叉树</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CreateBiTree</span><span class="params">(Tree* t)</span> &#123;</span><br><span class="line">ElemType tempdata;<span class="comment">//存放临时存储数据</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tempdata);<span class="comment">//读取输入数据</span></span><br><span class="line"><span class="keyword">if</span> (tempdata==<span class="number">-999</span>)</span><br><span class="line">&#123;</span><br><span class="line">(*t) = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">(TreeNode*)(*t) = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));<span class="comment">//新结点生成内存空间</span></span><br><span class="line">(*t)-&gt;data = tempdata;<span class="comment">//结点赋值</span></span><br><span class="line">CreateBiTree(&amp;(*t)-&gt;lchild);<span class="comment">//创造左子树</span></span><br><span class="line">CreateBiTree(&amp;(*t)-&gt;rchild);<span class="comment">//创造右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序入口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">Tree t = <span class="literal">NULL</span>;<span class="comment">//声明二叉树</span></span><br><span class="line">InitTree(&amp;t);<span class="comment">//初始化二叉树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入二叉树数据:\n&quot;</span>);</span><br><span class="line">CreateBiTree(&amp;t);<span class="comment">//创建二叉树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建二叉树完成\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=====先序遍历二叉树=====\n&quot;</span>);</span><br><span class="line">PreOrder(&amp;t);<span class="comment">//先序遍历二叉树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=====中序遍历二叉树=====\n&quot;</span>);</span><br><span class="line">InOrder(&amp;t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=====后序遍历二叉树=====\n&quot;</span>);</span><br><span class="line">PostOrder(&amp;t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=====层序遍历二叉树=====\n&quot;</span>);</span><br><span class="line">LevelOrder(&amp;t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我代码创建二叉树采用的逻辑是先序遍历创建二叉树，所以创建二叉树的结构如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae46fbe4a2.png" alt="image-20220827003935280" style="zoom:50%;" /><p>运行结果如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae4736641c.png" alt="image-20220827002636196" style="zoom: 80%;" /><h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><p>我们在创建和使用二叉树的时候，会发现一个问题，对于一个 $n$ 个结点的二叉树，其叶子结点和度为 1 的结点总共空出来 $n+1$ 个指针，我们将这些指针利用起来从而形成的新树称为线索二叉树。</p><p>线索二叉树通过先序&#x2F;中序&#x2F;后序遍历将其空指针指向其遍历的前一个结点，进而线程一个“线性表”，如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae477bb9b0.png" alt="image-20220827005713725" style="zoom:80%;" /><blockquote><p>图片来源：王道《数据结构》，图中使用的是中序遍历线索化成功的线索二叉树</p></blockquote><p>由于不同的遍历方式，自然会产生先序&#x2F;中序&#x2F;后续线索二叉树。</p><h2 id="线索二叉树的存储结构"><a href="#线索二叉树的存储结构" class="headerlink" title="线索二叉树的存储结构"></a>线索二叉树的存储结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">ElemType data;<span class="comment">//结点存储的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span><span class="comment">//左孩子和右孩子的指针</span></span><br><span class="line"><span class="type">int</span> ltag, rtag;<span class="comment">//左，右线索标识，0表示为结点，1表示线索</span></span><br><span class="line">&#125;TreeNode, * Tree;</span><br></pre></td></tr></table></figure><h2 id="先序线索二叉树"><a href="#先序线索二叉树" class="headerlink" title="先序线索二叉树"></a>先序线索二叉树</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ThreadTree</span><span class="params">(TreeNode* node)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">node-&gt;lchild = pre;<span class="comment">//设置结点前驱线索</span></span><br><span class="line">node-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;rchild = node;<span class="comment">//设置结点后继线索</span></span><br><span class="line">pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre = node;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PreThread</span><span class="params">(Tree* t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((*t) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ThreadTree((TreeNode*)(*t));<span class="comment">//再获取根结点的值</span></span><br><span class="line"><span class="keyword">if</span> ((*t)-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">PreThread(&amp;(Tree*)(*t)-&gt;lchild);<span class="comment">//先获取左边结点的值</span></span><br><span class="line">&#125;</span><br><span class="line">PreThread(&amp;(Tree*)(*t)-&gt;rchild);<span class="comment">//再获取右边结点的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建先序线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatPreThread</span><span class="params">(Tree* t)</span> &#123;</span><br><span class="line">pre = <span class="literal">NULL</span>;<span class="comment">//初始化全局变量指针</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PreThread(t);<span class="comment">//中序线索化</span></span><br><span class="line"><span class="comment">//需要最后处理一下最后一个结点</span></span><br><span class="line"><span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序线索二叉树"><a href="#中序线索二叉树" class="headerlink" title="中序线索二叉树"></a>中序线索二叉树</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序线索化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InThread</span><span class="params">(Tree* t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((*t) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">InThread(&amp;(Tree*)(*t)-&gt;lchild);<span class="comment">//先获取左边结点的值</span></span><br><span class="line">ThreadTree((TreeNode*)(*t));<span class="comment">//再获取根结点的值</span></span><br><span class="line">InThread(&amp;(Tree*)(*t)-&gt;rchild);<span class="comment">//再获取右边结点的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建中序线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatInThread</span><span class="params">(Tree* t)</span> &#123;</span><br><span class="line">pre = <span class="literal">NULL</span>;<span class="comment">//初始化全局变量指针</span></span><br><span class="line"><span class="keyword">if</span> (t!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">InThread(t);<span class="comment">//中序线索化</span></span><br><span class="line"><span class="comment">//需要最后处理一下最后一个结点</span></span><br><span class="line"><span class="keyword">if</span> (pre==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后续线索二叉树"><a href="#后续线索二叉树" class="headerlink" title="后续线索二叉树"></a>后续线索二叉树</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序线索化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PostThread</span><span class="params">(Tree* t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((*t) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PostThread(&amp;(Tree*)(*t)-&gt;lchild);<span class="comment">//先获取左边结点的值</span></span><br><span class="line">PostThread(&amp;(Tree*)(*t)-&gt;rchild);<span class="comment">//再获取右边结点的值</span></span><br><span class="line">ThreadTree((TreeNode*)(*t));<span class="comment">//再获取根结点的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建后序线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatPostThread</span><span class="params">(Tree* t)</span> &#123;</span><br><span class="line">pre = <span class="literal">NULL</span>;<span class="comment">//初始化全局变量指针</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PostThread(t);<span class="comment">//中序线索化</span></span><br><span class="line"><span class="comment">//需要最后处理一下最后一个结点</span></span><br><span class="line"><span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索化代码示例"><a href="#线索化代码示例" class="headerlink" title="线索化代码示例"></a>线索化代码示例</h2><p>此处拿中序线索化二叉树示例，运行代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">Tree t = <span class="literal">NULL</span>;<span class="comment">//声明二叉树</span></span><br><span class="line">InitTree(&amp;t);<span class="comment">//初始化二叉树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入二叉树数据:\n&quot;</span>);</span><br><span class="line">CreateBiTree(&amp;t);<span class="comment">//创建二叉树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建二叉树完成\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=====先序遍历二叉树=====\n&quot;</span>);</span><br><span class="line">PreOrder(&amp;t);<span class="comment">//先序遍历二叉树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=====中序遍历二叉树=====\n&quot;</span>);</span><br><span class="line">InOrder(&amp;t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=====后序遍历二叉树=====\n&quot;</span>);</span><br><span class="line">PostOrder(&amp;t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=====层序遍历二叉树=====\n&quot;</span>);</span><br><span class="line">LevelOrder(&amp;t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=====中序线索化二叉树=====\n&quot;</span>);</span><br><span class="line">CreatInThread(&amp;t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我创建的二叉树图示如下，蓝色为应该正确的线索，黑色为二叉树原貌。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae47e840d5.png" alt="image-20220827023744191" style="zoom:50%;" /><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae48217d77.png" alt="image-20220827023327898" style="zoom: 80%;" /><p>上图红色为根节点，绿色为根节点的子节点，紫色是新建立的线索，可以得知线索和预测的正确二叉树线索一致。</p><h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><p>前面讨论的是二叉树的存储结构，现在来说明对于一般的树来说如何存储，对于普通的树来说可以存在多个不限于两个的子节点，可以通过如下的方式来存储：</p><ul><li><strong>双亲表示法</strong></li><li><strong>孩子表示法</strong></li><li><strong>孩子兄弟表示法</strong></li></ul><h2 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h2><p><strong>每个结点都存在自己的父节点（根节点除外）</strong>，所以可以通过<strong>顺序存储</strong>的方式来声明一个空间来存储每个结点的双亲，存储结构代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100<span class="comment">//最大结点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="type">int</span> parent;<span class="comment">//父节点的位置</span></span><br><span class="line">&#125;PNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">PNode p[MaxSize];<span class="comment">//存放结点</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//结点数目</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><h2 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h2><p>孩子表示法是采用了<strong>顺序存储和链式存储结合</strong>方法来实现的，它通过将结点存储指向第一个孩子（左孩子）的指针，然后让孩子指向自己另外的孩子，如此反复，如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae486849f1.png" alt="image-20220827030432143" style="zoom: 80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae48ad7f6b.png" alt="image-20220827030356923" style="zoom: 67%;" /><blockquote><p>图片来源：《大话数据结构》</p></blockquote><h2 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h2><p>可以采用<strong>纯链式</strong>的存储方式，存储结构代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">ElemType data;<span class="comment">//结点存储的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">firstChild</span>, * <span class="title">nextChild</span>;</span><span class="comment">//左孩子和堂兄弟的指针</span></span><br><span class="line">&#125;TreeNode, * Tree;</span><br></pre></td></tr></table></figure><p>图示关系为：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae48eef64d.png" alt="image-20220827030305362" style="zoom:50%;" /><blockquote><p>图片来源：王道《数据结构》</p></blockquote><h1 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h1><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>树的遍历可以分为如下三种：</p><ul><li><strong>先根遍历（广度优先遍历）</strong>：若树非空，先访问根结点，再依次对每棵子树进行先根遍历。</li><li><strong>后根遍历（深度优先遍历）</strong>：若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。</li><li><strong>层次遍历</strong>：同二叉树层次遍历，需要使用队列作为辅助</li></ul><h2 id="森林的先序遍历"><a href="#森林的先序遍历" class="headerlink" title="森林的先序遍历"></a>森林的先序遍历</h2><p>森林的遍历可以分为如下两种：</p><ul><li><strong>先序遍历森林</strong>：森林非空，则访问第一棵树根节点，然后访问根节点的左右子树，如此递归。最终效果同先根遍历。</li><li><strong>中序遍历森林</strong>：最终效果同后根遍历。</li></ul><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><ul><li><p>结点的权：结点的某些现实含义。</p></li><li><p><strong>结点的带权路径长度</strong>：<strong>从树的根节点到该结点的路径长度与该结点上权值的乘积</strong>。</p></li><li><p><strong>树的带权路径长度</strong>：树中<strong>所有叶子结点</strong>的<strong>带权路径长度之和</strong>（<strong>WPL</strong>，Weighted Path Length）</p></li><li><p><strong>哈夫曼树（最优二叉树）</strong>：在含有 $n$ 个带权叶子结点的二叉树中，其中<strong>带权路径长度最小的二叉树</strong>。</p></li></ul><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>利用哈夫曼带权路径长度的最小值，构造哈夫曼编码可以进行相关数据的压缩，懒得说明了，自行查阅相关资料吧，理解起来没什么难度。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae494bd19d.png" alt="image-20220827033036414" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于C语言的一些零碎思考</title>
      <link href="/2022/01/28/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E6%80%9D%E8%80%83/"/>
      <url>/2022/01/28/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用<code>C</code>的时候难免会碰到一些奇怪的用法或者令人困惑的语法等等，考虑到问题过于琐碎，就写于这个合集中，名为<strong>关于<code>C</code>语言的零碎思考</strong></p><h1 id="typedef-和-define-的区别"><a href="#typedef-和-define-的区别" class="headerlink" title="typedef 和 define 的区别"></a>typedef 和 define 的区别</h1><p>这种关键字的使用常见于对于某种类型的替换，例如下面的场景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> NewType</span><br></pre></td></tr></table></figure><p><strong>两者的区别在于：<code>define</code>是一种宏定义，本质上来说就是字符串替换，而<code>typedef</code>是一种类型封装</strong>。</p><p>例如参考下面的代码，思考各个变量的类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int*</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">ElemType a,b;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<strong>变量<code>a</code>的类型为<code>int*</code>，而变量<code>b</code>的类型为<code>int</code>类型</strong>，不难理解宏定义只是字符串替换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* ElemType</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ElemType a,b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中**变量<code>a</code>和变量<code>b</code>的类型均为<code>int*</code>**，可以理解为<code>typedef</code>将<code>int*</code>封装成了一个新的类型。</p><h1 id="typedef-和-struct-的使用"><a href="#typedef-和-struct-的使用" class="headerlink" title="typedef 和 struct 的使用"></a>typedef 和 struct 的使用</h1><p>关于结构体的相关基础内容我已经在这篇文章中做过说明<a href="httpss://www.helloseraphine.top/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%909-0%E3%80%91C-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%85%B1%E7%94%A8%E4%BD%93/#%E7%BB%93%E6%9E%84%E4%BD%93">【9.0】C-结构体与共用体</a>.</p><p>这里主要是梳理当<code>typedef</code>和<code>struct</code>关键词连用时的逻辑关系，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">&#125;Test1;</span><br></pre></td></tr></table></figure><p>如果我们使用上述代码来定义结构体，那么**<code>Test1</code>表示的被定义的变量**，而不是数据类型。</p><p>上述代码意味着：<strong>你将不可能在其他位置声明和<code>Test1</code>相同类型的变量</strong>，除非你继续在结构体声明的时候再添加其他变量。同样的，如果使用如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">&#125;Test1;</span><br></pre></td></tr></table></figure><p>此处的<code>Test1</code>是表示类型为<code>Test</code>的结构体变量，<strong>此代码与上述代码不同之处在于你可以通过使用<code>struct Test</code>关键词来在其他地方继续声明和<code>Test1</code>变量相同类型的其他变量</strong>。</p><p>但是如果对<code>struct</code>关键词配合<code>typedef</code>关键词的话，其逻辑结构就不同了，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">&#125;Test1;</span><br></pre></td></tr></table></figure><p>在使用<code>typedef</code>关键词后，<strong>如上代码中的<code>Test1</code>就不再是变量了，而是结构体类型名称</strong>，如果你使用<code>Test1.a</code>则编译器会报错。你可以通过<code>Test1 变量名称</code>来定义相同结构体类型的变量。</p><p>在了解如上代码的逻辑后，现在来判断如下代码中的<code>Test1</code>,<code>Test2</code>,<code>Test</code>是代表的什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">&#125;Test1,Test2;</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc4b230a4.png" alt="image-20220801205502564" style="zoom:80%;" /><p><strong>答案是三者都表示同一种结构体类型</strong>，只是这种结构体类型的不同名称变体，其并非变量。不过不同的是，对于<code>Test1</code>和<code>Test2</code>两者是相同的，与<code>Test</code>不同，如下是三者使用时声明的代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Test1 a;</span><br><span class="line">    Test2 b;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">c</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里你就会明白了，其实上面的代码，是下面代码的缩写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是上面的代码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">&#125;Test1,Test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是其拆解后的过程</span></span><br><span class="line"><span class="comment">//先声明结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">&#125;Test1,Test2;</span><br><span class="line"><span class="comment">//然后使用typedef函数改变其函数声明格式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">Test1</span>,<span class="title">Test2</span>;</span></span><br></pre></td></tr></table></figure><h1 id="Bool函数的使用问题"><a href="#Bool函数的使用问题" class="headerlink" title="Bool函数的使用问题"></a>Bool函数的使用问题</h1><p>如果<strong>你使用<code>GCC</code>编译器</strong>，将其连接到<code>Visual Code</code>编辑器中使用，编译<code>C</code>语言文件。<strong>如果文件中使用了<code>bool</code>关键字，则会报错，需要引用<code>#include &lt;stdbool.h&gt;</code>来使用<code>bool</code>关键字</strong>。</p><p>如果你<strong>使用<code>Visual Studio</code>安装的<code>C/C++</code>环境</strong>，使用<code>bool</code>关键词，通用需要引用<code>#include &lt;stdbool.h&gt;</code>，不过在引用后，<strong>IDE 依旧会报错，需要再引用<code>#define _CRT_SECURE_NO_WARNINGS</code>即可使用</strong>。</p><h1 id="取余运算-取模运算的算法规则"><a href="#取余运算-取模运算的算法规则" class="headerlink" title="取余运算&#x2F;取模运算的算法规则"></a>取余运算&#x2F;取模运算的算法规则</h1><p>取模运算也就是取余运算，它的作用之一是<strong>可以将无线的集合，通过取余来映射到有限的集合里</strong>。</p><p><strong><code>C</code>语言中取余运算符为：<code>%</code>，其作用于两个整型数（正负皆可），运算结果是返回两数的余数（即返回值为整数）</strong>，它遵循如下规定：（示例<code>a%b</code>）</p><ul><li>运算结果的正负和被除数(<code>a</code>)符号一致</li><li><strong>被除数(<code>a</code>)小于除数(<code>b</code>)时，运算结果等于被除数(<code>a</code>)</strong></li></ul><h1 id="单引号和双引号引发的问题"><a href="#单引号和双引号引发的问题" class="headerlink" title="单引号和双引号引发的问题"></a>单引号和双引号引发的问题</h1><p>如果你学习过<code>C#</code>，<code>JAVA</code>或者<code>Python</code>等现代高级语言的时候，你或许对于字符串和字符来说，都是通常来使用双引号（<code>&quot;&quot;</code>）来表示，例如：<code>&quot;这是一个字符串&quot;</code>，这是一个<code>&quot;c&quot;</code>字符）。</p><p>这种写法在高级语言中是合法的，但是在C语言中，这种写法是不规范的，也是不完全合法的，例如下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个char类型的数组str，声明其包含字符a,b,c</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>请思考如上写法是否合法？</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc514d8cf.png" alt="image-20220809025647389" style="zoom:80%;" /><p>很不幸，这种写法并不合法，我们的编译器会给我们报错，如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc551ba53.png" alt="image-20220809025317930" style="zoom:80%;" /><p>那么这是为什么？一共就三个字符<code>a,b,c</code>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc58b0502.png" alt="image-20220809025404051" style="zoom:80%;" /><p>这是因为<code>C</code>语言在处理字符的时候，<strong>对于双引号（<code>&quot;这是双引号的内容&quot;</code>）的内容来说，它会被优先认为是字符串，对于单引号（<code>&#39;这是单引号内容&#39;</code>）会被优先认为是字符</strong>。</p><p>那么问题来了，请思考如下写法编译器是否会报错？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&quot;b&quot;</span>;</span><br></pre></td></tr></table></figure><p>答案：<strong>会但是不完全会</strong>，我们的编辑器或者 IDE 并不会直接报错，它不会和上面的数组示例一样，在未编译的时候就报错，这种写法只会在编译的时候报错，<strong>但是仅仅是警告，而不是错误</strong>，也就是说，<strong>这种写法并不会中断程序的运行</strong>。</p><p>在程序中，有句话叫做：“错误需要解决，警告可以不管，程序能跑就行”，但是这样真的可以让程序万无一失吗？</p><p>答案是并不能，<strong>我们在给字符<code>c</code>赋值字符串<code>b</code>的时候，编译器会将字符<code>c</code>的值变为<code>ASCII</code>码的第 40 号（<code>(</code>）字符</strong>，这也就意味着程序并不能如我们所说的那样，警告可以不用管。</p><h1 id="C中各种类型的问题"><a href="#C中各种类型的问题" class="headerlink" title="C中各种类型的问题"></a>C中各种类型的问题</h1><h2 id="所占内存"><a href="#所占内存" class="headerlink" title="所占内存"></a>所占内存</h2><table><thead><tr><th>类型</th><th>字节</th></tr></thead><tbody><tr><td><code>int</code></td><td><strong>4字节（Byte）</strong></td></tr><tr><td><code>char</code></td><td><strong>1字节（Byte）</strong></td></tr><tr><td><code>float</code></td><td><strong>4字节（Byte）</strong></td></tr><tr><td><code>double</code></td><td><strong>8字节（Byte）</strong></td></tr><tr><td><code>long</code></td><td><strong>4字节（Byte）</strong></td></tr></tbody></table><h2 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h2><p>因为**<code>char</code>类型占一个字节<strong>，也就是说换算成数值类型，其</strong>可以表示 $2^8$ 个数值，也就是 $0 \sim 255$** 。但是实际上<strong>考虑到正负号</strong>的问题，所以<strong>它可以表示的实际数值为 $-128 \sim 127$</strong> 。</p><p>综上结果，我们是可以将<code>int</code>类型存储在<code>char</code>类型的变量中的，但是其大小只能被限制到如上的实际数值范围中。现在问题来了，思考如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="number">128</span>;</span><br></pre></td></tr></table></figure><p>请问它是否合法？</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc5d547d3.png" alt="image-20220809204325744" style="zoom:90%;" /><p>答：赋值合法。但是为什么？</p><p>这需要从<code>char</code>类型和<code>int</code>类型所占用的内存空间说起，如上表格所示，<code>char</code>类型在内存占用<strong>1 个字节</strong>，也就是<strong>8 个位</strong>，而<code>int</code>类型占用<strong>4 个字节</strong>，也就是<strong>32 个位</strong>。计算机本质是二进制的数值，也就是说对于计算机来说本来就没有字符这一个说法，这些字符的说法都是源于<code>ASCII</code>码的映射。</p><p>标准的<code>ASCII</code>码是采用<strong>1 个字节（8 位）</strong>来表示字符，但是<strong>实际上最高位用来做数据的奇偶校验位</strong>，用来验证数据完整。也就是说，**<code>ASCII</code>码实际能用的之后的后 7 位**，也就是会产生 $2^7&#x3D;128$ 种情况。这 128 种情况对应标准<code>ASCII</code>码中的字符数字控制符等。</p><blockquote><p>奇偶检验的相关内容详情查看《计算机组成原理》</p></blockquote><p><strong>通过<code>ASCII</code>码，我们建立了字符和数值的映射，这也就意味着字符本质还是数值</strong>。所以上述代码“合法”，但是它真的能用吗？请思考如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="number">128</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;字符A的十进制表示为：%d\n&quot;</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;字符A的字符表示为：%c\n&quot;</span>, a);</span><br></pre></td></tr></table></figure><p>它们的运行结果是什么？</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc611d3d3.png" alt="image-20220810001213562" style="zoom:80%;" /><p>答案：</p><ul><li><strong>字符A的十进制表示为：-128</strong></li><li><strong>字符A的字符表示为：€</strong></li></ul><p>为什么？明明给它赋值的 128 ，为什么他的数值结果确是 -128 ？关键是 -128 数值竟然还有对应的字符映射？</p><p>先解释第二个，之所以字符表示为<strong>€</strong>，是因为前面说到标准的<code>ASCII</code>码表最高位用来做校验位，导致其容量只有 128 个映射。后来人将其最高位也算在数值映射内，也就是使用 8 位来映射字符，而形成了新的<strong>拓展<code>ASCII</code>码表</strong>，其拓展内容如下：</p><table><thead><tr><th align="center">十进制</th><th align="center">八进制</th><th align="center">十六进制</th><th align="center">二进制</th><th align="center">符号</th><th align="center">HTML 编号</th><th align="center">HTML 名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">128</td><td align="center">200</td><td align="center">80</td><td align="center">10000000</td><td align="center">€</td><td align="center">&#128;</td><td align="center">&euro;</td><td align="left">欧元符号</td></tr><tr><td align="center">129</td><td align="center">201</td><td align="center">81</td><td align="center">10000001</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">130</td><td align="center">202</td><td align="center">82</td><td align="center">10000010</td><td align="center">‚</td><td align="center">&#130;</td><td align="center">&sbquo;</td><td align="left">单个低9引号</td></tr><tr><td align="center">131</td><td align="center">203</td><td align="center">83</td><td align="center">10000011</td><td align="center">ƒ</td><td align="center">&#131;</td><td align="center">&fnof;</td><td align="left">拉丁小写字母f</td></tr><tr><td align="center">132</td><td align="center">204</td><td align="center">84</td><td align="center">10000100</td><td align="center">„</td><td align="center">&#132;</td><td align="center">&bdquo;</td><td align="left">双低9引号</td></tr><tr><td align="center">133</td><td align="center">205</td><td align="center">85</td><td align="center">10000101</td><td align="center">…</td><td align="center">&#133;</td><td align="center">&hellip;</td><td align="left">水平省略号</td></tr><tr><td align="center">134</td><td align="center">206</td><td align="center">86</td><td align="center">10000110</td><td align="center">†</td><td align="center">&#134;</td><td align="center">&dagger;</td><td align="left">匕首</td></tr><tr><td align="center">135</td><td align="center">207</td><td align="center">87</td><td align="center">10000111</td><td align="center">‡</td><td align="center">&#135;</td><td align="center">&Dagger;</td><td align="left">双匕首</td></tr><tr><td align="center">136</td><td align="center">210</td><td align="center">88</td><td align="center">10001000</td><td align="center">ˆ</td><td align="center">&#136;</td><td align="center">&circ;</td><td align="left">修饰语字母抑扬音</td></tr><tr><td align="center">137</td><td align="center">211</td><td align="center">89</td><td align="center">10001001</td><td align="center">‰</td><td align="center">&#137;</td><td align="center">&permil;</td><td align="left">千分号</td></tr><tr><td align="center">138</td><td align="center">212</td><td align="center">8A</td><td align="center">10001010</td><td align="center">Š</td><td align="center">&#138;</td><td align="center">&Scaron;</td><td align="left">拉丁大写字母S</td></tr><tr><td align="center">139</td><td align="center">213</td><td align="center">8B</td><td align="center">10001011</td><td align="center">‹</td><td align="center">&#139;</td><td align="center">&lsaquo;</td><td align="left">单左角引号</td></tr><tr><td align="center">140</td><td align="center">214</td><td align="center">8C</td><td align="center">10001100</td><td align="center">Œ</td><td align="center">&#140;</td><td align="center">&OElig;</td><td align="left">拉丁字母连字OE</td></tr><tr><td align="center">141</td><td align="center">215</td><td align="center">8D</td><td align="center">10001101</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">142</td><td align="center">216</td><td align="center">8E</td><td align="center">10001110</td><td align="center">Ž</td><td align="center">&#142;</td><td align="center"></td><td align="left">拉丁大写字母Z</td></tr><tr><td align="center">143</td><td align="center">217</td><td align="center">8F</td><td align="center">10001111</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">144</td><td align="center">220</td><td align="center">90</td><td align="center">10010000</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">145</td><td align="center">221</td><td align="center">91</td><td align="center">10010001</td><td align="center">‘</td><td align="center">&#145;</td><td align="center">&lsquo;</td><td align="left">左单引号</td></tr><tr><td align="center">146</td><td align="center">222</td><td align="center">92</td><td align="center">10010010</td><td align="center">’</td><td align="center">&#146;</td><td align="center">&rsquo;</td><td align="left">右单引号</td></tr><tr><td align="center">147</td><td align="center">223</td><td align="center">93</td><td align="center">10010011</td><td align="center">“</td><td align="center">&#147;</td><td align="center">&ldquo;</td><td align="left">左双引号</td></tr><tr><td align="center">148</td><td align="center">224</td><td align="center">94</td><td align="center">10010100</td><td align="center">”</td><td align="center">&#148;</td><td align="center">&rdquo;</td><td align="left">右双引号</td></tr><tr><td align="center">149</td><td align="center">225</td><td align="center">95</td><td align="center">10010101</td><td align="center">•</td><td align="center">&#149;</td><td align="center">&bull;</td><td align="left">子弹</td></tr><tr><td align="center">150</td><td align="center">226</td><td align="center">96</td><td align="center">10010110</td><td align="center">–</td><td align="center">&#150;</td><td align="center">&ndash;</td><td align="left">破折号</td></tr><tr><td align="center">151</td><td align="center">227</td><td align="center">97</td><td align="center">10010111</td><td align="center">—</td><td align="center">&#151;</td><td align="center">&mdash;</td><td align="left">破折号</td></tr><tr><td align="center">152</td><td align="center">230</td><td align="center">98</td><td align="center">10011000</td><td align="center">˜</td><td align="center">&#152;</td><td align="center">&tilde;</td><td align="left">小波浪号</td></tr><tr><td align="center">153</td><td align="center">231</td><td align="center">99</td><td align="center">10011001</td><td align="center">™</td><td align="center">&#153;</td><td align="center">&trade;</td><td align="left">商标标志</td></tr><tr><td align="center">154</td><td align="center">232</td><td align="center">9A</td><td align="center">10011010</td><td align="center">š</td><td align="center">&#154;</td><td align="center">&scaron;</td><td align="left">拉丁小写字母S</td></tr><tr><td align="center">155</td><td align="center">233</td><td align="center">9B</td><td align="center">10011011</td><td align="center">›</td><td align="center">&#155;</td><td align="center">&rsaquo;</td><td align="left">单个右指向角引号</td></tr><tr><td align="center">156</td><td align="center">234</td><td align="center">9C</td><td align="center">10011100</td><td align="center">œ</td><td align="center">&#156;</td><td align="center">&oelig;</td><td align="left">拉丁文小连字oe</td></tr><tr><td align="center">157</td><td align="center">235</td><td align="center">9D</td><td align="center">10011101</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">158</td><td align="center">236</td><td align="center">9E</td><td align="center">10011110</td><td align="center">ž</td><td align="center">&#158;</td><td align="center"></td><td align="left">拉丁小写字母z</td></tr><tr><td align="center">159</td><td align="center">237</td><td align="center">9F</td><td align="center">10011111</td><td align="center">Ÿ</td><td align="center">&#159;</td><td align="center">&Yuml;</td><td align="left">拉丁大写字母Y</td></tr><tr><td align="center">160</td><td align="center">240</td><td align="center">A0</td><td align="center">10100000</td><td align="center"></td><td align="center">&#160;</td><td align="center">&nbsp;</td><td align="left">不间断空间</td></tr><tr><td align="center">161</td><td align="center">241</td><td align="center">A1</td><td align="center">10100001</td><td align="center">¡</td><td align="center">&#161;</td><td align="center">&iexcl;</td><td align="left">倒感叹号</td></tr><tr><td align="center">162</td><td align="center">242</td><td align="center">A2</td><td align="center">10100010</td><td align="center">¢</td><td align="center">&#162;</td><td align="center">&cent;</td><td align="left">分号</td></tr><tr><td align="center">163</td><td align="center">243</td><td align="center">A3</td><td align="center">10100011</td><td align="center">£</td><td align="center">&#163;</td><td align="center">&pound;</td><td align="left">英镑符号</td></tr><tr><td align="center">164</td><td align="center">244</td><td align="center">A4</td><td align="center">10100100</td><td align="center">¤</td><td align="center">&#164;</td><td align="center">&curren;</td><td align="left">货币符号</td></tr><tr><td align="center">165</td><td align="center">245</td><td align="center">A5</td><td align="center">10100101</td><td align="center">¥</td><td align="center">&#165;</td><td align="center">&yen;</td><td align="left">日元符号</td></tr><tr><td align="center">166</td><td align="center">246</td><td align="center">A6</td><td align="center">10100110</td><td align="center">¦</td><td align="center">&#166;</td><td align="center">&brvbar;</td><td align="left">管道，竖线损坏</td></tr><tr><td align="center">167</td><td align="center">247</td><td align="center">A7</td><td align="center">10100111</td><td align="center">§</td><td align="center">&#167;</td><td align="center">&sect;</td><td align="left">分区标志</td></tr><tr><td align="center">168</td><td align="center">250</td><td align="center">A8</td><td align="center">10101000</td><td align="center">¨</td><td align="center">&#168;</td><td align="center">&uml;</td><td align="left">间隔透析-umlaut</td></tr><tr><td align="center">169</td><td align="center">251</td><td align="center">A9</td><td align="center">10101001</td><td align="center">©</td><td align="center">&#169;</td><td align="center">&copy;</td><td align="left">版权标志</td></tr><tr><td align="center">170</td><td align="center">252</td><td align="center">AA</td><td align="center">10101010</td><td align="center">ª</td><td align="center">&#170;</td><td align="center">&ordf;</td><td align="left">女性顺序指示器</td></tr><tr><td align="center">171</td><td align="center">253</td><td align="center">AB</td><td align="center">10101011</td><td align="center">«</td><td align="center">&#171;</td><td align="center">&laquo;</td><td align="left">左双角引号</td></tr><tr><td align="center">172</td><td align="center">254</td><td align="center">AC</td><td align="center">10101100</td><td align="center">¬</td><td align="center">&#172;</td><td align="center">&not;</td><td align="left">不签名</td></tr><tr><td align="center">173</td><td align="center">255</td><td align="center">AD</td><td align="center">10101101</td><td align="center">­</td><td align="center">&#173;</td><td align="center">&shy;</td><td align="left">软连字符</td></tr><tr><td align="center">174</td><td align="center">256</td><td align="center">AE</td><td align="center">10101110</td><td align="center">®</td><td align="center">&#174;</td><td align="center">&reg;</td><td align="left">注册商标标志</td></tr><tr><td align="center">175</td><td align="center">257</td><td align="center">AF</td><td align="center">10101111</td><td align="center">¯</td><td align="center">&#175;</td><td align="center">&macr;</td><td align="left">间隔宏-上划线</td></tr><tr><td align="center">176</td><td align="center">260</td><td align="center">B0</td><td align="center">10110000</td><td align="center">°</td><td align="center">&#176;</td><td align="center">&deg;</td><td align="left">学位标志</td></tr><tr><td align="center">177</td><td align="center">261</td><td align="center">B1</td><td align="center">10110001</td><td align="center">±</td><td align="center">&#177;</td><td align="center">&plusmn;</td><td align="left">正负号</td></tr><tr><td align="center">178</td><td align="center">262</td><td align="center">B2</td><td align="center">10110010</td><td align="center">²</td><td align="center">&#178;</td><td align="center">&sup2;</td><td align="left">上标二平方</td></tr><tr><td align="center">179</td><td align="center">263</td><td align="center">B3</td><td align="center">10110011</td><td align="center">³</td><td align="center">&#179;</td><td align="center">&sup3;</td><td align="left">上标三方</td></tr><tr><td align="center">180</td><td align="center">264</td><td align="center">B4</td><td align="center">10110100</td><td align="center">´</td><td align="center">&#180;</td><td align="center">&acute;</td><td align="left">急性口音-间隔锐</td></tr><tr><td align="center">181</td><td align="center">265</td><td align="center">B5</td><td align="center">10110101</td><td align="center">µ</td><td align="center">&#181;</td><td align="center">&micro;</td><td align="left">微标志</td></tr><tr><td align="center">182</td><td align="center">266</td><td align="center">B6</td><td align="center">10110110</td><td align="center">¶</td><td align="center">&#182;</td><td align="center">&para;</td><td align="left">稻草人标志-段落标志</td></tr><tr><td align="center">183</td><td align="center">267</td><td align="center">B7</td><td align="center">10110111</td><td align="center">·</td><td align="center">&#183;</td><td align="center">&middot;</td><td align="left">中间点-格鲁吉亚逗号</td></tr><tr><td align="center">184</td><td align="center">270</td><td align="center">B8</td><td align="center">10111000</td><td align="center">¸</td><td align="center">&#184;</td><td align="center">&cedil;</td><td align="left">间距塞迪利亚</td></tr><tr><td align="center">185</td><td align="center">271</td><td align="center">B9</td><td align="center">10111001</td><td align="center">¹</td><td align="center">&#185;</td><td align="center">&sup1;</td><td align="left">上标一</td></tr><tr><td align="center">186</td><td align="center">272</td><td align="center">BA</td><td align="center">10111010</td><td align="center">º</td><td align="center">&#186;</td><td align="center">&ordm;</td><td align="left">男性顺序指示器</td></tr><tr><td align="center">187</td><td align="center">273</td><td align="center">BB</td><td align="center">10111011</td><td align="center">»</td><td align="center">&#187;</td><td align="center">&raquo;</td><td align="left">右双角引号</td></tr><tr><td align="center">188</td><td align="center">274</td><td align="center">BC</td><td align="center">10111100</td><td align="center">¼</td><td align="center">&#188;</td><td align="center">&frac14;</td><td align="left">分数的四分之一</td></tr><tr><td align="center">189</td><td align="center">275</td><td align="center">BD</td><td align="center">10111101</td><td align="center">½</td><td align="center">&#189;</td><td align="center">&frac12;</td><td align="left">分数的一半</td></tr><tr><td align="center">190</td><td align="center">276</td><td align="center">BE</td><td align="center">10111110</td><td align="center">¾</td><td align="center">&#190;</td><td align="center">&frac34;</td><td align="left">分数四分之三</td></tr><tr><td align="center">191</td><td align="center">277</td><td align="center">BF</td><td align="center">10111111</td><td align="center">¿</td><td align="center">&#191;</td><td align="center">&iquest;</td><td align="left">倒问号</td></tr><tr><td align="center">192</td><td align="center">300</td><td align="center">C0</td><td align="center">11000000</td><td align="center">À</td><td align="center">&#192;</td><td align="center">&Agrave;</td><td align="left">拉丁大写字母A</td></tr><tr><td align="center">193</td><td align="center">301</td><td align="center">C1</td><td align="center">11000001</td><td align="center">Á</td><td align="center">&#193;</td><td align="center">&Aacute;</td><td align="left">拉丁大写字母A</td></tr><tr><td align="center">194</td><td align="center">302</td><td align="center">C2</td><td align="center">11000010</td><td align="center">Â</td><td align="center">&#194;</td><td align="center">&Acirc;</td><td align="left">拉丁大写字母A</td></tr><tr><td align="center">195</td><td align="center">303</td><td align="center">C3</td><td align="center">11000011</td><td align="center">Ã</td><td align="center">&#195;</td><td align="center">&Atilde;</td><td align="left">拉丁大写字母A</td></tr><tr><td align="center">196</td><td align="center">304</td><td align="center">C4</td><td align="center">11000100</td><td align="center">Ä</td><td align="center">&#196;</td><td align="center">&Auml;</td><td align="left">拉丁大写字母A</td></tr><tr><td align="center">197</td><td align="center">305</td><td align="center">C5</td><td align="center">11000101</td><td align="center">Å</td><td align="center">&#197;</td><td align="center">&Aring;</td><td align="left">拉丁大写字母A</td></tr><tr><td align="center">198</td><td align="center">306</td><td align="center">C6</td><td align="center">11000110</td><td align="center">Æ</td><td align="center">&#198;</td><td align="center">&AElig;</td><td align="left">拉丁大写字母AE</td></tr><tr><td align="center">199</td><td align="center">307</td><td align="center">C7</td><td align="center">11000111</td><td align="center">Ç</td><td align="center">&#199;</td><td align="center">&Ccedil;</td><td align="left">拉丁大写字母C</td></tr><tr><td align="center">200</td><td align="center">310</td><td align="center">C8</td><td align="center">11001000</td><td align="center">È</td><td align="center">&#200;</td><td align="center">&Egrave;</td><td align="left">拉丁大写字母E</td></tr><tr><td align="center">201</td><td align="center">311</td><td align="center">C9</td><td align="center">11001001</td><td align="center">É</td><td align="center">&#201;</td><td align="center">&Eacute;</td><td align="left">拉丁大写字母E</td></tr><tr><td align="center">202</td><td align="center">312</td><td align="center">CA</td><td align="center">11001010</td><td align="center">Ê</td><td align="center">&#202;</td><td align="center">&Ecirc;</td><td align="left">拉丁大写字母E</td></tr><tr><td align="center">203</td><td align="center">313</td><td align="center">CB</td><td align="center">11001011</td><td align="center">Ë</td><td align="center">&#203;</td><td align="center">&Euml;</td><td align="left">拉丁大写字母E</td></tr><tr><td align="center">204</td><td align="center">314</td><td align="center">CC</td><td align="center">11001100</td><td align="center">Ì</td><td align="center">&#204;</td><td align="center">&Igrave;</td><td align="left">拉丁大写字母I</td></tr><tr><td align="center">205</td><td align="center">315</td><td align="center">CD</td><td align="center">11001101</td><td align="center">Í</td><td align="center">&#205;</td><td align="center">&Iacute;</td><td align="left">拉丁大写字母I</td></tr><tr><td align="center">206</td><td align="center">316</td><td align="center">CE</td><td align="center">11001110</td><td align="center">Î</td><td align="center">&#206;</td><td align="center">&Icirc;</td><td align="left">拉丁大写字母I</td></tr><tr><td align="center">207</td><td align="center">317</td><td align="center">CF</td><td align="center">11001111</td><td align="center">Ï</td><td align="center">&#207;</td><td align="center">&Iuml;</td><td align="left">拉丁大写字母I</td></tr><tr><td align="center">208</td><td align="center">320</td><td align="center">D0</td><td align="center">11010000</td><td align="center">Ð</td><td align="center">&#208;</td><td align="center">&ETH;</td><td align="left">拉丁大写字母ETH</td></tr><tr><td align="center">209</td><td align="center">321</td><td align="center">D1</td><td align="center">11010001</td><td align="center">Ñ</td><td align="center">&#209;</td><td align="center">&Ntilde;</td><td align="left">拉丁大写字母N</td></tr><tr><td align="center">210</td><td align="center">322</td><td align="center">D2</td><td align="center">11010010</td><td align="center">Ò</td><td align="center">&#210;</td><td align="center">&Ograve;</td><td align="left">拉丁大写字母O</td></tr><tr><td align="center">211</td><td align="center">323</td><td align="center">D3</td><td align="center">11010011</td><td align="center">Ó</td><td align="center">&#211;</td><td align="center">&Oacute;</td><td align="left">拉丁大写字母O</td></tr><tr><td align="center">212</td><td align="center">324</td><td align="center">D4</td><td align="center">11010100</td><td align="center">Ô</td><td align="center">&#212;</td><td align="center">&Ocirc;</td><td align="left">拉丁大写字母O</td></tr><tr><td align="center">213</td><td align="center">325</td><td align="center">D5</td><td align="center">11010101</td><td align="center">Õ</td><td align="center">&#213;</td><td align="center">&Otilde;</td><td align="left">拉丁大写字母O</td></tr><tr><td align="center">214</td><td align="center">326</td><td align="center">D6</td><td align="center">11010110</td><td align="center">Ö</td><td align="center">&#214;</td><td align="center">&Ouml;</td><td align="left">拉丁大写字母O</td></tr><tr><td align="center">215</td><td align="center">327</td><td align="center">D7</td><td align="center">11010111</td><td align="center">×</td><td align="center">&#215;</td><td align="center">&times;</td><td align="left">乘法</td></tr><tr><td align="center">216</td><td align="center">330</td><td align="center">D8</td><td align="center">11011000</td><td align="center">Ø</td><td align="center">&#216;</td><td align="center">&Oslash;</td><td align="left">拉丁大写字母O</td></tr><tr><td align="center">217</td><td align="center">331</td><td align="center">D9</td><td align="center">11011001</td><td align="center">Ù</td><td align="center">&#217;</td><td align="center">&Ugrave;</td><td align="left">拉丁大写字母U</td></tr><tr><td align="center">218</td><td align="center">332</td><td align="center">DA</td><td align="center">11011010</td><td align="center">Ú</td><td align="center">&#218;</td><td align="center">&Uacute;</td><td align="left">拉丁大写字母U</td></tr><tr><td align="center">219</td><td align="center">333</td><td align="center">DB</td><td align="center">11011011</td><td align="center">Û</td><td align="center">&#219;</td><td align="center">&Ucirc;</td><td align="left">拉丁大写字母U</td></tr><tr><td align="center">220</td><td align="center">334</td><td align="center">DC</td><td align="center">11011100</td><td align="center">Ü</td><td align="center">&#220;</td><td align="center">&Uuml;</td><td align="left">拉丁大写字母U</td></tr><tr><td align="center">221</td><td align="center">335</td><td align="center">DD</td><td align="center">11011101</td><td align="center">Ý</td><td align="center">&#221;</td><td align="center">&Yacute;</td><td align="left">拉丁大写字母Y</td></tr><tr><td align="center">222</td><td align="center">336</td><td align="center">DE</td><td align="center">11011110</td><td align="center">Þ</td><td align="center">&#222;</td><td align="center">&THORN;</td><td align="left">拉丁大写字母THORN</td></tr><tr><td align="center">223</td><td align="center">337</td><td align="center">DF</td><td align="center">11011111</td><td align="center">ß</td><td align="center">&#223;</td><td align="center">&szlig;</td><td align="left">拉丁小写字母sharp s - ess-zed</td></tr><tr><td align="center">224</td><td align="center">340</td><td align="center">E0</td><td align="center">11100000</td><td align="center">à</td><td align="center">&#224;</td><td align="center">&agrave;</td><td align="left">拉丁小写字母a</td></tr><tr><td align="center">225</td><td align="center">341</td><td align="center">E1</td><td align="center">11100001</td><td align="center">á</td><td align="center">&#225;</td><td align="center">&aacute;</td><td align="left">拉丁小写字母a</td></tr><tr><td align="center">226</td><td align="center">342</td><td align="center">E2</td><td align="center">11100010</td><td align="center">â</td><td align="center">&#226;</td><td align="center">&acirc;</td><td align="left">拉丁小写字母a</td></tr><tr><td align="center">227</td><td align="center">343</td><td align="center">E3</td><td align="center">11100011</td><td align="center">ã</td><td align="center">&#227;</td><td align="center">&atilde;</td><td align="left">拉丁小写字母a</td></tr><tr><td align="center">228</td><td align="center">344</td><td align="center">E4</td><td align="center">11100100</td><td align="center">ä</td><td align="center">&#228;</td><td align="center">&auml;</td><td align="left">拉丁小写字母a</td></tr><tr><td align="center">229</td><td align="center">345</td><td align="center">E5</td><td align="center">11100101</td><td align="center">å</td><td align="center">&#229;</td><td align="center">&aring;</td><td align="left">拉丁小写字母a</td></tr><tr><td align="center">230</td><td align="center">346</td><td align="center">E6</td><td align="center">11100110</td><td align="center">æ</td><td align="center">&#230;</td><td align="center">&aelig;</td><td align="left">拉丁小写字母a</td></tr><tr><td align="center">231</td><td align="center">347</td><td align="center">E7</td><td align="center">11100111</td><td align="center">ç</td><td align="center">&#231;</td><td align="center">&ccedil;</td><td align="left">拉丁小写字母c</td></tr><tr><td align="center">232</td><td align="center">350</td><td align="center">E8</td><td align="center">11101000</td><td align="center">è</td><td align="center">&#232;</td><td align="center">&egrave;</td><td align="left">拉丁小写字母e</td></tr><tr><td align="center">233</td><td align="center">351</td><td align="center">E9</td><td align="center">11101001</td><td align="center">é</td><td align="center">&#233;</td><td align="center">&eacute;</td><td align="left">拉丁小写字母e</td></tr><tr><td align="center">234</td><td align="center">352</td><td align="center">EA</td><td align="center">11101010</td><td align="center">ê</td><td align="center">&#234;</td><td align="center">&ecirc;</td><td align="left">拉丁小写字母e</td></tr><tr><td align="center">235</td><td align="center">353</td><td align="center">EB</td><td align="center">11101011</td><td align="center">ë</td><td align="center">&#235;</td><td align="center">&euml;</td><td align="left">拉丁小写字母e</td></tr><tr><td align="center">236</td><td align="center">354</td><td align="center">EC</td><td align="center">11101100</td><td align="center">ì</td><td align="center">&#236;</td><td align="center">&igrave;</td><td align="left">拉丁小写字母i</td></tr><tr><td align="center">237</td><td align="center">355</td><td align="center">ED</td><td align="center">11101101</td><td align="center">í</td><td align="center">&#237;</td><td align="center">&iacute;</td><td align="left">拉丁小写字母i</td></tr><tr><td align="center">238</td><td align="center">356</td><td align="center">EE</td><td align="center">11101110</td><td align="center">î</td><td align="center">&#238;</td><td align="center">&icirc;</td><td align="left">拉丁小写字母i</td></tr><tr><td align="center">239</td><td align="center">357</td><td align="center">EF</td><td align="center">11101111</td><td align="center">ï</td><td align="center">&#239;</td><td align="center">&iuml;</td><td align="left">拉丁小写字母i</td></tr><tr><td align="center">240</td><td align="center">360</td><td align="center">F0</td><td align="center">11110000</td><td align="center">ð</td><td align="center">&#240;</td><td align="center">&eth;</td><td align="left">拉丁小写字母eth</td></tr><tr><td align="center">241</td><td align="center">361</td><td align="center">F1</td><td align="center">11110001</td><td align="center">ñ</td><td align="center">&#241;</td><td align="center">&ntilde;</td><td align="left">拉丁小写字母n</td></tr><tr><td align="center">242</td><td align="center">362</td><td align="center">F2</td><td align="center">11110010</td><td align="center">ò</td><td align="center">&#242;</td><td align="center">&ograve;</td><td align="left">拉丁小写字母o</td></tr><tr><td align="center">243</td><td align="center">363</td><td align="center">F3</td><td align="center">11110011</td><td align="center">ó</td><td align="center">&#243;</td><td align="center">&oacute;</td><td align="left">拉丁小写字母o</td></tr><tr><td align="center">244</td><td align="center">364</td><td align="center">F4</td><td align="center">11110100</td><td align="center">ô</td><td align="center">&#244;</td><td align="center">&ocirc;</td><td align="left">拉丁小写字母o</td></tr><tr><td align="center">245</td><td align="center">365</td><td align="center">F5</td><td align="center">11110101</td><td align="center">õ</td><td align="center">&#245;</td><td align="center">&otilde;</td><td align="left">拉丁小写字母o</td></tr><tr><td align="center">246</td><td align="center">366</td><td align="center">F6</td><td align="center">11110110</td><td align="center">ö</td><td align="center">&#246;</td><td align="center">&ouml;</td><td align="left">拉丁小写字母o</td></tr><tr><td align="center">247</td><td align="center">367</td><td align="center">F7</td><td align="center">11110111</td><td align="center">÷</td><td align="center">&#247;</td><td align="center">&divide;</td><td align="left">除号</td></tr><tr><td align="center">248</td><td align="center">370</td><td align="center">F8</td><td align="center">11111000</td><td align="center">ø</td><td align="center">&#248;</td><td align="center">&oslash;</td><td align="left">拉丁小写字母o</td></tr><tr><td align="center">249</td><td align="center">371</td><td align="center">F9</td><td align="center">11111001</td><td align="center">ù</td><td align="center">&#249;</td><td align="center">&ugrave;</td><td align="left">拉丁小写字母u</td></tr><tr><td align="center">250</td><td align="center">372</td><td align="center">FA</td><td align="center">11111010</td><td align="center">ú</td><td align="center">&#250;</td><td align="center">&uacute;</td><td align="left">拉丁小写字母u</td></tr><tr><td align="center">251</td><td align="center">373</td><td align="center">FB</td><td align="center">11111011</td><td align="center">û</td><td align="center">&#251;</td><td align="center">&ucirc;</td><td align="left">拉丁小写字母u</td></tr><tr><td align="center">252</td><td align="center">374</td><td align="center">FC</td><td align="center">11111100</td><td align="center">ü</td><td align="center">&#252;</td><td align="center">&uuml;</td><td align="left">拉丁小写字母u</td></tr><tr><td align="center">253</td><td align="center">375</td><td align="center">FD</td><td align="center">11111101</td><td align="center">ý</td><td align="center">&#253;</td><td align="center">&yacute;</td><td align="left">拉丁小写字母y</td></tr><tr><td align="center">254</td><td align="center">376</td><td align="center">FE</td><td align="center">11111110</td><td align="center">þ</td><td align="center">&#254;</td><td align="center">&thorn;</td><td align="left">拉丁小写字母thorn</td></tr><tr><td align="center">255</td><td align="center">377</td><td align="center">FF</td><td align="center">11111111</td><td align="center">ÿ</td><td align="center">&#255;</td><td align="center">&yuml;</td><td align="left">拉丁小写字母y</td></tr></tbody></table><p>你可以很清楚的发现，表中的对应关系，**十进制的 128 对应的字符为 <code>€</code>**，这也就是为什么第二个输出为字符<code>€</code>。</p><p>那为什么第一个采用十进制输出就变成了 -128 了呢？</p><p><strong>这就不得不提到数值是如何在计算机中存储的</strong>了，我在博客没搬家之前写过一篇《计算机的原码，反码，补码》的内容，不过搬到<code>Hexo</code>后感觉质量不是很好，遂没有腾过来。</p><blockquote><p>计算机原码，反码，补码的详细内容可以参考<a href="httpss://www.zhihu.com/question/30395946/answer/696377317">(知乎)计算机补码运算背后的数学原理是什么？</a>，知识出处《计算机组成原理》</p></blockquote><p>我先说结论，<strong>数值在计算机中采用补码的形式存储</strong>，前面提到字符其实是数值十进制的映射，而十进制和二进制又有一层映射，所以<strong>本质来说，所有字符数值都是和二进制（当前情况是 8 位）的映射</strong>。</p><p>我们在代码中（<code>char a = 128</code>）给变量<code>a</code>赋值 128 （十进制），其二进制原码为 <code>1000 0000</code>，很不幸的是，计算机采用 8 位，<strong>存储整型数值的时候，最高位用来表示符号位</strong>，也就是说计算机用 8 位表示数值的时候只能表示 $-128 \sim 127$ 这个范围。<strong>对于 128 的二进制源码其实它溢出到最高位</strong>了（最高位是符号位，只有 $2^7 &#x3D;128$ 个数值了），127 的二进制原码为<code>0111 1111</code>，将它 $+1$ 也就是 128 ，<strong>它最后数值溢出到了最高位符号位上了，计算机会将它认为是负数</strong>，会按照 原码 -&gt; 反码 -&gt; 补码 的过程将其转换成补码存储。</p><p>当计算机需要读取它的十进制数值的时候，会再将 补码 -&gt; 反码 -&gt; 原码 -&gt; 十进制呈现在屏幕上。这样就是为什么最后再输出十进制的时候会变成 -128 了。根据上述原理，<strong>下述代码同样的就是 -127 （十进制数值）</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="number">129</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;字符A的十进制表示为：%d\n&quot;</span>,a);</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc6b19311.png" alt="image-20220810004238779" style="zoom:80%;" /><p>现在查看如下代码，请判断其是否合法？如果合法其输出结果是什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;33&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;字符A的十进制表示为：%d\n&quot;</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;字符A的字符表示为：%c\n&quot;</span>, a);</span><br></pre></td></tr></table></figure><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc6e8202f.png" alt="image-20220810004446624" style="zoom:80%;" /><p>答：“合法但是有问题”，上述代码会根据编译器的不同而不同，但是最多报个警报，并不会终端程序的运行，代码运行结果如下：</p><ul><li><strong>字符A的十进制表示为：51</strong></li><li><strong>字符A的字符表示为：3</strong></li></ul><p>看着这个输出结果，更加迷惑了，明明赋值的 33 输出一个 51 一个给我 3 .</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc71f0a98.png" alt="image-20220810004905053" style="zoom: 50%;" /><p>原因：在上面的单引号和双引号的部分我说过，<strong>单引号（<code>&#39;&#39;</code>）表示字符</strong>，也就是说，你赋值的<code>&#39;33&#39;</code>意味着你告诉计算机我要赋值给这个变量<code>a</code>一个字符<code>33</code>，计算机说：好的，字符<code>&#39;33&#39;</code>赋值给…..嗯？我这<code>ASCII</code>码表里可没有你说的字符<code>&#39;33&#39;</code>，怎么办？<strong>它在这里做了一个模运算</strong>，伪代码应该是这样<code>数值%10</code>，<strong>这里的模运算的结果是将无限的整型数值映射到了<code>ASCII</code>码表里有的 $0 \sim 9$ 字符</strong>。</p><p>我们<strong>示例中的<code>&#39;33&#39;</code>经过模运算就是字符<code>&#39;3&#39;</code>，查询<code>ASCII</code>码表可知，字符<code>&#39;3&#39;</code>对应的十进制整型数值为 51 。</strong></p><h2 id="类型转换带来的未定义行为"><a href="#类型转换带来的未定义行为" class="headerlink" title="类型转换带来的未定义行为"></a>类型转换带来的未定义行为</h2><p>关于未定义行为（<strong>Undefined behavior</strong>）的解释如下：</p><p><em>In <a href="httpss://en.wikipedia.org/wiki/Computer_programming">computer programming</a>, <strong>undefined behavior</strong> (<strong>UB</strong>) is the result of executing a program whose <a href="httpss://en.wikipedia.org/wiki/Behavior">behavior</a> is prescribed to be unpredictable, in the <a href="httpss://en.wikipedia.org/wiki/Language_specification">language specification</a> to which the <a href="httpss://en.wikipedia.org/wiki/Computer_code">computer code</a> adheres. This is different from <a href="httpss://en.wikipedia.org/wiki/Unspecified_behavior">unspecified behavior</a>, for which the language specification does not prescribe a result, and implementation-defined behavior that defers to the documentation of another component of the <a href="httpss://en.wikipedia.org/wiki/Platform_(computing)">platform</a> (such as the <a href="httpss://en.wikipedia.org/wiki/Application_binary_interface">ABI</a> or the <a href="httpss://en.wikipedia.org/wiki/Translator_(computing)">translator</a> documentation).</em></p><p><em>In the <a href="httpss://en.wikipedia.org/wiki/C_(programming_language)">C community</a>, undefined behavior may be humorously referred to as “<strong>nasal demons</strong>“, after a <a href="httpss://en.wikipedia.org/wiki/Comp.*_hierarchy">comp.std.c</a> post that explained undefined behavior as allowing the compiler to do anything it chooses, even “to make demons fly out of your nose”.</em></p><blockquote><p>内容来源：<a href="httpss://en.wikipedia.org/wiki/Undefined_behavior">维基百科Undefined behavior</a></p></blockquote><p>简述来说，未定义行为并不是错误，更多的来说是<strong>因为<code>C</code>的标准定义并没有对此进行详细的标准定义</strong>，以至于其对于不同的编译器可能会存在不同的处理方式，最终出现对于不同的编译器来说，运行结果不同的结果。</p><p>现在来尝试观察如下代码，分析其输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">float</span> a = <span class="number">1.5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test: %d&quot;</span>, (a+b) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码运行结果：我不好说，<strong>因为它已经进入了未定义行为了</strong>。</p><p>如果你了解隐式类型转换的话，<strong>对于上述运行的来说变量<code>a</code>是<code>float</code>类型， 和<code>int</code>类型的变量<code>b</code>进行加和的时候编译器会将<code>b</code>转换成<code>float</code>类型再参与运算</strong>，你发现了吗？<strong>其运算结果是<code>float</code>类型，也就意味着在<code>printf()</code>函数中使用<code>%d</code>输出<code>float</code>值就会出现未定义行为了</strong>。</p><p>现在对上述代码进行微小改动，来参考如下代码，思考其运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">float</span> a = <span class="number">1.5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = a + b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test: %d&quot;</span>, c / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<code>test：1</code></p><p>你会发现**对于<code>c=a+b</code>来说，会将<code>a+b</code>其值的<code>float</code>类型转换为<code>int</code>**，虽然会丢失一定的精度，但是不至于因为<code>%d</code>而出现未定义行为。</p><p>现在来陈胜追击，查看一段奇怪的代码，思考其运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>                                              </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;                                                    </span><br><span class="line">    <span class="type">int</span> i=<span class="number">10</span>;                                                     </span><br><span class="line">    <span class="type">float</span> x=<span class="number">43.2892f</span>;                                              </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i=%f  x=%d \n&quot;</span>,i,x);                               </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码出自：【Stack Overfl0w】 <a href="httpss://stackoverflow.com/questions/44571175/why-are-the-int-and-float-passed-in-printf-going-to-the-wrong-positions-in-the-f">Why are the int and float passed in printf going to the wrong positions in the format string?</a>]</p></blockquote><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc76f29e8.png" alt="image-20220902204628036" style="zoom:50%;" /><p>根据一开始的代码可以得知，这段代码也会因为<code>%f</code>，<code>%d</code>而出现未定义行为，其提问者的运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">43.289200</span>  x=<span class="number">10</span>      </span><br></pre></td></tr></table></figure><p>其中一个高赞回答：</p><p><em>What you’re doing invokes undefined behavior1, but looking at <a href="httpss://godbolt.org/g/Wo4wYT">the resulting assembly</a> using GCC on a platform with the <a href="httpss://en.m.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">System V AMD64 ABI</a> we might formulate a hypothesis. The floating-point value is passed in the <code>xmm0</code> register (an SSE register), while the integer is passed in the <code>esi</code> register (a general register). Presumably, your <code>printf</code> implementation expects floating-point numbers to be passed in SSE registers and integers to be passed in general registers, and simply picks the <code>xmm0</code> register to read from when it encounters the first <code>%f</code> (and vice versa).</em></p><p>简述来说，就是如上代码的操作会引发未定义行为，在具有<code>System V AMD64 ABI</code> 的平台上使用 GCC 查看其汇编，推出的假设是：浮点值在寄存器（SSE 寄存器）中传递，而整数在寄存器（通用寄存器）中传递，因为调用关系问题，导致寄存器读取取反了。</p><blockquote><p>回答作者：<a href="httpss://stackoverflow.com/users/147845/you">You</a></p></blockquote><h1 id="C函数问题"><a href="#C函数问题" class="headerlink" title="C函数问题"></a>C函数问题</h1><h2 id="关于-Main-函数的有趣问题"><a href="#关于-Main-函数的有趣问题" class="headerlink" title="关于 Main 函数的有趣问题"></a>关于 Main 函数的有趣问题</h2><p>如果你使用<code>Visual Studio</code>集成的 C&#x2F;C++ 编译器，在编写<code>main()</code>函数的时候将其写为<code>mian()</code>，编译器并不会保<code>mian()</code>的错误，反而是报错如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc7cef75f.png" alt="image-20220902190945178" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc808fcd7.png" alt="image-20220902191052794" style="zoom:50%;" /><h2 id="Scanf函数读取问题"><a href="#Scanf函数读取问题" class="headerlink" title="Scanf函数读取问题"></a>Scanf函数读取问题</h2><p><code>Scanf</code>作为C语言入门级别函数，功能上来说学习过C语言的人都理解，现在来思考一下下面一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入字符\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> tempdata;</span><br><span class="line">    <span class="comment">//读取字符</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;tempdata);</span><br><span class="line"><span class="keyword">while</span> (tempdata != <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//输出读取的字符</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的字符为:%c\n&quot;</span>, tempdata);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;tempdata);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在如果读取字符的时候，输入一个 A （或者任意一个单字符），猜一下输出结果是什么？会是<code>输入的字符为:A</code>吗？又或者是其他结果？</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc854d44e.png" alt="image-20220829055941223" style="zoom:80%;" /><p>很不幸，它的运行结果如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc899c291.png" alt="image-20220829060030262" style="zoom:80%;" /><p>这就奇了个怪了，<code>scanf</code>函数不应该不读取回车字符吗？</p><p>有了上面的运行结果，现在来看看下面的代码，猜一下运行结果是什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数值\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> tempdata;</span><br><span class="line">    <span class="comment">//读取字符</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tempdata);</span><br><span class="line"><span class="keyword">while</span> (tempdata != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//输出读取的字符</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的数值为:%d\n&quot;</span>, tempdata);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tempdata);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在输入 2 （或者任意一个单数值），然后回车确认，猜猜运行结果是什么？运行结果如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc8d2c612.png" alt="image-20220829061227547" style="zoom:80%;" /><p>发现了，<code>scanf</code>对于<code>%c</code>即字符的处理和其他的处理是不一样的，我猜测是因为字符采用的是<code>ASCII</code>码表存储的，因为<code>ASCII</code>存在各种控制字符，包括“回车”和“空格”等控制字符，<strong>事实上对于一般除字符格式的字符都会在<code>scanf</code>前将空格等控制字符删除，而字符缺不会做这个处理，也就出现了上面的字符读取了回车字符的情况</strong>。</p><p>关于上述<code>scanf</code>读取回车字符的解决方案如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>,&amp;value);<span class="comment">//在%c前面加个空格就可以读取输入字符的时候避免回车和空格</span></span><br></pre></td></tr></table></figure><p>当然你也可以选择使用其他的读取输入的函数，例如：<code>sscanf</code>等等来解决上述问题。</p><p>题外话：<strong>对于读取输入函数<code>scanf</code>来说，其实它会将键盘的输入读取到缓存区，你可以把它理解为队列，读取的字符压入队列，先入先出，对于每次输入结束都会在其末尾加上回车符（编译器自动），但是对于字符来说，编译器并没有给我的缓存区加上回车符，而是我们输入的时候把回车符输入了，由于字符的特殊性，导致读取字符的时候编译器并没有给我们删除前面的控制字符，使得我们读取到了回车字符。</strong></p><p>因为缓存区的存在，所以对于上述输入来说，例如：我们希望输入<code>ABCD</code>四个字符，其实可以不需要<code>A</code>，回车，<code>B</code>，回车，这样输入，其实<strong>我们可以直接在第一次输入就输入<code>ABCD</code>，程序会依次将第一次输入存储到缓存区，然后挨个读取。</strong></p><h2 id="返回值数组"><a href="#返回值数组" class="headerlink" title="返回值数组"></a>返回值数组</h2><p><code>C</code>不允许函数返回一个数组，但是可以通过返回一个类型指针来代替（顺序表）。</p><p><strong>关于数组指针，需要注意的是它是线性的</strong>。</p><p>数组名本身其实是一块地址的首地址，<strong>创建一个数组例如<code>int a[10]</code>类型的数组，编译器会根据我们传入的数组包含的数组个数(10)，来开辟一块大小为 $10 \times 4byte$ 大小空间，并将空间的首地址返回给所其的数组名称<code>a</code>，所以本质上来说，数组名其实是一块首地址的指针</strong>；至于我们根据数组下标的访问数组，其实是根据首地址的加和计算出来的。所以参考如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>] = &#123; <span class="number">1</span>,<span class="number">2</span> &#125;;<span class="comment">//创建一个一维数组</span></span><br><span class="line"><span class="type">int</span>* b = a;<span class="comment">//声明并定义 int 类型指针，其初始值为数组 a 的“首地址”</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;其值为:%d\n&quot;</span>, b[i]);<span class="comment">//输出其值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc914dc2f.png" alt="image-20220901074210064" style="zoom:80%;" /><p><strong>对于二维及以上的数组来说，如果采用数组指针的方式要获取其值，不可以采用常规的<code>a[n][n]...</code>来获取值</strong>，其本质原因是因为数组本身就是线性的，<strong>二维数组本质是上还是线性的存储</strong>，参考如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125; &#125;;<span class="comment">//声明并定义二维数组</span></span><br><span class="line"><span class="type">int</span>* b = a;<span class="comment">//int 类型的指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;其值为:%d\n&quot;</span>, b[j][i]);<span class="comment">//遍历数组</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你运行上述代码，会发现它是无法运行的，原因就是其本质是线性存储的，如果你希望正常读取二维数组的内容，可以修改成如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125; &#125;;<span class="comment">//声明并定义二维数组</span></span><br><span class="line"><span class="type">int</span>* b = a;<span class="comment">//int 类型的指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;其值为:%d\n&quot;</span>, b[j]);<span class="comment">//遍历数组</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码也印证了数组名是个地址，而且二维数组是线性存储的，其运行结果如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abbc950cd4f.png" alt="image-20220901074633848" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【1.1】数据结构与算法</title>
      <link href="/2022/01/25/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%901.1%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/25/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%901.1%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算法是什么？我们如何来评估算法的好坏？有没有一种优美的数学方式来评估算法好坏，而不受客观环境的影响。例如计算机的性能影响？</p><p>学习此部分，需要掌握一定的<strong>C语言基础</strong></p><p><strong>本部分内容参考程杰老师《大话数据结构》，青岛大学王卓老师的授课等 综合个人所学的总结笔记</strong></p><p>本篇写于 <strong>时间</strong> ，部分内容可能与现在不符，请自行判断</p><h4 id="start" align="center"><font color="blue">——这一招是我从我最爱的游戏里学来的♬</font></h4><h1 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h1><p><mark><strong>算法是解决特定问题求解步骤的描述，在计算机中表示为指令的有限序列并且每条指令表示一个或者多个操作</strong></mark><br>算法通俗理解就是对于问题的特定解决步骤。</p><h1 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h1><ul><li><strong>输入输出</strong><br>算法具有零个或者多个输入，至少有一个输出。</li><li><strong>有穷性</strong><br>算法在有限的步骤之后，能够自动结束而非无限循环。</li><li><strong>确定性</strong><br>算法的每一个步骤都具有确定的含义，不会存在二义性。</li><li><strong>可行性</strong><br>算法的每一个步骤都必须是可行的，也就是说每一步，都能执行有限次数完成。</li></ul><h1 id="算法设计要求"><a href="#算法设计要求" class="headerlink" title="算法设计要求"></a>算法设计要求</h1><ul><li><strong>正确性</strong><br>算法的正确性是指算法至少应该具有输入，输出和加工处理无歧义性，能正确的反映问题的需求，能够得到问题的正确答案。</li><li><strong>可读性</strong><br>算法设计的另一目的是为了便于阅读，理解和交流</li><li><mark><strong>健壮性</strong></mark><br>当输入的数据不合法时，算法也可以对其做出相应处理，而不是产生异常或者奇怪的结果</li><li>时间效率高和存储量低<br>即最大限度的提升算法消耗的时间和资源占用度</li></ul><h1 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h1><p>如何来评估一个算法的效率和好坏？可以通过两种方法来分析：</p><ol><li>事后统计方法<br>就是对于不同算法来使用同一计算机运行，结束后统计算法耗时</li><li>事前分析估算法<br><strong>在计算机编制前，依据统计方法对算法的进行评估</strong></li></ol><p>经过分析发现，一个高级语言编写的程序在计算机上运行时所消耗的时间取决于以下因素：</p><ol><li>算法采用的策略，方法；</li><li>编译产生的代码的质量；</li><li>问题的输入规模</li><li>机器执行指令的速度</li></ol><p>对于第一条来说就算法好坏的根本，剩下的都需要看外部环境，也就是说抛开计算机硬件和软件的环境因素，<strong>一个软件的运行时间，依赖于算法的好坏和问题的输入规模</strong>。</p><p>下面举例一个算法，求和 $1+2+3+4+…+100$ 的和</p><ul><li>第一种算法：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;    <span class="comment">//执行了一次</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i &lt;= n; i++)  <span class="comment">//执行了n+1次</span></span><br><span class="line">&#123;</span><br><span class="line">    sum = sum + i;  <span class="comment">//执行了n次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);  <span class="comment">//执行了1次</span></span><br></pre></td></tr></table></figure></li><li>第二种算法：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, n = <span class="number">100</span>;   <span class="comment">//执行了1次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;  <span class="comment">//执行了1次</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);  <span class="comment">//执行了1次</span></span><br></pre></td></tr></table></figure></li></ul><p>显然第一种算法执行了 $1+(n+1)+n+1$次 $&#x3D;2n+3$ 次；而第二种算法执行了 $1+1+1&#x3D;3$ 次。实际上两个算法的第一句和最后一句是一样的，所以我们只需要关心中间部分。如果我们把循环堪称一个整体，忽略判断的执行次数，那么对于两个算法执行了 <code>n</code> 次还是 <code>1</code> 次的差距，算法的好坏就一目了然了。</p><p>再来延申一下这个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j, x = <span class="number">0</span>, sum = <span class="number">0</span>, n = <span class="number">100</span>;  <span class="comment">//执行1次</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; j &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        x++;    <span class="comment">//执行nxn次</span></span><br><span class="line">        sum = sum + x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);  <span class="comment">//执行1次</span></span><br></pre></td></tr></table></figure><p>对于这个例子来说，算法需要执行 $n^2$ 次，算法的效率也远差于上面的两个例子。</p><p>此时就可以得出，测试运行时间最可靠的方法解释计算对运行时间消耗的基本操作的执行次数。</p><p>这样就引出了我们的<strong>算法的时间复杂度</strong>。</p><h1 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h1><h2 id="算法时间复杂度的定义"><a href="#算法时间复杂度的定义" class="headerlink" title="算法时间复杂度的定义"></a>算法时间复杂度的定义</h2><p><mark><strong>在进行算法分析时，语句总的执行次数 $T(n)$ 是关于问题规模 $n$ 的函数，进而分析 $T(n)$ 随 $n$ 的变化情况并确定 $T(n)$ 的数量级。算法的时间复杂度，也就是算法的时间量度，记作：$T(n)&#x3D;O(f(n))$。</strong></mark>它表示随问题规模 $n$ 的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中 $f(n)$ 是问题规模 $n$ 的某个函数。</p><p>这样用大写 $O()$ 来体现算法时间复杂度的记法，我们称之为<strong>大O记法</strong>。</p><p>一般情况下，随着 $n$ 增大， $T(n)$ 增长最慢的算法为最优算法。</p><h1 id="推导大-O-阶方法"><a href="#推导大-O-阶方法" class="headerlink" title="推导大 $O$ 阶方法"></a>推导大 $O$ 阶方法</h1><p>推导大 $O$ 阶的基本方法：</p><ol><li>用常数1取代运行时间中的所有加法常数</li><li>在修改后的运行次数函数中，只保留最高阶项</li><li>如果最高阶项存在且不是1，则去除与这个项相乘的常数。</li><li>最终得到的结果就是大 $O$ 阶</li></ol><h2 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h2><p>对于一开始第二种算法的时间复杂度来说</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, n = <span class="number">100</span>;   <span class="comment">//执行了1次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;  <span class="comment">//执行了1次</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);  <span class="comment">//执行了1次</span></span><br></pre></td></tr></table></figure><p>这个算法的运行次数是 $f(n)&#x3D;3$ 。<strong>根据大 $O$ 推导法，不含最高阶，常数项用1取代</strong>，所以该算法的时间复杂度为 $O(1)$</p><p>同理，类比下面的算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, n = <span class="number">100</span>;   <span class="comment">//执行了1次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;  <span class="comment">//执行了1次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;  <span class="comment">//执行了1次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;  <span class="comment">//执行了1次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;  <span class="comment">//执行了1次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;  <span class="comment">//执行了1次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;  <span class="comment">//执行了1次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;  <span class="comment">//执行了1次</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);  <span class="comment">//执行了1次</span></span><br></pre></td></tr></table></figure><p>不论 $n$ 的值为多少，<strong>只要是常数项，一律时间复杂度为 $O(1)$</strong> ，我们称这种时间复杂度为<strong>常数阶</strong></p><blockquote><p>对于单纯的分支结构，它的执行次数是固定的，不会随着 $n$ 的次数增大而变化，对于分支结构的时间复杂度也为常数阶，即 $O(1)$ </p></blockquote><h2 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h2><p>线性阶的循环结构会有些复杂。<strong>一般情况下，首要去分析循环结构的运行情况来分析算法的复杂度。</strong><br>例如,下面的代码，它的循环时间复杂度为 $O(n)$ ,因为在循环体中代码需要执行 $n$ 次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 时间复杂度为O(1)的步骤 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h2><p>如下经典的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (count&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">    count = count * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每次循环都乘2，所以循环 $x$ 次后，$2^x&#x3D;n$ ,转换一下就是 $x&#x3D;log_2n$，则会退出循环，所以该段代码的复杂度为 $O(log_2n)$</p><h2 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h2><p>下面是一个嵌套循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 时间复杂度为O(1)的步骤 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个嵌套循环次数为 $n$ ，嵌套后整体的算法复杂度为 $O(n^2)$<br>如果外层嵌套循环次数改为了 $m$，那么时间复杂度则为 $O(m \times n)$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 时间复杂度为O(1)的步骤 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以得出，对于嵌套循环来说，时间复杂度为 $外层循环次数 \times 嵌套循环次数$ 。</p><p>那么对于下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; i &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 时间复杂度为O(1)的步骤 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据嵌套关系可知：总的执行次数为: $n+(n-1)+(n-2)+(n-3)+…+1 &#x3D;\frac{n(n+1)}{2}&#x3D;\frac{n^2}{2}+\frac{n}{2}$</p><blockquote><p>不理解的详情查询数学《等差数列》</p></blockquote><p>根据时间复杂度大 $O$ 阶的表示方法，保留最高项，去除最高项常数，所以最终的时间复杂度为：$O(n^2)$。<br>一般的代码时间复杂度大概说明了，那么对于方法的时间复杂度怎么计算？例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    function(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的$执行次数&#x3D;代码部分+方法部分$，方法的执行次数为$1$，那么总的时间复杂度为$O(n)$。<br>那么对于下面的代码来说，时间复杂度则同上面的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = count; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 时间复杂度为1的代码 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    function(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为：$O(n^2)$。</p><h1 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h1><p>常见的时间复杂度如下表所示：</p><table><thead><tr><th align="center">执行次数函数</th><th align="center">阶</th><th align="center">非正式术语</th></tr></thead><tbody><tr><td align="center">$12$</td><td align="center">$O(1)$</td><td align="center">常数阶</td></tr><tr><td align="center">$2n+3$</td><td align="center">$O(n)$</td><td align="center">线性阶</td></tr><tr><td align="center">$3n^2+2n+1$</td><td align="center">$O(n^2)$</td><td align="center">平方阶</td></tr><tr><td align="center">$5log_2n+20$</td><td align="center">$O(log_2n)$</td><td align="center">对数阶</td></tr><tr><td align="center">$2n+3nlog_2n+19$</td><td align="center">$O(nlog_2n)$</td><td align="center">$nlog_2n$阶</td></tr><tr><td align="center">$6n^3+2n^2+3n+4$</td><td align="center">$O(n^3)$</td><td align="center">立方阶</td></tr><tr><td align="center">$2^n$</td><td align="center">$O(x^n)$</td><td align="center">指数阶</td></tr><tr><td align="center">常用的时间复杂度所耗时从小到大的排序：</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">$$O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$$</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">对于时间复杂度在 $O(n^3)$ 之后的时间复杂度，随着 $n$ 的增大，所耗时是指数级增大。</td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h1><p>最坏情况是运行时间的一种保证，对于最坏情况来说是一种最差的可能性了。在常规的应用中，除非特别指定，我们提到的运行时间都是最坏情况下的运行时间。</p><p>平均运行时间是所有情况下最有意义的，因为它是期望的运行时间。</p><h1 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h1><p>在写代码的时候，我们可以通过增加空间复杂度来换取时间复杂度，例如：在计算某年是否是闰年，可以通过算法来实现计算，也可以提前把大量可能的闰年计算出来列入一个表存储起来，这样利用一定的空间来换取时间复杂度。</p><p>**算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：$S(n)&#x3D;O(f(n))$**，其中，n为问题的规模，$f(n)$ 为语句关于 $n$ 所占存储空间的函数。</p>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【2.2】线性表的物理结构</title>
      <link href="/2022/01/25/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%902.2%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/"/>
      <url>/2022/01/25/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%902.2%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面介绍了线性表是什么，现在来讲述线性表的两种物理结构的第一种——顺序存储结构。</p><p>学习本文需要掌握一定的 <strong>C语言基础</strong>。</p><p><strong>本部分内容参考程杰老师《大话数据结构》，青岛大学王卓老师的授课，王道考研公开课等 综合个人所学的总结笔记。</strong></p><h1 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h1><p><strong>顺序表——用顺序存储的方式实现的线性表</strong></p><h2 id="顺序存储定义"><a href="#顺序存储定义" class="headerlink" title="顺序存储定义"></a>顺序存储定义</h2><p><strong>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</strong></p><p>线性表的顺序存储示意图如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae279634d5.png" alt="image-20220721193719024" style="zoom:80%;" /><blockquote><p>可以通过<code>sizeof(ElemType)</code>函数来获取数据元素的大小</p></blockquote><p>顺序表的特点是表中元素的<strong>逻辑顺序与其物理顺序相同</strong>。</p><h2 id="顺序表上的基本操作的实现"><a href="#顺序表上的基本操作的实现" class="headerlink" title="顺序表上的基本操作的实现"></a>顺序表上的基本操作的实现</h2><h3 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h3><p>静态分配，顾名思义，它的分配空间在一开始定义的时候就是固定的，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10  <span class="comment">//链表默认空间大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MaxSize];  <span class="comment">//静态空间大小</span></span><br><span class="line">    <span class="type">int</span> length;     <span class="comment">//链表的长度</span></span><br><span class="line">&#125;SqList;    <span class="comment">//链表结构体</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p><code>ElemType</code>需要看你具体使用的数据结构的类型</p></li><li><p>此处<code>Sq</code>为<code>sequence</code>的缩写</p></li></ul></blockquote><p>实现了顺序表静态分配表的初始化和插入操作，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性表的顺序表示</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10  <span class="comment">//链表默认空间大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MaxSize];  <span class="comment">//静态空间大小</span></span><br><span class="line">    <span class="type">int</span> length;     <span class="comment">//链表的长度</span></span><br><span class="line">&#125;SqList;    <span class="comment">//链表结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList sq)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sq.data[i] = <span class="number">0</span>;    <span class="comment">//初始化线性表的空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    sq.length = <span class="number">0</span>; <span class="comment">//设定初始长度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListInsert</span><span class="params">(SqList *sq,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;sq-&gt;length+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;超出预定数组&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==sq-&gt;length+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sq-&gt;data[i<span class="number">-1</span>] = e;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (sq-&gt;length-i+<span class="number">1</span>); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sq-&gt;data[sq-&gt;length-i] = sq-&gt;data[sq-&gt;length - i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            sq-&gt;data[i - <span class="number">1</span>] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        sq-&gt;length += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入操作完成\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出线性表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(SqList *sq)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sq-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,sq-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList sq;<span class="comment">//声明顺序表</span></span><br><span class="line">    InitList(sq);<span class="comment">//初始化顺序表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sq.data[i] = i+<span class="number">1</span>;<span class="comment">//“违规”填入5个数据测试</span></span><br><span class="line">    &#125;</span><br><span class="line">    sq.length = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    PrintList(&amp;sq);<span class="comment">//输出当前顺序表的内容</span></span><br><span class="line">    ListInsert(&amp;sq, <span class="number">4</span>, <span class="number">6</span>);<span class="comment">//在第4个插入整型6</span></span><br><span class="line">    PrintList(&amp;sq);<span class="comment">//输出插入后的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae28890b0a.png" alt="image-20220724233259720" style="zoom:80%;" /><p>可以很明显的看出来，这种静态分配的方式的弊端在于其分配的内存空间在一开始是缺点的，使用起来很不灵活，所以引出下面的动态分配，通过动态的分配内存空间来合理运用内存。</p><h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><p><strong>动态分配内存则需要使用两个函数<code>malloc()</code>和<code>free()</code>函数</strong>，这两个函数分别负责<strong>申请和释放内存</strong>，关于这两个函数的详细说明查看这篇文章：<a href="httpss://www.helloseraphine.top/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%909-0%E3%80%91C-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%85%B1%E7%94%A8%E4%BD%93/#%E5%A4%84%E7%90%86%E5%8A%A8%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%87%BD%E6%95%B0">处理动态链表的函数</a>。</p><blockquote><p>使用如上函数需要引入<code>&lt;malloc.h&gt;</code>头文件</p></blockquote><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10     <span class="comment">//初始化表长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> *data;  <span class="comment">//表的开始地址</span></span><br><span class="line">    <span class="type">int</span> maxsize;    <span class="comment">//表长度</span></span><br><span class="line">    <span class="type">int</span> length;  <span class="comment">//表的数据长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SqList *sq, <span class="type">int</span> size)</span>; <span class="comment">//增加表长度函数原型声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList *sq)</span>;   <span class="comment">//初始化表函数原型声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList sq;</span><br><span class="line">    InitList(&amp;sq);   <span class="comment">//初始化表</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前表长度为:%d \n&quot;</span>, sq.maxsize);  <span class="comment">//当前表长</span></span><br><span class="line">    IncreaseSize(&amp;sq, <span class="number">5</span>);    <span class="comment">//增加表长</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前表长度为:%d&quot;</span>, sq.maxsize);  <span class="comment">//增加表长后的表长</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList *sq)</span>&#123;</span><br><span class="line">    sq-&gt;data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * InitSize);    <span class="comment">//将申请的空间的头指针返回表</span></span><br><span class="line">    sq-&gt;maxsize = InitSize;  <span class="comment">//初始化表大小</span></span><br><span class="line">    sq-&gt;length = <span class="number">0</span>;  <span class="comment">//初始化表长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态的增加表的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SqList *sq,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="type">int</span> * tempdata = sq-&gt;data;   <span class="comment">//交互旧数据到临时指针</span></span><br><span class="line">    sq-&gt;data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (sq-&gt;maxsize + size)); <span class="comment">//开辟新内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sq-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sq-&gt;data[i] = tempdata[i];   <span class="comment">//将旧数据复制到新内存上</span></span><br><span class="line">    &#125;</span><br><span class="line">    sq-&gt;maxsize += size; <span class="comment">//增加数据表长度</span></span><br><span class="line">    <span class="built_in">free</span>(tempdata); <span class="comment">//释放临时指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae28d8f2c9.png" alt="image-20220725000655736" style="zoom:80%;" /><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>插入元素的时候，需要将插入的元素位置后的元素全部向后移动一位，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList *sq,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span>||i&gt;sq-&gt;length+<span class="number">1</span>)    <span class="comment">//插入非法位置判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (sq-&gt;length&gt;=sq-&gt;maxsize)    <span class="comment">//存储空间满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = sq-&gt;length; j &gt;= i; j--)   <span class="comment">//插入元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        sq-&gt;data[j] = sq-&gt;data[j<span class="number">-1</span>];  <span class="comment">//元素位置后移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    sq-&gt;data[i<span class="number">-1</span>] = e;  <span class="comment">//插入元素</span></span><br><span class="line">    sq-&gt;length++;   <span class="comment">//增加顺序表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//返回操作成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：如果你使用<code>VS code</code>编译器报错存在未定义的<code>bool</code>，则引入<code>#include &lt;stdbool.h&gt;</code></p></blockquote><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除元素的时候，需要将删除元素位置后的元素全部前移一位，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList *sq,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;sq-&gt;length)   <span class="comment">//判断删除位置是否合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除元素 %d \n&quot;</span>,sq-&gt;data[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; sq-&gt;length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sq-&gt;data[j - <span class="number">1</span>] = sq-&gt;data[j];  <span class="comment">//前移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    sq-&gt;length--;   <span class="comment">//顺序表长度减一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//返回操作成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除测试</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList sq;<span class="comment">//声明顺序表</span></span><br><span class="line">    InitList(sq);<span class="comment">//初始化顺序表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sq.data[i] = i+<span class="number">1</span>;   <span class="comment">//非法传入8个参数</span></span><br><span class="line">    &#125;</span><br><span class="line">    sq.length = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    PrintList(&amp;sq);</span><br><span class="line">    <span class="keyword">if</span> (ListDelete(&amp;sq, <span class="number">2</span>))     <span class="comment">//删除第五个位置的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除元素成功\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除元素失败，删除位置不合法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PrintList(&amp;sq);     <span class="comment">//输出删除后的元素列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae29259c29.png" alt="image-20220729161209323" style="zoom:80%;" /><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找操作——按位查找</span></span><br><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SqList *sq,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span>||i&gt;sq-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> sq-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找</span></span><br><span class="line">ElemType <span class="title function_">LocateElem</span><span class="params">(SqList *sq,ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sq-&gt;length; i++)</span><br><span class="line">        <span class="keyword">if</span> (sq-&gt;data[i]==e)</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找测试"><a href="#查找测试" class="headerlink" title="查找测试"></a>查找测试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList sq;<span class="comment">//声明顺序表</span></span><br><span class="line">    InitList(&amp;sq);<span class="comment">//初始化顺序表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sq.data[i] = i+<span class="number">1</span>;   <span class="comment">//非法传入8个参数</span></span><br><span class="line">    &#125;</span><br><span class="line">    sq.length = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    PrintList(&amp;sq);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按位置查找元素值为 %d \n&quot;</span>,GetElem(&amp;sq, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按值查找元素位置为 %d&quot;</span>,LocateElem(&amp;sq, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae295f01af.png" alt="image-20220801163745308" style="zoom:80%;" /><h2 id="顺序表的特点"><a href="#顺序表的特点" class="headerlink" title="顺序表的特点"></a>顺序表的特点</h2><ul><li><strong>随机访问</strong>，即在 $O(1)$ 的时间内找到第 i 个元素</li><li>存储密度高，每个节点只存储数据元素</li><li>拓展容量不方便（即使是动态分配，也需要大量的时间拓展）</li><li>插入，删除操作不方便，需要移动大量的元素</li></ul><h1 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h1><p>顺序表可以随时存取表中任意一个元素，它的存储和读取更为直观，但是对于插入和删除操作则需要移动大量元素。使用链式存储，不需要大量连续的存储地址，它通过指针来指示下一部分的存储位置，对于删除和插入操作来说，它不需要大量移动元素就可以完成。</p><p>链式存储结构根据其设计类型不同还可以分为：</p><ul><li><strong>单链表</strong></li><li><strong>双链表</strong></li><li><strong>循环链表</strong></li><li><strong>静态链表</strong></li></ul><blockquote><p>前排提醒：下面代码中的<code>ElemType</code>，是我一开始定义的<code>#define ElemType int</code></p></blockquote><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h3><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae29a28684.png" alt="image-20220801193918816" style="zoom:80%;" /><h3 id="单链表的基本操作实现"><a href="#单链表的基本操作实现" class="headerlink" title="单链表的基本操作实现"></a>单链表的基本操作实现</h3><h4 id="单链表的定义-1"><a href="#单链表的定义-1" class="headerlink" title="单链表的定义"></a>单链表的定义</h4><p>单链表的每个结点包含两个部分：<strong>数据域</strong>和<strong>指针域</strong>，分别用来存储数据和指向下一个结点的地址。</p><p>而头结点只表示链表的地址，也<strong>就是链表本身的表示方式，其数据域负责存储链表的结点数量信息</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表头结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SingleList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">//表示链表长度</span></span><br><span class="line">    Node *first;    <span class="comment">//链表的起始地址</span></span><br><span class="line">&#125;SingleList;</span><br></pre></td></tr></table></figure><h4 id="初始化链表"><a href="#初始化链表" class="headerlink" title="初始化链表"></a>初始化链表</h4><p>对创建的单链表进行初始化工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(SingleList* L)</span>&#123;</span><br><span class="line">    L-&gt;first = <span class="literal">NULL</span>;<span class="comment">//头结点为NULL</span></span><br><span class="line">    L-&gt;n = <span class="number">0</span>;<span class="comment">//结点数量初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h4><p>将新数据插入链表中，需要考虑插入的位序是否在链表中不存在，在插入过程中，需要给插入的数据创建专门的结点，然后将结点的指针域指向至其要插入的位序的下一个结点，再将其要插入位序的上一个结点指向新结点完成插入。代码示例：</p><blockquote><p>注意：需要先将新结点指向后面再将插入点前的结点的指针域指向新指针吗，反之，则会<strong>出现断链</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位序插入结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNode</span><span class="params">(SingleList* L,<span class="type">int</span> locattion,ElemType data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (locattion &gt; L-&gt;n+<span class="number">1</span> || locattion &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// Node* tempout = malloc(sizeof(Node));   //申请插入结点的内存空间</span></span><br><span class="line">        Node* tempout = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); </span><br><span class="line">        Node* tempin = (Node *)L;    <span class="comment">//临时结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; locattion<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tempin = tempin-&gt;next;  <span class="comment">//获取插入结点的前一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        tempout-&gt;data = data;   <span class="comment">//插入结点包含的数据</span></span><br><span class="line">        tempout-&gt;next = tempin-&gt;next;   <span class="comment">//将插入结点的下一个指针指向原来指针指向的位置</span></span><br><span class="line">        tempin-&gt;next = tempout; <span class="comment">//将插入位置前一个结点的指针指向插入结点</span></span><br><span class="line">        L-&gt;n++;<span class="comment">//链表长度+1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入成功\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><p>思路：便利获取删除结点的前一个结点或者便利获取删除结点的前一个结点和删除结点，然后将删除结点的前一个结点的指针域指向删除的结点的指针域，即删除结点的下一个结点。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除结点——按位序删除</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(SingleList* L,<span class="type">int</span> location)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (location &lt; <span class="number">1</span> || location &gt; L-&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *temp = (Node*)L;  <span class="comment">//删除结点的前一个结点</span></span><br><span class="line">    Node *tempNext = (Node*)L;  <span class="comment">//删除结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; location; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tempNext = tempNext-&gt;next;  <span class="comment">//获取删除结点</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;location<span class="number">-1</span>)</span><br><span class="line">            temp = temp-&gt;next;  <span class="comment">//获取删除结点的前一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = tempNext-&gt;next;    <span class="comment">//将删除结点的前一个结点的指针域指向删除结点的后一个结点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除位序(%d)成功，其数据为 %d\n&quot;</span>, location, tempNext-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(tempNext); <span class="comment">//释放删除结点</span></span><br><span class="line">    L-&gt;n--; <span class="comment">//表长度减一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出链表"><a href="#输出链表" class="headerlink" title="输出链表"></a>输出链表</h4><p>思路：遍历链表打印输出即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PrintList</span><span class="params">(SingleList* L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;first ==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输出失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node *temp = (Node*)L;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表的数据为：&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表查找——按位序查找"><a href="#链表查找——按位序查找" class="headerlink" title="链表查找——按位序查找"></a>链表查找——按位序查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的查找——按位查找</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetElem</span><span class="params">(SingleList* L,<span class="type">int</span> location)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (location &lt; <span class="number">1</span> || location &gt;L-&gt;n) <span class="comment">//判断查找位序是否超出范围</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * temp = (Node*)L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; location; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;  <span class="comment">//便利到指定位序获取结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;该位序数据域为: %d \n&quot;</span>, temp-&gt;data);    <span class="comment">//输出查找的位序结点的数据域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表查找——按值查找"><a href="#链表查找——按值查找" class="headerlink" title="链表查找——按值查找"></a>链表查找——按值查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的查找——按值查找</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetElemLocation</span><span class="params">(SingleList* L,ElemType data)</span>&#123;</span><br><span class="line">    Node * temp = (Node*)L; <span class="comment">//起始位置为头结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;  <span class="comment">//移动下一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;data ==data)  <span class="comment">//判断是否符合数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;指定数据的位序为: %d\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//遍历完成不存在该数据，返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="建立单链表——尾插法"><a href="#建立单链表——尾插法" class="headerlink" title="建立单链表——尾插法"></a>建立单链表——尾插法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的建立——尾插法</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_TailInsert</span><span class="params">(SingleList* L)</span>&#123;</span><br><span class="line">    Node *temp = (Node*)L;</span><br><span class="line">    <span class="type">int</span> datas;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;datas);    <span class="comment">//获取第一个输入的数值</span></span><br><span class="line">    <span class="keyword">while</span> (datas!=<span class="number">9999</span>) <span class="comment">//取一个特殊值表示终止单链表数据的输入</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node *tempNext = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//申请一个新结点的内存空间</span></span><br><span class="line">        tempNext-&gt;data = datas; <span class="comment">//新结点的数据域设定为输入的数据</span></span><br><span class="line">        temp-&gt;next = tempNext;  <span class="comment">//将结点指向新创建的结点</span></span><br><span class="line">        temp = temp-&gt;next;  <span class="comment">//结点向下走一个</span></span><br><span class="line">        L-&gt;n++; <span class="comment">//表长+1</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;datas);</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//单链表最后的结点的指针域为NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="建立单链表——头插法"><a href="#建立单链表——头插法" class="headerlink" title="建立单链表——头插法"></a>建立单链表——头插法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的建立——头插法</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_HandInsert</span><span class="params">(SingleList* L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> datas;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;datas);    <span class="comment">//获取第一个输入的数值</span></span><br><span class="line">    <span class="keyword">while</span> (datas!=<span class="number">9999</span>) <span class="comment">//取一个特殊值表示终止单链表数据的输入</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node *tempNext = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//为新数据结点开辟内存空间</span></span><br><span class="line">        tempNext-&gt;data = datas; <span class="comment">//将输入的数据传递给新结点的数据域</span></span><br><span class="line">        tempNext-&gt;next = L-&gt;first;  <span class="comment">//新结点的指针域指向单链表的第一个结点</span></span><br><span class="line">        L-&gt;first = tempNext;    <span class="comment">//单链表头结点指向新结点</span></span><br><span class="line">        L-&gt;n++; <span class="comment">//链表长度+1</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;datas);    <span class="comment">//获取第一个输入的数值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>在单链表插入操作的时候，往往我们是没有办法直接获取一个结点的前驱结点，双链表就解决了这个问题，在定义结点的时候，不仅存储下一个结点的位置，还存储上一个结点的位置。</p><h3 id="双链表-带头结点"><a href="#双链表-带头结点" class="headerlink" title="双链表(带头结点)"></a>双链表(带头结点)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">before</span>;</span>    <span class="comment">//前结点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">//后结点指针</span></span><br><span class="line">&#125;Node,Dlist;</span><br></pre></td></tr></table></figure><h4 id="双链表建立——尾插法"><a href="#双链表建立——尾插法" class="headerlink" title="双链表建立——尾插法"></a>双链表建立——尾插法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立双链表——尾插法</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_TailInsert</span><span class="params">(Dlist* L)</span>&#123;</span><br><span class="line">    Node* temp = L;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数值：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    <span class="keyword">while</span> (data != <span class="number">9999</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* tempNext = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//插入的新结点开辟内存空间</span></span><br><span class="line">        tempNext-&gt;data = data;  <span class="comment">//将数值放入结点的数据域</span></span><br><span class="line">        tempNext-&gt;next = temp-&gt;next;  <span class="comment">//新结点的后指针指向前一个结点的后指针</span></span><br><span class="line">        tempNext-&gt;before = temp;    <span class="comment">//新结点的前指针指向前一个结点</span></span><br><span class="line">        temp-&gt;next = tempNext;  <span class="comment">//前一个结点的后指针指向新结点</span></span><br><span class="line">        temp = temp-&gt;next;  <span class="comment">//结点光标移动到下一位</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入数值：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>*L</code>的用法详见<a href="httpss://www.helloseraphine.top/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%908-0%E3%80%91C-%E6%8C%87%E9%92%88/#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97%E7%AC%A6">C指针运算符</a></p></blockquote><h4 id="输出双链表内容"><a href="#输出双链表内容" class="headerlink" title="输出双链表内容"></a>输出双链表内容</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PrintList</span><span class="params">(Dlist* L)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* temp = L-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内容为：&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, temp-&gt;data);</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表-不带头结点"><a href="#双链表-不带头结点" class="headerlink" title="双链表(不带头结点)"></a>双链表(不带头结点)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">before</span>;</span>    <span class="comment">//前结点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">//后结点指针</span></span><br><span class="line">&#125;Node, * Dlist;</span><br></pre></td></tr></table></figure><h4 id="双链表建立——头插法"><a href="#双链表建立——头插法" class="headerlink" title="双链表建立——头插法"></a>双链表建立——头插法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插法建立双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_TailInsert</span><span class="params">(Dlist* L)</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数值：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    <span class="keyword">while</span> (data != <span class="number">9999</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        newNode-&gt;data = data;</span><br><span class="line">        newNode-&gt;next = *L;</span><br><span class="line">        newNode-&gt;before = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        *L = newNode;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入数值：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出双链表的内容"><a href="#输出双链表的内容" class="headerlink" title="输出双链表的内容"></a>输出双链表的内容</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PrintList</span><span class="params">(Dlist* L)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* temp = *L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内容为：&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, temp-&gt;data);</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表是单链表的最后一个结点的指针域指向头结点。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae2a51570a.png" alt="image-20220806203230096" style="zoom:80%;" /><h3 id="循环链表的定义"><a href="#循环链表的定义" class="headerlink" title="循环链表的定义"></a>循环链表的定义</h3><p>此处借用单链表定义的内容，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环链表结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环表头结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SingleList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">//表示链表长度</span></span><br><span class="line">    Node *first;    <span class="comment">//链表的起始地址</span></span><br><span class="line">&#125;SingleList;</span><br></pre></td></tr></table></figure><h3 id="循环链表初始化"><a href="#循环链表初始化" class="headerlink" title="循环链表初始化"></a>循环链表初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环链表初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(SingleList * L)</span>&#123;</span><br><span class="line">    L-&gt;first = (Node*)L;</span><br><span class="line">    L-&gt;n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表的建立——头插法"><a href="#循环链表的建立——头插法" class="headerlink" title="循环链表的建立——头插法"></a>循环链表的建立——头插法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环链表建立——头插法</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_headInsert</span><span class="params">(SingleList *L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数值：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    <span class="keyword">while</span> (data !=<span class="number">9999</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        newNode-&gt;data = data;   <span class="comment">//数据赋值到新结点</span></span><br><span class="line">        newNode-&gt;next = L-&gt;first;   <span class="comment">//新结点指向头结点的指针域</span></span><br><span class="line">        L-&gt;first = newNode;   <span class="comment">//头结点指向新结点</span></span><br><span class="line">        L-&gt;n++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入数值：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出双链表"><a href="#输出双链表" class="headerlink" title="输出双链表"></a>输出双链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出循环链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">printList</span><span class="params">(SingleList * L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;n&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Node *temp = L-&gt;first;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;循环链表数值为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>在一些没有指针的语言中，前辈们想到的用静态链表的方式来实现链表的功能的办法。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae2a9b9d25.png" alt="image-20220806230258918" style="zoom: 50%;" /><h3 id="静态链表的定义"><a href="#静态链表的定义" class="headerlink" title="静态链表的定义"></a>静态链表的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;Node,StaicList[MaxSize];</span><br></pre></td></tr></table></figure><h3 id="静态链表的操作"><a href="#静态链表的操作" class="headerlink" title="静态链表的操作"></a>静态链表的操作</h3><p>不想写啊啊啊，空着了</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>如上，线性表部分结束，最后呈现单链表，双链表的整合代码，代码不全，仅做示例。</p><ul><li><p>单链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表头结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SingleList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">//表示链表长度</span></span><br><span class="line">    Node *first;    <span class="comment">//链表的起始地址</span></span><br><span class="line">&#125;SingleList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(SingleList *L)</span>;   <span class="comment">//初始化表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNode</span><span class="params">(SingleList *L, <span class="type">int</span> locattion, ElemType data)</span>; <span class="comment">//按位序插入结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PrintList</span><span class="params">(SingleList *L)</span>;  <span class="comment">//输出链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(SingleList *L, <span class="type">int</span> location)</span>;   <span class="comment">//删除结点——按位序</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetElem</span><span class="params">(SingleList* L,<span class="type">int</span> location)</span>;  <span class="comment">//链表查找——按位序</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetElemLocation</span><span class="params">(SingleList *L, ElemType data)</span>; <span class="comment">//链表查找——按值</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_TailInsert</span><span class="params">(SingleList *L)</span>;    <span class="comment">//建立单链表——尾插法</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_HandInsert</span><span class="params">(SingleList *L)</span>;    <span class="comment">//建立单链表——头插法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//程序入口点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SingleList singleList;</span><br><span class="line">    InitList(&amp;singleList);</span><br><span class="line">    List_HandInsert(&amp;singleList);</span><br><span class="line"></span><br><span class="line">    PrintList(&amp;singleList);</span><br><span class="line"></span><br><span class="line">    InsertNode(&amp;singleList, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    PrintList(&amp;singleList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(SingleList* L)</span>&#123;</span><br><span class="line">    L-&gt;first = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位序插入结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNode</span><span class="params">(SingleList* L,<span class="type">int</span> locattion,ElemType data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (locattion &gt; L-&gt;n+<span class="number">1</span> || locattion &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// Node* tempout = malloc(sizeof(Node));   //申请插入结点的内存空间</span></span><br><span class="line">        Node* tempout = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); </span><br><span class="line">        Node* tempin = (Node *)L;    <span class="comment">//临时结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; locattion<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tempin = tempin-&gt;next;  <span class="comment">//获取插入结点的前一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        tempout-&gt;data = data;   <span class="comment">//插入结点包含的数据</span></span><br><span class="line">        tempout-&gt;next = tempin-&gt;next;   <span class="comment">//将插入结点的下一个指针指向原来指针指向的位置</span></span><br><span class="line">        tempin-&gt;next = tempout; <span class="comment">//将插入位置前一个结点的指针指向插入结点</span></span><br><span class="line">        L-&gt;n++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入成功\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PrintList</span><span class="params">(SingleList* L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;first ==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输出失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node *temp = (Node*)L;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表的数据为：&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点——按位序删除</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(SingleList* L,<span class="type">int</span> location)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (location &lt; <span class="number">1</span> || location &gt; L-&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *temp = (Node*)L;  <span class="comment">//删除结点的前一个结点</span></span><br><span class="line">    Node *tempNext = (Node*)L;  <span class="comment">//删除结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; location; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tempNext = tempNext-&gt;next;  <span class="comment">//获取删除结点</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;location<span class="number">-1</span>)</span><br><span class="line">            temp = temp-&gt;next;  <span class="comment">//获取删除结点的前一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = tempNext-&gt;next;    <span class="comment">//将删除结点的前一个结点的指针域指向删除结点的后一个结点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除位序(%d)成功，其数据为 %d\n&quot;</span>, location, tempNext-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(tempNext); <span class="comment">//释放删除结点</span></span><br><span class="line">    L-&gt;n--; <span class="comment">//表长度减一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表的查找——按位查找</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetElem</span><span class="params">(SingleList* L,<span class="type">int</span> location)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (location &lt; <span class="number">1</span> || location &gt;L-&gt;n) <span class="comment">//判断查找位序是否超出范围</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * temp = (Node*)L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; location; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;  <span class="comment">//便利到指定位序获取结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;该位序数据域为: %d \n&quot;</span>, temp-&gt;data);    <span class="comment">//输出查找的位序结点的数据域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表的查找——按值查找</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetElemLocation</span><span class="params">(SingleList* L,ElemType data)</span>&#123;</span><br><span class="line">    Node * temp = (Node*)L; <span class="comment">//起始位置为头结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;  <span class="comment">//移动下一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;data ==data)  <span class="comment">//判断是否符合数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;指定数据的位序为: %d\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//遍历完成不存在该数据，返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表的建立——尾插法</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_TailInsert</span><span class="params">(SingleList* L)</span>&#123;</span><br><span class="line">    Node *temp = (Node*)L;</span><br><span class="line">    <span class="type">int</span> datas;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;datas);    <span class="comment">//获取第一个输入的数值</span></span><br><span class="line">    <span class="keyword">while</span> (datas!=<span class="number">9999</span>) <span class="comment">//取一个特殊值表示终止单链表数据的输入</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node *tempNext = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//申请一个新结点的内存空间</span></span><br><span class="line">        tempNext-&gt;data = datas; <span class="comment">//新结点的数据域设定为输入的数据</span></span><br><span class="line">        temp-&gt;next = tempNext;  <span class="comment">//将结点指向新创建的结点</span></span><br><span class="line">        temp = temp-&gt;next;  <span class="comment">//结点向下走一个</span></span><br><span class="line">        L-&gt;n++; <span class="comment">//表长+1</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;datas);</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//单链表最后的结点的指针域为NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表的建立——头插法</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_HandInsert</span><span class="params">(SingleList* L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> datas;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;datas);    <span class="comment">//获取第一个输入的数值</span></span><br><span class="line">    <span class="keyword">while</span> (datas!=<span class="number">9999</span>) <span class="comment">//取一个特殊值表示终止单链表数据的输入</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node *tempNext = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//为新数据结点开辟内存空间</span></span><br><span class="line">        tempNext-&gt;data = datas; <span class="comment">//将输入的数据传递给新结点的数据域</span></span><br><span class="line">        tempNext-&gt;next = L-&gt;first;  <span class="comment">//新结点的指针域指向单链表的第一个结点</span></span><br><span class="line">        L-&gt;first = tempNext;    <span class="comment">//单链表头结点指向新结点</span></span><br><span class="line">        L-&gt;n++; <span class="comment">//链表长度+1</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;datas);    <span class="comment">//获取第一个输入的数值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">before</span>;</span>    <span class="comment">//前结点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">//后结点指针</span></span><br><span class="line">&#125;Node,Dlist;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_TailInsert</span><span class="params">(Dlist* L)</span>;  <span class="comment">//建立双链表——尾插法</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PrintList</span><span class="params">(Dlist* L)</span>;    <span class="comment">//输出链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitSingleList</span><span class="params">(Dlist* L)</span>;   <span class="comment">//初始化链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//程序入口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Dlist L;</span><br><span class="line">    InitSingleList(&amp;L);</span><br><span class="line">    List_TailInsert(&amp;L);</span><br><span class="line">    PrintList(&amp;L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitSingleList</span><span class="params">(Dlist* L)</span> &#123;</span><br><span class="line">    L-&gt;before = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立双链表——尾插法</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_TailInsert</span><span class="params">(Dlist* L)</span>&#123;</span><br><span class="line">    Node* temp = L;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数值：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    <span class="keyword">while</span> (data != <span class="number">9999</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* tempNext = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//插入的新结点开辟内存空间</span></span><br><span class="line">        tempNext-&gt;data = data;  <span class="comment">//将数值放入结点的数据域</span></span><br><span class="line">        tempNext-&gt;next = temp-&gt;next;  <span class="comment">//新结点的后指针指向前一个结点的后指针</span></span><br><span class="line">        tempNext-&gt;before = temp;    <span class="comment">//新结点的前指针指向前一个结点</span></span><br><span class="line">        temp-&gt;next = tempNext;  <span class="comment">//前一个结点的后指针指向新结点</span></span><br><span class="line">        temp = temp-&gt;next;  <span class="comment">//结点光标移动到下一位</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入数值：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PrintList</span><span class="params">(Dlist* L)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* temp = L-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内容为：&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, temp-&gt;data);</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【2.1】线性表的逻辑结构</title>
      <link href="/2022/01/25/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%902.1%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/"/>
      <url>/2022/01/25/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%902.1%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有了前面的基础，现在开始正式学习数据结构最常用也是最简单的一种结构——线性表。</p><p>学习本文需要掌握一定的 <strong>C语言基础</strong>。</p><p><strong>本部分内容参考程杰老师《大话数据结构》，青岛大学王卓老师的授课，王道考研公开课等 综合个人所学的总结笔记。</strong></p><h1 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h1><p>线性表，顾名思义，是具有像线一样串联起来的表。串联则意味着存在一个头部，一个尾部，且中间的每个元素都是一个挨着一个，这样的表就可以称为线性表。</p><p><strong>线性表(List)：零个或多个数据元素的有限序列。</strong></p><p>需要强调的是：</p><ol><li>首先它是一个序列，也就是说，元素之间是有顺序的，如果元素存在多个，那么第一个元素无前驱，最后一个元素无后继，其他的元素都有且只有一个前驱和后继。</li><li>其次，线性表是有限的。事实上，计算机中处理的对象都是有限，无限的序列，只存于数学中的概念。</li></ol><p>如果使用数学语言来进行定义的话，如下：</p><p><strong>若将线性表记为（$a_1,·····,a_{i-1},a_i,a_{i+1},···,a_n$），则表中 $a_{i-1}$ 领先于 $a_i$ ，$a_i$ 领先于 $a_{i+1}$，称 $a_{i-1}$ 是 $a_i$ 的直接前驱，$a_{i+1}$ 是 $a_i$ 的直接后继。当 $i&#x3D;1,2,···，n-1$ 时，$a_i$ 有且仅有一个直接后继；当 $i&#x3D;2,3,···，n$ 时，$a_i$ 有且仅有一个直接前驱。</strong> 如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae1fd3dff3.png" alt="image-20220725001546950" style="zoom:80%;" /><p>所以<strong>线性表元素的个数 $n$ ($n\geq0$)定义为线性表的长度，当 $n&#x3D;0$ 时，称为空表。</strong></p><p>在非空表中的每个数据元素都有一个确定的位置，如 $a_1$是第一个数据元素，$a_n$是最后一个数据元素，$a_i$ 是第 $i$ 个数据元素，称 $i$ 为数据元素 $a_i$ 在线性表中的位序。</p><h2 id="线性表的例子"><a href="#线性表的例子" class="headerlink" title="线性表的例子"></a>线性表的例子</h2><ul><li><p>26个英文字母组成的英文表<br>  ($A,B,C,···,Z$)<br>  元素都是字母；元素关系是线性的；</p></li><li><p>学生情况登记表</p><table><thead><tr><th align="center">学号</th><th align="center">姓名</th><th align="center">性别</th><th align="center">年龄</th><th align="center">班级</th></tr></thead><tbody><tr><td align="center">001</td><td align="center">于春梅</td><td align="center">女</td><td align="center">18</td><td align="center">01级计算机1班</td></tr><tr><td align="center">002</td><td align="center">何仕鹏</td><td align="center">男</td><td align="center">20</td><td align="center">01级计算机2班</td></tr><tr><td align="center">003</td><td align="center">王亚</td><td align="center">女</td><td align="center">19</td><td align="center">01级计算机4班</td></tr><tr><td align="center">：</td><td align="center">：</td><td align="center">：</td><td align="center">：</td><td align="center">：</td></tr></tbody></table></li></ul><h1 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h1><p>线性表的抽象数据类型定义如下：</p><h2 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ADT List&#123;</span><br><span class="line">    数据对象：对象的基本信息</span><br><span class="line">    数据关系：数据元素之间的关系</span><br><span class="line">    基本操作：</span><br><span class="line">        InitList(&amp;L);    <span class="comment">//创建线性表</span></span><br><span class="line">        DestroyList(&amp;L);    <span class="comment">//销毁线性表</span></span><br><span class="line">        ListInsert(&amp;L,i,e);    <span class="comment">//插入数据</span></span><br><span class="line">        ListDelete(&amp;L,i,&amp;e);    <span class="comment">//删除数据</span></span><br><span class="line">        ....等等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>InitList(&amp;L)<ul><li>操作结果：<strong>构造一个空的线性表L</strong><blockquote><p>initialization     &#x2F;i,niʃəlai’zeiʃən&#x2F;    初始化，设定初值</p></blockquote></li></ul></li><li>DestoryList(&amp;L)<ul><li>初始条件：线性表L已经存在</li><li>操作结果：<strong>销毁线性表L</strong></li></ul></li><li>ClearList(&amp;L)<ul><li>初始条件：线性表L已经存在</li><li>操作结果：<strong>将线性表L重置为空表</strong></li></ul></li><li>ListEmpty(L)<ul><li>初始条件：线性表L已经存在</li><li>操作结果：<strong>若线性表L为空表，则返回TRUE；否则返回FLASE</strong></li></ul></li><li>ListLength(L)<ul><li>初始条件：线性表L已经存在</li><li>操作结果：<strong>返回线性表L中的数据元素的个数。</strong></li></ul></li><li>GetElem(L,i,&amp;e);<ul><li>初始条件：线性表L已经存在，$1 \leq i \leq ListLength(L)$。</li><li>操作结果：<strong>用 e 返回线性表L中第 i 个数据元素的值。</strong></li></ul></li><li>LocateElem(L,e,compare())<ul><li>初始条件：线性表L已经存在，<code>compare()</code>是数据元素判定函数。</li><li>操作结果：<strong>返回L中第一个与e满足<code>compare()</code>的数据元素的位序。若这样的数据元素不存在则返回值为0。</strong></li></ul></li><li>PriorElem(L,cur_e,&amp;pre_e)<ul><li>初始条件：线性表L已经存在</li><li>操作结果：<strong>若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义。</strong><blockquote><p>prior    &#x2F;‘praɪɚ&#x2F;    在前的，在先的；优先的；<br>pre- 【前缀】先于；在….前；</p></blockquote></li></ul></li><li>NextElem(L,cur_e.&amp;next_e)<ul><li>初始条件：线性表L已经存在</li><li>操作结果：<strong>若cur_e是L的数据元素，且不是第最后一个，则用Next_e返回它的后继，否则操作失败，next_e无意义。</strong><blockquote><p>currently    &#x2F;‘kʌrəntli&#x2F;    当前；目前；眼下</p></blockquote></li></ul></li><li>ListInsert(&amp;L,i,e)<ul><li>初始条件：线性表L已经存在，$1 \leq i \leq ListLength(L)+1$。</li><li>操作结果：<strong>在L的第 i 个位置之前插入信的数据元素e，L的长度加一。</strong></li></ul></li><li>ListDelete(&amp;L,i,&amp;e)<ul><li>初始条件：线性表L已经存在，$1 \leq i \leq ListLength(L)$</li><li>操作结果：<strong>删除L的第 i 个数据元素，并用 e 返回其值，L的长度减一。</strong></li></ul></li><li>ListTraverse(&amp;L,visited())<ul><li>初始条件：线性表L已经存在</li><li>操作结果：<strong>依次对线性表中的每个元素调用<code>visited()</code></strong></li></ul></li></ul><p>以上所提及的运算是逻辑结构上定义的运算。主要是给出这些运算的功能是”做什么“，至于”怎么做“等实现细节，只有在确定了存储结构之后才考虑。</p><h1 id="线性表的存储结构"><a href="#线性表的存储结构" class="headerlink" title="线性表的存储结构"></a>线性表的存储结构</h1><p>在计算机中，线性表有两种基本的存储结构：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>，也就是耳熟能详的，顺序表和链式表。后面的部分会讲述如何通过顺序存储结构和链式存储结构来表示和实现线性表。</p>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【1.0】C-引言</title>
      <link href="/2022/01/22/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%901.0%E3%80%91%E5%BC%95%E8%A8%80/"/>
      <url>/2022/01/22/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%901.0%E3%80%91%E5%BC%95%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="【1-0】引言"><a href="#【1-0】引言" class="headerlink" title="【1.0】引言"></a>【1.0】引言</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是C语言基础的笔记，也是我的复习笔记，本笔记没有长篇大论的理论，也没有过多的基础解释，对于稍微熟悉一点计算机语言的但是又迫切复习的小伙伴来说可能会有一些帮助。</p><p>前排提醒，本文需要一定的<strong>计算机基础</strong>和<strong>计算机语言基础</strong></p><p>废话不多说，直接开始C语言之旅。</p><h1 id="C语言入门程序结构"><a href="#C语言入门程序结构" class="headerlink" title="C语言入门程序结构"></a>C语言入门程序结构</h1><p>直接展示计算机语言的入门编程，<code>Hello world</code>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);    <span class="comment">//输出Hello World</span></span><br><span class="line">    getchar();    <span class="comment">//暂停控制台</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//返回 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整段代码结构很简单，先来剖析一下每一个部分是什么意思。</p><ul><li>第一行代码 <code>#include &lt;stdio.h&gt;</code> ，是C语言的头函数，<code>#</code>后面是预处理函数宏，这句话的意思是引入<code>stdio.h</code> 这个系统文件，在头文件中包含了C语言开始的入口和基本的处理，所以需要编写C语言，开头一定需要引入头函数。</li><li>第二行 <code>int main()&#123;&#125;</code> 表示这是个“主函数”，所有我们需要跑的代码都需要写在 <code>&#123;&#125;</code> 花括号里面才可以运行，它是我们的写的代码的入口点。</li><li>第三行 <code>printf(&quot;Hello world&quot;);</code> 它的意思是在屏幕上输出 <code>()</code> 括号里的内容。因为括号里写的是 “Hello world”,所以它会在控制台上输出相应的字符。</li><li>第四行 <code>getchar();</code> ，你可能在一般入门的地方不会见到这个函数，如果你使用的是 <code>VScode</code> 编辑器手动链路C底层或者其他编辑器，如果运行的时候，控制台一秒闪过，就需要使用这个函数来暂停控制台。</li><li>第五行 <code>return 0;</code> 它的意思是返回一个 0 ，你或许会有疑问：为什么要返回 0，返回其他可以不可以，为什么要返回 0 ，我可以先告诉你的是：它可以自定义返回大部分的整型数字，例如：1，2，3，4，5，6，7，8，9等等。至于为什么不可以返回例如 “你好” 之类的，后面学到函数的时候就会明白了。</li><li>如果你足够细心就会发现，对于主函数里的每行代码的末尾都有 <code>;</code> ，结束。是的，<code>;</code> 表示每行代码的结束。</li></ul><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>另外，最终重要的是注释，注释是对代码的一种解释说明，它不会影响代码的任何运行，只是为了方便后来的人来阅读或者理解别人的代码来辅助的。<br>C语言的注释格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双斜杠，表示行内注释，它只能注释一行的内容</span></span><br><span class="line"><span class="comment">//如果你希望可以注释很多行的内容可以使用如下：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这样/*~*/</span>里面的内容就全部注释了</span><br><span class="line">    这行也是被注释了</span><br><span class="line">    这行也是</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>注释是我们的法宝，也是帮助我们快速入门看懂代码的基础。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，你现在已经学会C语言了，快去写一个学生管理系统吧（bushi）</p><p>C语言是万物的基础，对于 <code>JAVA</code> <code>C#</code> 等高级语言来说，底层是又C语言发展而来，俗话说得好“汇编生C，C生万物”。掌握好C语言，对不论是其他计算机语言，还是其他计算机的知识，都有一定的帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【2.0】C-数据类型及运算</title>
      <link href="/2022/01/22/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%902.0%E3%80%91%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%BF%90%E7%AE%97/"/>
      <url>/2022/01/22/%E8%AF%AD%E8%A8%80%E6%A0%91/C%E8%AF%AD%E8%A8%80/%E3%80%902.0%E3%80%91%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="【2-0】数据类型及运算"><a href="#【2-0】数据类型及运算" class="headerlink" title="【2.0】数据类型及运算"></a>【2.0】数据类型及运算</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>c 语言经典的入门内容，笔记断断续续写了一个多礼拜，最近一直在考试，碰到考试周了就很头疼。</p><h1 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h1><p>C程序由C语言的基本字符组成，基本字符依据规则组成C语言的<strong>标识符</strong>和<strong>关键词</strong>，再按照语法要求构成程序。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>C语言中由<strong>用户命名的符号称为标识符</strong>，用来标明用户设定的变量名，数组名，函数名，结构体名等。标识符必须由有效字符构成，也就是标识符要合法。</p><p>C语言的命名规则如下：</p><ol><li><p>标识符只能由<strong>字母，下划线，数字</strong>组成，且<strong>第一个字符必须是字母或者下划线</strong>，不能是数字。如：<code>cla</code>,<code>cla1</code>都是合法的，但是<code>2cla</code>,<code>%123</code>等都是不合法的。</p></li><li><p>字母区分大小写，例如：<code>AB</code> 和 <code>ab</code>是两个不同的标识符</p><blockquote><p>当然有的计算机语言不区分大小写；例如：VB语言不区分大小写</p></blockquote></li><li><p>不能使用C语言中的关键字</p></li><li><p>C语言虽然本身不限制标识符的长度，但是实际长度收到不同的编译系统和机器系统的限制。</p></li></ol><p><strong>为了提高标识符的可读性，一般来说，业内较为流行的有驼峰命名法，下划线命名法和匈牙利命名法</strong></p><ul><li><strong>驼峰命名法</strong><ul><li><p>小驼峰命名法：除了第一个单词之外，其他单词首字母都大学。例如：<code>myFileName</code>，<code>openFileSys</code>等。</p><blockquote><p>常用于变量名，函数名；</p></blockquote></li><li><p>大驼峰命名法（又称帕斯卡命名法）：所有单词的首字母均大写，例如：<code>OpenFileSys</code>，<code>ConDataBase</code>等</p><blockquote><p>常用于类名，属性，命名空间等；</p></blockquote></li></ul></li><li><strong>下划线命名法</strong><ul><li>名称中的每一个逻辑断点都用一个下划线来标记，例如，函数名 <code>print_student_name</code>。下划线命名法是随着C语言的出现而流行的，在UNIX&#x2F;Linux这样的环境，以及GNU代码中非常普遍。</li></ul></li><li><strong>匈牙利命名法</strong><ul><li>该命名法由微软公司名为 Charles Simonyi 的匈牙利程序员发明的，其基本原则是，<strong>变量名&#x3D;属性+类型+对象描述</strong>。通过在变量名前面加上相应的小写字母的符号标识作为前缀，标识出变量的作用域，类型等。这些符号可以多个同时使用，顺序是先 <code>m_</code>（成员变量），再指针，再简单数据类型，再其他。例如，<code>m_lpsStr</code> 表示指向一个字符串的长指针成员变量。</li></ul></li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>C语言规定具有特别意义的字符串为关键字（即保留字），关键字不能作为用户标识符。在一些IDE中，关键字会显示为彩色字符来做明显标识。</p><p>C语言的关键字如下表，可以分为以下几类：</p><ol><li>类型声明符。如表示整型的 <code>int</code>等</li><li>语句定义符。用于表示语句功能的，例如条件语句的 <code>if</code>,<code>else</code>等</li><li>预处理命令字。它们是以固定的形式用于专门的位置，表示一个预处理命名，通常将它们当作关键字来看待，如文件包含预处理命令 <code>include</code> 等</li></ol><p><strong>C语言中的关键字</strong></p><table><thead><tr><th align="center">int</th><th align="center">long</th><th align="center">short</th><th align="center">float</th><th align="center">double</th><th align="center">char</th></tr></thead><tbody><tr><td align="center">while</td><td align="center">do</td><td align="center">switch</td><td align="center">case</td><td align="center">continue</td><td align="center">break</td></tr><tr><td align="center">const</td><td align="center">signed</td><td align="center">unsigned</td><td align="center">if</td><td align="center">else</td><td align="center">for</td></tr><tr><td align="center">default</td><td align="center">auto</td><td align="center">register</td><td align="center">static</td><td align="center">extern</td><td align="center">void</td></tr><tr><td align="center">return</td><td align="center">struct</td><td align="center">union</td><td align="center">enum</td><td align="center">typedef</td><td align="center">volatile</td></tr><tr><td align="center">goto</td><td align="center">sizeof</td><td align="center">inline</td><td align="center">restrict</td><td align="center">bool</td><td align="center">_ Complex</td></tr><tr><td align="center">_Imaginary</td><td align="center">include</td><td align="center">define</td><td align="center">undef</td><td align="center">ifdef</td><td align="center">ifndef</td></tr><tr><td align="center">endif</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>其中的bool,_Complex和_Imaginary是C99新增的关键字，其余的关键字全由小写字母组成。</p><h1 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h1><p>C程序的处理对象为<strong>数据，它们通常以常量或者变量的形式出现</strong>。常量是在程序运行过程中值保持不变的量，变量则是在程序运行过程中值可以改变的量。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>C语言的常量有两种，一种是字面常量，字面常量不需要定义，是非定义量，即通常的数字和字符，例如：123，456，-123，12.4或者字符”A”,”b”等。第二种是自定义常量，或者符号常量，<strong>以一个标识符来代表某一个字面常量，通常利用C语言的宏定义命令 <code>define</code> 来定义</strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415962</span></span><br></pre></td></tr></table></figure><p>其含义为以标识符 <code>PI</code> 来代表数据 3.1415926。宏定义命令之后，程序凡是用到 3.1415926 的地方都可以使用 <code>PI</code> 来表示，减少书写的工作量，还可以通过别名来提高程序的可读性。</p><p>使用符号常量后，程序的可维护性好，当需要修改某一常量时，只要修改宏定义中的常量即可，不必逐一修改。</p><blockquote><p>有关于宏的知识，后面会详细讲述</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>每个变量都有三个属性：变量名，存储空间，变量值</strong>。</p><ol><li>变量名：即变量的名字，是我们自定义的标识符，程序中通常使用变量名来对变量进行引用。</li><li>存储空间：每个变量在内存中都占用一定的存储单元。存储单元的大小由变量的类型决定。在C程序中，变量可以通过变量名称访问，也可以通过变量的地址来访问。</li><li>变量值，即变量存储空间中存放的值。</li></ol><p>在C程序中，对任何变量都必须 <strong>先声明，后使用</strong> ，只有在定义了变量的名字，数据类型之后，才能对变量进行各种运算。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>完整的变量定义语句包含两个元素：<strong>变量名和数据类型</strong>。数据类型规定了变量的三个限制：</p><ol><li>变量所占用的存储空间的大小，存储空间以字节为单位，如整型变量占用2个字节，浮点型占用4个字节。</li><li>变量的取值范围，变量的取值返回与存储空间的大小有关，如整型取值范围为 $-32728$~$32767$ ，浮点型取值范围为 $-3.4 \times 10^{-38}$ ~ $3.4 \times 10^{38}$ 。</li><li>变量能进行的运算。如只有整型或者字符型的数据可以进行”取余”运算</li></ol><blockquote><p>关于为什么整型的取值范围为 -32728~32767 ，详情参见 <a href="httpss://helloseraphine.top/index.php/archives/368.html">原码，反码，补码的前世今生</a></p></blockquote><p>C语言的数据类型如下图所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb7f237f39.png" alt="image-20220107161251322" style="zoom:80%;" /><blockquote><p>存储类型以字节为单位，实际长度由机器字长决定。整型数据取值范围与存储长度一致，但浮点型数据的取值范围还与其系统存储格式有关。</p></blockquote><h2 id="整型数据"><a href="#整型数据" class="headerlink" title="整型数据"></a>整型数据</h2><p>整型数据包括整常数和存放整数的变量，C语言中整型常量可以有三种表示形式：</p><ol><li>十进制形式，如15，-1555</li><li>八进制形式。<strong>C语言中八进制以数字 0 开头</strong>，只能以 0~ 7 这8个数字组合表示，如 0271 对应十进制的数为 $2 \times 8^2 + 7 \times 8^1 +1 \times 8^0 &#x3D; 185$</li><li>十六进制形式。<strong>C语言中十六进制数以 0x 或者 0X 开头，可以用 0<del>9 这10个数表示以及字母 A</del>F（或 a~f ）组合来表示</strong>。如 0x61F 对应的十进制数为 $6 \times 16^2 + 1 \times 16^1 + 15 \times 16^0 &#x3D; 1567$</li></ol><p>整型数据按存储空间长度可以分为五种：</p><ol><li><p><strong>基本整型：关键字为 <code>int</code></strong> 。在16位计算机中基本整型数据占据2个字节，最高位表示正负符号位，取值范围 $-32768$ ~ $32767$。在32位计算机中基本整型占据4个字节，最高位位正负符号位，取值范围为 $-2147493648$ ~ $2147483647$ 。代码示例：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;    <span class="comment">//声明了整型变量 a</span></span><br></pre></td></tr></table></figure></li><li><p>**短整型：关键字为 <code>short int</code> (<code>int</code>可以省略)**。短整型占2个字节，最高位为符号位，取值范围为 $-32768$ ~ $32767$。代码示例：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="type">int</span> a;    <span class="comment">//声明了短整型变量 a</span></span><br><span class="line"><span class="type">short</span> a;</span><br></pre></td></tr></table></figure></li><li><p>**长整型：关键字为 <code>long int</code>( <code>int</code> 可以省略)**。长整型占4个字节，最高位为符号位，取值范围为 $-2^{31}$ ~ $2^{31}-1$ 。代码示例：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> a;    <span class="comment">//声明了长整型变量 a</span></span><br><span class="line"><span class="type">long</span> a;</span><br></pre></td></tr></table></figure></li><li><p><strong>双长整型：关键字为 <code>long long int</code>（<code>int</code> 可以省略）</strong>。双长整型占 8 个字节，最高位为符号位，取值范围为 $-2^{63}$ ~ $2^{63}-1$ 。代码示例：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> a;    <span class="comment">//声明了双长整型变量 a</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a;</span><br></pre></td></tr></table></figure></li><li><p><strong>布尔型：关键字为 <code>bool</code><strong>。布尔型数据占据 2 个字节。</strong>其取值有两种：真（TRUE&#x2F;1）和假（FLASE&#x2F;0）</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> x;    <span class="comment">//声明了布尔型变量 x</span></span><br></pre></td></tr></table></figure><blockquote><p>C99之后的Bool被定义为 <code>_bool</code>，再次之前布尔类型是通过 <code>int</code> 类型来定义的</p></blockquote></li></ol><p>以上基本整型，短整型，长整型及双长整型都是可正可负的，可以看作省略了关键字 <code>signed</code> 的有符号类型，即以上的定义可以写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">signed</span> <span class="type">short</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> loog a;</span><br></pre></td></tr></table></figure><p>如果在使用的数值无须符号，则定义为无符号类型，其关键字为 <code>unsigned</code> 。 定义无符号类型的整型变量只需要在前面加上该关键字即可。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> loog a;</span><br></pre></td></tr></table></figure><blockquote><p>无符号类型即全为正数，无负数（抛弃了符号位）</p></blockquote><p>无符号关键字只适用于整型变量。</p><p>C语言的变量必须“先定义，后使用”，从上面的示例可以看出，C语言中变量的定义格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存储类型 数学类型 变量名称；</span><br></pre></td></tr></table></figure><blockquote><p>其中存储类型可以默认省略。</p></blockquote><h2 id="实型数据"><a href="#实型数据" class="headerlink" title="实型数据"></a>实型数据</h2><p>实型数据包括实型常数（常量）和实型变量，实型数据即带小数的数据（实数），或称浮点数。</p><p>C语言中实型常量只用十进制形式，但是其表示方式有两种：</p><ol><li>直接十进制形式，如：0123，-456.48。</li><li>指数形式，如： $1.23e-2$，$-4.123e2$。<br> 指数形式通常用来表示一些比较大的数值，格式为：实数部分+字母 E 或者 e +正负号+整数部分。其中的 E 或者 e 表示十次方，即 $实数e^{-&#x2F;+整数}$，并不是常规数学表达式中的自然底数，正负号表示指数部分的符号，整数为幂的大小。字母 E 或者 e 之前必须有数字，之后的数字必须为整数。</li></ol><p>C语言中实型数据按长度大小可以分为三类：</p><ol><li>**单精度型：关键字为 <code>float</code>**，占 4 个字节。提高 7 位有效数字，取值范围为 $-3.4 \times 10^{-38}$ ~ $3.4 \times 10^{38}$。</li><li>**双精度型：关键字为 <code>double</code>**，占 8 个字节，提供 16 位有效数字，取值范围为 $-1.7 \times 10^{-308}$ ~ $1.7 \times 10^{308}$。</li><li>**长双精度型：关键字为 <code>long double</code>**，占 16 个字节，取值范围为  $-1.2 \times 10^{-4932}$ ~ $1.2 \times 10^{4932}$。</li></ol><blockquote><p>计算机中实型数据实际上是以指数的形式存储的，用二进制来表示小数部分以及用 2 的幂次来表示指数部分。但不同长度类型中究竟用多少位来表示小数部分，多少位来表示指数部分，各种 C 编译系统不尽相同。</p></blockquote><p>【实例】输出单精度实数，验证有效数字位数<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">1111111.222222</span>;    <span class="comment">//小数点前7位</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, a);</span><br></pre></td></tr></table></figure><p>【输出结果】 <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb7fd6b3dc.png" alt="image-20220107164922598" style="zoom:80%;" /><br>【说明】我用的是VScode，手动配置链接的 <a href="httpss://sourceforge.net/projects/mingw-w64/files/">MinGW</a>，可以得出此编译器的单精度浮点的有效位为 8 位。</p><p>【实例】输出双精度实数<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">1111111.22222</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, a);</span><br></pre></td></tr></table></figure><p>【输出结果】 <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb803db070.png" alt="image-20220107165026188" style="zoom:80%;" /><br>【说明】</p><ul><li><strong>使用 <code>%f</code> 可以输出单精度或者双精度浮点数，对于长双精度浮点数，使用 <code>%Lf</code> 。</strong></li><li><strong><code>double</code> 输出的时候，默认输出小数后 6 位 ，不足 6 位时补 0，多余 6 位时四舍五入后只输出前 6 位。</strong></li><li><strong>可以使用 <code>%.xf</code> 修改 x 的值来指定输出小数点后几位</strong></li></ul><h2 id="字符型数据"><a href="#字符型数据" class="headerlink" title="字符型数据"></a>字符型数据</h2><p>C语言中字符型数据包括字符常量和字符变量。</p><p><strong>字符常量必须用单引号括起来，单引号中只能为单个字符</strong>，在内存中占用一个字节，例如：<code>A</code>，<code>a</code>，<code>#</code>等。</p><p><strong>字符型数据在C语言中是以 ASCII 码形式存储的</strong>，即字符常量的数值就是其保持的 ASCII 码的值，如：<code>A</code> 的 ASCII 码值为 65 。<strong>因为 ASCII 码值为整型，故C语言中字符型数据与整型数据可以在同一个表达式中出现，并且不会进行类型转换</strong>。例如： <code>a</code>-32相当于 97-32 。</p><blockquote><p>可以通过对大写字母 +32 来进行大小写转换。</p></blockquote><p>C语言中还有一类特殊的字符，称为<strong>转义字符</strong>，<strong>以 <code>\</code> 开头，根据斜杠后面的不同字符表达特定的含义</strong>。常用的转义字符如下：</p><ul><li><strong><code>\n</code>：回车换行。</strong></li><li><code>\b</code>：退格</li><li><code>\r</code>：回车</li><li><strong><code>\t</code>：水平制表，即横向跳到下一个制表位。</strong></li><li><code>\v</code>：垂直制表，即纵向跳到下一个制表位。</li><li><strong><code>\\</code>：反斜线符号 <code>\</code>。</strong></li><li>**<code>\&#39;</code>：单引号 <code>&#39;</code>**。</li><li>**<code>\&quot;</code>：双引号 <code>&quot;</code>**。</li><li><code>\a</code>：鸣铃。</li><li><code>\f</code>：走纸换页。</li><li><strong><code>\ddd</code>：1~3位八进制数所代表的字符</strong>。</li><li><strong><code>\xhh</code>：1~2位十六进制数所代表的字符</strong></li></ul><p>实际上，利用 <code>\ddd</code> 和 <code>\xhh</code> 可以表示任意一个字符，分别利用八进制和十六进制转换为 ASCII 码的值。例如：<code>\123</code> 输出表示为 <code>S</code>。</p><p>**定义字符型变量的关键字为 <code>char</code>**，字符型变量在内存中占用一个字节。需要注意的是，在使用字符型存储整型时，只有一个字节的大小，注意溢出问题。</p><p>【实例】输出字符及其对应的 ASCII 码<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ch=%c\nASCII=%d&quot;</span>, ch, ch);</span><br></pre></td></tr></table></figure><p>【输出结果】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb8088ab6d.png" alt="image-20220107165203189" style="zoom:80%;" /></p><p>此外，C语言中还有一类数据，是用一对双引号括起来的一个或者多个字符，称为字符串常量，简称字符串，例如 <code>Hello,World</code>。</p><p>但是C语言并没有字符串类型，字符串类型的处理需要字符型数组。数组的内容后面会涉及，此处先不赘述。</p><h1 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h1><p>C语言允许不同类型的数据混合运算，运算中可以按照一定的规则或者人为干预进行类型转换。<strong>转换的方式分为两种：隐式类型转换和显式类型转换</strong>。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>隐式类型转换是编译系统自动进行的，不需要人为干预，隐式类型转换遵循三个基本规则：</p><ol><li><p>如果参与运算的变量类型不同，则先转换成同一类型，然后进行运算。</p></li><li><p>按“低位向高级转换”原则，如果运算中有几种不同类型的操作数，则同一转换为类型高的数据类型，再进行运算，例如：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="type">double</span> c = <span class="number">2.3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,a + b + c);</span><br></pre></td></tr></table></figure><p> 在计算的时候，先将 a,b转换为 <code>double</code> 类型，然后进行计算，所得的结果为 <code>double</code> 类型。</p><p> 各种类型转换方向如下图所示：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(char,short) --&gt;B(int) --&gt;C(unsigned) --&gt;D(long) --&gt;E(double)</span><br><span class="line">    F(float) --&gt;E(double)</span><br></pre></td></tr></table></figure><blockquote><p>浮点型运算时系统一律转换为双精度浮点进行运算，运算结束后再根据类型来转换回去，以防止计算精度丢失。</p></blockquote></li><li><p>赋值运算符号作业两边的数据类型不同时，赋值号右边数据类型将转化为与左边数据一致的类型。例如：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="type">double</span> c = <span class="number">2.3</span>;</span><br><span class="line"><span class="type">int</span> d = a + b + c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,d);</span><br></pre></td></tr></table></figure><p> a+b+c得出的结果为 <code>double</code> 类型，在进行赋值后，被强制转换为 d 的 <code>int</code> 类型，丢失部分精度。</p></li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>强制类型转换即显式类型转换，其作用是人为将相关类型转换为指定的数据类型。转换格式代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(目标的类型标识符)(要转换的变量)</span><br></pre></td></tr></table></figure><p>【实例】使用强制类型转换参与运算<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="type">int</span> d = a + (<span class="type">int</span>)b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%f&quot;</span>,d,b);</span><br></pre></td></tr></table></figure><p>【输出结果】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb813a7966.png" alt="image-20220107165321653" style="zoom:80%;" /><br>【说明】<strong>强制类型转换不改变原数据类型，只是在参与运算的时候改变运算时的参与数据类型</strong>。</p><h1 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h1><p>运算表达式是对数据进行操作和处理的基本单位，一个运算表达式由两m个要素组成的运算量与运算符。运算量包括常量和变量。C语言提供了很多基本运算来实现运算处理，这些运算符可以分为以下几类：</p><ol><li>算术运算符：<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>%</code>(求余数，或者称模运算)。</li><li>自增自减运算符：<code>++</code>,<code>--</code>。</li><li>关系运算符：用于比较运算，包括 <code>&gt;</code>,<code>&lt;</code>,<code>&gt;=</code>,<code>=&lt;</code>,<code>==</code>,<code>!=</code>(不相等)。</li><li>逻辑运算符：用于逻辑运算，包括 <code>&amp;&amp;</code>(与),<code>||</code>(或),<code>!</code>(非)。</li><li>位运算符：按照二进制位进行运算，包括 <code>&amp;</code>(位与)，<code>|</code>(位或)，<code>~</code>(位非)，<code>&lt;&lt;</code>(左移)，<code>&gt;&gt;</code>(右移)。</li><li>条件运算符：<code>?:</code> 条件运算符是C语言中唯一一个三目运算符，用于条件求值。</li><li>赋值运算符：可以分为下面三类<ul><li>简单赋值运算符：<code>=</code></li><li>复合算术赋值运算符：<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code>。</li><li>复合位位运算赋值运算符：<code>&amp;=</code>，<code>|=</code>，<code>^=</code>，<code>&gt;&gt;=</code>，<code>&lt;&lt;=</code>。</li></ul></li><li>逗号运算符：<code>,</code>。</li><li>指针运算符：<code>*</code>。</li><li>地址运算符：<code>&amp;</code>。</li><li>构造类型特殊运算符：<code>.</code>(引用成员运算符)，<code>-&gt;</code>(指向成员运算符)，<code>[]</code>(下标运算符)。</li><li>小括号运算符：<code>()</code>。</li><li>花括号运算符：<code>&#123;&#125;</code>。</li><li>长度运算符：<code>sizeof(类型运算符)</code>用于计算数据类型所占的字节数。</li><li>类型转换运算符：（类型标识符）（表达式）</li></ol><h2 id="算术运算符和算术表达式"><a href="#算术运算符和算术表达式" class="headerlink" title="算术运算符和算术表达式"></a>算术运算符和算术表达式</h2><h3 id="算符运算符及其相关"><a href="#算符运算符及其相关" class="headerlink" title="算符运算符及其相关"></a>算符运算符及其相关</h3><p>算术运算符：<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>%</code>(求余数，或者称模运算)。<br>需要注意的是：</p><ol><li><strong>关于除法运算符 <code>/</code>：如果两个整数相除，则结果为整数，小数部分将被去掉，例如：5&#x2F;2，结果为 2，而不是 2.5。两个操作数只要有一个是浮点数，则结果为浮点数</strong>。</li><li><strong>关于模运算符 <code>%</code>:只适用于两个整数取余，其两个运算量只能是整型或者字符型，不能是其他类型，取余结果的符号是由被除数决定的，例如：7%(-3)的结果是 1，而（-7）%（-3）结果为 -1</strong>。</li></ol><h3 id="算术运算符的优先级与结合性"><a href="#算术运算符的优先级与结合性" class="headerlink" title="算术运算符的优先级与结合性"></a>算术运算符的优先级与结合性</h3><p>算术表达式的计算按运算符的优先级从高到低依次进行。双目运算符的优先级与基本四则运算法则一致，先乘除再加减。</p><p>在一个运算符出现同级运算符时，运算遵循“左结合律”，即按照自左向右进行计算，例如：a+b+c，先 a+b ,再 +c。</p><h2 id="赋值运算符和赋值表达式"><a href="#赋值运算符和赋值表达式" class="headerlink" title="赋值运算符和赋值表达式"></a>赋值运算符和赋值表达式</h2><h3 id="赋值运算符及其说明"><a href="#赋值运算符及其说明" class="headerlink" title="赋值运算符及其说明"></a>赋值运算符及其说明</h3><p>赋值运算符的作用时将一个数据赋值给一个变量。赋值运算符：可以分为下面三类</p><ul><li>简单赋值运算符：<code>=</code></li><li>复合算术赋值运算符：<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code>。</li><li>复合位位运算赋值运算符：<code>&amp;=</code>，<code>|=</code>，<code>^=</code>，<code>&gt;&gt;=</code>，<code>&lt;&lt;=</code>。</li></ul><blockquote><p>例如：<code>a+=1</code> 等价于 <code>a=a+1</code>，其余同理，此处不做过多说明。</p></blockquote><p><strong>所有赋值运算符都是将右边的值赋值给左边，因此赋值运算符左边只能为变量。</strong></p><h3 id="赋值运算符的结合性"><a href="#赋值运算符的结合性" class="headerlink" title="赋值运算符的结合性"></a>赋值运算符的结合性</h3><p>赋值运算符遵循“右结合性”，方向为“自右向左”。</p><p>【实例】验证赋值运算符的结合性<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a =<span class="number">10</span>;</span><br><span class="line">a *= a += <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br></pre></td></tr></table></figure><p>【输出结果】 <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb819781e7.png" alt="image-20220107165243975" style="zoom:80%;" /></p><h2 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h2><h3 id="自增自减运算符及其表达式"><a href="#自增自减运算符及其表达式" class="headerlink" title="自增自减运算符及其表达式"></a>自增自减运算符及其表达式</h3><p>自增运算符 <code>++</code>，自减运算符 <code>--</code> 的作用是让变量加 1 或者减 1 ，常用于循环结构中，但自增自减运算符都有前置和后置之分，前置后置决定了变量使用与计算的顺序：</p><ul><li>自增运算符前置：如 <code>++i</code>，是先将 i 的值加 1 后，再使用 i 的值。</li><li>自增运算符后置：如 <code>i++</code>，是先使用 i 的值，然后再加 1 。</li><li>自减运算符前置：如 <code>--i</code>，是先将 i 的值减 1 后，再使用 i 的值。</li><li>自减运算符后置：如 <code>i--</code>，是先使用 i 的值，再使 i 的值减 1 。</li></ul><p><strong>自增自减运算符只能作用域变量，不能用于常量或者表达式，如 <code>3++</code>，<code>--（x*y）</code>等都是不合法的</strong>。</p><h3 id="自增自减的结合性"><a href="#自增自减的结合性" class="headerlink" title="自增自减的结合性"></a>自增自减的结合性</h3><p>自增自减运算符为右结合性，结合方向为“自右向左”。需要注意的是，自增自减运算符不可以作用于表达式。</p><p>【实例】验证自增自减运算符结合性<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b,c;</span><br><span class="line">a =<span class="number">10</span>;</span><br><span class="line">b = !a++;</span><br><span class="line">c = a--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\nc=%d&quot;</span>,a,b,c);</span><br></pre></td></tr></table></figure><p>【输出结果】 <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb81d8d240.png" alt="image-20220107165448270" style="zoom:80%;" /><br>【说明】 <code>!x</code>x代表数值，结果为 0 。<code>!</code>默认非 0 值为真，采用非操作后，变为假，然后整型输出就是 0 。反之，如果 <code>!0</code>，则输出 1 。</p><h2 id="逗号运算符和逗号表达式"><a href="#逗号运算符和逗号表达式" class="headerlink" title="逗号运算符和逗号表达式"></a>逗号运算符和逗号表达式</h2><p>C语言中，<code>,</code>逗号运算符作为分割符号。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br></pre></td></tr></table></figure><p>也可以作为运算符，用于链接多个表达式，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表达式 <span class="number">1</span>,表达式 <span class="number">2</span>,...,表达式 n;</span><br></pre></td></tr></table></figure><p>当逗号用于运算时，将从左到右依次求取各个表达式的值。</p><h1 id="数据的输入和输出"><a href="#数据的输入和输出" class="headerlink" title="数据的输入和输出"></a>数据的输入和输出</h1><p>在C语言中通过输入&#x2F;输出函数实现数据的输入&#x2F;输出。<strong>系统提供了一批标准输出函数，这些函数包含在一些头文件中，称为库函数</strong>。要使用这些函数，必须在程序开头事先用文件包含命令 <code>#include</code> 包含这些头函数。</p><p>以下部分，主要是标准输入&#x2F;输出函数，即 <code>&lt;stdio.h&gt;</code> 库函数里的内容。</p><h2 id="格式输入函数-scanf"><a href="#格式输入函数-scanf" class="headerlink" title="格式输入函数 scanf"></a>格式输入函数 <code>scanf</code></h2><p>格式输入函数 <code>scanf</code> 将数据按规定的格式从键盘上读取到指定变量中。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式示例</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;格式控制字符串&quot;</span>,输入项地址列表);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line"><span class="keyword">if</span> (a==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a的值为空&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <code>scanf</code> 函数从键盘读入数据时，需要注意以下几点：</p><ol><li><p>输入多个数据时，建议使用空格或者相关分隔符进行分割，这样数据的输入不会出现二义性。代码示例</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如说下面这样</span></span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a,&amp;b,&amp;c);</span><br></pre></td></tr></table></figure></li><li><p>输入的数据个数与顺序要与 <code>sacnf()</code> 函数一致。</p></li><li><p>如果格式控制字符串中有普通字符，则必须依次原样输入，否则可能发生错误。代码示例：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;a=%d,b=%d,c=%d&quot;</span>, &amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>, a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入的时候需要输入</span></span><br><span class="line"><span class="comment">//a=1,b=2,c=3</span></span><br></pre></td></tr></table></figure></li></ol><p>下面对C语言的格式符进行解释说明。<br><strong>格式符皆以 <code>%</code> 开始标记</strong>，格式示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% [m][l或h]数据类型声明字母</span><br></pre></td></tr></table></figure><p>其中，方括号为可选项，可以为空，但是数据类型字母声明不可缺省。</p><ol><li>数据类型声明字母<ul><li><strong>d：输入十进制整数</strong>。</li><li>o：输入八进制整数。</li><li>x：输入十六进制整数。</li><li>u：输入无符号十进制整数。</li><li><strong>f：输入小数形式实型数</strong>。</li><li>e：输入指数形式实型数。</li><li><strong>c：输入单个字符</strong>。</li><li>s：输入字符串。</li></ul></li><li><strong><code>l</code> 和 <code>h</code> 为长度格式符。<code>l</code> 用于规定长整型和双长整型，<code>h</code> 则规定输入为短整型</strong>。<ul><li><code>%ld</code> , <code>%lo</code> , <code>%lx</code>：表示输入数据为长整型十进制，长整型八进制，长整型十六进制。</li><li><code>%lf</code> , <code>le</code>：表示输入双精度型小数形式，双精度指数形式。</li><li><code>%hd</code> , <code>%ho</code> , <code>%hx</code> ：表示输入的数据类型为短整型十进制，短整型八进制，短整型十六进制。</li></ul></li><li><strong><code>m</code> 为十进制整数，用于指定输入数据的宽度（即数字个数）</strong>。代码示例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%5d&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br></pre></td></tr></table></figure>输入 123456，输出结果：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb8229d85b.png" alt="image-20220107165540946" style="zoom:80%;" /><br>该代码读取的时候只读取前 5 个字符，即5个宽度。后面的默认去除。</li></ol><p>对于指定了宽度的输入格式，数据之间可以无分隔符，系统会自动截取宽度来读入。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%5d%2d&quot;</span>, &amp;a,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, a,b);</span><br></pre></td></tr></table></figure><p>输入1234567，输出结果：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb82671606.png" alt="image-20220107165620883" style="zoom:80%;" /></p><p><strong>对于浮点型，数据宽度为数据的整体宽度，包括小数点在内，即数据宽度 m&#x3D;整体位数+1（小数点）+小数位数</strong>。格式输入函数只能指定数据整体的宽度，无法指定小数位数，这和后面输出函数 <code>printf</code>时不同的。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%3f%3f&quot;</span>, &amp;a,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%f,b=%f&quot;</span>, a, b);</span><br></pre></td></tr></table></figure><p>输入 1.23.4 ，输出结果：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb82a61b6f.png" alt="image-20220107165634840" style="zoom:80%;" /></p><h2 id="格式输出函数-printf"><a href="#格式输出函数-printf" class="headerlink" title="格式输出函数 printf"></a>格式输出函数 <code>printf</code></h2><p><strong>格式输出函数 <code>printf</code> 将指定的数据按指定的格式输出到控制台上</strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学术定义版</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;格式控制字符串&quot;</span>,输出项列表);</span><br><span class="line"><span class="comment">//通俗版</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要输出到控制的部分&quot;</span>,伴随输出需要的参数);</span><br></pre></td></tr></table></figure><p><code>printf()</code> 函数中的格式控制字符和 <code>scansf()</code> 函数一致，包含格式符与普通字符。格式符用于控制输出格式，普通字符将原样输出显示。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a=<span class="number">1.2</span>,b=<span class="number">1.3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%f,b=%f&quot;</span>, a, b);</span><br></pre></td></tr></table></figure><p>其中 <code>%f</code> 为格式控制符， <code>a=</code> 则是普通字符，会输出到屏幕上。<br><code>printf()</code> 中的格式符与 <code>scanf()</code> 一致，皆以 <code>%</code> 为开始标记，但是相比要复杂一些，格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% [±] [<span class="number">0</span>] [m] [.n] [l或h] 数据类型字母</span><br></pre></td></tr></table></figure><ol><li><p>数据类型声明字母与 <code>scanf()</code> 基本一致，有少许扩充：</p><ul><li><strong>d：以十进制整数形式输出</strong>。</li><li>o：以八进制整数形式输出。</li><li>x或者X：以十六进制整数形式输出。</li><li>u：以无符号十进制整数形式输出。</li><li><strong>f：以小数形式实型数输出</strong>。</li><li>e或者E：以指数形式实数输出。</li><li>c：以单个字符形式输出。</li><li>s：以字符串形式输出。</li><li>g或者G：由系统决定采用 <code>%f</code> 格式还是 <code>%e</code> 格式，以使输出宽度最小，不输出无意义的 0。</li><li>% ：输出百分号（例如<code>%%</code>）</li></ul></li><li><p><code>l</code> 或 <code>h</code> 的含义同 <code>sancf()</code>；<code>l</code> 双精度&#x2F;长整型，<code>h</code> 短整型。</p></li><li><p><code>m.n</code> 指定输出数据的宽度。<br> 输出整数时：<strong>只有 <code>m</code>，没有 <code>.n</code> 部分。 <code>m</code> 表示输出整数的位数。如果整数的实际位数大于指定的 <code>m</code>，则按照实际的位数输出，如果整数的实际位数小于指定 <code>m</code>，则左边按位补空格</strong>。<br> 输出浮点数时：<code>m</code> 指定数据总宽度，含义与 <code>scanf</code> 函数相同， <strong>m&#x3D;整数位数+1（小数位）+小数位数</strong>。**<code>n</code> 指定小数位数**。<br> 【实例】指定浮点数输出格式</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a=<span class="number">1.123</span>,b=<span class="number">112.3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%3.1f b=%f&quot;</span>, a, b);</span><br></pre></td></tr></table></figure><p> 输出结果：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb82f5aaf1.png" alt="image-20220107171339828" style="zoom:80%;" /></p><p> 说明：<code>%3.1f</code>指定了3位输出位数，排除一位小数点，<code>.1</code>指定了一位小数，则输出<code>1.1</code>。</p></li><li><p><strong>[0]指定输出数据空位置的填充方式，指定0则以0填充，不指定则默认空格填充</strong>。代码示例：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">123</span>;</span><br><span class="line"><span class="type">float</span> a=<span class="number">1.123</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%3.1f b=%05d&quot;</span>, a, b);</span><br></pre></td></tr></table></figure><p> 输出结果：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb833e584b.png" alt="image-20220107171951763" style="zoom:80%;" /></p></li><li><p><strong><code>±</code>指定输出数据的对齐方式：指定 <code>+</code> 时，输出右对齐；指定 <code>-</code> 时，输出左对齐；不指定时默认为<code>+</code>，输出右对齐</strong>。</p><blockquote><p>此项在不同的编译器有不同的处理方式，部分编译器不支持该格式</p></blockquote></li></ol><h2 id="字符输出函数-getchar"><a href="#字符输出函数-getchar" class="headerlink" title="字符输出函数 getchar()"></a>字符输出函数 <code>getchar()</code></h2><p><strong>字符输入函数 <code>getchar()</code>的功能是从输入设备上读取输入的一个字符，其返回值即为所读入的字符</strong>，一般与赋值语句联用，将读取的字符传递给变量。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line">c = getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c的值为%c&quot;</span>, c);</span><br></pre></td></tr></table></figure><blockquote><p>该函数只会读取一个字符，如果输入多个字符，默认读取首字符。</p></blockquote><h2 id="字符输出函数-putchar"><a href="#字符输出函数-putchar" class="headerlink" title="字符输出函数 putchar()"></a>字符输出函数 <code>putchar()</code></h2><p><strong>字符输出函数 <code>putchar()</code>的功能是向控制台输出一个字符</strong>，调用格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">putchar</span>(c);</span><br></pre></td></tr></table></figure><p>c可以是输出的字符常量或者变量，也可以<strong>是整型常量或者变量（此时系统会默认将其转化为ASCII码对应的字符）</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">78</span>;</span><br><span class="line"><span class="built_in">putchar</span>(a);</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb83865349.png" alt="image-20220107173133432" style="zoom:80%;" /></p><h1 id="赋值语句和顺序结构程序设计"><a href="#赋值语句和顺序结构程序设计" class="headerlink" title="赋值语句和顺序结构程序设计"></a>赋值语句和顺序结构程序设计</h1><h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><p><strong>赋值语句即实现赋值功能</strong>，这里主要说明<code>=</code>运算符构成的赋值语句。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量=表达式;</span><br></pre></td></tr></table></figure><p>表达式可以是常量，变量或者运算式。关于<code>=</code>赋值要注意的是：</p><ol><li><p>可以在声明变量的时候，直接赋值。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>也可以先声明变量，后赋值，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>赋值语句可以嵌套，即表达式可以为赋值表达式，例如下面的操作是合法的，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = d = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>但是<strong>下面的操作是非法的</strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = b = c = d = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="顺序结构程序设计"><a href="#顺序结构程序设计" class="headerlink" title="顺序结构程序设计"></a>顺序结构程序设计</h2><p>C语言为结构化程序设计语言，分为三种基本结构：顺序结构，选择结构，循环结构。<strong>顺序结构是最基本的结构，程序从上到下依次执行</strong>。实际上选择结构与循环结构都为局部结构，是在整体顺序框架中的。顺序结构程序按照需要实现的功能逻辑顺序进行设计。</p><p>【实例】输入圆的半径，计算圆的面积<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> r;    <span class="comment">//定义圆的半径</span></span><br><span class="line">    <span class="type">float</span> s;    <span class="comment">//定义圆的面积</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入圆的半径&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;r);</span><br><span class="line">    s = <span class="number">3.14</span> * r * r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;圆的面积为%f&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出结果】<img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb83e4e79c.png" alt="image-20220107175919896" style="zoom:80%;" /></p><h1 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h1><p>数学函数属于库函数(Library function)，在头文件<code>math.h</code>中，因此**要使用数学函数，必须在程序开头处使用文件包含命令<code>#include</code>将<code>math.h</code>包含进来，例如<code>#include &lt;math.h&gt;</code>**。C语言函数库提供了丰富的数学函数供用户使用，如下是一些常用的函数：</p><ol><li><p>**绝对值函数<code>abs()</code>**，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">abs</span>(<span class="number">-5</span>);</span><br></pre></td></tr></table></figure><p>输出结果：5</p><blockquote><p><code>labs()</code>以及<code>fabs()</code>分别用于求长整型数和实数的绝对值</p></blockquote></li><li><p>**开方函数<code>sqrt()</code>**，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">sqrt</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">sqrt</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>输出结果：2</p></li><li><p>**对数函数<code>log10()</code>**（以10为底），代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">log10</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">log10</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>输出结果：1.000000</p></li><li><p>**自然对数函数<code>log()</code>**，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">log</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">log</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出结果：0.693147</p></li><li><p>**指数函数<code>exp()</code>**（即$e^x$，以e为底），代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">exp</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">exp</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出结果：7.389056</p></li><li><p>**次方函数<code>pow10()</code>**（即$10^x$，以10为底），代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">pow10</span><span class="params">(<span class="type">int</span> p)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line">pow10(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出结果：100</p><blockquote><p>部分编译器不支持该函数</p></blockquote></li><li><p>**次方函数<code>pow()</code>**（即$x^y$），代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">pow</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出结果：4</p></li><li><p>**正弦函数<code>sin()</code>**，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">sin</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">sin</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>输出结果：-0.988032</p></li><li><p>**余弦函数<code>cos()</code>**，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">cos</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">cos</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>输出结果：0.154251</p></li><li><p>**正切函数<code>tan()</code>**，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">tan</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">tan</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>输出结果：-6.405331</p></li><li><p>**反正弦函数<code>asin()</code>，反余弦函数<code>acos()</code>，反正切函数<code>atan()</code>**，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">asin</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">acos</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">atan</span><span class="params">(<span class="type">double</span> x)</span>;</span><br></pre></td></tr></table></figure></li></ol><h1 id="常见错误分析"><a href="#常见错误分析" class="headerlink" title="常见错误分析"></a>常见错误分析</h1><ol><li>遗漏符号，例如分号，逗号，引号等。</li><li>未定义就使用，或者在定义之前使用该变量。</li><li>使用中文字符不被识别。</li><li>语法错误。</li><li>数据溢出。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【2.0】访问寄存器和内存</title>
      <link href="/2022/01/09/%E8%AF%AD%E8%A8%80%E6%A0%91/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E3%80%902.0%E3%80%91%E8%AE%BF%E9%97%AE%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98/"/>
      <url>/2022/01/09/%E8%AF%AD%E8%A8%80%E6%A0%91/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E3%80%902.0%E3%80%91%E8%AE%BF%E9%97%AE%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分集中在寄存器和内存的角度来访问和使用，CPU 和内存以及寄存器的交互命令。</p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>一个典型的 CPU 是由运算器，控制器，寄存器等器件构成的，这些器件由内部总线相连。</p><p>对于汇编程序员来说，CPU 中的主要部件就是寄存器。寄存器是 CPU 中程序员可以用指令读写的部件。程序员通过改变寄存器中的内容来实现对 CPU 的控制。</p><p>不同的 CPU ，寄存器的个数，结构是不相同的。<strong>8086 CPU有14个寄存器</strong>，每个寄存器都有一个名称，分别是：</p><ul><li><strong>通用寄存器：<code>AX</code>，<code>BX</code>，<code>CX</code>，<code>DX</code></strong></li><li><strong>变址寄存器：<code>SI</code>，<code>DI</code></strong></li><li><strong>指令寄存器：<code>SP</code>，<code>BP</code></strong></li><li><strong>指令指针寄存器：<code>IP</code></strong></li><li><strong>段寄存器：<code>CS</code>，<code>SS</code>，<code>DS</code>，<code>ES</code></strong></li><li><strong>标志寄存器：<code>PSW</code></strong></li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2b58e75b.png" alt="image-20230106012617899" style="zoom:67%;" /><p>其中 <strong>8086 所有寄存器都是 16 位</strong>的，这就意味着都可以存储两个字节的数据。</p><h1 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h1><p>以<code>AX</code>为例，一个 16 位的寄存器存储一个 16 位的数据最大值是 $2^{16}-1$ 。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2bada66e.png" alt="image-20230106012849579" style="zoom:80%;" /><p>因为 8086 上一代 CPU 中的寄存器都是 8位 的，这样就会存在 8位的程序没有办法运行在 16位的 8086上，为了解决兼容性的问题，**8086给出的解决方案就是将通用寄存器分为两个独立的 8 位寄存器来使用，即<code>AX</code>可以分为<code>AH</code>和<code>AL</code>**（高 8 位和低 8 位）。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2be5ad93.png" alt="image-20230106013550936" style="zoom:67%;" /><p>从数据的角度来看，我们可以通过十六进制很容易的看出这个寄存器要表示的数据是什么。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2c1c2c9b.png" alt="image-20230106013607520" style="zoom:67%;" /><p>由上述即可知，<code>BX</code>也可以分为<code>BH</code>和<code>BL</code>，同理<code>CX</code>,<code>DX</code>也是如此。</p><h1 id="字在寄存器中的存储"><a href="#字在寄存器中的存储" class="headerlink" title="字在寄存器中的存储"></a>字在寄存器中的存储</h1><p>8086 是 16 位CPU，其<strong>字长</strong>为 16 bit。</p><p>一个<strong>字</strong>可以存在一个 16 位的寄存器中，这个字的高位字节存在这个寄存器的高 8 位寄存器，而其低位字节，存在这个寄存器的低 8 位寄存器。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2c5c52d2.png" alt="image-20230106014201334" style="zoom:67%;" /><h1 id="几条汇编指令"><a href="#几条汇编指令" class="headerlink" title="几条汇编指令"></a>几条汇编指令</h1><table><thead><tr><th>汇编指令</th><th>操作</th><th>高级语言描述</th></tr></thead><tbody><tr><td><code>mov ax,18</code></td><td>将 18 送入<code>AX</code></td><td><code>AX = 18</code></td></tr><tr><td><code>mov ah,78</code></td><td>将 78 送入<code>AH</code></td><td><code>AH = 78</code></td></tr><tr><td><code>add ax,8</code></td><td>将寄存器中<code>AX</code>中的数值加上 8</td><td><code>AX = AX +8</code></td></tr><tr><td><code>mov ax,bx</code></td><td>将寄存器<code>BX</code>中的数据送入寄存器<code>AX</code>中</td><td><code>AX = BX</code></td></tr><tr><td><code>add ax,bx</code></td><td>将<code>BX</code>和<code>AX</code>中的内容的内容相加，结果存在<code>AX</code>中</td><td><code>AX = AX + BX</code></td></tr></tbody></table><blockquote><p>注：<strong>汇编指令不区分大小写</strong>，上述 18 不指定进制的话，默认是十进制</p></blockquote><h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p>CPU 访问内存单元时要给出内存单元的地址，所有的内存单元构成的存储空间是一个一维的线性空间，每个存储单元在这个空间中有一个唯一的地址，这个唯一的的地址的就是<strong>物理地址</strong>。</p><p>我们知道 <strong>8086 有 20 位的地址总线</strong>，可以传送 20 位的地址，<strong>寻址能力为 1M</strong>。同时 <strong>8086 是 16 位的CPU</strong>，意味着它的运算器一次最多可以处理 16 位的数据，<strong>寄存器的最大宽度为 16位</strong>，在 8086 内部处理的，暂存的，传输的地址也是 16 位的，其寻址能力只有 64KB，这样就<strong>与它的地址总线的寻址能产生了冲突</strong>。、</p><p>为了解决这个寻址能力冲突的问题，8086 给出了它的解决方法，它<strong>将两个 16 位地址划分为段地址（基地址）和偏移地址，将两个 16 位的地址合成为一个 20 位的物理地址</strong>。</p><p>地址加法器合成物理地址的方法：$物理地址 &#x3D; 段地址 \times 16 + 偏移地址$ ，例如：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2cddfbed.png" alt="image-20230106172248311" style="zoom: 50%;" /><blockquote><p>上述例子左移了一位，因为它是十六进制，所以左移一位就是 4 个二进制比特位</p></blockquote><h1 id="用分段的方式管理内存"><a href="#用分段的方式管理内存" class="headerlink" title="用分段的方式管理内存"></a>用分段的方式管理内存</h1><p>8086 CPU 用“$段地址 \times 16 + 偏移地址 &#x3D; 物理地址$”的方法给出内存的物理地址。需要注意的是：<strong>内存实际上并没有分段，段的划分是来自于CPU内部</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2d184788.png" alt="image-20230106173314679" style="zoom:50%;" /><h2 id="通一段内存，多种分段方案"><a href="#通一段内存，多种分段方案" class="headerlink" title="通一段内存，多种分段方案"></a>通一段内存，多种分段方案</h2><p>例如下图分段：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2d504147.png" alt="image-20230106173705951" style="zoom:50%;" /><p>**它的物理地址（起始地址）为 <code>10000H</code>，那么它的短地址为<code>1000H</code>，大小为<code>100H</code>**。</p><p>还可以采用如下的分段方式：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2d809471.png" alt="image-20230106173822276" style="zoom:50%;" /><p>**它的物理地址（起始地址）为<code>10000H</code>和<code>10080H</code>，段地址为<code>1000H</code>和<code>1008H</code>，大小均为<code>80H</code>**。</p><p>当然还有其他的分段方案，其原理也类似相同。不同的分段遵循如下规则：</p><ol><li><strong>段地址 $\times 16$ 必然是 16 的倍数，所以一个段的起始地址也一定是 16的倍数</strong></li><li><strong>偏移地址为 16 位，16位地址的寻址能力为 64K，所以一个段的长度最大为 64K</strong></li></ol><h2 id="不同段地址和偏移地址形成同一个物理地址"><a href="#不同段地址和偏移地址形成同一个物理地址" class="headerlink" title="不同段地址和偏移地址形成同一个物理地址"></a>不同段地址和偏移地址形成同一个物理地址</h2><table><thead><tr><th>物理地址</th><th>段地址</th><th>偏移地址</th></tr></thead><tbody><tr><td><code>21F60H</code></td><td><code>2000H</code></td><td><code>1F60H</code></td></tr><tr><td></td><td><code>2100H</code></td><td><code>0F60H</code></td></tr><tr><td></td><td><code>21F0H</code></td><td><code>0060H</code></td></tr></tbody></table><p>由上述可知同一个物理地址会根据段的划分不同而有不同的表示方法。例如：数据<code>21F60H</code>在内存单元中，段地址是<code>2000H</code>，其表示方法为：</p><ol><li><strong>数据存在内存<code>2000:1F60</code>单元中</strong></li><li>数据存在内存的<code>2000H</code>段中的<code>1F60H</code>单元中</li></ol><p>因为段地址很重要，所以 <strong>CPU 中专门提供了 4 个段地址寄存器</strong>：</p><ul><li><strong><code>CS</code>：代码段寄存器</strong></li><li><strong><code>DS</code>：数据段寄存器</strong></li><li><strong><code>SS</code>：栈段寄存器</strong></li><li><strong><code>ES</code>：附加段寄存器</strong></li></ul><blockquote><p><code>CS</code>是英文 <em>Code Segment</em> 的缩写，意思是代码段，其他同理分别为：<em>Data</em>，<em>Stack</em>，<em>Extra</em></p></blockquote><h1 id="Debug的使用"><a href="#Debug的使用" class="headerlink" title="Debug的使用"></a>Debug的使用</h1><p>Debug相信学习过编程的都很了解，它是一种调试程序，在DOS系统中，使用命令<code>debug</code>即可运行，例如：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2dc0992e.png" alt="image-20230106175814665" style="zoom:80%;" /><p>使用Debug程序，可以查看CPU各种寄存器中的内容，内存的情况，并且在机器指令级跟踪程序的运行。</p><table><thead><tr><th><code>Debug</code>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>R</code></td><td>查看，改变CPU寄存器的内容</td></tr><tr><td><code>D</code></td><td>查看内存中的内容</td></tr><tr><td><code>E</code></td><td>改变内存中的内容</td></tr><tr><td><code>U</code></td><td>将内存中的机器指令翻译成汇编指令</td></tr><tr><td><code>A</code></td><td>以汇编指令的格式在内存中写入机器指令</td></tr><tr><td><code>T</code></td><td>执行机器指令</td></tr></tbody></table><h2 id="R命令——查看-改变寄存器内容"><a href="#R命令——查看-改变寄存器内容" class="headerlink" title="R命令——查看&#x2F;改变寄存器内容"></a><code>R</code>命令——查看&#x2F;改变寄存器内容</h2><p>**<code>R</code>命令改变寄存器的内容，命令格式：<code>r 寄存器名称</code>**。输入完成后，系统会弹出<code>ax</code>当前的值，以及等待你输入要改变的值的内容，改变完成后，使用<code>r</code>命令来查看改变后的<code>ax</code>寄存器的值。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2e353a60.png" alt="image-20230106182339854" style="zoom:80%;" /><blockquote><p><code>R</code>是寄存器英文 <em>register</em> 的简写</p></blockquote><h2 id="D命令——查看内存内容"><a href="#D命令——查看内存内容" class="headerlink" title="D命令——查看内存内容"></a><code>D</code>命令——查看内存内容</h2><ul><li><p><code>D</code>命令列出预设地址内存处的 128 个字节的内容，如果<strong>连续输入<code>d</code>，则继续向下查看 128 个字节的内容</strong></p></li><li><p>也可以使用<code>d 段地址:偏移地址</code>来查看你设定的地址的内存的内容。</p></li><li><p>同样的使用命令<code>d 段地址:偏移地址 结尾偏移地址</code>会列出内存中<strong>指定地址范围</strong>的内容</p></li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2e6ec454.png" alt="image-20230106184817521" style="zoom:80%;" /><blockquote><p><code>D</code>是数据存储空间的英文 <em>dump</em> 的简写</p></blockquote><h2 id="E命令——改变内存内容"><a href="#E命令——改变内存内容" class="headerlink" title="E命令——改变内存内容"></a><code>E</code>命令——改变内存内容</h2><ul><li><code>E 段地址:偏移地址 数据1 数据2 ...</code>用来<strong>改变指定地址的内存中的内容</strong></li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2ea808ed.png" alt="image-20230106185410960" style="zoom:80%;" /><ul><li><code>E 段地址:偏移地址</code>系统会逐个询问式修改，<kbd>space</kbd>(空格)表示继续，<kbd>enter</kbd>(回车)表示结束。</li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2edab1f1.png" alt="image-20230106185547233" style="zoom:80%;" /><blockquote><p><code>E</code>是输入的英文 <em>enter</em> 的简写</p></blockquote><h2 id="U命令——将机器指令翻译成汇编命令"><a href="#U命令——将机器指令翻译成汇编命令" class="headerlink" title="U命令——将机器指令翻译成汇编命令"></a><code>U</code>命令——将机器指令翻译成汇编命令</h2><p>现在有汇编指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0003H</span><br><span class="line">mov ax,bx</span><br><span class="line">add ax,bx</span><br></pre></td></tr></table></figure><p>其对应的机器码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B8 23 01</span><br><span class="line">BB 03 00</span><br><span class="line">89 D8</span><br><span class="line">01 D8</span><br></pre></td></tr></table></figure><p>现在我们使用<code>E</code>命令将机器码写入，然后使用<code>D</code>命令查看内容，再<strong>使用<code>U 段地址:偏移地址</code>命令查看机器码对应的汇编</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2f18d8d5.png" alt="image-20230106190525880" style="zoom:80%;" /><blockquote><p>我们可以把内存中的一段数据，可以看作数据内容，也可以看作命令</p><p><code>U</code>是反汇编英文 <em>unassemble</em> 的简写</p></blockquote><h2 id="A命令——将汇编命令翻译成机器指令"><a href="#A命令——将汇编命令翻译成机器指令" class="headerlink" title="A命令——将汇编命令翻译成机器指令"></a><code>A</code>命令——将汇编命令翻译成机器指令</h2><p>现在我们继续使用上述的汇编指令，现在使用<code>a 段地址:偏移地址</code>来输入汇编指令，将其转换为机器指令存入指定内存。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2f55e61f.png" alt="image-20230106191927894" style="zoom:80%;" /><blockquote><p>我们在Debug中默认就是十六进制，所以输入数值就不需要加<code>H</code>表示十六进制了</p><p><code>A</code>是汇编的英文 <em>assemble</em> 的简写</p></blockquote><h2 id="T命令——执行机器指令"><a href="#T命令——执行机器指令" class="headerlink" title="T命令——执行机器指令"></a><code>T</code>命令——执行机器指令</h2><p><strong><code>T</code>命令执行<code>CS:IP</code>处的指令</strong>，我们可以通过修改 <code>IP</code> 和<code>CS</code>的内容，即位置来让其执行指定位置的指令。</p><p>每次输入<code>T</code>命令后逐条执行后面的命令。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2f96b3d4.png" alt="image-20230106193618428" style="zoom:80%;" /><blockquote><p><code>T</code>是追踪的英文 <em>trace</em> 的简写</p></blockquote><h2 id="Q命令——退出Debug"><a href="#Q命令——退出Debug" class="headerlink" title="Q命令——退出Debug"></a><code>Q</code>命令——退出Debug</h2><p><strong>使用<code>Q</code>命令退出Debug程序</strong>。</p><blockquote><p><code>Q</code>是退出的英文 <em>quit</em> 的简写</p></blockquote><h1 id="CS，IP与代码段"><a href="#CS，IP与代码段" class="headerlink" title="CS，IP与代码段"></a>CS，IP与代码段</h1><p>CS（代码段地址）和 IP（指令指针寄存器）其<code>CS:IP</code>指向的内容是 <strong>CPU 当作指令来执行</strong>的地址。示例：</p><p>当前，<code>CS</code>中的内容为<code>2000H</code>，<code>IP</code>中的内容是<code>0000H</code>，那么 CPU 通过地址加法器来计算出其 20 位的物理地址，然后在内存中找到物理地址其内容作为机器指令，然后将找到的指令通过数据总线传到 CPU 内的指令缓冲器中，进而由执行控制器进行执行。执行完成后，<code>IP</code>会根据这个指令的内容大小，向下递增。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb2fd9c489.png" alt="image-20230109162527783" style="zoom:80%;" /><p>8086 工作过程简要描述：</p><ol><li>从<code>CS:IP</code>指向的内存单元读取指令，读取的指令进入指令缓冲器。</li><li><code>IP</code>&#x3D;<code>IP</code> + <strong>所读取的指令的长度，从而指向下一条指令</strong></li><li>执行指令。转到第一步，重复这个过程。</li></ol><h1 id="JMP指令"><a href="#JMP指令" class="headerlink" title="JMP指令"></a>JMP指令</h1><p>我们知道 CPU 执行指令取决于 <code>CS:IP</code>指向的内容，所以我们可以<strong>通过改变 <code>CS:IP</code>中的内容，来控制 CPU 执行的目标指令</strong>。</p><p>我们可以通过使用<code>Debug</code>程序的<code>R</code>命令来改变寄存器的值，但是需要注意的是这是调试的手段，这并不是程序的方式。我们需要通过指令来修改<code>CS</code>和<code>IP</code>的值。</p><p>因为 8086 不支持直接使用如下代码修改寄存器的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#这是错误的</span><br><span class="line">mov cs 2000H</span><br><span class="line">mov ip 0000H</span><br></pre></td></tr></table></figure><p>我们需要<strong>使用转移指令<code>jmp</code>来修改<code>CS</code>和<code>IP</code>的内容</strong>，代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#同时修改CS,IP的内容，格式：jmp 段地址:偏移地址</span><br><span class="line">jmp 2AE3:3</span><br><span class="line">#仅修改IP的内容，格式jmp 某一合法寄存器</span><br><span class="line">jmp ax</span><br><span class="line">jmp bx</span><br><span class="line">#如上指令类似于 mov IP,ax 和 mpv IP,bx</span><br></pre></td></tr></table></figure><h1 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h1><p>对于 8096 CPU，16位作为一个字。一个 16 位的字，在寄存器中，<strong>高 8 位存放高字节，低 8 位存放低字节</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb302614c9.png" alt="image-20230109170524793" style="zoom:80%;" /><p>那么对于 16 位的字在内存中是如何存储的？<strong>内存中的解决方案是，低位字节存在低地址单元，高位字节存在高地址单元</strong>。例如<code>4E20H</code>存放在内存中两个的地址0，1中，0 存放低地址<code>20H</code>，1存放高地址<code>4EH</code>。</p><blockquote><p>需要注意的是：我们读取数据时高地址+低地址，但是数据的存放地址是低地址开始</p><p>这也就是<strong>大小端</strong>的由来</p></blockquote><h1 id="DS-和-address"><a href="#DS-和-address" class="headerlink" title="DS 和 [address]"></a>DS 和 [address]</h1><p>8086 CPU 从内存中读取数据，需要<strong>利用<code>DS</code>寄存器存放要访问的数据的段地址，偏移地址使用<code>[]</code>的形式给出</strong>。代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#将1000:0中的数据读取到al中</span><br><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx</span><br><span class="line">mov al,[0]</span><br><span class="line"></span><br><span class="line">#将al中的数据写入到1000:0</span><br><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx</span><br><span class="line">mov [0],al</span><br></pre></td></tr></table></figure><p>用<code>[0]</code> 表示其段地址默认就是<code>DS</code>，其偏移地址就是<code>0</code>，其中要首先把段地址存入<code>DS</code>。另外需要注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#这句是错误的，在设计的时候就不支持这种方式</span><br><span class="line">mov ds 1000H</span><br><span class="line"></span><br><span class="line">#这句是正确的，即借助通用寄存器来赋值</span><br><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx</span><br></pre></td></tr></table></figure><p>8086 可以<strong>一次性传送一个字（16位的数据）</strong>，同理也是一次写 16 位的数据。</p><blockquote><p>区别每次取的数据大小，可以看取数据要往寄存器哪里放，如果是<code>AX</code>这种通用寄存器，按照 8086 就是 16位的数据；如果是<code>AL</code>或者<code>AH</code>就表示每次自取&#x2F;写 8位数据。</p></blockquote><h1 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h1><ul><li><strong><code>mov</code>指令</strong>：不支持<code>mov ds,8</code>，即数据不可以直接存放在段寄存器中</li><li><strong><code>add</code>指令</strong>：不支持<code>add ds,ax</code>，即通用寄存器和段寄存器相加；不支持<code>add [1],[2]</code>，即两个内存单元的相加</li><li><strong><code>sub</code>指令</strong>：（减法指令）同加法</li></ul><h1 id="栈以及栈操作的实现"><a href="#栈以及栈操作的实现" class="headerlink" title="栈以及栈操作的实现"></a>栈以及栈操作的实现</h1><p>栈是一种特殊的数据结构，它是一种<strong>操作受限的线性表，它只允许在一端进行插入或者删除操作</strong>。关于栈数据结构的详情可以查看<a href="https://helloseraphine.top:8090/archives/31%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97">【3.1】栈和队列</a> ，此处不再过多赘述。</p><p>现在的 CPU 中会直接提供栈的设计。8086 支持用栈的方式访问内存空间，基于 8086 CPU编程可以将一段内存当作栈来使用。其指令如下：</p><ul><li><strong><code>PUSH</code>(入栈)<strong>：格式<code>push ax</code>，</strong>将<code>ax</code>中的数据送入栈中</strong></li><li><strong><code>POP</code>(出栈)<strong>：格式<code>pop ax</code>，</strong>从栈顶取出数据送入<code>ax</code></strong></li></ul><blockquote><p>注意：栈的操作是以字为单位对栈进行操作，非字节；即 8086 是 16位为一次数据</p></blockquote><p>现在对于内存 CPU 使用栈来使用，会产生下面两个疑问：</p><ol><li><p><strong>CPU是如何知道一段内存空间被当作栈来使用的？执行<code>push</code>和<code>pop</code>的时候，如何知道哪个单元是栈顶单元？</strong></p><p>8086中存在两个与栈相关的寄存器，即：</p><ul><li><strong><code>SS</code>(栈段寄存器)：存放栈顶的段地址</strong></li><li><strong><code>SP</code>(栈顶指针寄存器)：存放栈顶的偏移地址</strong></li></ul><blockquote><p>即在任何时刻，**<code>SS:SP</code>永远指向栈顶元素**</p></blockquote></li></ol><p>从汇编的角度，我们可以利用栈来交换两个元素的值，代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#修改栈的位置</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0010H</span><br><span class="line"></span><br><span class="line">#元素赋值</span><br><span class="line">mov ax,001AH</span><br><span class="line">mov bx,001BH</span><br><span class="line"></span><br><span class="line">#元素入栈</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line"></span><br><span class="line">#元素出栈</span><br><span class="line">pop ax</span><br><span class="line">pop bx</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是：<strong>使用栈的时候可能会出现栈顶超界的问题</strong>，CPU不会进行检查，需要程序人员自己避免。</p></blockquote><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>总结来说，汇编的段可以分为三种：</p><ul><li><strong>数据段</strong>：即将段地址存放在<code>DS</code>中，然后使用<code>mov</code>,<code>add</code>,<code>sub</code>等指令将数据段的内容当作数据来访问</li><li><strong>代码段</strong>：即将段地址存放在<code>CS</code>中，将段中第一条指令存放在偏移地址<code>IP</code>中，CPU 将会执行我们定义的代码段中的指令</li><li><strong>栈段</strong>：将段地址存放在<code>SS</code>中，栈顶元素的偏移地址存放在<code>SP</code>中，CPU 进行栈操作的时候会将我们定义的栈段当作栈空间来使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【1.0】基础知识</title>
      <link href="/2022/01/06/%E8%AF%AD%E8%A8%80%E6%A0%91/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E3%80%901.0%E3%80%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/01/06/%E8%AF%AD%E8%A8%80%E6%A0%91/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E3%80%901.0%E3%80%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本部分汇编内容是基于 8086 的架构，内容来源学习自<strong>王爽</strong>老师的《汇编语言》，你可以在 B站或者其他平台查找到相关视频内容，例如：<a href="httpss://www.bilibili.com/video/BV1Wu411B72F?p=1">通俗易懂的汇编语言（王爽老师的书）</a>。</p><blockquote><p>汇编系列内容仅作为本人学习记录用途，请自行参考</p></blockquote><h1 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h1><p>众所周知，计算机最开始也是最底层就是二进制的 0 和 1，早期的程序员就是在一堆 0 和 1 中编程。</p><p>使用 0 和 1 的机器语言不仅抽象，而且出错不易查找错误，增加了复杂性和难度。</p><h1 id="汇编语言的产生"><a href="#汇编语言的产生" class="headerlink" title="汇编语言的产生"></a>汇编语言的产生</h1><p>早期的程序员为了解决直接使用机器语言所带来的问题，于是产生了汇编语言。</p><p>汇编语言的主体是汇编指令，汇编指令和机器指令的差别在于指令的表示方法上，汇编指令更加便于记忆和理解书写的格式。</p><p>例如：机器指令 1000100111011000 表示将寄存器 BX 的内容送到 AX 中。汇编指令则写成 <code>mov ax,bx</code>。这种写法更加符合人类的语言和逻辑。</p><p>于是，程序员就使用汇编编写程序，然后通过编译器将汇编语言写出的源程序编译成机器码，最终计算机执行指令。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb26591a8e.png" alt="image-20230106000851058" style="zoom:80%;" /><blockquote><p>图片来源：王爽老师的《汇编语言》</p></blockquote><h1 id="计算机中的总线"><a href="#计算机中的总线" class="headerlink" title="计算机中的总线"></a>计算机中的总线</h1><p>在计算机中专门连接 CPU 和其他芯片的导线就是总线，从物理角度看，就是一堆线的集合。</p><p>计算机的总线可以从逻辑上分为三种：</p><ol><li><strong>地址总线</strong></li><li><strong>数据总线</strong></li><li><strong>控制总线</strong></li></ol><h2 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h2><p>CPU 通过地址总线来指定存储单元。地址总线的宽度，决定了可寻址的存储单元的大小。例如 N 根地址总线（宽度为 N），对应的寻址空间为 $2^N$ 。</p><h2 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h2><p>CPU 与内存或者其他元器件之间数据传输通过数据总线进行。数据总线的宽度决定了 CPU 和外界数据传输的速度。</p><h2 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h2><p>CPU 通过控制总线对外部元器件进行控制。控制总线的宽度决定了 CPU 对外部元器件的控制能力。</p><h1 id="CPU-对存储器的读写"><a href="#CPU-对存储器的读写" class="headerlink" title="CPU 对存储器的读写"></a>CPU 对存储器的读写</h1><p>CPU 要进行数据读写，必须和外部器件进行三类信息的交互：</p><ol><li>存储单元的地址（地址信息）</li><li>器件的选择，读或写命令（控制信息）</li><li>读和写的数据（数据信息）</li></ol><p>总结来说就是从哪里拿什么数据用什么做什么事情。</p><p>从逻辑上，CPU将各类存储器看作一个逻辑存储器进行统一编制。每个物理存储器在这个逻辑存储器占有一个地址段，即一段地址空间。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb26a7957d.png" alt="image-20230106004255580" style="zoom:67%;" /><blockquote><p>图片来源：王爽老师的《汇编语言》</p></blockquote><h1 id="汇编语言环境搭建"><a href="#汇编语言环境搭建" class="headerlink" title="汇编语言环境搭建"></a>汇编语言环境搭建</h1><p>本文基于 DOS 环境进行汇编语言的学习，我们采用 DOS 模拟器（<a href="httpss://www.dosbox.com/"><strong>DosBox</strong></a>）来模拟 DOS 环境。下载安装<code>DosBox</code>模拟器后，还需要安装汇编的环境，汇编环境文件[点我访问](链接: httpss:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1-utULVh-oflpoOZcrryY0Q?pwd&#x3D;nkxd) (提取码<code>nkxd</code>)。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb26eecad2.png" alt="image-20230106004728708" style="zoom:67%;" /><p>安装完成后，软件界面如下：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb272af7ef.png" alt="image-20230106004834797" style="zoom: 60%;" /><p>首先我们要先将我们的工作空间挂载到 DOS 上，目前 DOS 指向的是 Z 盘 ，命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount c d:\Calculate Software\DosBox\Data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这句指令的意思是 将DOS模拟器环境中的C盘 对应到我们实际机器上的后面的路径</span></span><br></pre></td></tr></table></figure><p>如下表示挂载成功。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb276d57e7.png" alt="image-20230106005614743" style="zoom:80%;" /><p>然后将我们的汇编环境文件拷贝到我们的挂载文件路径下。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb27ada432.png" alt="image-20230106010432525" style="zoom:80%;" /><p>再挂载完成后，然后使用命令<code>c:</code>将目录切换到<code>C</code>盘，再使用<code>dir</code>命令查看当前路径下的文件，如下所示：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb27e7c716.png" alt="image-20230106010557163" style="zoom:80%;" /><p>到目前为止，你就已经完成汇编环境的搭建。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>从后面开始就是正式的汇编语言的学习了，再次提醒，本文是基于 8086 架构的汇编语言。</p>]]></content>
      
      
      <categories>
          
          <category> 语言树 </category>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于网站搭建那些事（下）</title>
      <link href="/2021/11/29/NAS%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2021/11/29/NAS%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分是建立在网站服务器搭建完成的基础上改造而来的，如果不知道如何网站搭建，可以查看<a href="httpss://helloseraphine.top/index.php/archives/168.html">关于网站搭建那些事（上）</a>。</p><p>这部分就是<strong>SSL部署，对象存储和CDN加速，WAF以及小部分代码改造</strong>部分的指南了，前面网站搭建的文章里解释了<strong>DNS，IP，域名以及服务器的搭建</strong>的相关内容，此处不做赘述。</p><p><strong>关于所有内容都是在我当前博客实现或者实现过的功能，该博客建立——以此纪念我的大学生活</strong></p><h1 id="SSL部署"><a href="#SSL部署" class="headerlink" title="SSL部署"></a>SSL部署</h1><h2 id="什么是SSL？"><a href="#什么是SSL？" class="headerlink" title="什么是SSL？"></a>什么是SSL？</h2><p>老规矩先解释这是个什么东西，以下斜体定义引用自百度百科：</p><p><em>SSL(Secure Sockets Layer <a href="httpss://baike.baidu.com/item/安全套接字协议">安全套接字协议</a>),及其继任者<a href="httpss://baike.baidu.com/item/传输层安全">传输层安全</a>（Transport Layer Security，TLS）是为<a href="httpss://baike.baidu.com/item/网络通信/9636548">网络通信</a>提供安全及<a href="httpss://baike.baidu.com/item/数据完整性/110071">数据完整性</a>的一种安全协议。TLS与SSL在<a href="httpss://baike.baidu.com/item/传输层/4329536">传输层</a>与<a href="httpss://baike.baidu.com/item/应用层/16412033">应用层</a>之间对网络连接进行加密。</em></p><p>定义依旧很学术，<strong>通俗来理解：SSL提供了安全访问保护</strong>。对于成功部署SSL的网站，在网站网址左侧会有一把小锁表示安全，如下图（图示浏览器为谷歌浏览器）：</p><img src="httpss://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224212715945.png" alt="image-20220224212715945" style="zoom:150%;" /><h2 id="SSL证书申请"><a href="#SSL证书申请" class="headerlink" title="SSL证书申请"></a>SSL证书申请</h2><h3 id="SSL证书提供商"><a href="#SSL证书提供商" class="headerlink" title="SSL证书提供商"></a>SSL证书提供商</h3><p>SSL有收费的和免费，此处仅演示免费版，SSL证书分为单域名SSL证书，和泛域名SSL证书，关于两者的区别，可以参考这个文章<a href="httpss://jingyan.baidu.com/article/ad310e80992f5a5849f49ed6.html">单域名SSL证书和泛域名SSL证书之间的区别</a></p><p>因为是免费的，没得挑，就是单域名SSL证书，申请服务商：</p><ul><li><a href="httpss://console.cloud.tencent.com/certoverview">腾讯云SSL证书</a></li><li><a href="httpss://yundun.console.aliyun.com/?spm=5176.12818093.ProductAndService--ali--widget-home-product-recent.dre9.12d216d0yYAj17&p=cas#/overview/cn-hangzhou">阿里云SSL证书</a></li></ul><ol><li><p><a href="httpss://console.cloud.tencent.com/certoverview">腾讯云SSL证书</a></p><p>我网站使用的SSL证书就是腾讯云免费申请的，有效期一年，SSL到期了再来申请即可，SSL申请部署以腾讯云为实例，其他服务商类比</p></li><li><p><a href="httpss://yundun.console.aliyun.com/?spm=5176.12818093.ProductAndService--ali--widget-home-product-recent.dre9.12d216d0yYAj17&p=cas#/overview/cn-hangzhou">阿里云SSL证书</a></p><p>没申请过，不清楚</p></li></ol><h3 id="申请SSL证书"><a href="#申请SSL证书" class="headerlink" title="申请SSL证书"></a>申请SSL证书</h3><ol><li><p><strong>进入腾讯云SSL证书控制台</strong>，在左侧选择<strong>我的证书</strong>，然后<strong>【选择 申请免费证书】</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae8d4ef0f4.png" alt="image-20220224213634777" style="zoom:67%;" /></li><li><p>然后弹出证书选择，选择默认即可</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae8d8c99b3.png" alt="image-20220224213816184" style="zoom:50%;" /></li><li><p>然后<strong>进入证书申请</strong>页面，填写相关域名和资料，按自己需求和内容填写即可</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae8dc86492.png" alt="image-20220224213906041" style="zoom:67%;" /></li><li><p>最后提交等待审核即可，审核一般隔天吧，记不太清楚了，审核通过之后，就可以在<strong>我的证书</strong>页面中看到审核通过的SSL证书，到这里SSL证书申请完成。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae8e05d0e6.png" alt="image-20220224214047022" style="zoom:150%;" /></li></ol><h3 id="部署SSL证书"><a href="#部署SSL证书" class="headerlink" title="部署SSL证书"></a>部署SSL证书</h3><p>我在<a href="httpss://helloseraphine.top/index.php/archives/168.html">关于网站搭建那些事（上）</a>中说明了我的网站服务器使用的是阿里云的轻量应用服务器。它是基于<strong>LNMP</strong>网站架构，关于LNMP的说明，以下斜体内容引用百度百科：</p><p><em><strong>LNMP</strong>是指一组通常一起使用来运行动态网站或者服务器的自由软件名称首字母缩写。L指Linux，N指Nginx，M一般指MySQL，也可以指MariaDB，P一般指PHP，也可以指Perl或Python。</em></p><p>所以，这部分部署步骤实例，是基于Nginx服务器的，其他服务器自行查询部署方法：</p><ol><li><p>首先下载之前申请的SSL证书到本地，<strong>下载的时候，选择对应的服务器</strong>，此处选择 Nginx</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae8e3cd5bb.png" alt="image-20220224214942925" style="zoom:67%;" /></li><li><p>下载完成后，解压到本地，会得到如下的文件</p><p><strong>.crt：证书文件（公钥）</strong></p><p><strong>.pem：证书文件（安装时可忽略）</strong></p><p><strong>.key：私钥</strong></p><p><strong>.csr：CSR文件（安装时可忽略）</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae8e825c1c.png" alt="image-20220224215121684" style="zoom:80%;" /></li><li><p>使用远程登录工具，例如WinSCP，<strong>将证书文件（公钥）和私钥文件上传到 Nginx 服务器的 <code>/usr/local/nginx/conf</code> 目录（一般 Nginx 默认安装目录）下</strong>。</p><p><strong>需要注意的是：阿里云轻量应用服务器，起码我这个它的服务器文件目录十分杂乱（ <code>:(</code> 差评），所以你往往找不到这个目录，或者该目录不存在</strong>，如果出现了我说的这两种情况请使用如下方法：</p><ul><li><p>使用其他远程工具或者阿里云轻量应用服务器网页版的控制台，输入如下Linux命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure><img src="httpss://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224220455104.png" alt="image-20220224220455104" style="zoom:150%;" /><p>然后根据命令查找到的目录，使用WinSCP工具，<strong>查找文件目录下是否含有<code>nginx.conf</code>文件，如果存在，则是该目录</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae8ef21fff.png" alt="image-20220224220941410" style="zoom:67%;" /></li></ul></li><li><p><strong>然后在该目录下，创建名称为<code>cert</code>的文件，将下载的证书文件上传到该文件夹中。</strong></p></li><li><p>然后打开<code>nginx.conf</code>文件，里面最下面一部分的代码内容如下：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Settings <span class="keyword">for</span> a TLS enabled server.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#    server &#123;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       listen       443 ssl https2;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       listen       [::]:443 ssl https2;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       server_name  _;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       root         xxxx这里是你网站的根目录;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#        ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       ssl_certificate_key <span class="string">&quot;/etc/pki/nginx/private/server.key&quot;</span>;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       ssl_session_cache shared:SSL:1m;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       ssl_session_timeout  10m;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       ssl_ciphers PROFILE=SYSTEM;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       ssl_prefer_server_ciphers on;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#        # Load configuration files for the default server block.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#        error_page 404 /404.html;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">           location = /40x.html &#123;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       &#125;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#        error_page 500 502 503 504 /50x.html;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">           location = /50x.html &#123;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       &#125;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   &#125;</span></span><br></pre></td></tr></table></figure><p> 可以使用下面的代码示例来替换上面代码的位置：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen       443 ssl https2;</span><br><span class="line">listen       [::]:443 ssl https2;</span><br><span class="line">server_name  这里填绑定证书的域名;</span><br><span class="line">root         这里填你网站的根目录;</span><br><span class="line"></span><br><span class="line">ssl_certificate &quot;这里填写SSL证书文件里的.scr文件的路径&quot;;</span><br><span class="line">ssl_certificate_key &quot;这里填写SSL证书文件里.key路径&quot;;</span><br><span class="line">ssl_session_cache shared:SSL:1m;</span><br><span class="line">ssl_session_timeout  10m;</span><br><span class="line">ssl_ciphers PROFILE=SYSTEM;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Load configuration files <span class="keyword">for</span> the default server block.</span></span><br><span class="line">include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">error_page 404 /404.html;</span><br><span class="line">location = /40x.html &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_page 500 502 503 504 /50x.html;</span><br><span class="line">location = /50x.html &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果你希望<strong>设置强制HTTP请求自动跳转HTTPS</strong>。则在上述代码前面添加如下代码：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 这里写你证书绑定的域名;</span><br><span class="line">    rewrite ^(.*)$ httpss://$host$1; #将所有HTTP请求通过rewrite指令重定向到HTTPS。</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试，访问，网址栏左侧出现一把小锁，则配置成功</p> <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae8f51f2a9.png" alt="image-20220224223553931" style="zoom:150%;" /></li></ol><h1 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h1><h2 id="什么是对象存储？"><a href="#什么是对象存储？" class="headerlink" title="什么是对象存储？"></a>什么是对象存储？</h2><p>老规矩先解释这是个什么东西。以下斜体定义引自百度百科：</p><p><em>对象存储是用来描述解决和处理离散单元的方法的通用术语。对象在一个层结构中不会再有层级结构，是以扩展元数据为特征的。</em></p><p>很不幸，这个定义说的很学术，看的人云里雾里，通俗来说就是：<strong>对象存储可以实现将指定文件生成对应直链</strong>。举一个例子，我想要在文章里插入一个图片，这个时候，就需要给文章的图片指定一个地址，这个地址就是图片的直链，借用HTML代码来展示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//图片语法格式示例</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;url&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;some_text&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>url</code>：就是需要提高图片的地址</li><li><code>alt</code>：是对这张图片的描述</li></ul><p>可以看到，这个图片的地址，就是需要提供图片的直链<strong>，类似于我们在Word里插入图片也要提供图片位置，唯一不同的是文件的地址表现形式不同，在网络上文件的地址表示是<code>url</code>的形式</strong>。</p><h2 id="对象存储有什么用？"><a href="#对象存储有什么用？" class="headerlink" title="对象存储有什么用？"></a>对象存储有什么用？</h2><p>一般情况下，对于入门级或者一些配置低的服务器会存在带宽低的问题，低带宽带来的致命缺陷就是超长的加载时间，对于常规的文本可以忽略不记，有句话叫做：代码是最不占空间的东西，网站提供的服务中，多媒体图片，音频，视频的资源往往是带宽的瓶颈。例如腾讯云的学生优惠服务器：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae8f95864d.png" alt="image-20220224171200715" style="zoom:60%;" /><p>这个是我弄服务器的时候的套餐了，现在似乎是不支持了，有新版的套餐了。我记得当时是 99&#x2F;年，可以续费三次，价格很便宜，可以明显的看到这个套餐的配置，属于是入门级别的，可以稍微玩玩，要命的是它的带宽只有 1Mbps，这是一个什么概念呢，$1&#x2F;8 &#x3D; 0.125$（MB），这是计算的理论速度，由于路由分发和各种问题，实际速度80k左右大概。对于一个图片，如果图片大小是 0.8 （MB），那么预计8秒才可以加载完成，或许这个速度放在20年前没有任何问题，但是对于现在来说，超过3秒的加载以及足以让人有些焦灼了。</p><p>国内服务器现状，空间不值钱，但是带宽翻一倍，价格翻两倍，所以带宽由贵由重要，有没有什么更好的解决方案？那就是对象存储，在早期的网站是将所有资源放在网站服务器上，所有资源文件同网站共享一个带宽，很容易被带宽掐脖子，对象存储提供了自定义文件的直链，就可以跳出网站服务器的限制，因为你的资源（图片，音频，视频）放在了对象存储的库中了，使用的是对象存储提供商提供的带宽。</p><p>这样将你网站的图片，视频，音频上传到对象存储上，获取文件对应的直链，直接在博客网站中引用，就实现了资源分离，也解决了加载的带宽问题。</p><p>使用对象存储可以解决：</p><ol><li>图片加载问题，图片可以很快加载</li><li>音频播放问题，音频歌曲可以顺畅播放</li><li>视频播放问题，甚至4K+的流媒体在线播放</li></ol><h2 id="对象存储的使用示例"><a href="#对象存储的使用示例" class="headerlink" title="对象存储的使用示例"></a>对象存储的使用示例</h2><h3 id="对象存储服务商推荐-个人见解"><a href="#对象存储服务商推荐-个人见解" class="headerlink" title="对象存储服务商推荐&amp;个人见解"></a>对象存储服务商推荐&amp;个人见解</h3><ul><li><a href="httpss://cloud.tencent.com/product/cos">腾讯云的COS</a></li><li><a href="httpss://www.aliyun.com/product/oss?spm=5176.19720258.J_8058803260.33.e9392c4a8qw2OR">阿里云的OSS</a></li><li><a href="httpss://www.upyun.com/products/file-storage">又拍云的USS</a></li><li><a href="httpss://www.huaweicloud.com/product/obs.html">华为云的OBS</a></li></ul><p>当然还有移动云，电信云，联通云等等的对象存储产品。</p><blockquote><p>关于它们提供的对象存储服务的名字不一样，但是用法都是通用的</p></blockquote><ol><li><p><a href="httpss://cloud.tencent.com/product/cos">腾讯云的COS</a></p><p>我目前用的就是腾讯云的COS，你可以通过体验我的网站视频，音频，图片的加载速度和相关体验来对腾讯云的对象存储有大概的了解。</p><p>腾讯云的优点：老牌稳定，带宽可以，价格很可以接受。</p><p>【需要付费】关于价格我大概如下说明一下：</p><p>腾讯云定期搞活动，全年活动无休，无非是优惠力度大小问题，对于学生和新用户优惠力度更大，建议购买前先去腾云最新活动页面看看属于新用户的优惠，很值的，我就是错过了这个新用户活动。关于具体的优惠活动不做多解释。</p><p>COS 的收费可以分为：存储空间和外网下行流量。</p><blockquote><p>该收费标准是通用的，阿里云，又拍云等对象存储服务商大致是这个收费标准</p></blockquote><p>存储空间很容易理解，花钱买空间，外围下行流量的意思是文件生成的直链，被别人访问的时候（也就是加载文件）所消耗的流量，例如：上面说的图片，如果图片30KB，则在对象存储上占用30KB的存储空间，如果别人访问网站需要加载这个图片，则消耗对应大小的外网下行流量来实现加载。</p><p>我的存储空间白嫖的活动，【1元&#x2F;1年】50GB的存储空间，外网下行流量是单买的流量包，价格我记得大概是【3.6元&#x2F;10 GB&#x2F;月】，当然也有优惠活动，对于老用户过年的时候有个活动是【84元&#x2F;100GB&#x2F;月】，100GB对于个人博客而言，属于那种往死里用都管够的那种，还是很值的。</p></li><li><p><a href="httpss://www.aliyun.com/product/oss?spm=5176.19720258.J_8058803260.33.e9392c4a8qw2OR">阿里云的OSS</a></p><p>阿里云我没用过，但是我看过它们的收费标准，阿里云的对象存储外网下行流量包最低起步是 100GB&#x2F;月，这样价格就起来了，100GB太多了对于一般网站，所以有些多余，自行根据需求选择。</p><p>至于阿里云OSS的使用效果如何，请自行体验</p></li><li><p><a href="httpss://www.upyun.com/products/file-storage">又拍云的USS</a></p><p>又拍云有个好处，它提供开发者又拍云联盟计划，你需要在你的网站下面引用又拍云提供对象存储技术支持相关文字和链接，这样它每月提供15GB的流量和10GB的存储空间。</p><p>通俗来说，就是稍微在你的网站打一下广告，你可以获得每月15GB的流量和一共10GB的存储空间，这真的很诱人，一度让我尝试去申请，不过，由于我以及使用了COS，转移数据过于麻烦等一系列原因，最终没有选择使用，对于想要白嫖的玩家来说，这是个很不错的选择。</p><blockquote><p>点击查看<a href="httpss://www.upyun.com/league">又拍云联盟计划活动</a></p></blockquote><p>至于又拍云的使用效果如何，可以参考这个博客<a href="httpss://keymoe.com/">Sanakeyの小站</a></p></li><li><p><a href="httpss://www.huaweicloud.com/product/obs.html">华为云的OBS</a></p><p>华为云没用过，我也没看过它的收费标准和使用效果，只是一己私利支持一下华为（狗是不是该给我广告费）</p></li></ol><h3 id="腾讯云对象存储（COS）使用指南"><a href="#腾讯云对象存储（COS）使用指南" class="headerlink" title="腾讯云对象存储（COS）使用指南"></a>腾讯云对象存储（COS）使用指南</h3><p>因为我目前使用的就是腾讯云的对象存储，所以只提供腾讯云的对象存储的使用指南，其他服务商的对象存储服务，自行查找或者参考相关文档。</p><h4 id="存储桶的创建"><a href="#存储桶的创建" class="headerlink" title="存储桶的创建"></a>存储桶的创建</h4><ol><li><p>首先<strong>【进入<a href="httpss://console.cloud.tencent.com/cos">腾讯云对象存储的控制台</a>】</strong>，在<strong>左侧</strong>一栏<strong>【选择存储桶列表】</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae8fe6dc3c.png" alt="image-20220224185119735" style="zoom:67%;" /></li><li><p><strong>选择【创建存储桶】</strong>，然后弹出来存储桶创建的窗口，根据下面的选择自己的需求，然后<strong>【点击下一步】</strong></p><p><strong>所在地域</strong>：可以默认，也可以选择一共距离自己目前位置较近的位置。如果想要访问的快一些，就选择距离自己近一些的地域。</p><p><strong>名称</strong>：自定义名称，随意</p><p><strong>访问权限</strong>：默认私有读写即可，特殊需求除外</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae901c0450.png" alt="image-20220224185334651" style="zoom:67%;" /></li><li><p>在<strong>高级可选配置</strong>中，没特殊需求，默认即可，<strong>然后【点击下一步】</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae906284b7.png" alt="image-20220224192106362" style="zoom:67%;" /></li><li><p>最后在<strong>确认配置页面</strong>，<strong>【点击创建】</strong>即可，这就完成了存储桶的创建（即存储空间，可以理解为云硬盘）</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae90a3c05e.png" alt="image-20220224192251443" style="zoom:67%;" /></li><li><p>创建完成后，就可以在<strong>存储桶列表</strong>中看见自己刚刚创建的存储桶了</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae90dd5cd4.png" alt="image-20220224192414204" style="zoom:67%;" /></li></ol><h4 id="对象存储基本使用"><a href="#对象存储基本使用" class="headerlink" title="对象存储基本使用"></a>对象存储基本使用</h4><p>在创建完成存储桶之后，就可以上传指定文件到存储桶中，生成对应的文件直链了，此处举例如下图，我上传了张图片：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae91194816.png" alt="image-20220224192738882" style="zoom:150%;" /><p>然后点击图片的详情，进入文件的详情页面，就可以看到该文件的直链了：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae914f37f7.png" alt="image-20220224192916835" style="zoom:80%;" /><p>有了这个直链你就可以直接在网络引用该图片，同样的音频，视频也同理。</p><blockquote><p>需要注意的是，默认腾讯云存储桶存在一个生命周期规则，将其删除即可，具体原因我后面再专门写一部分对象存储的内容，基本的对象存储使用到这里就完成了。</p></blockquote><h4 id="对象存储的第三方调用和开发"><a href="#对象存储的第三方调用和开发" class="headerlink" title="对象存储的第三方调用和开发"></a>对象存储的第三方调用和开发</h4><p>如果需要使用对象存储进行软件开发或者其他需要对接的接口等，参考文档：腾讯云提供的<a href="httpss://cloud.tencent.com/document/product/436/6474">对象存储文档</a>。</p><h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><h2 id="什么是CDN？"><a href="#什么是CDN？" class="headerlink" title="什么是CDN？"></a>什么是CDN？</h2><p>老规矩先解释定义，斜体引用百度百科的定义：</p><p><em>CDN的全称是Content Delivery Network，即<a href="httpss://baike.baidu.com/item/内容分发网络/4034265">内容分发网络</a>。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</em></p><p>依旧是比较学术的定义，看的人一头雾水，<strong>通俗理解为：CDN通过多个加速节点来实现网站访问加速</strong>。虽然看起来我解释的不是很通俗易懂，这里需要插播一下 CDN 技术原理，推荐这个视频</p><ul><li><a href="httpss://www.bilibili.com/video/av211739167">CDN:一定要会用的网站加速方法</a></li></ul><p>或者看我的简单描述：</p><p>首先，要明白网站是怎么访问的，简述来说：用户通过域名访问网站服务器，网站服务器将网站的相关文件发送给你（或者理解为你下载了网站的相关文件），然后通过你本地的浏览器，将接受（下载）的网站相关文件解析，呈现出来的过程。</p><p>在有了上述的理解之后，需要明白，每个访问网站的用户的实际地理位置是不同的，而网站服务器的位置是固定的，也就是说，存在着如果访问的用户地理位置距离服务器地理位置很近则访问速度会更快的情况，因为距离越远，路由中继转发也就越多，耗时越长。</p><p>所以，为了提高访问速度，CDN提供了一套解决方案：在全国不同位置建立 N 个结点，将网站服务器的静态资源文件拷贝到对应的不同结点上，在用户访问的时候，优先将距离用户最近的结点的网站静态文件传输过去，这样提高了网站的加载速度和访问速度。</p><blockquote><p>关于啥是静态资源文件，理解为基本不会改变的资源文件，例如图片，音频，相关文件等我们上传了就基本不会再做二次修改了（主要是看你怎么理解这个基本不修改）</p></blockquote><h2 id="CDN的使用示例"><a href="#CDN的使用示例" class="headerlink" title="CDN的使用示例"></a>CDN的使用示例</h2><p>老规矩，先看看有那些服务商提供CDN服务，并挑选一个</p><h3 id="CDN服务商推荐-个人见解"><a href="#CDN服务商推荐-个人见解" class="headerlink" title="CDN服务商推荐&amp;个人见解"></a>CDN服务商推荐&amp;个人见解</h3><ul><li><a href="httpss://console.cloud.tencent.com/cdn">腾讯云CDN</a></li><li><a href="httpss://cdn.console.aliyun.com/overview">阿里云CDN</a></li><li><a href="httpss://www.upyun.com/products/cdn">又拍云CDN</a></li><li><a href="httpss://www.huaweicloud.com/product/cdn.html">华为云CDN</a></li></ul><ol><li><p><a href="httpss://console.cloud.tencent.com/cdn">腾讯云CDN</a></p><p>我没用过，大致看了一下，我很喜欢腾讯云活动的频繁程度和优惠程度相比于阿里云好一些，价格两者CDN差不多，但是腾讯云的活动稍微多一些，但是从CDN的结点数量和分发能力上来说，稍微弱于阿里云CDN，具体效果的自行查找相关网站或者文档</p></li><li><p><a href="httpss://cdn.console.aliyun.com/overview">阿里云CDN</a></p><p>我目前使用的就是阿里云CDN，阿里云的产品有个好处就是有客服，纯小白也可以靠客服的指引来学习和配置。阿里云CDN的结点目前应该是国内最多也是最大的了，因为我的服务器也在阿里云，所以就购买并配置了阿里云CDN。具体效果，你通过访问<a href="httpss://helloseraphine.top/">Seraphineの小窝</a>来体验。</p></li><li><p><a href="httpss://www.upyun.com/products/cdn">又拍云CDN</a></p><p>又拍云的CDN也是比较有名的，不过我没用过，也不了解，具体价格和使用方法自行查看官网，使用效果查看这个网站：<a href="httpss://keymoe.com/">Sanakeyの小站</a></p></li><li><p><a href="httpss://www.huaweicloud.com/product/cdn.html">华为云CDN</a></p><p>老规矩，又是我的一己私利，个人放着推荐</p></li></ol><h3 id="阿里云-DCDN-使用指南"><a href="#阿里云-DCDN-使用指南" class="headerlink" title="阿里云 DCDN 使用指南"></a>阿里云 DCDN 使用指南</h3><p>如果你足够细心，会发现这里变成了DCDN，是我打错了吗？NO，CDN的变种：CDN、SCDN、DCDN。具体区别：可以参考这个文章<a href="httpss://www.vpsss.net/12947.html">SLB CDN SCDN DCDN区别在哪？如何选择？</a>。</p><blockquote><p>配置CDN前提，要有网站且已备案（国内）</p></blockquote><p>DCDN中文名称：全站加速，你可以理解为CDN的升级版，如此理解即可。</p><ol><li><p>首先<strong>访问<a href="httpss://dcdn.console.aliyun.com/?spm=5176.11785003.app_menu.5.6402142fYmRp9f#/overview">阿里云全站加速控制台</a><strong>，在</strong>右侧，域名数量处，选择【管理】</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae91be40a2.png" alt="image-20220224201618935" style="zoom:67%;" /></li><li><p>在<strong>域名管理页面</strong>，<strong>选择【添加域名】</strong>，进入域名添加页面</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae91fd8266.png" alt="image-20220224201735577" style="zoom:80%;" /></li><li><p>进入<strong>添加域名</strong>页面，配置内容如下，添加完成后，<strong>【选择下一步】</strong></p><p><strong>加速域名</strong>：你要加速的域名，例如我希望别通过www.域名访问的时候CDN加速访问，就填www.域名</p><p><strong>资源分组</strong>：默认分组即可</p><p><strong>加速区域</strong>：中国内地即可</p><p><strong>源站信息</strong>：<strong>【点击新增源站信息】</strong>，根据弹出窗口内容提示填写，类型：我使用的IP：填写服务器的公网IP即可；没有多个服务器源站优先级：默认【主】即可；权重同理默认即可；<strong>端口需要注意一下：如果网站配置了SSL证书，就选择443端口，反之，则默认80端口即可</strong>（划重点）。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae925881d3.png" alt="image-20220224204608796" style="zoom: 67%;" /></li><li><p>完成后弹出添加成功提醒，然后<strong>【点击 配置CNAME】</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9295e5bd.png" alt="image-20220224205429744" style="zoom:67%;" /></li><li><p>然后在<strong>域名管理</strong>页面，查看创建的加速域名并复制其CNAME</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae92d54c34.png" alt="image-20220224205655913" style="zoom:150%;" /></li><li><p><strong>复制对应CNAME后，找到你购买域名时的服务商，进入域名解析页面设置</strong>，例如我使用的腾讯云的DNSPod；</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae93162726.png" alt="image-20220224210022432" style="zoom:80%;" /><blockquote><p>需要注意的是，添加解析的时候，需要先将原有的对应的 A 记录解析暂停或者删除，例如：我的加速域名是www.域名，而我之前存在对应的 www 记录的其他记录（一般是 A 记录），那么就需要将该记录暂停或者删除</p></blockquote></li><li><p><strong>【点击 添加记录后】</strong>，需要做以下修改填写，然后保存即可</p><p><strong>主机记录</strong>：添加你加速域名的主机记录，例如我加速的www.域名，则主机记录为<code>wwww</code></p><p><strong>记录类型</strong>：<strong>选择<code>CNAME</code>(必须是)</strong></p><p><strong>记录值</strong>：就是之前在阿里云DCDN控制台生成的<code>CNAME</code>值，复制粘贴进入即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae935c1948.png" alt="image-20220224210347736" style="zoom:150%;" /><blockquote><p>需要注意的是修改DNS解析，因为TTL默认设置是600秒，即10分钟，所以有时候需要等待5-10分钟才会设置成功</p></blockquote></li><li><p>完成上述DNS解析配置后，返回DCDN控制台，<strong>稍微等待一下，刷新一下或者鼠标放在等待配置的叹号上，打开配置向导，手动检测CNAME配置状态</strong>。配置成功后如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae939a6ade.png" alt="image-20220224211104663" style="zoom: 67%;" /></li><li><p><strong>到这步，如果你的网站没有配置SSL就结束了</strong>。你<strong>可以使用Win系统的<code>CMD</code> <code>Ping</code>一下你的加速域名</strong>，<strong>如果返回的值不是你的公网IP而是一个含有<code>kunlun.com</code>的字符串就说明配置完成了</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae93cdac07.png" alt="image-20220224211412580" style="zoom:67%;" /></li><li><p><strong>如果你的网站部署了SSL，那么你需要注意的是：你的源站信息里的端口一定要是 443 之前强调过的。然后在左侧栏找到【HTTPS配置点击进入】</strong>，开启HTTPS安全加速</p><p><strong>HTTPS安全加速</strong>：开启的时候因为是收费的，所以会询问你是否开启，自行选择，如果不开启，则没必要看下去了</p><p><strong>证书来源</strong>：根据实际情况选择，我的证书是腾讯云免费申请的SSL证书，所以我选择的是自定义上传</p><p><strong>证书（公钥）&#x2F;（私钥）</strong>：根据申请的SSL证书，找到相关文件，以<code>txt</code>格式打开，复制内容粘贴即可。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae9411bbc2.png" alt="image-20220224211759797" style="zoom:67%;" /><p>HTTPS配置完成后，可以在强制跳转中选择，是否强制跳转访问方式，例如强制HTTPS访问。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae944eb617.png" alt="image-20220224212153850" style="zoom:67%;" /></li></ol><p>到现在，基本上DCDN基本配置完成了，剩下的就是根据需求设置和调整了。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>部分内容写的相对捡漏，还有一些后续的配置调试等没有细写，关于一些原理实现等也没有细写，主要是写下如何正确配置步骤，一来可以给新入门的伙伴帮助，二来给我自己记一份笔记，以备不时之需。</p>]]></content>
      
      
      <categories>
          
          <category> NAS及服务器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于网站搭建那些事（上）</title>
      <link href="/2021/11/19/NAS%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2021/11/19/NAS%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>文章最后更新于 2021-11-19 21:01:31 星期五 ，部分内容可能与现在不符，请自行判断</p></blockquote><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>之前购买的服务器商说是要给我们提供长期免费的带宽和服务器，但是我感觉它要跑路了，再加上该服务器商数据的不稳定性，综合决定要网站搬迁，前排踩坑提醒（<strong>不要轻易购买零度空间的服务器或者其他产品</strong>）,当时购买的时候是看上了它的香港IP，这样我就可以免去国内备案的麻烦事。</p><p>如今不得不购买国内的相关服务器来进行网站搬迁，新网站域名 <a href="https://helloseraphine.top/">helloseraphine.top</a>,暂时还在备案中，无法通过域名访问,可以通过公网IP来访问 <a href="https://120.76.134.66/">120.76.134.66</a></p><p>目前服务器和数据库在阿里云，对象存储域名解析在腾讯云，年维护费用100左右（排除人工成本）</p><p>为了避免更多的小伙伴踩坑，写下个人博客网站建设教程来帮助后面的小伙伴<br>#网站基础知识<br>在开始建站之前需要了解一些基础知识：</p><ol><li><strong>带宽：带宽可以通俗的理解为网速，即别人访问你的网站，你的网站能和它互动的网速</strong></li><li><strong>服务器：可以通俗理解为功能偏向于大规模计算应用方面的电脑，记住它也是电脑，不要觉得服务器和电脑差异很大</strong></li><li><strong>数据库：存储数据的地方，类似于Excel，但是功能强大与其，可以理解为加强强强强版Excel，其他感兴趣的去学习数据库基础</strong></li><li><strong>公网IP：只有公网IP才可以被外界直接访问到，平时用到的网络都是局域网，这也就是为什么计算机网络讨论IP不够用了，但是我们依旧用的很好，不够用是因为公网IP是有限的，其他的详细知识感兴趣去学习计算机网络</strong></li></ol><p>网站可以分为<strong>静态网站</strong>和<strong>动态网站</strong>两种，静态网站顾名思义是静态的，它一般是HTML直接静态加载，通俗来讲上面有什么内容就是什么内容，没有所谓的评论，登录，更新文章之类的，就是不存在后期部分内容更新的，当然要更新也可以，需要更新HTML文件，覆盖源文件来实现，成本最低，但是不能直接用作个人博客，这部分内容不涉及静态网站如果建设，后面会新开一个文章来说明</p><p>绝大部分情况下，我们所见到的网站都是动态网站，一个动态网站需要服务器，数据库和一个公网IP，服务器来存放网站文件和各种计算处理，数据库调用存储写入各种网站数据，公网IP是供外界访问。</p><h1 id="服务商选择"><a href="#服务商选择" class="headerlink" title="服务商选择"></a>服务商选择</h1><p>目前只建议三种选择：<strong>1.<a href="httpss://www.aliyun.com/">阿里云</a> 2.<a href="httpss://cloud.tencent.com/">腾讯云</a> 3.自己手动从硬件搭建</strong></p><p>其他选择例如：华为云，移动云等从长远和费用来考虑，建议不要轻易选择<br>该教程目前使用阿里云来示例建站，腾讯云同理，两者相同</p><h2 id="【1】产品选择以及购买"><a href="#【1】产品选择以及购买" class="headerlink" title="【1】产品选择以及购买"></a>【1】产品选择以及购买</h2><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae772ee61b.png"/><p>打开阿里云首页后，会有很多选择,目前仅推荐两个，云服务器ECS和轻量应用服务器，概念普及：</p><p><strong>云服务器ECS：标准的服务器，购买的价格相对较贵（有学生优惠，我记得是99&#x2F;年），买的是一整个服务器实例</strong></p><p><strong>轻量应用服务器：轻量级，价格相对便宜（一般活动价格例如双十一也就60左右&#x2F;年），买的是一个直接给搭建好镜像的系统，只能干些小事情，例建站等</strong></p><p>此处选择轻量应用服务器，轻量应用服务器建站优点：</p><ol><li>便宜，比云服务器便宜很多</li><li>快速上手，该产品已经提前按照我们购买的选择，搭建好了相关镜像，省去了云服务器需要手动搭建各种网站数据库等的环境</li><li>带宽高，性能相对好同价格下，对于轻量级应用服务器的带宽5M起步，而学生价的云服务器才1M<blockquote><p>带宽计算规则，带宽&#x2F;8&#x3D;网速，例如1M&#x2F;8约等于128kb的网速，这还只是理论速度</p></blockquote></li></ol><p>然后，通过相关活动专场购买，例如现在的 <a href="httpss://www.aliyun.com/activity/1111/ecs?spm=5176.161059.J_5253785160.2.2c07a505OUI2nx">双十一服务器专场</a></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae7c553491.jpg" width="90%"><p>然后进入专场，选择对应的产品</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae7cecfae7.jpg" width="90%"><p>地区选择距离自己目前所在地近一点的，当然默认的也可以，国内基本不影响</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae7d95c30b.jpg" width="90%"><p>镜像可以选择，WordPress或者Typecho，两个都是博客框架，<strong>个人更加推荐WordPress</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae7e14be3c.jpg" width="90%"><p>剩下的都是默认的就好，选择购买，支付，然后返回轻量应用服务器的控制台即可</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae7e9b733e.jpg" width="90%"><h2 id="【2】轻量级服务器控制台"><a href="#【2】轻量级服务器控制台" class="headerlink" title="【2】轻量级服务器控制台"></a>【2】轻量级服务器控制台</h2><p>选择购买的轻量服务器，进入控制台管理页面.</p><p>在该页面可以看到服务器流量，内存，CPU情况，续费情况，服务器镜像，公网IP等等一系列重要的信息，其中最直接有用的信息是：</p><ul><li><strong>流量：每个月1000GB的流量，如果超出是会按量计费，不过对于个人博客这个流量足够足够用了</strong></li><li><strong>公网IP：这个是我们后面连接服务器，访问服务器的直接IP</strong></li></ul><p>如果是刚刚购买的轻量级服务器，那么域名部分，你是没有绑定的，你需要购买域名并解析域名到你的公网IP上。在国内建站还需要进行备案，<strong>国内除了服务器在香港地区的无须备案，其他都需要备案。</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae7f189ac3.jpg" width="100%"><h2 id="【3】域名注册与解析"><a href="#【3】域名注册与解析" class="headerlink" title="【3】域名注册与解析"></a>【3】域名注册与解析</h2><p>首先需要解释一下什么是域名，为什么要域名。</p><ul><li>什么是域名？<br>例如：<a href="httpss://www.baidu.com/">baidu.com</a> 就是一个域名，<a href="httpss://www.bilibili.com/">bilibili.com</a> 也是一个域名</li><li>为什么要域名？<br>在一开始互联网通信，每个参与通信的电脑需要具备一个公网IP这样就可以被其他计算机访问到，网站的原理就是别人通过你的公网IP来访问你服务器（电脑）的网页文件，他访问你的网页实际上是从你服务器（电脑）上下载你的网页文件，然后在本地浏览器上解析显示来的。<br>在知道这些后，那么别人想要访问你的网站，就需要输入你的公网IP来直接访问，但是有一个问题，公网IP是一串无规律的数字，总不能让每个上网的人记住每一个网站的数字吧，这样的体验是灾难性的。为了解决这个问题，引入了一个中间服务器，在该服务器上专门记录了一列按照一定格式自定义的域名和一列对应的公网IP地址，这样人们访问网站的时候只需要记住相对好记的域名，而后面的工作则是计算机访问DNS来获取公网IP，然后浏览器再通过公网IP来访问网站。只不过这些都在后台被计算机隐藏了，让用户更加专注于网上冲浪。</li></ul><p><strong>域名注册，就是自定义域名的方法，而域名解析就是将你购买的域名映射到你的公网IP的过程。</strong></p><p>国内域名购买，目前综合考虑也是只在这里推荐两个：**<a href="httpss://dnspod.cloud.tencent.com/domain/buy">腾讯云域名注册</a> 或者 <a href="httpss://wanwang.aliyun.com/domain/yumingheji">阿里云域名注册</a>**<br>此处举例：腾讯云域名注册</p><ol><li><p>首先进入<a href="httpss://dnspod.cloud.tencent.com/domain/buy">腾讯云域名注册</a>页面，例如：</p> <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae7fa06086.jpg" width="100%"></li><li><p>然后将自己给自己网站起的域名输入并点击搜索，例如我现在起个名字叫：SDAUceshi,然后点击查询</p> <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae800cac2a.jpg" width="100%"></li><li><p>然后在里面挑选价格和域名合适的，自己顺眼的也可以，加入购物车，支付，此处不做演示你可以很清楚的了解到，<strong>域名可以大致拆分为分为 <code>域名+后缀</code>，不过不要误解，域名是这个整合的整体，此处拆分是便于理解</strong></p></li><li><p>在域名注册（购买）完成后，进入域名控制台，可以看到你购买的域名</p> <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae80bbee78.jpg" width="100%"></li><li><p>然后选择需要解析的域名，点击 <code>解析</code>，进入域名解析页面</p> <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae812b1466.jpg" width="100%"><p> 上图中，红框部分是一开始默认存在的，蓝框部分我自己后来添加的解析，如果是刚刚购买的域名，则只有上面两个红框部分</p></li><li><p>添加解析，点击添加解析，弹出一行如下图:</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae81981d32.jpg" width="100%"></li></ol><p>  主机记录，常见的值：</p><ul><li><p><strong><code>www</code>：常见主机记录，将域名解析为 www.自定义域名.后缀</strong></p></li><li><p><strong><code>@</code>：直接解析主域名 自定义域名.后缀</strong></p></li><li><p><strong><code>mail</code>：将域名解析为 mail.自定义域名.后缀，通常用于邮件服务</strong></p></li><li><p>**<code>*</code>：泛解析，匹配其他所有域名 <em>.自定义域名.后缀</em>*<br>上面的综合来理解就是，在你输入域名访问的时候，如果你添加了www解析，那么你在输入www.自定义域名.后缀 就可以直接访问到你的网站，而输入sss.自定义域名.后缀 就访问不了你的网站，因为你没有添加sss解析，同理@解析的意思是，你可以不输入前缀，例如我直接不输入www，直接输入自定义域名.后缀 也是可以解析到网站的，综上所述，以此类推<br>记录值为，你服务器的公网IP。<br>其余不了解一律默认即可<br>如果觉得自己不能自主选择解析方式，那么你可以就添加我的两种解析，如下如图：</p></li></ul><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae82081368.jpg" width="100%"><p>在添加完域名解析后，这样就完成了域名注册和解析，这个时候就可以通过域名来访问网站了，而不是通过输入一串难记的数字来访问，因为国内建站需要备案，所以还需要备案这一步，这一步暂时不做说明，自行百度或者看腾讯云&#x2F;阿里云的相关文档</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae82760ab3.jpg" width="90%"><h2 id="【4】网站搭建"><a href="#【4】网站搭建" class="headerlink" title="【4】网站搭建"></a>【4】网站搭建</h2><p>现在回到轻量级应用服务器控制台，选择应用详情,按照阿里云给的提示一步一步走下去</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae82fc16a0.jpg" width="80%"><p>其中重要的是三个地方，一个是镜像的账户密码，一个是数据库的账户密码，这两个可以根据阿里云的提示自行获取，如下图：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae837af3b0.jpg" width="100%"><p>第三个重要的地方是在 服务器运维-&gt;远程连接，设置服务器SSH连接的密码</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae83f2655b.jpg" width="80%"><p>在完成上面的账户密码获取和设置后，我们需要做两个事情，第一个事情是访问服务器，即直接访问服务器的文件，这样我们可以完成对服务器的文件的删除上传等操作，第二个事情是访问数据库，这样我们可以对数据库后期操作，或者之前有网站的，通过将备份的数据导入数据库来实现网站搬迁。</p><h3 id="服务器远程连接"><a href="#服务器远程连接" class="headerlink" title="服务器远程连接"></a>服务器远程连接</h3><ol><li><p>我们需要一个软件，这里推荐 <strong><a href="httpss://winscp.net/eng/docs/lang:chs">WinSCP</a></strong> ,选择自己的系统平台，下载，安装。运行后是这个样子：</p> <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae846f043d.jpg" width="100%"> </li><li><p>输入对应的账户密码后点击登录</p> <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae84e5afcd.jpg" width="40%"> <image src="httpss://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_21-32-14.jpg" width="90%"> </li><li><p>找到我之前说的网站目录文件位置，这就是你的网站根目录，后期你需要在网站调试，插件上传，附件操作，模板上传等等一系列文件操作都需要先找到网站目录，即网站在服务器中的位置</p> <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae855432c0.jpg" width="90%"> <p> 好的，现在实现了对服务器的远程连接，后续可以通过这个方法来实现对服务器文件的操作</p></li></ol><h3 id="数据库远程连接"><a href="#数据库远程连接" class="headerlink" title="数据库远程连接"></a>数据库远程连接</h3><p>一般来说，如果你是第一次建站，是不需要进行这一步的，因为在你建站完成的时候，数据库自动和网站建立连接了，无须你手动调试或者更改，但是如果你需要导入你之前网站的数据，则需要连接数据库，对数据库进行操作。如果第一次建站可以忽略这一步，或者后面需要连接数据库再回来看该方法。</p><ol><li>连接数据库，我们也需要一个软件，这里推荐 <strong><a href="httpss://www.navicat.com.cn/">Navicat</a></strong>,下载，安装，运行后如下图：<blockquote><p>注：该软件收费，所以自行下载破解版，破解教程自行百度</p></blockquote></li></ol><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae85d26233.jpg" width="100%"><ol><li><p>现在来新建一个MySQL连接，选择如图：</p> <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae864863da.jpg" width="30%"></li><li><p>点击新建MySql连接后，如下图：</p> <img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae86b47338.jpg" width="70%" ></li></ol><ul><li><p>连接名：可以随意起，起一个能让你知道这个连接是连接哪个数据库的名称</p></li><li><p>主机：可以使用默认的 <code>localhost</code> ，也可以使用前面阿里云给的数据库地址 <code>127.0.0.1</code> ，注意，阿里云提供的地址，加上了端口，即有个 <code>:3306</code>，</p><blockquote><p>localhost 和 <code>127.0.0.1</code> 都是表示本地数据库的地址，两者不同在于localhost不会进过网卡，而127.0.0.1会经过网卡，再回到本地数据库</p></blockquote></li><li><p>端口：使用默认的3306即可</p></li><li><p>用户名：就是你数据库的用户名</p></li><li><p>密码：数据库的密码</p></li></ul><p>1.然后选择SSH，进入SSH配置页面</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae86f45f48.jpg" width="70%" style="zoom:50%;" ><ul><li><strong>主机：即轻量级应用服务器的公网IP地址</strong></li><li>端口：使用默认的22</li><li>用户名&amp;密码：就是你设置的用户名和密码</li></ul><p>2.然后测试连接，弹出连接成功，则完成数据库的远程连接，剩下就是数据库的操作不做说明<br><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aae874485a3.jpg" width="50%"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过上面的操作，就对轻量级应用服务器的连接操作和基本配置完成了。</p><p>对于一般的网站来说，网页内容和网站框架是分开来存放的，举一个简单的例子，网站的基础框架是放在我们的 <code>www</code> 根目录下的，但是我们在网站上面的发布的博客文章和相关的图片，文件等一般情况下是要放在另一个地方。这样可以让功能分离，也不会要求网站服务器的带宽过高。</p><p>对于附件，文件，图片等的存放地址，网站一般会额外购买对象存储来满足带宽，管理等的综合要求。</p><p>关于对象存储，博客框架的调试等，我会再出一个教程来说明。</p><blockquote><p><a href="httpss://helloseraphine.top/index.php/archives/487.html">关于网站搭建那些事（下）</a>已更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NAS及服务器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CamShar</title>
      <link href="/2021/10/22/%E5%BE%AE%E8%BD%AF%E5%A4%A9%E5%9D%91/WPF/CamShar/"/>
      <url>/2021/10/22/%E5%BE%AE%E8%BD%AF%E5%A4%A9%E5%9D%91/WPF/CamShar/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是半年前开发的一个相对完整的桌面应用软件，名称为：<strong>CamShar</strong>，是单词<strong>Campus</strong>（校园）和单词<strong>Share</strong>（分享）的组合，寓意为：校园共享。现在在博客上补上，之前发的由于数据库迁移删除了。</p><h1 id="想法来源"><a href="#想法来源" class="headerlink" title="想法来源"></a>想法来源</h1><p>这个软件的想法是我们大一的时候在聊天的时候想到的，由于每次考试周考试的时候，都需要去打印店打印相关资料和试卷之类的，甚至有的试卷和目前考试年份差的很远，这样对我们考试很没有帮助，我们希望提供一套解决方案，这样大家每次将自己的资料或者考试题目上传记录，每一级的人考试的时候都会事半功倍，也减少了挂科的风险。</p><h1 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h1><p>不过这个想法由于综合原因没有去实现，我和纸人（好友昵称）在去年国庆的时候决定去实现它，我采用的是WPF技术来实现桌面应用软件，纸人使用AndroidStudiio实现安卓端。如下是我留存的软件演示视频：</p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"https://mos.helloseraphine.top:9100/blog/Video/CamShar/CamShar.mp4","pic":"https://img.helloseraphine.top:8089/blog/2023/07/09/64aab13703558.webp"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>我之前录了1个多小时的视频来说明我的代码原理，不过后面不是很满意就没有处理，也就没有上传，这个软件是我WPF学习的作品，也是我做的相对用心的一个作品，整个软件开发周期是半个月，每天在我没课的时候就开始开发，一直到这个视频做出的晚上。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64abb76e37110.png" alt="image-20220206172624924" style="zoom:50%;" /><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>我尝试上传到GitHub上去，由于源代码中含有相关数据库，存储地址密钥等信息，一直没有处理，现在也懒得处理了，所以只将软件UI上传到GitHub上面，感兴趣的可以通过下面的链接下载。</p>]]></content>
      
      
      <categories>
          
          <category> 微软天坑 </category>
          
          <category> WPF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【2.0】统一建模语言</title>
      <link href="/2021/06/21/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%902.0%E3%80%91%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/"/>
      <url>/2021/06/21/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%902.0%E3%80%91%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习设计模式之前，需要了解一下什么是<strong>统一建模语言（Unified Modeling Language,UML），用人话来说，对于现实生活中的建筑大楼有它的设计图，而统一建模语言是程序的设计图，只有看懂了设计图，才会设计实现程序</strong>。</p><h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><p>如果要盖一栋楼，为了让不把它盖成一个狗窝，所以需要先画一些设计图，这些设计图就是楼房的蓝图。设计图是一种设计语言，也就是模型语言，是不同工程设计人员和生产人员直接沟通的语言。</p><p><strong>软件工程也需要使用模型来描述一个软件，使用户和开发人员都能够更好的理解开发的系统。</strong>建模是开发优秀软件的所有活动中最核心的部分之一，其目的是将结构和系统的行为联系起来，并对系统的结构进行可视化控制</p><p>随着软件系统的复杂度提高，好的建模语言需求越来越迫切，面向对象建模语言由此诞生，诞生初期软件建模增加到50多种，杂乱的建模语言让用户难以交流和使用</p><p>为了解决建模方法过多造成的种种问题，UML三位创始人，<strong>将所有建模语言统一起来也就形成了UML（统一建模语言）</strong></p><h1 id="UML的结构"><a href="#UML的结构" class="headerlink" title="UML的结构"></a>UML的结构</h1><p>UML是一种语言，也就意味着它有属于自己的表达规则。它不同于C#，JAVA等语言，而是一种分析设计语言，也就是一种建模语言，UML是由图形符号来达到建模语言，其主要结构如下：</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>在UML建模过程中，使用不同的视图从不同的角度来描述软件系统。UML包括5种视图：</p><ol><li>用户视图：以用户的观点表示系统的目标，它是所有视图的核心，该视图描述系统的需求</li><li>结构视图：表示系统的静态行为，描述系统的静态元素，如包，类与对象，以及它们之间的关系</li><li>行为视图：表示系统的动态行为，描述系统的组成元素（如对象）在系统运行时的交互关系</li><li>实现视图：表示系统中逻辑元素的分布，描述系统中物理文件以及它们之间的关系</li><li>环境视图：表示系统中物理元素的分布，描述系统中硬件设备以及它们之间的关系</li></ol><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>在UML 2.0中，提供13种图，与上述5种视图相对应</p><ul><li>用例图（Use Case Diagram）:又称为用况图，对应用户视图。在用例图中，<strong>使用用例来表示系统的功能需求</strong>，用例图用于表示多个外部执行者与系统用例之间以及用例与用例之间的关系。用例图与用例说明文档（Use Case     Specification）是常用的需求建模工具，也称为用例建模</li><li><strong>类图（Class     Diagram）</strong>:对应于结构视图。<strong>类图使用类来描述系统的静态结构，类图包含类和它们之间的关系</strong>，它描述系统内所声明的类，但没有描述系统运行时类的行为。</li><li>对象图（Object Diagram）:对应于结构视图。对象图是类图在某个时刻的一个实例，<strong>用于表示对象实例之间的关系</strong></li><li>包图（Package Diagram）:UML2.0新增图，对应于结构视图。<strong>包图用于描述包与包之间的关系</strong>，包是将多个元素组织在一起的机制，例如可以将多个类组织到一个包里</li><li>组合结构图（Composite     Structure Diagram）:UML2.0新增图，对应于结构视图。组合结构图将每一个类放在一个整体中，从类的内部结构来审视一个类。<strong>组合结构图用于表示一个类的内部结构，用于描述一些包含复杂成员或内部类的类结构</strong></li><li><strong>状态图（State     Diagram）</strong>:对应于行为视图。<strong>状态图用来描述一个特定对象的所有可能状态以及引起状态转移的事件</strong>。一个状态图包括一系列对象的状态以及状态和状态之间的转换</li><li>活动图（Activity Diagram）:对应于行为视图。活动图用来表示系统中的各种活动次序，它的应用比较广泛，既可以用来表示用例的工作流程，也可以描述类的某个方法的操作行为</li><li><strong>顺序图（Sequence     Diagram）</strong>:又称为时序图或者序列图，对应于行为视图。<strong>顺序图用于表示对象之间的交互，重点表示对象之间发送消息的时间顺序</strong></li><li>通信图（Communiccation）:在UML 1.x中称为协作图，对应于行为视图。通信图展示了一组对象，这些对象间的连接以及它们之间收发的消息。它与顺序图是同结构图，也就是它们包含了相同的信息，只是表达形式不同，两这个可以相互转换</li><li>定时图（Timing Diagram）:UML 2.0的新增图，对应于行为视图。定时图采用一种带数字刻度的时间轴来精确表示消息的顺序，而不是像顺序图那样只是指定消息的相对顺序</li><li>交互概览图</li><li>组件图</li><li>部署图</li></ul><h2 id="模型元素"><a href="#模型元素" class="headerlink" title="模型元素"></a>模型元素</h2><p>在UML中，模型元素包括事物以及事物之间的联系。事物是UML的重要组成部分。事物和事物之间的联系就是对应的模型元素。同一个模型元素可以在不同的UML图中使用，但是不论在那个UML图中，它所表达的意思是不变的</p><h2 id="通用机制"><a href="#通用机制" class="headerlink" title="通用机制"></a>通用机制</h2><p>UML提供的通用机制为模型元素提供的额外的注释，修饰和语义等，主要包括规格说明，修饰，公共分类个扩展机制四种。扩展机制运行用户对UML进行扩展</p><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p>类图是使用频率最高的UML图之一，<strong>在设计模式中，我们将使用类图来描述一个模式的结构，通过类图来分析每一个模式实例</strong></p><h2 id="类与类图"><a href="#类与类图" class="headerlink" title="类与类图"></a>类与类图</h2><p>类（Class）封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性，操作，关系的对象集合的总称。在系统中，每个类具有一定的职责，职责指的是类所担任的任务，即类要完成什么样的功能，要承担什么样的义务。一个类可以有多种职责，设计的好的类一般只有一种职责。在定义类的时候，将类的职责分解成类的属性和操作（方法）。类的属性就即类的数据职责，类的方法即类的行为职责</p><p><strong>在软件系统运行时，类将被实例化成对象（Object），对象对应于某个具体的事物。类是对一组具体相同属性，表现相同行为的对象的抽象，对象是类的实例（Instance）</strong></p><p>类图（Class Diagram)通过出现在系统中的不同类来描述系统的静态结构，类图用来描述不同的类和它们之间的关系。在UML中。类使用具有类名称，属性，方法分隔的长方形来表示，其对应的代码为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> email;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyInfo</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其对应的类图为：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc537a6a8.png" alt="image-20220621144756496" style="zoom: 80%;" /><p>由上图可以看出，UML类图由三个部分组成：</p><ul><li><p><strong>类名</strong>：，每个类都必须有一个名字，类名是一个字符串。<strong>按照C#类名规则，开头要大写字母</strong></p></li><li><p><strong>属性（Attributes）:属性是指类的性质，即类的成员变量</strong>。类可以有任意多个属性，也可以没有属性</p><ul><li><p>UML规定属性的表示方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可见性 名称：类型 [默认值]</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>可见性表示该属性对类外的元素是否可见，包括公有（Public），私有（Private）和受保护（Protected）三种，在类图中对应的符号分别是“+”“-”和“#”表示.</strong></li><li><em>名称表示属性名<strong>，用一个字符串表示，</strong>按照C#命名规则，一般是属性第一个字母要小写*</em></li><li>类型表示定义属性的数据类型，可以是基本属性类型，也可以用户自定义类型</li><li>默认值是一个可选项，即属性的初始值</li></ol></li><li><p><strong>类的操作（方法）（Operations）</strong>：操作是类的任意一个实例对象都可以使用的行为，操作是类的方法成员</p><ul><li><p>UML规定操作的表示方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可见性 名称([参数列表])：[返回类型]</span><br></pre></td></tr></table></figure></li></ul><ol><li>可见性的定义与属性定义相同</li><li>名称即操作名称或者方法名称，用一个字符串表示</li><li>参数列表表示操作的参数，其语法与属性表示相同，参数个数是任意的，多个参数之间用逗号隔开</li><li>返回类型是一个可选项，表示方法的返回值类型，依赖具体编程语言，可以是基本数据类型，也可以是用户自定义类型，也可以是空类型（void）。如果是构造方法，则无返回类型</li></ol></li></ul><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><p>关联关系是类与类之间最常用的一种关系，它是一种结构化的关系，<strong>用于表示一类对象与另一类对象之间有联系</strong>，例如：车辆与轮胎，老师与学生等。</p><p>在UML图中，通过实线来链接有关联的对象，在<code>C#</code>等编程语言中表示关联关系，<strong>通常将一个类的对象作为另一个类的属性</strong>。<strong>在使用类图表示关联关系时，可以通过在关联线上标注角色名(字符串)，一般使用一个表示两者之间的关系的动词作为角色名（字符串）</strong>。角色名不是必须的，在有必要的情况下标注，可以更好的理解关系。</p><p>对应的代码示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc57aef2b.png" alt="image-20220621153839727"  /><p>对应的UML图示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc5b30658.png" alt="image-20220621153910479" style="zoom:80%;" /><p>关联关系可以分为以下几种类型：</p><ul><li><p><strong>双向关联</strong></p><p>默认情况下，关联是双向的，例如，顾客（Customer）购买商品（Product）并拥有商品；反之，卖出的商品总有某个顾客与之相关联。因此Customer类和Product类之间具有关联关系。</p><p>其代码示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc5edaa25.png" alt="image-20220621154104022" style="zoom:80%;" /><p>其 UML 图示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc62a835f.png" alt="image-20220621154050982"  /></li><li><p><strong>单向关联</strong></p><p>类的关联关系也可以是单向的，用带箭头的实线来表示，例如：顾客（Customer）拥有地址（Address）</p><p>，则Customer类和Address类是单向关系。</p><p>其代码示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc663948f.png" alt="image-20220621154141366" style="zoom: 80%;" /><p>其 UML 图示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc69550a9.png" alt="image-20220621154205119"  /></li><li><p><strong>自关联</strong></p><p>在系统中可能存在一些自关联的类，类的属性对象类型是自身。例如：一个节点类(Node)的</p><p>成员又是节点对象。</p><p>其代码示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc6c820b8.png" alt="image-20220621154230261" style="zoom:100%;" /><p>其 UML 图示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc6fddbe9.png" alt="image-20220621154353368"  /></li><li><p><strong>多重性关联</strong></p><p>多重性关联关系又称为重数性关联关系（Multiolicity），表示一个类的对象与另一个类的对象链接的个数。在UML重多重性关联关系可以直接在关联直线上增加一个数字表示与之对应的另一个对象的个数。</p><table><thead><tr><th>表示方式</th><th>多重性说明</th></tr></thead><tbody><tr><td>1……1</td><td>表示另一个类的一个对象与一个该类对象有关系</td></tr><tr><td>0……*</td><td>表示另一个类的一个对象与零个或者多个该类的对象有关系</td></tr><tr><td>1……*</td><td>表示另一个类的一个对象与一个或多个该类的对象有关系</td></tr><tr><td>0……1</td><td>表示另一个类的一个对象与零个或一个该类对象有关系</td></tr><tr><td>m……n</td><td>表示另一个类的一个对象与最少m，最多n个该类的对象有关系（m&lt;&#x3D;n）</td></tr></tbody></table><p>例如：一个窗体可以拥有多个Button，但是一个Button只能对应一个窗体。代码示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc7390b9b.png" alt="image-20220621161914228" style="zoom:80%;" /><p>UML 图示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc76a46ed.png" alt="image-20220621161929797"  /></li></ul><h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p><strong>聚合关系（Aggregation）表示一个整体和部分的关系</strong>。通常在定义好一个整体类，从中分析整体类的组成结构，从而找出一些成员类，该整体类和成员类之间就形成了聚合关系。例如：计算机包括显示器，主机，键盘，鼠标等等。在聚合关系中，成员类是整体的一部分，即成员对象是整体对象的一部分，但是成员类的对象可以脱离整体独立存在。例如：汽车和发动机是聚合关系，但是发动机可以脱离汽车单独存在。</p><p><strong>在 UML 图中，这种关系用带空心菱形的直线表示</strong>，代码示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc79f3f4d.png" alt="image-20220621162325093" style="zoom: 80%;" /><p>UML 图示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc7d6cd63.png" alt="image-20220621162345390" style="zoom:80%;" /><blockquote><p>在代码中，Car定义了一个Engine类的成员变量，从语义上来说，Engine是Car的一部分，但是Engine对象可以脱离Car独立存在。因此，在类Car中不直接实例化Engine，而是通过构造方法等将在类外部实例化好的Engine对象已参数形式传入Car中，这种方式称为：注入（Injection）。</p></blockquote><h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>组合关系也表示整体和部分之间的关系，但是组合关系中整体和部分拥有统一的生存期。一旦</p><p>整体对象不存在时，部分对象也将不存在，部分对象和整体对象有共同生死的关系。例如：消息界面的按钮，控件等等和界面是组合关系，界面不存在，则控件部分也不存在。成员类是整体类的一部分，而整体类的生存期控制成员类的生存期。<strong>在UML中，这种关系用带实心菱形的直线表示。</strong></p><p>例如：人的头（Head）与嘴巴（Mouth），嘴巴是头的部分，头不存在，则嘴巴不存在。UML 图示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc810bcdf.png" alt="image-20220621162508287" style="zoom:80%;" /><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>依赖关系（Dependency）是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，<strong>在需要表示一个事物使用另一个事物时使用依赖关系</strong>。大多数的情况下，依赖关系体现在某个类方法使用另一个类的对象作为参数。</p><p><strong>在 UML 中，依赖关系用带箭头的虚线表示，由依赖方指向被依赖方。</strong></p><p>例如：驾驶员开车，在Driver类的drive()方法中将Car类型的对象car作为参数传递给被依赖的一方，代码示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc8667c26.png" alt="image-20220621162648222" style="zoom:80%;" /><p>UML 图示例：</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc89d2578.png" alt="image-20220621162705231"  /><h3 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h3><p>泛化关系（Generalization）也就是继承关系，也称为“is-a-kind-of”关系，<strong>泛化关系用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类</strong>。<strong>在UML中，泛化关系用带空心三角形的直线来表示</strong>。在代码实现时，使用面向对象的继承机制来实现泛化关系。</p><p>例如：Student类和Teacher类都是Person类的子类，Student类和Techer类继承了Person类的属性和方法，另外Student类增加了属性学号（studentNo）,Teacher类增加了属性教师编号（teacherNo）</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc8db2b52.png" alt="image-20220621162806974" style="zoom:67%;" /><h3 id="接口与实现关系"><a href="#接口与实现关系" class="headerlink" title="接口与实现关系"></a>接口与实现关系</h3><p>现在很多面向对象编程，引入了接口的概念。<strong>在接口中，一般没有属性，而且所有操作都是抽象的，只有操作的声明，没有操作的实现。</strong>UML中用与类的表示法类似的方法表示接口。</p><p>接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现关系（Realiazation）。<strong>在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。</strong></p><p>在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。</p><p>例如：定义了一个交通工具接口Vehicle,其中有一个抽象操作move()，在类Ship和类Car中都实现了该move()操作，不过具体的实现细节可能会不一样。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc9142a19.png" alt="image-20220621162933693" style="zoom:80%;" /><h1 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h1><p>顺序图是最常用的系统动态建模工具之一，也是使用频率最高的交互图，它用于表示对象之间的动态交互，而且以图形化的方式描述了对象间消息传递的时间顺序。</p><h2 id="顺序图的定义"><a href="#顺序图的定义" class="headerlink" title="顺序图的定义"></a>顺序图的定义</h2><p><strong>顺序图（Sequence Diagram）是一种强调对象间消息传递次序的交互图，又称为时序图</strong>或者序列图。</p><p>顺序图以图形化的方式描述了在一个用例或者操作的执行过程中对象如何通过消息互相交互，说明了消息如何在对象之间发送和接收以及发送的顺序。顺序图允许直观地表示出对象的生存期，在生存期内，对象可以对输入消息做出响应，还可以发送消息。</p><h2 id="顺序图组成元素与绘制"><a href="#顺序图组成元素与绘制" class="headerlink" title="顺序图组成元素与绘制"></a>顺序图组成元素与绘制</h2><p>在UML中，顺序图将交互关系表示为一个二维图，纵向是时间轴，时间沿竖线向下延申；横向轴表示了在交互过程中的独立对象，对象的活动用生命线来表示。<strong>顺序图由执行者（Actor）,生命线（Lifeline），对象（Object），激活（Activation）和消息（Message）等元素组成</strong>。</p><p>UML顺序图的组成元素说明如下：</p><ol><li><p>执行者是交互的发起人，使用与用例图一样的“小人”符号表示，在有些交互过程中无须使用执行者</p></li><li><p>生命线用一条纵向虚线表示</p></li><li><p>对象表示为一个矩形，其中对象名称标有下划线</p></li><li><p>激活是过程的执行，包括等待过程执行的时间。在顺序图中激活部分替换生命线，使用长条的矩形表示</p></li><li><p>消息是对象之间的通信，是两个对象之间的单路通信，是从发送者到接收者之间的控制信息流。消息在顺序图中由有标记的箭头表示，箭头从一个对象的生命线指向另一个对象的生命线。消息按时间顺序在途中从上到下排列。</p></li><li><p>一个复杂的顺序图可以划分为几个小块，每个小块称为一个交互片段（Interaction     Fragment）。每个交互片段由一个大方框包围，在方框左上角的间隔区内标注该交互片段的操作类型，该操作类型用操作符表示，常用的操作符包括：</p></li><li><ul><li>alt:多条路径，条件为真时执行</li><li>opt:任选，仅当条件为真时执行</li><li>par:并行，每一片段都并发执行</li><li>loop:循环，片段可以多次执行</li></ul></li></ol><p>例如：ATM的用户登录流程</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc962cb6e.png" alt="image-20220621163052414" style="zoom: 67%;" /><p>在顺序图中，有的消息对应于激活，表示它将会激活一个对象，这种消息被称为调用消息（Call Message）；如果消息没有对应激活框，表示它不是一个调用消息，不会引发其他对象活动，这种消息称为发送消息（Send Message）；如果对象的一个方法调用了自己的另一个方法时，消息是由对象发送给自身，这种消息被称为自身消息（Self Call Message）</p><p>顺序图中的消息还包括创建消息和销毁消息，创建消息用于使用New关键字创建另一个对象，而销毁消息用于调用对象的销毁方法将一个对象从内存中销毁。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc99a967b.png" alt="image-20220621163130021" style="zoom:67%;" /><h1 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h1><p>对于系统中那些具有多种状态的对象，状态图是一种常用的建模手段。状态图用于描述对象的各种状态以及状态之间的转换。在设计模式中，使用状态图来描述某些模式中对象的状态以及状态间的转换。</p><h2 id="状态图的定义"><a href="#状态图的定义" class="headerlink" title="状态图的定义"></a>状态图的定义</h2><p>状态图（Statechart Diagram）用来描述一个特定对象的所有可能状态以及引起其状态改变的事件。我们通常用状态图来描述单个对象的行为，它确定了由事件序列引出的状态序列，但并不是所有的类都需要使用状态图来描述它的行为，只有那些具有重要交互行为的类，我们才会使用状态图来描述。一个状态图包括一系列的状态以及状态之间的转移。</p><p>状态图适用于描述在不同用例之间的对象行为，但并不适合于描述包括若干协作的对象行为，因为一个状态图只能用于描述一个类的对象状态，如果涉及多个不同类的对象，则需要使用活动图。</p><h2 id="状态图组成元素与绘制"><a href="#状态图组成元素与绘制" class="headerlink" title="状态图组成元素与绘制"></a>状态图组成元素与绘制</h2><p>在UML状态图中包括如下组成元素。</p><ol><li>状态（State）:又称为中间状态，用圆角矩形框表示。在一个状态图中可以有多个状态，每个状态包含两格：上格放置状态名称，下格说明处于该状态时对象可以进行的活动（Action）</li><li>初始状态（Initial State）：又称为初态，用一个黑色的实心圆圈表示。在一个状态图中只能够有一个初始状态</li><li>结束状态（Final State）：又称为终止状态或者终态，用一个实心圆外加一个圆圈表示。在一个状态图中可能有多个结束状态</li><li>转移（Transition）：用于从一个状态到另一个状态之间的连线和箭头说明状态的转移情况，并用文字说明引发这个状态变换的相应事件是什么。事件有可能在特定的条件下发生，在UML中这样的条件称为守护条件（Guard Condition），发生事件时的处理也称为动作（Action）。状态之间的转移可带有标注，由三部分组成（每一个部分都可以省略），其语法为：<code>事件名[条件]/动作名</code></li></ol><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadc9e2e169.png" alt="image-20220621163228884" style="zoom:80%;" /><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aadca199ecb.png" alt="image-20220621163246622" style="zoom:80%;" /><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>终于弄完了最开始的设计模式部分，说实话我是没打算发这部分的，但是考虑到部分伙伴可能就没接触过设计模式还是把它腾上来了。后面的文章我会跳过后面设计原则说明部分，直接开始设计模式实际实现和相关内容。</p>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【1.0】设计模式概述</title>
      <link href="/2021/06/21/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%901.0%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/06/21/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%901.0%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设计模式去年我已经学过一遍了，所有内容都记录在我的<code>OneNote</code>笔记上了，现在遂打算把它们重新复习一遍，发到我的博客上，希望能有新的感悟，我会省去大量的定义尝试去用简单的语法和方法来说明每种设计模式的思路和方法实现。</p><p><strong>前排提醒：</strong></p><ul><li><strong>该设计模式使用的是<code>C#</code>作为示例语言</strong>，当然模式思想是通用的，前提是你能看到我的代码思想。</li><li>需要有一定的<code>C#</code>语言基础（<code>.NET</code>），例如：是否知道什么是类，属性，方法，接口，委托</li><li>需要有一定的 Visual Studio IDE使用基础</li></ul><blockquote><p>如下内容看个眼熟，理解即可，等到学习完全部具体的设计模式，再回看这里就明白了。</p></blockquote><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><strong>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结</strong>。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，<strong>每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案</strong>，这也是设计模式能被广泛应用的原因。</p><h1 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h1><p>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，<strong>总共有</strong> <strong>23</strong> <strong>种设计模式</strong>。这些模式可以分为三大类：<strong>创建型模式（****Creational Patterns</strong>）、结构型模式（<strong>Structural Patterns</strong>）、行为型模式（<strong>Behavioral Patterns</strong>）**。</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>这些设计模式提供了一种<strong>在创建对象的同时隐藏创建逻辑的方式</strong>，而不是使用new运算符直接实例化对象；这使得程序在判断针对某个给定实例需要创建哪些对象更加灵活；</p><ul><li><strong>工厂模式</strong></li><li><strong>抽象工厂模式</strong></li><li><strong>单例模式</strong></li><li><strong>建造者模式</strong></li><li><strong>原型模式</strong></li></ul><h2 id="结构性模式"><a href="#结构性模式" class="headerlink" title="结构性模式"></a>结构性模式</h2><p>这些设计模式<strong>关注类和对象的组合</strong>；继承的概念被用来组合接口和定义组合对象获得新功能的方式</p><ul><li><strong>适配器模式</strong></li><li><strong>桥接模式</strong></li><li><strong>过滤器模式</strong></li><li><strong>组合模式</strong></li><li><strong>装饰器模式</strong></li><li><strong>外观模式</strong></li><li><strong>享元模式</strong></li><li><strong>代理模式</strong></li></ul><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>这些设计模式特别<strong>关注对象之间通信</strong>；</p><ul><li><strong>责任链模式</strong></li><li><strong>命令模式</strong></li><li><strong>解释器模式</strong></li><li><strong>迭代器模式</strong></li><li><strong>中介者模式</strong></li><li><strong>备忘录模式</strong></li><li><strong>观察者模式</strong></li><li><strong>状态模式</strong></li><li><strong>空对象模式</strong></li><li><strong>策略模式</strong></li><li><strong>模板模式</strong></li><li><strong>访问者模式</strong></li></ul><h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><p><strong>1、开闭原则（Open Close Principle）</strong></p><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><p>合成复用原则是指：尽量使用合成&#x2F;聚合的方式，而不是使用继承。</p><table><thead><tr><th>设计原则名称</th><th>设计原则简介</th></tr></thead><tbody><tr><td>单一职责原则  （Single  Responsibility Principle,SRP）</td><td>类的职责要单一，不能将太多的职责放在一个类中</td></tr><tr><td>开闭原则  （Open-Closed  Principle,OCP）</td><td>软件实体对拓展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上拓展其功能</td></tr><tr><td>里氏代换原则  （Liskov  Substitution Principle,LSP）</td><td>在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象</td></tr><tr><td>依赖倒转原则  （Dependency  Inversion Principle,DIP）</td><td>要针对抽象层编程，而不要针对具体类编程</td></tr><tr><td>接口隔离原则  （Interface  Segregation Principle,ISP）</td><td>使用多个专门的接口来取代一个统一的接口</td></tr><tr><td>合成复用原则  （Composite  Reuse Principle,CRP）</td><td>在复用功能时，应该尽量多使用组合和聚合关联关系，尽量少使用甚至不使用继承关系</td></tr><tr><td>迪米特法则  （Law of  Demeter,LoD）</td><td>一个软件实体对其他实体的引用越少越好，或者说如果两个类不必须彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互</td></tr></tbody></table><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>这篇概述很水，我只是将我笔记复制过来，修改了一点点内容，其实我是打算解释一下六大原则的，这六大原则对于设计模式来说是核心思想，但是懒得用长篇大论来解释这些原则，希望可以在如上有限的文字中理解，如果实在不理解，也可以在后面的详细的每个设计模式中理解到。</p>]]></content>
      
      
      <categories>
          
          <category> 底层基础 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>环境变量那些事</title>
      <link href="/2020/10/12/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2020/10/12/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于大部分涉及到一些软件安装等，例如：软件开发的学生，在安装相关开发工具或包的时候配置部分总会有一个东西，叫做<strong>配置环境变量</strong>，环境变量到底是什么？我一开始初学的时候并没有思考这个问题，我甚至想都呢想，反正按着教程一次配置完成就不会再接触了，但是最近我突然想到这个问题，就查询学习，写了这篇文章以记录。</p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><h2 id="环境变量的定义"><a href="#环境变量的定义" class="headerlink" title="环境变量的定义"></a>环境变量的定义</h2><p>百度百科对于环境变量的定义：</p><p><em>环境变量（environment variables）一般是指在<a href="httpss://baike.baidu.com/item/操作系统/192">操作系统</a>中用来指定操作系统运行环境的一些参数，如：<a href="httpss://baike.baidu.com/item/临时文件夹/1061467">临时文件夹</a>位置和<a href="httpss://baike.baidu.com/item/系统文件夹/5328647">系统文件夹</a>位置等。</em></p><h2 id="环境变量的由来"><a href="#环境变量的由来" class="headerlink" title="环境变量的由来"></a>环境变量的由来</h2><p><strong>在早期的 DOS 系统 或者现在的Linux系统，对于非图形化的系统来说（当然Wind也可以），如果需要打开某个程序，需要进入控制台，通过命令进入该程序的目录</strong>（如下图，我用<code>git</code>举例，因为<code>git</code>本就是因为Linux系统而研制出来的），<strong>然后再输入程序名称来启动程序</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaea3d7c6c6.png" alt="image-20220221213848738" style="zoom:67%;" /><p>这样就会有一个问题，对于我们常用的软件或者其他的，我们每次启动都需要先进入该目录，然后再启动软件，很麻烦，所以<strong>如果我们配置了环境变量，就可以在输入程序名称的时候，系统在系统内部的路径找不到该程序，会在配置的环境变量中来寻找该程序，这样我们就可以直接在控制台输入程序名称来启动程序，省去了查找进入目录的繁琐过程</strong>。</p><h1 id="环境变量实例"><a href="#环境变量实例" class="headerlink" title="环境变量实例"></a>环境变量实例</h1><p>举例来说就是：<strong>如果我们使用常规的 CMD 命令或者其他系统的命令来执行相关操作的时候，系统不仅仅会在自己预定义的系统指令中查找，还会从我们配置的环境变量中查找</strong>。看下面的例子就很容易明白是什么意思了，以 Win10 环境启动微信举例：</p><ol><li><p>对着<strong>【我的电脑（此电脑）右键】，【选择属性】</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaea414d3f6.png" alt="image-20220221211307277" style="zoom:67%;" /></li><li><p>在弹出的属性页面中，<strong>在右侧选择【高级系统设置】</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaea4b58b01.png" alt="image-20220221211354091" style="zoom:67%;" /></li><li><p>在<strong>【高级】</strong>选项卡中，选择<strong>【环境变量】</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaea4ee0ad2.png" alt="image-20220221211742884" style="zoom:67%;" /></li><li><p>在弹出的环境变量窗口可以看到分为上下两栏，<strong>上半部分为用户环境变量，下半部分为系统环境变量</strong>。两者区别在于，Win系统是多用户操作系统，所以可以自定义每个用户不同的环境变量，如果做过编程可以理解为局部变量，而系统变量是应用在全用户上的，也就是全局变量。现在<strong>在系统变量中找到【变量名称为<code>PATH</code>，选中，点击编辑】</strong>。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaea52c1165.png" alt="image-20220221211913110" style="zoom:67%;" /></li><li><p>在单击编辑后，在弹出的窗口我们可以看到很多环境变量，有我们配置的，有程序安装的时候自动配置的，还有系统预定义的。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaea5891053.png" alt="image-20220221214508645" style="zoom:67%;" /></li><li><p>现在我们<strong>【打开 Win 的控制台命令程序】</strong>，即CMD</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaea5c89b58.png" alt="image-20220221214553322" style="zoom:67%;" /></li><li><p><strong>【输入<code>WeChat.exe</code>】</strong>，来尝试通过控制台来启动微信（模拟控制台系统的操作方式），输入后可以看到，Win 系统不知道我们输入的是什么命令，背后其实是 Win 在已定义的环境路径下找不到该程序。</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaea5fcbe35.png" alt="image-20220221214700807" style="zoom: 80%;" /></li><li><p>现在我们来将微信的安装路径添加到环境变量中</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaea62ed5f6.png" alt="image-20220221214947025" style="zoom:67%;" /></li><li><p>然后<strong>关闭之前开启的控制台命令程序</strong>，<strong>【重新打开控制台命令程序】</strong>，【输入<code>WeChat.exe</code>】</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaea66c948c.png" alt="image-20220221215309791" style="zoom:67%;" /><p>可以看到已经<strong>成功通过控制台命令程序启动了微信，这样就代表环境变量也配置成功了</strong>。</p></li></ol><h1 id="环境变量拓展"><a href="#环境变量拓展" class="headerlink" title="环境变量拓展"></a>环境变量拓展</h1><p>可以通过上述方法配置我们的环境变量，同样的也可以通过下面的方法来配置环境变量（以QQ举例）</p><ol><li><p>这次我们<strong>直接在系统环境变量中【新建变量】</strong>，而不是进入<code>PATH</code>环境来新增</p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaea6ad70e7.png" alt="image-20220221222809826" style="zoom:67%;" /></li><li><p>然后<strong>选中<code>PATH</code>，点击编辑，新建一个变量，我们将其值改为<code>%QQ%</code></strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaea6e7f191.png" alt="image-20220221223003295" style="zoom: 67%;" /></li><li><p>然后<strong>通过控制台命令程序，来启动QQ</strong></p><img src="https://img.helloseraphine.top:8089/blog/2023/07/10/64aaea727ed70.png" alt="image-20220221223125559" style="zoom:67%;" /><p>可以看到QQ已经被成功启动了。</p></li></ol><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>所以，在某些软件安装完成后需要手动配置环境变量，是因为软件后台需要通过向系统发送控制台命令等来调用相关进程功能，当然也可能有其他的用途和说法，目前我还不知晓，不过上门的过程可以让你对什么是环境变量，如何配置环境变量有一定的了解。</p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
